import {
  BoxedEditorUIView,
  EditorUI,
  ElementApiMixin,
  InlineEditableUIView,
  MenuBarView,
  StickyPanelView,
  ToolbarView,
  attachToForm,
  dialogview_default,
  editor_default,
  enablePlaceholder,
  normalizeToolbarConfig
} from "./chunk-6E3JQ6U6.js";
import "./chunk-OWJNOFJW.js";
import "./chunk-SDF6D7WI.js";
import {
  CKEditorError,
  ElementReplacer,
  Rect,
  getDataFromElement
} from "./chunk-3X5M7Q3U.js";
import "./chunk-2KI6HXVW.js";
import {
  isElement_default
} from "./chunk-K6UGUURS.js";

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditorui.js
var ClassicEditorUI = class extends EditorUI {
  /**
   * Creates an instance of the classic editor UI class.
   *
   * @param editor The editor instance.
   * @param view The view of the UI.
   */
  constructor(editor, view) {
    super(editor);
    this.view = view;
    this._toolbarConfig = normalizeToolbarConfig(editor.config.get("toolbar"));
    this._elementReplacer = new ElementReplacer();
    this.listenTo(editor.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
  }
  /**
   * @inheritDoc
   */
  get element() {
    return this.view.element;
  }
  /**
   * Initializes the UI.
   *
   * @param replacementElement The DOM element that will be the source for the created editor.
   */
  init(replacementElement) {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    view.editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    if (replacementElement) {
      this._elementReplacer.replace(replacementElement, this.element);
    }
    this._initPlaceholder();
    this._initToolbar();
    if (view.menuBarView) {
      this._initMenuBar(view.menuBarView);
    }
    this._initDialogPluginIntegration();
    this._initContextualBalloonIntegration();
    this.fire("ready");
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    this._elementReplacer.restore();
    if (editingView.getDomRoot(view.editable.name)) {
      editingView.detachDomRoot(view.editable.name);
    }
    view.destroy();
  }
  /**
   * Initializes the editor toolbar.
   */
  _initToolbar() {
    const view = this.view;
    view.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
    view.stickyPanel.limiterElement = view.element;
    view.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top }) => top || 0);
    view.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
    this.addToolbar(view.toolbar);
  }
  /**
   * Enable the placeholder text on the editing root.
   */
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const sourceElement = editor.sourceElement;
    let placeholderText;
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      placeholderText = typeof placeholder === "string" ? placeholder : placeholder[this.view.editable.name];
    }
    if (!placeholderText && sourceElement && sourceElement.tagName.toLowerCase() === "textarea") {
      placeholderText = sourceElement.getAttribute("placeholder");
    }
    if (placeholderText) {
      editingRoot.placeholder = placeholderText;
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
  /**
   * Provides an integration between the sticky toolbar and {@link module:ui/panel/balloon/contextualballoon contextual balloon plugin}.
   * It allows the contextual balloon to consider the height of the
   * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel}. It prevents the balloon from overlapping
   * the sticky toolbar by adjusting the balloon's position using viewport offset configuration.
   */
  _initContextualBalloonIntegration() {
    if (!this.editor.plugins.has("ContextualBalloon")) {
      return;
    }
    const { stickyPanel } = this.view;
    const contextualBalloon = this.editor.plugins.get("ContextualBalloon");
    contextualBalloon.on("getPositionOptions", (evt) => {
      const position = evt.return;
      if (!position || !stickyPanel.isSticky || !stickyPanel.element) {
        return;
      }
      const stickyPanelHeight = new Rect(stickyPanel.element).height;
      const target = typeof position.target === "function" ? position.target() : position.target;
      const limiter = typeof position.limiter === "function" ? position.limiter() : position.limiter;
      if (target && limiter && new Rect(target).height >= new Rect(limiter).height - stickyPanelHeight) {
        return;
      }
      const viewportOffsetConfig = { ...position.viewportOffsetConfig };
      const newTopViewportOffset = (viewportOffsetConfig.top || 0) + stickyPanelHeight;
      evt.return = {
        ...position,
        viewportOffsetConfig: {
          ...viewportOffsetConfig,
          top: newTopViewportOffset
        }
      };
    }, { priority: "low" });
    const updateBalloonPosition = () => {
      if (contextualBalloon.visibleView) {
        contextualBalloon.updatePosition();
      }
    };
    this.listenTo(stickyPanel, "change:isSticky", updateBalloonPosition);
    this.listenTo(this.editor.ui, "change:viewportOffset", updateBalloonPosition);
  }
  /**
   * Provides an integration between the sticky toolbar and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
   * It allows the UI-agnostic engine method to consider the geometry of the
   * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel} that pins to the
   * edge of the viewport and can obscure the user caret after scrolling the window.
   *
   * @param evt The `scrollToTheSelection` event info.
   * @param data The payload carried by the `scrollToTheSelection` event.
   * @param originalArgs The original arguments passed to `scrollViewportToShowTarget()` method (see implementation to learn more).
   */
  _handleScrollToTheSelectionWithStickyPanel(evt, data, originalArgs) {
    const stickyPanel = this.view.stickyPanel;
    if (stickyPanel.isSticky) {
      const stickyPanelHeight = new Rect(stickyPanel.element).height;
      data.viewportOffset.top += stickyPanelHeight;
    } else {
      const scrollViewportOnPanelGettingSticky = () => {
        this.editor.editing.view.scrollToTheSelection(originalArgs);
      };
      this.listenTo(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
      setTimeout(() => {
        this.stopListening(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
      }, 20);
    }
  }
  /**
   * Provides an integration between the sticky toolbar and {@link module:ui/dialog/dialog the Dialog plugin}.
   *
   * It moves the dialog down to ensure that the
   * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel sticky panel}
   * used by the editor UI will not get obscured by the dialog when the dialog uses one of its automatic positions.
   */
  _initDialogPluginIntegration() {
    if (!this.editor.plugins.has("Dialog")) {
      return;
    }
    const stickyPanel = this.view.stickyPanel;
    const dialogPlugin = this.editor.plugins.get("Dialog");
    dialogPlugin.on("show", () => {
      const dialogView = dialogPlugin.view;
      dialogView.on("moveTo", (evt, data) => {
        if (!stickyPanel.isSticky || dialogView.wasMoved || dialogView.isModal) {
          return;
        }
        const stickyPanelContentRect = new Rect(stickyPanel.contentPanelElement);
        if (data[1] < stickyPanelContentRect.bottom + dialogview_default.defaultOffset) {
          data[1] = stickyPanelContentRect.bottom + dialogview_default.defaultOffset;
        }
      }, { priority: "high" });
    }, { priority: "low" });
  }
};

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditoruiview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css";
var ClassicEditorUIView = class extends BoxedEditorUIView {
  /**
   * Creates an instance of the classic editor UI view.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param editingView The editing view instance this view is related to.
   * @param options Configuration options for the view instance.
   * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
   * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
   * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
   * @param options.label When set, this value will be used as an accessible `aria-label` of the
   * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
   */
  constructor(locale, editingView, options = {}) {
    super(locale);
    this.stickyPanel = new StickyPanelView(locale);
    this.toolbar = new ToolbarView(locale, {
      shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
    });
    if (options.useMenuBar) {
      this.menuBarView = new MenuBarView(locale);
    }
    this.editable = new InlineEditableUIView(locale, editingView, void 0, {
      label: options.label
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    if (this.menuBarView) {
      this.stickyPanel.content.addMany([this.menuBarView, this.toolbar]);
    } else {
      this.stickyPanel.content.add(this.toolbar);
    }
    this.top.add(this.stickyPanel);
    this.main.add(this.editable);
  }
};

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditor.js
var ClassicEditor = class extends ElementApiMixin(editor_default) {
  /**
   * @inheritDoc
   */
  static get editorName() {
    return "ClassicEditor";
  }
  /**
   * Creates an instance of the classic editor.
   *
   * **Note:** do not use the constructor to create editor instances. Use the static
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data. For more information see
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
   * @param config The editor configuration.
   */
  constructor(sourceElementOrData, config = {}) {
    if (!isElement(sourceElementOrData) && config.initialData !== void 0) {
      throw new CKEditorError("editor-create-initial-data", null);
    }
    super(config);
    this.config.define("menuBar.isVisible", false);
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData(sourceElementOrData));
    }
    if (isElement(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
    }
    this.model.document.createRoot();
    const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
    const menuBarConfig = this.config.get("menuBar");
    const view = new ClassicEditorUIView(this.locale, this.editing.view, {
      shouldToolbarGroupWhenFull,
      useMenuBar: menuBarConfig.isVisible,
      label: this.config.get("label")
    });
    this.ui = new ClassicEditorUI(this, view);
    attachToForm(this);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * Updates the original editor element with the data if the
   * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
   * configuration option is set to `true`.
   */
  destroy() {
    if (this.sourceElement) {
      this.updateSourceElement();
    }
    this.ui.destroy();
    return super.destroy();
  }
  /**
   * Creates a new classic editor instance.
   *
   * There are three ways how the editor can be initialized.
   *
   * # Replacing a DOM element (and loading data from it)
   *
   * You can initialize the editor using an existing DOM element:
   *
   * ```ts
   * ClassicEditor
   * 	.create( document.querySelector( '#editor' ) )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * The element's content will be used as the editor data and the element will be replaced by the editor UI.
   *
   * # Creating a detached editor
   *
   * Alternatively, you can initialize the editor by passing the initial data directly as a string.
   * In this case, the editor will render an element that must be inserted into the DOM:
   *
   * ```ts
   * ClassicEditor
   * 	.create( '<p>Hello world!</p>' )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   *
   * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
   * 		document.body.appendChild( editor.ui.element );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
   * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
   *
   * # Replacing a DOM element (and data provided in `config.initialData`)
   *
   * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
   *
   * ```ts
   * ClassicEditor
   * 	.create( document.querySelector( '#editor' ), {
   * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
   * 	} )
   * 	.then( editor => {
   * 		console.log( 'Editor was initialized', editor );
   * 	} )
   * 	.catch( err => {
   * 		console.error( err.stack );
   * 	} );
   * ```
   *
   * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
   * makes it difficult to set the content of the source element.
   *
   * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
   *
   * # Configuring the editor
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
   * customizing plugins, toolbar and more.
   *
   * @param sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data.
   *
   * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
   * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
   * in the DOM (the original one will be hidden and the editor will be injected next to it).
   *
   * If the {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
   * option is set to `true`, the editor data will be set back to the original element once the editor is destroyed and when a form,
   * in which this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration
   * with native web forms.
   *
   * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
   * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
   *
   * @param config The editor configuration.
   * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
   */
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init(isElement(sourceElementOrData) ? sourceElementOrData : null)).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
function getInitialData(sourceElementOrData) {
  return isElement(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement(value) {
  return isElement_default(value);
}
export {
  ClassicEditor as default
};
/*! Bundled license information:

ckeditor5/src/engine.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-classic/src/classiceditorui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-classic/src/classiceditoruiview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-editor-classic/src/classiceditor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-editor-classic_src_classiceditor.js.map
