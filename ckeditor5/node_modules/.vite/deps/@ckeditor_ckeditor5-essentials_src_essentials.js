import {
  AccessibilityHelp,
  BubblingEventInfo,
  Command,
  DataTransfer,
  DomEventData,
  DomEventObserver,
  FocusObserver,
  LiveRange,
  MenuBarMenuListItemButtonView,
  MouseObserver,
  NoOperation,
  Observer,
  Range,
  TreeWalker,
  icons,
  transformSets
} from "./chunk-6E3JQ6U6.js";
import {
  ButtonView,
  Template,
  View
} from "./chunk-OWJNOFJW.js";
import {
  Plugin
} from "./chunk-SDF6D7WI.js";
import {
  DomEmitterMixin,
  EmitterMixin,
  EventInfo,
  ObservableMixin,
  Rect,
  compareArrays,
  count,
  createElement,
  delay,
  env_default,
  getCode,
  getLocalizedArrowKeyCodeDirection,
  getRangeFromMouseEvent,
  global_default,
  isForwardArrowKeyCode,
  isInsideCombinedSymbol,
  isInsideEmojiSequence,
  isInsideSurrogatePair,
  keyCodes,
  parseKeystroke,
  resizeobserver_default,
  toUnit,
  uid
} from "./chunk-3X5M7Q3U.js";
import "./chunk-2KI6HXVW.js";
import {
  debounce_default,
  mapValues_default,
  throttle_default
} from "./chunk-K6UGUURS.js";

// node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js
var ClipboardObserver = class extends DomEventObserver {
  constructor(view) {
    super(view);
    this.domEventType = [
      "paste",
      "copy",
      "cut",
      "drop",
      "dragover",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave"
    ];
    const viewDocument = this.document;
    this.listenTo(viewDocument, "paste", handleInput("clipboardInput"), { priority: "low" });
    this.listenTo(viewDocument, "drop", handleInput("clipboardInput"), { priority: "low" });
    this.listenTo(viewDocument, "dragover", handleInput("dragging"), { priority: "low" });
    function handleInput(type) {
      return (evt, data) => {
        data.preventDefault();
        const targetRanges = data.dropRange ? [data.dropRange] : null;
        const eventInfo = new EventInfo(viewDocument, type);
        viewDocument.fire(eventInfo, {
          dataTransfer: data.dataTransfer,
          method: evt.name,
          targetRanges,
          target: data.target,
          domEvent: data.domEvent
        });
        if (eventInfo.stop.called) {
          data.stopPropagation();
        }
      };
    }
  }
  onDomEvent(domEvent) {
    const nativeDataTransfer = "clipboardData" in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;
    const cacheFiles = domEvent.type == "drop" || domEvent.type == "paste";
    const evtData = {
      dataTransfer: new DataTransfer(nativeDataTransfer, { cacheFiles })
    };
    if (domEvent.type == "drop" || domEvent.type == "dragover") {
      const domRange = getRangeFromMouseEvent(domEvent);
      evtData.dropRange = domRange && this.view.domConverter.domRangeToView(domRange);
    }
    this.fire(domEvent.type, domEvent, evtData);
  }
};

// node_modules/@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js
function plainTextToHtml(text) {
  text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
  if (text.includes("</p><p>") || text.includes("<br>")) {
    text = `<p>${text}</p>`;
  }
  return text;
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js
function normalizeClipboardData(data) {
  return data.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
    if (spaces.length == 1) {
      return " ";
    }
    return spaces;
  }).replace(/<!--[\s\S]*?-->/g, "");
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js
var smallPaddingElements = ["figcaption", "li"];
var listElements = ["ol", "ul"];
function viewToPlainText(viewItem) {
  if (viewItem.is("$text") || viewItem.is("$textProxy")) {
    return viewItem.data;
  }
  if (viewItem.is("element", "img") && viewItem.hasAttribute("alt")) {
    return viewItem.getAttribute("alt");
  }
  if (viewItem.is("element", "br")) {
    return "\n";
  }
  let text = "";
  let prev = null;
  for (const child of viewItem.getChildren()) {
    text += newLinePadding(child, prev) + viewToPlainText(child);
    prev = child;
  }
  return text;
}
function newLinePadding(element, previous) {
  if (!previous) {
    return "";
  }
  if (element.is("element", "li") && !element.isEmpty && element.getChild(0).is("containerElement")) {
    return "\n\n";
  }
  if (listElements.includes(element.name) && listElements.includes(previous.name)) {
    return "\n\n";
  }
  if (!element.is("containerElement") && !previous.is("containerElement")) {
    return "";
  }
  if (smallPaddingElements.includes(element.name) || smallPaddingElements.includes(previous.name)) {
    return "\n";
  }
  if (element.is("element") && element.getCustomProperty("dataPipeline:transparentRendering") || previous.is("element") && previous.getCustomProperty("dataPipeline:transparentRendering")) {
    return "";
  }
  return "\n\n";
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardmarkersutils.js
var ClipboardMarkersUtils = class extends Plugin {
  constructor() {
    super(...arguments);
    this._markersToCopy = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ClipboardMarkersUtils";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * Registers marker name as copyable in clipboard pipeline.
   *
   * @param markerName Name of marker that can be copied.
   * @param config Configuration that describes what can be performed on specified marker.
   * @internal
   */
  _registerMarkerToCopy(markerName, config) {
    this._markersToCopy.set(markerName, config);
  }
  /**
   * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.
   *
   * 	1. Picks all markers in provided selection.
   * 	2. Inserts fake markers to document.
   * 	3. Gets copied selection fragment from document.
   * 	4. Removes fake elements from fragment and document.
   * 	5. Inserts markers in the place of removed fake markers.
   *
   * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.
   * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.
   *
   * @param action Type of clipboard action.
   * @param writer An instance of the model writer.
   * @param selection Selection to be checked.
   * @param getCopiedFragment	Callback that performs copy of selection and returns it as fragment.
   * @internal
   */
  _copySelectedFragmentWithMarkers(action, selection, getCopiedFragment = (writer) => writer.model.getSelectedContent(writer.model.document.selection)) {
    return this.editor.model.change((writer) => {
      const oldSelection = writer.model.document.selection;
      writer.setSelection(selection);
      const sourceSelectionInsertedMarkers = this._insertFakeMarkersIntoSelection(writer, writer.model.document.selection, action);
      const fragment = getCopiedFragment(writer);
      const fakeMarkersRangesInsideRange = this._removeFakeMarkersInsideElement(writer, fragment);
      for (const [markerName, elements] of Object.entries(sourceSelectionInsertedMarkers)) {
        fakeMarkersRangesInsideRange[markerName] || (fakeMarkersRangesInsideRange[markerName] = writer.createRangeIn(fragment));
        for (const element of elements) {
          writer.remove(element);
        }
      }
      fragment.markers.clear();
      for (const [markerName, range] of Object.entries(fakeMarkersRangesInsideRange)) {
        fragment.markers.set(markerName, range);
      }
      writer.setSelection(oldSelection);
      return fragment;
    });
  }
  /**
   * Performs paste of markers on already pasted element.
   *
   * 	1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).
   * 	2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.
   * 	3. Removes all fake markers present in transformed element.
   * 	4. Inserts new markers with removed fake markers ranges into pasted fragment.
   *
   * There are multiple edge cases that have to be considered before calling this function:
   *
   * 	* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.
   * 	* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.
   * 	* If `duplicateOnPaste` is `true` in marker config then associated marker ID is regenerated before pasting.
   *
   * @param action Type of clipboard action.
   * @param markers Object that maps marker name to corresponding range.
   * @param getPastedDocumentElement Getter used to get target markers element.
   * @internal
   */
  _pasteMarkersIntoTransformedElement(markers, getPastedDocumentElement) {
    const pasteMarkers = this._getPasteMarkersFromRangeMap(markers);
    return this.editor.model.change((writer) => {
      const sourceFragmentFakeMarkers = this._insertFakeMarkersElements(writer, pasteMarkers);
      const transformedElement = getPastedDocumentElement(writer);
      const removedFakeMarkers = this._removeFakeMarkersInsideElement(writer, transformedElement);
      for (const element of Object.values(sourceFragmentFakeMarkers).flat()) {
        writer.remove(element);
      }
      for (const [markerName, range] of Object.entries(removedFakeMarkers)) {
        if (!writer.model.markers.has(markerName)) {
          writer.addMarker(markerName, {
            usingOperation: true,
            affectsData: true,
            range
          });
        }
      }
      return transformedElement;
    });
  }
  /**
   * Pastes document fragment with markers to document.
   * If `duplicateOnPaste` is `true` in marker config then associated markers IDs
   * are regenerated before pasting to avoid markers duplications in content.
   *
   * @param fragment Document fragment that should contain already processed by pipeline markers.
   * @internal
   */
  _pasteFragmentWithMarkers(fragment) {
    const pasteMarkers = this._getPasteMarkersFromRangeMap(fragment.markers);
    fragment.markers.clear();
    for (const copyableMarker of pasteMarkers) {
      fragment.markers.set(copyableMarker.name, copyableMarker.range);
    }
    return this.editor.model.insertContent(fragment);
  }
  /**
   * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass
   * restrictions on markers that we want to copy.
   *
   * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy
   * content, markers with the specified name will be copied to the clipboard as well.
   *
   * @param markerName Which markers should be copied.
   * @param executor Callback executed.
   * @param config Optional configuration flags used to copy (such like partial copy flag).
   * @internal
   */
  _forceMarkersCopy(markerName, executor, config = {
    allowedActions: "all",
    copyPartiallySelected: true,
    duplicateOnPaste: true
  }) {
    const before = this._markersToCopy.get(markerName);
    this._markersToCopy.set(markerName, config);
    executor();
    if (before) {
      this._markersToCopy.set(markerName, before);
    } else {
      this._markersToCopy.delete(markerName);
    }
  }
  /**
   * Checks if marker can be copied.
   *
   * @param markerName Name of checked marker.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   * @internal
   */
  _isMarkerCopyable(markerName, action) {
    const config = this._getMarkerClipboardConfig(markerName);
    if (!config) {
      return false;
    }
    if (!action) {
      return true;
    }
    const { allowedActions } = config;
    return allowedActions === "all" || allowedActions.includes(action);
  }
  /**
   * Checks if marker has any clipboard copy behavior configuration.
   *
   * @param markerName Name of checked marker.
   */
  _hasMarkerConfiguration(markerName) {
    return !!this._getMarkerClipboardConfig(markerName);
  }
  /**
   * Returns marker's configuration flags passed during registration.
   *
   * @param markerName Name of marker that should be returned.
   * @internal
   */
  _getMarkerClipboardConfig(markerName) {
    const [markerNamePrefix] = markerName.split(":");
    return this._markersToCopy.get(markerNamePrefix) || null;
  }
  /**
   * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements
   * at positions where document markers start or end. This way `$marker` elements can be easily copied together with
   * the rest of the content of the selection.
   *
   * @param writer An instance of the model writer.
   * @param selection Selection to be checked.
   * @param action Type of clipboard action.
   */
  _insertFakeMarkersIntoSelection(writer, selection, action) {
    const copyableMarkers = this._getCopyableMarkersFromSelection(writer, selection, action);
    return this._insertFakeMarkersElements(writer, copyableMarkers);
  }
  /**
   * Returns array of markers that can be copied in specified selection.
   *
   * If marker cannot be copied partially (according to `copyPartiallySelected` configuration flag) and
   * is not present entirely in any selection range then it will be skipped.
   *
   * @param writer An instance of the model writer.
   * @param selection  Selection which will be checked.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   */
  _getCopyableMarkersFromSelection(writer, selection, action) {
    const selectionRanges = Array.from(selection.getRanges());
    const markersInRanges = new Set(selectionRanges.flatMap((selectionRange) => Array.from(writer.model.markers.getMarkersIntersectingRange(selectionRange))));
    const isSelectionMarkerCopyable = (marker) => {
      const isCopyable = this._isMarkerCopyable(marker.name, action);
      if (!isCopyable) {
        return false;
      }
      const { copyPartiallySelected } = this._getMarkerClipboardConfig(marker.name);
      if (!copyPartiallySelected) {
        const markerRange = marker.getRange();
        return selectionRanges.some((selectionRange) => selectionRange.containsRange(markerRange, true));
      }
      return true;
    };
    return Array.from(markersInRanges).filter(isSelectionMarkerCopyable).map((copyableMarker) => {
      const name = action === "dragstart" ? this._getUniqueMarkerName(copyableMarker.name) : copyableMarker.name;
      return {
        name,
        range: copyableMarker.getRange()
      };
    });
  }
  /**
   * Picks all markers from markers map that can be pasted.
   * If `duplicateOnPaste` is `true`, it regenerates their IDs to ensure uniqueness.
   * If marker is not registered, it will be kept in the array anyway.
   *
   * @param markers Object that maps marker name to corresponding range.
   * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
   */
  _getPasteMarkersFromRangeMap(markers, action = null) {
    const { model } = this.editor;
    const entries = markers instanceof Map ? Array.from(markers.entries()) : Object.entries(markers);
    return entries.flatMap(([markerName, range]) => {
      if (!this._hasMarkerConfiguration(markerName)) {
        return [
          {
            name: markerName,
            range
          }
        ];
      }
      if (this._isMarkerCopyable(markerName, action)) {
        const copyMarkerConfig = this._getMarkerClipboardConfig(markerName);
        const isInGraveyard = model.markers.has(markerName) && model.markers.get(markerName).getRange().root.rootName === "$graveyard";
        if (copyMarkerConfig.duplicateOnPaste || isInGraveyard) {
          markerName = this._getUniqueMarkerName(markerName);
        }
        return [
          {
            name: markerName,
            range
          }
        ];
      }
      return [];
    });
  }
  /**
   * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.
   * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during
   * steps between copy and paste.
   *
   * @param writer An instance of the model writer.
   * @param markers Array of markers that will be inserted.
   */
  _insertFakeMarkersElements(writer, markers) {
    const mappedMarkers = {};
    const sortedMarkers = markers.flatMap((marker) => {
      const { start, end } = marker.range;
      return [
        { position: start, marker, type: "start" },
        { position: end, marker, type: "end" }
      ];
    }).sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
    for (const { position, marker, type } of sortedMarkers) {
      const fakeMarker = writer.createElement("$marker", {
        "data-name": marker.name,
        "data-type": type
      });
      if (!mappedMarkers[marker.name]) {
        mappedMarkers[marker.name] = [];
      }
      mappedMarkers[marker.name].push(fakeMarker);
      writer.insert(fakeMarker, position);
    }
    return mappedMarkers;
  }
  /**
   * Removes all `$marker` elements from the given document fragment.
   *
   * Returns an object where keys are marker names, and values are ranges corresponding to positions
   * where `$marker` elements were inserted.
   *
   * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically
   * (to the end or start of the document fragment, respectively).
   *
   * @param writer An instance of the model writer.
   * @param rootElement The element to be checked.
   */
  _removeFakeMarkersInsideElement(writer, rootElement) {
    const fakeMarkersElements = this._getAllFakeMarkersFromElement(writer, rootElement);
    const fakeMarkersRanges = fakeMarkersElements.reduce((acc, fakeMarker) => {
      const position = fakeMarker.markerElement && writer.createPositionBefore(fakeMarker.markerElement);
      let prevFakeMarker = acc[fakeMarker.name];
      let skipAssign = false;
      if (prevFakeMarker && prevFakeMarker.start && prevFakeMarker.end) {
        const config = this._getMarkerClipboardConfig(fakeMarker.name);
        if (config.duplicateOnPaste) {
          acc[this._getUniqueMarkerName(fakeMarker.name)] = acc[fakeMarker.name];
        } else {
          skipAssign = true;
        }
        prevFakeMarker = null;
      }
      if (!skipAssign) {
        acc[fakeMarker.name] = {
          ...prevFakeMarker,
          [fakeMarker.type]: position
        };
      }
      if (fakeMarker.markerElement) {
        writer.remove(fakeMarker.markerElement);
      }
      return acc;
    }, {});
    return mapValues_default(fakeMarkersRanges, (range) => new Range(range.start || writer.createPositionFromPath(rootElement, [0]), range.end || writer.createPositionAt(rootElement, "end")));
  }
  /**
   * Returns array that contains list of fake markers with corresponding `$marker` elements.
   *
   * For each marker, there can be two `$marker` elements or only one (if the document fragment contained
   * only the beginning or only the end of a marker).
   *
   * @param writer An instance of the model writer.
   * @param rootElement The element to be checked.
   */
  _getAllFakeMarkersFromElement(writer, rootElement) {
    const foundFakeMarkers = Array.from(writer.createRangeIn(rootElement)).flatMap(({ item }) => {
      if (!item.is("element", "$marker")) {
        return [];
      }
      const name = item.getAttribute("data-name");
      const type = item.getAttribute("data-type");
      return [
        {
          markerElement: item,
          name,
          type
        }
      ];
    });
    const prependFakeMarkers = [];
    const appendFakeMarkers = [];
    for (const fakeMarker of foundFakeMarkers) {
      if (fakeMarker.type === "end") {
        const hasMatchingStartMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "start");
        if (!hasMatchingStartMarker) {
          prependFakeMarkers.push({
            markerElement: null,
            name: fakeMarker.name,
            type: "start"
          });
        }
      }
      if (fakeMarker.type === "start") {
        const hasMatchingEndMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "end");
        if (!hasMatchingEndMarker) {
          appendFakeMarkers.unshift({
            markerElement: null,
            name: fakeMarker.name,
            type: "end"
          });
        }
      }
    }
    return [
      ...prependFakeMarkers,
      ...foundFakeMarkers,
      ...appendFakeMarkers
    ];
  }
  /**
   * When copy of markers occurs we have to make sure that pasted markers have different names
   * than source markers. This functions helps with assigning unique part to marker name to
   * prevent duplicated markers error.
   *
   * @param name Name of marker
   */
  _getUniqueMarkerName(name) {
    const parts = name.split(":");
    const newId = uid().substring(1, 6);
    if (parts.length === 3) {
      return `${parts.slice(0, 2).join(":")}:${newId}`;
    }
    return `${parts.join(":")}:${newId}`;
  }
};

// node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js
var ClipboardPipeline = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ClipboardPipeline";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardMarkersUtils];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    view.addObserver(ClipboardObserver);
    this._setupPasteDrop();
    this._setupCopyCut();
  }
  /**
   * Fires Clipboard `'outputTransformation'` event for given parameters.
   *
   * @internal
   */
  _fireOutputTransformationEvent(dataTransfer, selection, method) {
    const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
    this.editor.model.enqueueChange({ isUndoable: method === "cut" }, () => {
      const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(method, selection);
      this.fire("outputTransformation", {
        dataTransfer,
        content: documentFragment,
        method
      });
    });
  }
  /**
   * The clipboard paste pipeline.
   */
  _setupPasteDrop() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      if (data.method == "paste" && !editor.model.canEditAt(editor.model.document.selection)) {
        evt.stop();
      }
    }, { priority: "highest" });
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      const dataTransfer = data.dataTransfer;
      let content;
      if (data.content) {
        content = data.content;
      } else {
        let contentData = "";
        if (dataTransfer.getData("text/html")) {
          contentData = normalizeClipboardData(dataTransfer.getData("text/html"));
        } else if (dataTransfer.getData("text/plain")) {
          contentData = plainTextToHtml(dataTransfer.getData("text/plain"));
        }
        content = this.editor.data.htmlProcessor.toView(contentData);
      }
      const eventInfo = new EventInfo(this, "inputTransformation");
      this.fire(eventInfo, {
        content,
        dataTransfer,
        targetRanges: data.targetRanges,
        method: data.method
      });
      if (eventInfo.stop.called) {
        evt.stop();
      }
      view.scrollToTheSelection();
    }, { priority: "low" });
    this.listenTo(this, "inputTransformation", (evt, data) => {
      if (data.content.isEmpty) {
        return;
      }
      const dataController = this.editor.data;
      const modelFragment = dataController.toModel(data.content, "$clipboardHolder");
      if (modelFragment.childCount == 0) {
        return;
      }
      evt.stop();
      model.change(() => {
        this.fire("contentInsertion", {
          content: modelFragment,
          method: data.method,
          dataTransfer: data.dataTransfer,
          targetRanges: data.targetRanges
        });
      });
    }, { priority: "low" });
    this.listenTo(this, "contentInsertion", (evt, data) => {
      data.resultRange = clipboardMarkersUtils._pasteFragmentWithMarkers(data.content);
    }, { priority: "low" });
  }
  /**
   * The clipboard copy/cut pipeline.
   */
  _setupCopyCut() {
    const editor = this.editor;
    const modelDocument = editor.model.document;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const onCopyCut = (evt, data) => {
      const dataTransfer = data.dataTransfer;
      data.preventDefault();
      this._fireOutputTransformationEvent(dataTransfer, modelDocument.selection, evt.name);
    };
    this.listenTo(viewDocument, "copy", onCopyCut, { priority: "low" });
    this.listenTo(viewDocument, "cut", (evt, data) => {
      if (!editor.model.canEditAt(editor.model.document.selection)) {
        data.preventDefault();
      } else {
        onCopyCut(evt, data);
      }
    }, { priority: "low" });
    this.listenTo(this, "outputTransformation", (evt, data) => {
      const content = editor.data.toView(data.content);
      viewDocument.fire("clipboardOutput", {
        dataTransfer: data.dataTransfer,
        content,
        method: data.method
      });
    }, { priority: "low" });
    this.listenTo(viewDocument, "clipboardOutput", (evt, data) => {
      if (!data.content.isEmpty) {
        data.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(data.content));
        data.dataTransfer.setData("text/plain", viewToPlainText(data.content));
      }
      if (data.method == "cut") {
        editor.model.deleteContent(modelDocument.selection);
      }
    }, { priority: "low" });
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/utils/changebuffer.js
var ChangeBuffer = class {
  /**
   * Creates a new instance of the change buffer.
   *
   * @param limit The maximum number of atomic changes which can be contained in one batch.
   */
  constructor(model, limit = 20) {
    this._batch = null;
    this.model = model;
    this._size = 0;
    this.limit = limit;
    this._isLocked = false;
    this._changeCallback = (evt, batch) => {
      if (batch.isLocal && batch.isUndoable && batch !== this._batch) {
        this._reset(true);
      }
    };
    this._selectionChangeCallback = () => {
      this._reset();
    };
    this.model.document.on("change", this._changeCallback);
    this.model.document.selection.on("change:range", this._selectionChangeCallback);
    this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
  }
  /**
   * The current batch to which a feature should add its operations. Once the {@link #size}
   * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   */
  get batch() {
    if (!this._batch) {
      this._batch = this.model.createBatch({ isTyping: true });
    }
    return this._batch;
  }
  /**
   * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
   * the {@link #batch batch} is set to a new one.
   */
  get size() {
    return this._size;
  }
  /**
   * The input number of changes into the buffer. Once the {@link #size} is
   * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   *
   * @param changeCount The number of atomic changes to input.
   */
  input(changeCount) {
    this._size += changeCount;
    if (this._size >= this.limit) {
      this._reset(true);
    }
  }
  /**
   * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
   */
  get isLocked() {
    return this._isLocked;
  }
  /**
   * Locks the buffer.
   */
  lock() {
    this._isLocked = true;
  }
  /**
   * Unlocks the buffer.
   */
  unlock() {
    this._isLocked = false;
  }
  /**
   * Destroys the buffer.
   */
  destroy() {
    this.model.document.off("change", this._changeCallback);
    this.model.document.selection.off("change:range", this._selectionChangeCallback);
    this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
  }
  /**
   * Resets the change buffer.
   *
   * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
   */
  _reset(ignoreLock = false) {
    if (!this.isLocked || ignoreLock) {
      this._batch = null;
      this._size = 0;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/inserttextcommand.js
var InsertTextCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param undoStepSize The maximum number of atomic changes
   * which can be contained in one batch in the command buffer.
   */
  constructor(editor, undoStepSize) {
    super(editor);
    this._buffer = new ChangeBuffer(editor.model, undoStepSize);
    this._isEnabledBasedOnSelection = false;
  }
  /**
   * The current change buffer.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._buffer.destroy();
  }
  /**
   * Executes the input command. It replaces the content within the given range with the given text.
   * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
   * at the beginning of the range (which after the removal is a collapsed range).
   *
   * @fires execute
   * @param options The command options.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const doc = model.document;
    const text = options.text || "";
    const textInsertions = text.length;
    let selection = doc.selection;
    if (options.selection) {
      selection = options.selection;
    } else if (options.range) {
      selection = model.createSelection(options.range);
    }
    if (!model.canEditAt(selection)) {
      return;
    }
    const resultRange = options.resultRange;
    model.enqueueChange(this._buffer.batch, (writer) => {
      this._buffer.lock();
      const selectionAttributes = Array.from(doc.selection.getAttributes());
      model.deleteContent(selection);
      if (text) {
        model.insertContent(writer.createText(text, selectionAttributes), selection);
      }
      if (resultRange) {
        writer.setSelection(resultRange);
      } else if (!selection.is("documentSelection")) {
        writer.setSelection(selection);
      }
      this._buffer.unlock();
      this._buffer.input(textInsertions);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/inserttextobserver.js
var TYPING_INPUT_TYPES = [
  // For collapsed range:
  //	- This one is a regular typing (all browsers, all systems).
  //	- This one is used by Chrome when typing accented letter â€“ 2nd step when the user selects the accent (Mac).
  // For non-collapsed range:
  //	- This one is used by Chrome when typing accented letter â€“ when the selection box first appears (Mac).
  //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
  "insertText",
  // This one is used by Safari when typing accented letter (Mac).
  // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
  "insertReplacementText"
];
var TYPING_INPUT_TYPES_ANDROID = [
  ...TYPING_INPUT_TYPES,
  "insertCompositionText"
];
var InsertTextObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    this.focusObserver = view.getObserver(FocusObserver);
    const typingInputTypes = env_default.isAndroid ? TYPING_INPUT_TYPES_ANDROID : TYPING_INPUT_TYPES;
    const viewDocument = view.document;
    viewDocument.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      const { data: text, targetRanges, inputType, domEvent } = data;
      if (!typingInputTypes.includes(inputType)) {
        return;
      }
      this.focusObserver.flush();
      const eventInfo = new EventInfo(viewDocument, "insertText");
      viewDocument.fire(eventInfo, new DomEventData(view, domEvent, {
        text,
        selection: view.createSelection(targetRanges)
      }));
      if (eventInfo.stop.called) {
        evt.stop();
      }
    });
    if (!env_default.isAndroid) {
      viewDocument.on("compositionend", (evt, { data, domEvent }) => {
        if (!this.isEnabled) {
          return;
        }
        if (!data) {
          return;
        }
        viewDocument.fire("insertText", new DomEventData(view, domEvent, {
          text: data
        }));
      }, { priority: "lowest" });
    }
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/input.js
var Input = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Input";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const mapper = editor.editing.mapper;
    const modelSelection = model.document.selection;
    this._compositionQueue = new CompositionQueue(editor);
    view.addObserver(InsertTextObserver);
    const insertTextCommand = new InsertTextCommand(editor, editor.config.get("typing.undoStep") || 20);
    editor.commands.add("insertText", insertTextCommand);
    editor.commands.add("input", insertTextCommand);
    this.listenTo(view.document, "insertText", (evt, data) => {
      if (!view.document.isComposing) {
        data.preventDefault();
      }
      if (env_default.isAndroid && view.document.isComposing) {
        this._compositionQueue.flush("next beforeinput");
      }
      const { text, selection: viewSelection } = data;
      let modelRanges;
      if (viewSelection) {
        modelRanges = Array.from(viewSelection.getRanges()).map((viewRange) => mapper.toModelRange(viewRange));
      } else {
        modelRanges = Array.from(modelSelection.getRanges());
      }
      let insertText = text;
      if (env_default.isAndroid) {
        const selectedText = Array.from(modelRanges[0].getItems()).reduce((rangeText, node) => {
          return rangeText + (node.is("$textProxy") ? node.data : "");
        }, "");
        if (selectedText) {
          if (selectedText.length <= insertText.length) {
            if (insertText.startsWith(selectedText)) {
              insertText = insertText.substring(selectedText.length);
              modelRanges[0].start = modelRanges[0].start.getShiftedBy(selectedText.length);
            }
          } else {
            if (selectedText.startsWith(insertText)) {
              modelRanges[0].start = modelRanges[0].start.getShiftedBy(insertText.length);
              insertText = "";
            }
          }
        }
        if (insertText.length == 0 && modelRanges[0].isCollapsed) {
          return;
        }
      }
      const commandData = {
        text: insertText,
        selection: model.createSelection(modelRanges)
      };
      if (env_default.isAndroid && view.document.isComposing) {
        this._compositionQueue.push(commandData);
      } else {
        editor.execute("insertText", commandData);
        view.scrollToTheSelection();
      }
    });
    if (env_default.isAndroid) {
      this.listenTo(view.document, "keydown", (evt, data) => {
        if (modelSelection.isCollapsed || data.keyCode != 229 || !view.document.isComposing) {
          return;
        }
        deleteSelectionContent(model, insertTextCommand);
      });
    } else {
      this.listenTo(view.document, "compositionstart", () => {
        if (modelSelection.isCollapsed) {
          return;
        }
        deleteSelectionContent(model, insertTextCommand);
      });
    }
    if (env_default.isAndroid) {
      this.listenTo(view.document, "mutations", (evt, { mutations }) => {
        if (!view.document.isComposing) {
          return;
        }
        for (const { node } of mutations) {
          const viewElement = findMappedViewAncestor(node, mapper);
          const modelElement = mapper.toModelElement(viewElement);
          if (this._compositionQueue.isComposedElement(modelElement)) {
            this._compositionQueue.flush("mutations");
            return;
          }
        }
      });
      this.listenTo(view.document, "compositionend", () => {
        this._compositionQueue.flush("composition end");
      });
      this.listenTo(view.document, "compositionend", () => {
        const mutations = [];
        for (const element of this._compositionQueue.flushComposedElements()) {
          const viewElement = mapper.toViewElement(element);
          if (!viewElement) {
            continue;
          }
          mutations.push({ type: "children", node: viewElement });
        }
        if (mutations.length) {
          view.document.fire("mutations", { mutations });
        }
      }, { priority: "lowest" });
    } else {
      this.listenTo(view.document, "compositionend", () => {
        view.document.fire("mutations", { mutations: [] });
      }, { priority: "lowest" });
    }
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._compositionQueue.destroy();
  }
};
var CompositionQueue = class {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    this.flushDebounced = debounce_default(() => this.flush("timeout"), 50);
    this._queue = [];
    this._compositionElements = /* @__PURE__ */ new Set();
    this.editor = editor;
  }
  /**
   * Destroys the helper object.
   */
  destroy() {
    this.flushDebounced.cancel();
    this._compositionElements.clear();
    while (this._queue.length) {
      this.shift();
    }
  }
  /**
   * Returns the size of the queue.
   */
  get length() {
    return this._queue.length;
  }
  /**
   * Push next insertText command data to the queue.
   */
  push(commandData) {
    const commandLiveData = {
      text: commandData.text
    };
    if (commandData.selection) {
      commandLiveData.selectionRanges = [];
      for (const range of commandData.selection.getRanges()) {
        commandLiveData.selectionRanges.push(LiveRange.fromRange(range));
        this._compositionElements.add(range.start.parent);
      }
    }
    this._queue.push(commandLiveData);
    this.flushDebounced();
  }
  /**
   * Shift the first item from the insertText command data queue.
   */
  shift() {
    const commandLiveData = this._queue.shift();
    const commandData = {
      text: commandLiveData.text
    };
    if (commandLiveData.selectionRanges) {
      const ranges = commandLiveData.selectionRanges.map((liveRange) => detachLiveRange(liveRange)).filter((range) => !!range);
      if (ranges.length) {
        commandData.selection = this.editor.model.createSelection(ranges);
      }
    }
    return commandData;
  }
  /**
   * Applies all queued insertText command executions.
   *
   * @param reason Used only for debugging.
   */
  flush(reason) {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    this.flushDebounced.cancel();
    if (!this._queue.length) {
      return;
    }
    const insertTextCommand = editor.commands.get("insertText");
    const buffer = insertTextCommand.buffer;
    model.enqueueChange(buffer.batch, () => {
      buffer.lock();
      while (this._queue.length) {
        const commandData = this.shift();
        editor.execute("insertText", commandData);
      }
      buffer.unlock();
    });
    view.scrollToTheSelection();
  }
  /**
   * Returns `true` if the given model element is related to recent composition.
   */
  isComposedElement(element) {
    return this._compositionElements.has(element);
  }
  /**
   * Returns an array of composition-related elements and clears the internal list.
   */
  flushComposedElements() {
    const result = Array.from(this._compositionElements);
    this._compositionElements.clear();
    return result;
  }
};
function deleteSelectionContent(model, insertTextCommand) {
  if (!insertTextCommand.isEnabled) {
    return;
  }
  const buffer = insertTextCommand.buffer;
  buffer.lock();
  model.enqueueChange(buffer.batch, () => {
    model.deleteContent(model.document.selection);
  });
  buffer.unlock();
}
function detachLiveRange(liveRange) {
  const range = liveRange.toRange();
  liveRange.detach();
  if (range.root.rootName == "$graveyard") {
    return null;
  }
  return range;
}
function findMappedViewAncestor(viewNode, mapper) {
  let node = viewNode.is("$text") ? viewNode.parent : viewNode;
  while (!mapper.toModelElement(node)) {
    node = node.parent;
  }
  return node;
}

// node_modules/@ckeditor/ckeditor5-typing/src/deletecommand.js
var DeleteCommand = class extends Command {
  /**
   * Creates an instance of the command.
   *
   * @param direction The directionality of the delete describing in what direction it
   * should consume the content when the selection is collapsed.
   */
  constructor(editor, direction) {
    super(editor);
    this.direction = direction;
    this._buffer = new ChangeBuffer(editor.model, editor.config.get("typing.undoStep"));
    this._isEnabledBasedOnSelection = false;
  }
  /**
   * The current change buffer.
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
   * or a piece of content in the {@link #direction defined direction}.
   *
   * @fires execute
   * @param options The command options.
   * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
   * @param options.sequence A number describing which subsequent delete event it is without the key being released.
   * See the {@link module:engine/view/document~Document#event:delete} event data.
   * @param options.selection Selection to remove. If not set, current model selection will be used.
   */
  execute(options = {}) {
    const model = this.editor.model;
    const doc = model.document;
    model.enqueueChange(this._buffer.batch, (writer) => {
      this._buffer.lock();
      const selection = writer.createSelection(options.selection || doc.selection);
      if (!model.canEditAt(selection)) {
        return;
      }
      const sequence = options.sequence || 1;
      const doNotResetEntireContent = selection.isCollapsed;
      if (selection.isCollapsed) {
        model.modifySelection(selection, {
          direction: this.direction,
          unit: options.unit,
          treatEmojiAsSingleUnit: true
        });
      }
      if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {
        this._replaceEntireContentWithParagraph(writer);
        return;
      }
      if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {
        this.editor.execute("paragraph", { selection });
        return;
      }
      if (selection.isCollapsed) {
        return;
      }
      let changeCount = 0;
      selection.getFirstRange().getMinimalFlatRanges().forEach((range) => {
        changeCount += count(range.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
      });
      model.deleteContent(selection, {
        doNotResetEntireContent,
        direction: this.direction
      });
      this._buffer.input(changeCount);
      writer.setSelection(selection);
      this._buffer.unlock();
    });
  }
  /**
   * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
   * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
   * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
   *
   * But, if the user pressed the key in an empty editable for the first time,
   * we want to replace the entire content with a paragraph if:
   *
   * * the current limit element is empty,
   * * the paragraph is allowed in the limit element,
   * * the limit doesn't already have a paragraph inside.
   *
   * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
   *
   * @param sequence A number describing which subsequent delete event it is without the key being released.
   */
  _shouldEntireContentBeReplacedWithParagraph(sequence) {
    if (sequence > 1) {
      return false;
    }
    const model = this.editor.model;
    const doc = model.document;
    const selection = doc.selection;
    const limitElement = model.schema.getLimitElement(selection);
    const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);
    if (!limitElementIsEmpty) {
      return false;
    }
    if (!model.schema.checkChild(limitElement, "paragraph")) {
      return false;
    }
    const limitElementFirstChild = limitElement.getChild(0);
    if (limitElementFirstChild && limitElementFirstChild.is("element", "paragraph")) {
      return false;
    }
    return true;
  }
  /**
   * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
   *
   * @param writer The model writer.
   */
  _replaceEntireContentWithParagraph(writer) {
    const model = this.editor.model;
    const doc = model.document;
    const selection = doc.selection;
    const limitElement = model.schema.getLimitElement(selection);
    const paragraph = writer.createElement("paragraph");
    writer.remove(writer.createRangeIn(limitElement));
    writer.insert(paragraph, limitElement);
    writer.setSelection(paragraph, 0);
  }
  /**
   * Checks if the selection is inside an empty element that is the first child of the limit element
   * and should be replaced with a paragraph.
   *
   * @param selection The selection.
   * @param sequence A number describing which subsequent delete event it is without the key being released.
   */
  _shouldReplaceFirstBlockWithParagraph(selection, sequence) {
    const model = this.editor.model;
    if (sequence > 1 || this.direction != "backward") {
      return false;
    }
    if (!selection.isCollapsed) {
      return false;
    }
    const position = selection.getFirstPosition();
    const limitElement = model.schema.getLimitElement(position);
    const limitElementFirstChild = limitElement.getChild(0);
    if (position.parent != limitElementFirstChild) {
      return false;
    }
    if (!selection.containsEntireContent(limitElementFirstChild)) {
      return false;
    }
    if (!model.schema.checkChild(limitElement, "paragraph")) {
      return false;
    }
    if (limitElementFirstChild.name == "paragraph") {
      return false;
    }
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/deleteobserver.js
var DELETE_CHARACTER = "character";
var DELETE_WORD = "word";
var DELETE_CODE_POINT = "codePoint";
var DELETE_SELECTION = "selection";
var DELETE_BACKWARD = "backward";
var DELETE_FORWARD = "forward";
var DELETE_EVENT_TYPES = {
  // --------------------------------------- Backward delete types -----------------------------------------------------
  // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
  deleteContent: {
    unit: DELETE_SELECTION,
    // According to the Input Events Level 2 spec, this delete type has no direction
    // but to keep things simple, let's default to backward.
    direction: DELETE_BACKWARD
  },
  // Chrome and Safari on Mac: Backspace or Ctrl + H
  deleteContentBackward: {
    // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
    // Take for instance "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘§", it equals:
    //
    //	* [ "ðŸ‘¨", "ZERO WIDTH JOINER", "ðŸ‘©", "ZERO WIDTH JOINER", "ðŸ‘§", "ZERO WIDTH JOINER", "ðŸ‘§" ]
    //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
    //
    // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
    // intention when deleting backwards ("ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘§[]", then backspace) is gradual "decomposition" (first to "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€[]",
    // then to "ðŸ‘¨â€ðŸ‘©â€[]", etc.).
    //
    //	* "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘§[]" + backward delete (by code point)  -> results in "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§[]", removed the last "ðŸ‘§" ðŸ‘
    //	* "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘§[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme ðŸ‘Ž
    //
    // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
    unit: DELETE_CODE_POINT,
    direction: DELETE_BACKWARD
  },
  // On Mac: Option + Backspace.
  // On iOS: Hold the backspace for a while and the whole words will start to disappear.
  deleteWordBackward: {
    unit: DELETE_WORD,
    direction: DELETE_BACKWARD
  },
  // Safari on Mac: Cmd + Backspace
  deleteHardLineBackward: {
    unit: DELETE_SELECTION,
    direction: DELETE_BACKWARD
  },
  // Chrome on Mac: Cmd + Backspace.
  deleteSoftLineBackward: {
    unit: DELETE_SELECTION,
    direction: DELETE_BACKWARD
  },
  // --------------------------------------- Forward delete types -----------------------------------------------------
  // Chrome on Mac: Fn + Backspace or Ctrl + D
  // Safari on Mac: Ctrl + K or Ctrl + D
  deleteContentForward: {
    // Unlike backward delete, this delete must be performed by character instead of by code point, which
    // provides the best UX for working with accented letters.
    // Take, for example "bÌ‚" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
    //
    //	* "bÌ‚[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark ðŸ‘
    //	* "[]bÌ‚" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone ðŸ‘Ž
    //	* "[]bÌ‚" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark ðŸ‘
    //
    // See: "deleteContentBackward" to learn more.
    unit: DELETE_CHARACTER,
    direction: DELETE_FORWARD
  },
  // On Mac: Fn + Option + Backspace.
  deleteWordForward: {
    unit: DELETE_WORD,
    direction: DELETE_FORWARD
  },
  // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
  // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
  // on Apple's webpage.
  deleteHardLineForward: {
    unit: DELETE_SELECTION,
    direction: DELETE_FORWARD
  },
  // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
  // deleteSoftLineBackward.
  deleteSoftLineForward: {
    unit: DELETE_SELECTION,
    direction: DELETE_FORWARD
  }
};
var DeleteObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    const document2 = view.document;
    let sequence = 0;
    document2.on("keydown", () => {
      sequence++;
    });
    document2.on("keyup", () => {
      sequence = 0;
    });
    document2.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      const { targetRanges, domEvent, inputType } = data;
      const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
      if (!deleteEventSpec) {
        return;
      }
      const deleteData = {
        direction: deleteEventSpec.direction,
        unit: deleteEventSpec.unit,
        sequence
      };
      if (deleteData.unit == DELETE_SELECTION) {
        deleteData.selectionToRemove = view.createSelection(targetRanges[0]);
      }
      if (inputType === "deleteContentBackward") {
        if (env_default.isAndroid) {
          deleteData.sequence = 1;
        }
        if (shouldUseTargetRanges(targetRanges)) {
          deleteData.unit = DELETE_SELECTION;
          deleteData.selectionToRemove = view.createSelection(targetRanges);
        }
      }
      const eventInfo = new BubblingEventInfo(document2, "delete", targetRanges[0]);
      document2.fire(eventInfo, new DomEventData(view, domEvent, deleteData));
      if (eventInfo.stop.called) {
        evt.stop();
      }
    });
    if (env_default.isBlink) {
      enableChromeWorkaround(this);
    }
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
};
function enableChromeWorkaround(observer) {
  const view = observer.view;
  const document2 = view.document;
  let pressedKeyCode = null;
  let beforeInputReceived = false;
  document2.on("keydown", (evt, { keyCode }) => {
    pressedKeyCode = keyCode;
    beforeInputReceived = false;
  });
  document2.on("keyup", (evt, { keyCode, domEvent }) => {
    const selection = document2.selection;
    const shouldFireDeleteEvent = observer.isEnabled && keyCode == pressedKeyCode && isDeleteKeyCode(keyCode) && !selection.isCollapsed && !beforeInputReceived;
    pressedKeyCode = null;
    if (shouldFireDeleteEvent) {
      const targetRange = selection.getFirstRange();
      const eventInfo = new BubblingEventInfo(document2, "delete", targetRange);
      const deleteData = {
        unit: DELETE_SELECTION,
        direction: getDeleteDirection(keyCode),
        selectionToRemove: selection
      };
      document2.fire(eventInfo, new DomEventData(view, domEvent, deleteData));
    }
  });
  document2.on("beforeinput", (evt, { inputType }) => {
    const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
    const isMatchingBeforeInput = isDeleteKeyCode(pressedKeyCode) && deleteEventSpec && deleteEventSpec.direction == getDeleteDirection(pressedKeyCode);
    if (isMatchingBeforeInput) {
      beforeInputReceived = true;
    }
  }, { priority: "high" });
  document2.on("beforeinput", (evt, { inputType, data }) => {
    const shouldIgnoreBeforeInput = pressedKeyCode == keyCodes.delete && inputType == "insertText" && data == "";
    if (shouldIgnoreBeforeInput) {
      evt.stop();
    }
  }, { priority: "high" });
  function isDeleteKeyCode(keyCode) {
    return keyCode == keyCodes.backspace || keyCode == keyCodes.delete;
  }
  function getDeleteDirection(keyCode) {
    return keyCode == keyCodes.backspace ? DELETE_BACKWARD : DELETE_FORWARD;
  }
}
function shouldUseTargetRanges(targetRanges) {
  if (targetRanges.length != 1 || targetRanges[0].isCollapsed) {
    return false;
  }
  const walker = targetRanges[0].getWalker({
    direction: "backward",
    singleCharacters: true,
    ignoreElementEnd: true
  });
  let count2 = 0;
  for (const { nextPosition, item } of walker) {
    if (nextPosition.parent.is("$text")) {
      const data = nextPosition.parent.data;
      const offset = nextPosition.offset;
      if (isInsideSurrogatePair(data, offset) || isInsideCombinedSymbol(data, offset) || isInsideEmojiSequence(data, offset)) {
        continue;
      }
      count2++;
    } else if (item.is("containerElement") || item.is("emptyElement")) {
      count2++;
    }
    if (count2 > 1) {
      return true;
    }
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-typing/src/delete.js
var Delete = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Delete";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const modelDocument = editor.model.document;
    view.addObserver(DeleteObserver);
    this._undoOnBackspace = false;
    const deleteForwardCommand = new DeleteCommand(editor, "forward");
    editor.commands.add("deleteForward", deleteForwardCommand);
    editor.commands.add("forwardDelete", deleteForwardCommand);
    editor.commands.add("delete", new DeleteCommand(editor, "backward"));
    this.listenTo(viewDocument, "delete", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      const { direction, sequence, selectionToRemove, unit } = data;
      const commandName = direction === "forward" ? "deleteForward" : "delete";
      const commandData = { sequence };
      if (unit == "selection") {
        const modelRanges = Array.from(selectionToRemove.getRanges()).map((viewRange) => {
          return editor.editing.mapper.toModelRange(viewRange);
        });
        commandData.selection = editor.model.createSelection(modelRanges);
      } else {
        commandData.unit = unit;
      }
      editor.execute(commandName, commandData);
      view.scrollToTheSelection();
    }, { priority: "low" });
    if (this.editor.plugins.has("UndoEditing")) {
      this.listenTo(viewDocument, "delete", (evt, data) => {
        if (this._undoOnBackspace && data.direction == "backward" && data.sequence == 1 && data.unit == "codePoint") {
          this._undoOnBackspace = false;
          editor.execute("undo");
          data.preventDefault();
          evt.stop();
        }
      }, { context: "$capture" });
      this.listenTo(modelDocument, "change", () => {
        this._undoOnBackspace = false;
      });
    }
  }
  /**
   * If the next user action after calling this method is pressing backspace, it would undo the last change.
   *
   * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
   */
  requestUndoOnBackspace() {
    if (this.editor.plugins.has("UndoEditing")) {
      this._undoOnBackspace = true;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/typing.js
var Typing = class extends Plugin {
  static get requires() {
    return [Input, Delete];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Typing";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/utils/getlasttextline.js
function getLastTextLine(range, model) {
  let start = range.start;
  const text = Array.from(range.getWalker({ ignoreElementEnd: false })).reduce((rangeText, { item }) => {
    if (!(item.is("$text") || item.is("$textProxy"))) {
      start = model.createPositionAfter(item);
      return "";
    }
    return rangeText + item.data;
  }, "");
  return { text, range: model.createRange(start, range.end) };
}

// node_modules/@ckeditor/ckeditor5-typing/src/textwatcher.js
var TextWatcher = class extends ObservableMixin() {
  /**
   * Creates a text watcher instance.
   *
   * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
   */
  constructor(model, testCallback) {
    super();
    this.model = model;
    this.testCallback = testCallback;
    this._hasMatch = false;
    this.set("isEnabled", true);
    this.on("change:isEnabled", () => {
      if (this.isEnabled) {
        this._startListening();
      } else {
        this.stopListening(model.document.selection);
        this.stopListening(model.document);
      }
    });
    this._startListening();
  }
  /**
   * Flag indicating whether there is a match currently.
   */
  get hasMatch() {
    return this._hasMatch;
  }
  /**
   * Starts listening to the editor for typing and selection events.
   */
  _startListening() {
    const model = this.model;
    const document2 = model.document;
    this.listenTo(document2.selection, "change:range", (evt, { directChange }) => {
      if (!directChange) {
        return;
      }
      if (!document2.selection.isCollapsed) {
        if (this.hasMatch) {
          this.fire("unmatched");
          this._hasMatch = false;
        }
        return;
      }
      this._evaluateTextBeforeSelection("selection");
    });
    this.listenTo(document2, "change:data", (evt, batch) => {
      if (batch.isUndo || !batch.isLocal) {
        return;
      }
      this._evaluateTextBeforeSelection("data", { batch });
    });
  }
  /**
   * Checks the editor content for matched text.
   *
   * @fires matched:data
   * @fires matched:selection
   * @fires unmatched
   *
   * @param suffix A suffix used for generating the event name.
   * @param data Data object for event.
   */
  _evaluateTextBeforeSelection(suffix, data = {}) {
    const model = this.model;
    const document2 = model.document;
    const selection = document2.selection;
    const rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);
    const { text, range } = getLastTextLine(rangeBeforeSelection, model);
    const testResult = this.testCallback(text);
    if (!testResult && this.hasMatch) {
      this.fire("unmatched");
    }
    this._hasMatch = !!testResult;
    if (testResult) {
      const eventData = Object.assign(data, { text, range });
      if (typeof testResult == "object") {
        Object.assign(eventData, testResult);
      }
      this.fire(`matched:${suffix}`, eventData);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-typing/src/texttransformation.js
var TRANSFORMATIONS = {
  // Common symbols:
  copyright: { from: "(c)", to: "Â©" },
  registeredTrademark: { from: "(r)", to: "Â®" },
  trademark: { from: "(tm)", to: "â„¢" },
  // Mathematical:
  oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "Â½", null] },
  oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "â…“", null] },
  twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "â…”", null] },
  oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "Â¼", null] },
  threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "Â¾", null] },
  lessThanOrEqual: { from: "<=", to: "â‰¤" },
  greaterThanOrEqual: { from: ">=", to: "â‰¥" },
  notEqual: { from: "!=", to: "â‰ " },
  arrowLeft: { from: "<-", to: "â†" },
  arrowRight: { from: "->", to: "â†’" },
  // Typography:
  horizontalEllipsis: { from: "...", to: "â€¦" },
  enDash: { from: /(^| )(--)( )$/, to: [null, "â€“", null] },
  emDash: { from: /(^| )(---)( )$/, to: [null, "â€”", null] },
  // Quotations:
  // English, US
  quotesPrimary: { from: buildQuotesRegExp('"'), to: [null, "â€œ", null, "â€"] },
  quotesSecondary: { from: buildQuotesRegExp("'"), to: [null, "â€˜", null, "â€™"] },
  // English, UK
  quotesPrimaryEnGb: { from: buildQuotesRegExp("'"), to: [null, "â€˜", null, "â€™"] },
  quotesSecondaryEnGb: { from: buildQuotesRegExp('"'), to: [null, "â€œ", null, "â€"] },
  // Polish
  quotesPrimaryPl: { from: buildQuotesRegExp('"'), to: [null, "â€ž", null, "â€"] },
  quotesSecondaryPl: { from: buildQuotesRegExp("'"), to: [null, "â€š", null, "â€™"] }
};
function buildQuotesRegExp(quoteCharacter) {
  return new RegExp(`(^|\\s)(${quoteCharacter})([^${quoteCharacter}]*)(${quoteCharacter})$`);
}

// node_modules/@ckeditor/ckeditor5-enter/src/utils.js
function* getCopyOnEnterAttributes(schema, allAttributes) {
  for (const attribute of allAttributes) {
    if (attribute && schema.getAttributeProperties(attribute[0]).copyOnEnter) {
      yield attribute;
    }
  }
}

// node_modules/@ckeditor/ckeditor5-enter/src/entercommand.js
var EnterCommand = class extends Command {
  /**
   * @inheritDoc
   */
  execute() {
    this.editor.model.change((writer) => {
      this.enterBlock(writer);
      this.fire("afterExecute", { writer });
    });
  }
  /**
   * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
   *
   * ```
   * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
   * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
   * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
   * ```
   *
   * In some cases, the split will not happen:
   *
   * ```
   * // The selection parent is a limit element:
   * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
   *
   * // The selection spans over multiple elements:
   * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
   * ```
   *
   * @param writer Writer to use when performing the enter action.
   * @returns Boolean indicating if the block was split.
   */
  enterBlock(writer) {
    const model = this.editor.model;
    const selection = model.document.selection;
    const schema = model.schema;
    const isSelectionEmpty = selection.isCollapsed;
    const range = selection.getFirstRange();
    const startElement = range.start.parent;
    const endElement = range.end.parent;
    if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
      if (!isSelectionEmpty && startElement == endElement) {
        model.deleteContent(selection);
      }
      return false;
    }
    if (isSelectionEmpty) {
      const attributesToCopy = getCopyOnEnterAttributes(writer.model.schema, selection.getAttributes());
      splitBlock(writer, range.start);
      writer.setSelectionAttribute(attributesToCopy);
      return true;
    } else {
      const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
      const isContainedWithinOneElement = startElement == endElement;
      model.deleteContent(selection, { leaveUnmerged });
      if (leaveUnmerged) {
        if (isContainedWithinOneElement) {
          splitBlock(writer, selection.focus);
          return true;
        } else {
          writer.setSelection(endElement, 0);
        }
      }
    }
    return false;
  }
};
function splitBlock(writer, splitPos) {
  writer.split(splitPos);
  writer.setSelection(splitPos.parent.nextSibling, 0);
}

// node_modules/@ckeditor/ckeditor5-enter/src/enterobserver.js
var ENTER_EVENT_TYPES = {
  insertParagraph: { isSoft: false },
  insertLineBreak: { isSoft: true }
};
var EnterObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    const doc = this.document;
    let shiftPressed = false;
    doc.on("keydown", (evt, data) => {
      shiftPressed = data.shiftKey;
    });
    doc.on("beforeinput", (evt, data) => {
      if (!this.isEnabled) {
        return;
      }
      let inputType = data.inputType;
      if (env_default.isSafari && shiftPressed && inputType == "insertParagraph") {
        inputType = "insertLineBreak";
      }
      const domEvent = data.domEvent;
      const enterEventSpec = ENTER_EVENT_TYPES[inputType];
      if (!enterEventSpec) {
        return;
      }
      const event = new BubblingEventInfo(doc, "enter", data.targetRanges[0]);
      doc.fire(event, new DomEventData(view, domEvent, {
        isSoft: enterEventSpec.isSoft
      }));
      if (event.stop.called) {
        evt.stop();
      }
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
};

// node_modules/@ckeditor/ckeditor5-enter/src/enter.js
var Enter = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Enter";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const t = this.editor.t;
    view.addObserver(EnterObserver);
    editor.commands.add("enter", new EnterCommand(editor));
    this.listenTo(viewDocument, "enter", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      if (data.isSoft) {
        return;
      }
      editor.execute("enter");
      view.scrollToTheSelection();
    }, { priority: "low" });
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Insert a hard break (a new paragraph)"),
          keystroke: "Enter"
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-enter/src/shiftentercommand.js
var ShiftEnterCommand = class extends Command {
  /**
   * @inheritDoc
   */
  execute() {
    const model = this.editor.model;
    const doc = model.document;
    model.change((writer) => {
      softBreakAction(model, writer, doc.selection);
      this.fire("afterExecute", { writer });
    });
  }
  /**
   * @inheritDoc
   */
  refresh() {
    const model = this.editor.model;
    const doc = model.document;
    this.isEnabled = isEnabled(model.schema, doc.selection);
  }
};
function isEnabled(schema, selection) {
  if (selection.rangeCount > 1) {
    return false;
  }
  const anchorPos = selection.anchor;
  if (!anchorPos || !schema.checkChild(anchorPos, "softBreak")) {
    return false;
  }
  const range = selection.getFirstRange();
  const startElement = range.start.parent;
  const endElement = range.end.parent;
  if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {
    return false;
  }
  return true;
}
function softBreakAction(model, writer, selection) {
  const isSelectionEmpty = selection.isCollapsed;
  const range = selection.getFirstRange();
  const startElement = range.start.parent;
  const endElement = range.end.parent;
  const isContainedWithinOneElement = startElement == endElement;
  if (isSelectionEmpty) {
    const attributesToCopy = getCopyOnEnterAttributes(model.schema, selection.getAttributes());
    insertBreak(model, writer, range.end);
    writer.removeSelectionAttribute(selection.getAttributeKeys());
    writer.setSelectionAttribute(attributesToCopy);
  } else {
    const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
    model.deleteContent(selection, { leaveUnmerged });
    if (isContainedWithinOneElement) {
      insertBreak(model, writer, selection.focus);
    } else {
      if (leaveUnmerged) {
        writer.setSelection(endElement, 0);
      }
    }
  }
}
function insertBreak(model, writer, position) {
  const breakLineElement = writer.createElement("softBreak");
  model.insertContent(breakLineElement, position);
  writer.setSelection(breakLineElement, "after");
}
function isInsideLimitElement(element, schema) {
  if (element.is("rootElement")) {
    return false;
  }
  return schema.isLimit(element) || isInsideLimitElement(element.parent, schema);
}

// node_modules/@ckeditor/ckeditor5-enter/src/shiftenter.js
var ShiftEnter = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "ShiftEnter";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  init() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const conversion = editor.conversion;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const t = this.editor.t;
    schema.register("softBreak", {
      allowWhere: "$text",
      isInline: true
    });
    conversion.for("upcast").elementToElement({
      model: "softBreak",
      view: "br"
    });
    conversion.for("downcast").elementToElement({
      model: "softBreak",
      view: (modelElement, { writer }) => writer.createEmptyElement("br")
    });
    view.addObserver(EnterObserver);
    editor.commands.add("shiftEnter", new ShiftEnterCommand(editor));
    this.listenTo(viewDocument, "enter", (evt, data) => {
      if (!viewDocument.isComposing) {
        data.preventDefault();
      }
      if (!data.isSoft) {
        return;
      }
      editor.execute("shiftEnter");
      view.scrollToTheSelection();
    }, { priority: "low" });
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Insert a soft break (a <code>&lt;br&gt;</code> element)"),
          keystroke: "Shift+Enter"
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-widget/src/highlightstack.js
var HighlightStack = class extends EmitterMixin() {
  constructor() {
    super(...arguments);
    this._stack = [];
  }
  /**
   * Adds highlight descriptor to the stack.
   *
   * @fires change:top
   */
  add(descriptor, writer) {
    const stack = this._stack;
    const oldTop = stack[0];
    this._insertDescriptor(descriptor);
    const newTop = stack[0];
    if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
      this.fire("change:top", {
        oldDescriptor: oldTop,
        newDescriptor: newTop,
        writer
      });
    }
  }
  /**
   * Removes highlight descriptor from the stack.
   *
   * @fires change:top
   * @param id Id of the descriptor to remove.
   */
  remove(id, writer) {
    const stack = this._stack;
    const oldTop = stack[0];
    this._removeDescriptor(id);
    const newTop = stack[0];
    if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
      this.fire("change:top", {
        oldDescriptor: oldTop,
        newDescriptor: newTop,
        writer
      });
    }
  }
  /**
   * Inserts a given descriptor in correct place in the stack. It also takes care about updating information
   * when descriptor with same id is already present.
   */
  _insertDescriptor(descriptor) {
    const stack = this._stack;
    const index = stack.findIndex((item) => item.id === descriptor.id);
    if (compareDescriptors(descriptor, stack[index])) {
      return;
    }
    if (index > -1) {
      stack.splice(index, 1);
    }
    let i = 0;
    while (stack[i] && shouldABeBeforeB(stack[i], descriptor)) {
      i++;
    }
    stack.splice(i, 0, descriptor);
  }
  /**
   * Removes descriptor with given id from the stack.
   *
   * @param id Descriptor's id.
   */
  _removeDescriptor(id) {
    const stack = this._stack;
    const index = stack.findIndex((item) => item.id === id);
    if (index > -1) {
      stack.splice(index, 1);
    }
  }
};
function compareDescriptors(a, b) {
  return a && b && a.priority == b.priority && classesToString(a.classes) == classesToString(b.classes);
}
function shouldABeBeforeB(a, b) {
  if (a.priority > b.priority) {
    return true;
  } else if (a.priority < b.priority) {
    return false;
  }
  return classesToString(a.classes) > classesToString(b.classes);
}
function classesToString(classes) {
  return Array.isArray(classes) ? classes.sort().join(",") : classes;
}

// node_modules/@ckeditor/ckeditor5-widget/src/utils.js
import dragHandleIcon from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-widget/theme/icons/drag-handle.svg";
var WIDGET_SELECTED_CLASS_NAME = "ck-widget_selected";
function isWidget(node) {
  if (!node.is("element")) {
    return false;
  }
  return !!node.getCustomProperty("widget");
}
function getLabel(element) {
  const widgetLabel = element.getCustomProperty("widgetLabel");
  return widgetLabel.reduce((prev, current) => {
    if (typeof current === "function") {
      return prev ? prev + ". " + current() : current();
    } else {
      return prev ? prev + ". " + current : current;
    }
  }, "");
}
function calculateResizeHostAncestorWidth(domResizeHost) {
  const getElementComputedWidth = (element) => {
    const { width, paddingLeft, paddingRight } = element.ownerDocument.defaultView.getComputedStyle(element);
    return parseFloat(width) - (parseFloat(paddingLeft) || 0) - (parseFloat(paddingRight) || 0);
  };
  const domResizeHostParent = domResizeHost.parentElement;
  if (!domResizeHostParent) {
    return 0;
  }
  let parentWidth = getElementComputedWidth(domResizeHostParent);
  const ancestorLevelLimit = 5;
  let currentLevel = 0;
  let checkedElement = domResizeHostParent;
  while (isNaN(parentWidth)) {
    checkedElement = checkedElement.parentElement;
    if (++currentLevel > ancestorLevelLimit) {
      return 0;
    }
    parentWidth = getElementComputedWidth(checkedElement);
  }
  return parentWidth;
}
function calculateResizeHostPercentageWidth(domResizeHost, resizeHostRect = new Rect(domResizeHost)) {
  const parentWidth = calculateResizeHostAncestorWidth(domResizeHost);
  if (!parentWidth) {
    return 0;
  }
  return resizeHostRect.width / parentWidth * 100;
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/utils.js
var TYPE_AROUND_SELECTION_ATTRIBUTE = "widget-type-around";
function isTypeAroundWidget(viewElement, modelElement, schema) {
  return !!viewElement && isWidget(viewElement) && !schema.isInline(modelElement);
}
function getClosestTypeAroundDomButton(domElement) {
  return domElement.closest(".ck-widget__type-around__button");
}
function getTypeAroundButtonPosition(domElement) {
  return domElement.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
}
function getClosestWidgetViewElement(domElement, domConverter) {
  const widgetDomElement = domElement.closest(".ck-widget");
  return domConverter.mapDomToView(widgetDomElement);
}
function getTypeAroundFakeCaretPosition(selection) {
  return selection.getAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js
import returnIcon from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-widget/theme/icons/return-arrow.svg";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css";
var POSSIBLE_INSERTION_POSITIONS = ["before", "after"];
var RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, "image/svg+xml").firstChild;
var PLUGIN_DISABLED_EDITING_ROOT_CLASS = "ck-widget__type-around_disabled";
var WidgetTypeAround = class extends Plugin {
  constructor() {
    super(...arguments);
    this._currentFakeCaretModelElement = null;
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "WidgetTypeAround";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Enter, Delete];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    this.on("change:isEnabled", (evt, data, isEnabled2) => {
      editingView.change((writer) => {
        for (const root of editingView.document.roots) {
          if (isEnabled2) {
            writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);
          } else {
            writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);
          }
        }
      });
      if (!isEnabled2) {
        editor.model.change((writer) => {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
        });
      }
    });
    this._enableTypeAroundUIInjection();
    this._enableInsertingParagraphsOnButtonClick();
    this._enableInsertingParagraphsOnEnterKeypress();
    this._enableInsertingParagraphsOnTypingKeystroke();
    this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
    this._enableDeleteIntegration();
    this._enableInsertContentIntegration();
    this._enableInsertObjectIntegration();
    this._enableDeleteContentIntegration();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._currentFakeCaretModelElement = null;
  }
  /**
   * Inserts a new paragraph next to a widget element with the selection anchored in it.
   *
   * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
   * the viewport to the selection in the inserted paragraph.
   *
   * @param widgetModelElement The model widget element next to which a paragraph is inserted.
   * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
   */
  _insertParagraph(widgetModelElement, position) {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const attributesToCopy = editor.model.schema.getAttributesWithProperty(widgetModelElement, "copyOnReplace", true);
    editor.execute("insertParagraph", {
      position: editor.model.createPositionAt(widgetModelElement, position),
      attributes: attributesToCopy
    });
    editingView.focus();
    editingView.scrollToTheSelection();
  }
  /**
   * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only
   * when the plugin {@link #isEnabled is enabled}.
   *
   * @param emitter The object that fires the event.
   * @param event The name of the event.
   * @param callback The function to be called on event.
   * @param options Additional options.
   * @param options.priority The priority of this event callback. The higher the priority value the sooner
   * the callback will be fired. Events having the same priority are called in the order they were added.
   */
  _listenToIfEnabled(emitter, event, callback, options) {
    this.listenTo(emitter, event, (...args) => {
      if (this.isEnabled) {
        callback(...args);
      }
    }, options);
  }
  /**
   * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
   * does not expect a position. Instead, it performs the insertion next to a selected widget
   * according to the `widget-type-around` model selection attribute value (fake caret position).
   *
   * Because this method requires the `widget-type-around` attribute to be set,
   * the insertion can only happen when the widget's fake caret is active (e.g. activated
   * using the keyboard).
   *
   * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
   */
  _insertParagraphAccordingToFakeCaretPosition() {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
    if (!typeAroundFakeCaretPosition) {
      return false;
    }
    const selectedModelElement = modelSelection.getSelectedElement();
    this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);
    return true;
  }
  /**
   * Creates a listener in the editing conversion pipeline that injects the widget type around
   * UI into every single widget instance created in the editor.
   *
   * The UI is delivered as a {@link module:engine/view/uielement~UIElement}
   * wrapper which renders DOM buttons that users can use to insert paragraphs.
   */
  _enableTypeAroundUIInjection() {
    const editor = this.editor;
    const schema = editor.model.schema;
    const t = editor.locale.t;
    const buttonTitles = {
      before: t("Insert paragraph before block"),
      after: t("Insert paragraph after block")
    };
    editor.editing.downcastDispatcher.on("insert", (evt, data, conversionApi) => {
      const viewElement = conversionApi.mapper.toViewElement(data.item);
      if (!viewElement) {
        return;
      }
      if (isTypeAroundWidget(viewElement, data.item, schema)) {
        injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);
        const widgetLabel = viewElement.getCustomProperty("widgetLabel");
        widgetLabel.push(() => {
          return this.isEnabled ? t("Press Enter to type after or press Shift + Enter to type before the widget") : "";
        });
      }
    }, { priority: "low" });
  }
  /**
   * Brings support for the fake caret that appears when either:
   *
   * * the selection moves to a widget from a position next to it using arrow keys,
   * * the arrow key is pressed when the widget is already selected.
   *
   * The fake caret lets the user know that they can start typing or just press
   * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.
   *
   * The fake caret disappears when the user changes the selection or the editor
   * gets blurred.
   *
   * The whole idea is as follows:
   *
   * 1. A user does one of the 2 scenarios described at the beginning.
   * 2. The "keydown" listener is executed and the decision is made whether to show or hide the fake caret.
   * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating
   *    on which side of the widget it should appear.
   * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
   *    fake caret on the view widget.
   * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher
   *    does the CSS class clean-up in the view.
   * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection
   *    attribute (the former also removes widget CSS classes).
   */
  _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const schema = model.schema;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "arrowKey", (evt, domEventData) => {
      this._handleArrowKeyPress(evt, domEventData);
    }, { context: [isWidget, "$text"], priority: "high" });
    this._listenToIfEnabled(modelSelection, "change:range", (evt, data) => {
      if (!data.directChange) {
        return;
      }
      editor.model.change((writer) => {
        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
      });
    });
    this._listenToIfEnabled(model.document, "change:data", () => {
      const selectedModelElement = modelSelection.getSelectedElement();
      if (selectedModelElement) {
        const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
          return;
        }
      }
      editor.model.change((writer) => {
        writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
      });
    });
    this._listenToIfEnabled(editor.editing.downcastDispatcher, "selection", (evt, data, conversionApi) => {
      const writer = conversionApi.writer;
      if (this._currentFakeCaretModelElement) {
        const selectedViewElement2 = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);
        if (selectedViewElement2) {
          writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement2);
          this._currentFakeCaretModelElement = null;
        }
      }
      const selectedModelElement = data.selection.getSelectedElement();
      if (!selectedModelElement) {
        return;
      }
      const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);
      if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement);
      this._currentFakeCaretModelElement = selectedModelElement;
    });
    this._listenToIfEnabled(editor.ui.focusTracker, "change:isFocused", (evt, name, isFocused) => {
      if (!isFocused) {
        editor.model.change((writer) => {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
        });
      }
    });
    function positionToWidgetCssClass(position) {
      return `ck-widget_type-around_show-fake-caret_${position}`;
    }
  }
  /**
   * A listener executed on each "keydown" in the view document, a part of
   * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
   *
   * It decides whether the arrow keypress should activate the fake caret or not (also whether it should
   * be deactivated).
   *
   * The fake caret activation is done by setting the `widget-type-around` model selection attribute
   * in this listener, and stopping and preventing the event that would normally be handled by the widget
   * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
   * includes inline widgets, which are ignored by the widget type around plugin).
   */
  _handleArrowKeyPress(evt, domEventData) {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const schema = model.schema;
    const editingView = editor.editing.view;
    const keyCode = domEventData.keyCode;
    const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);
    const selectedViewElement = editingView.document.selection.getSelectedElement();
    const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);
    let shouldStopAndPreventDefault;
    if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);
    } else if (modelSelection.isCollapsed) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);
    } else if (!domEventData.shiftKey) {
      shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);
    }
    if (shouldStopAndPreventDefault) {
      domEventData.preventDefault();
      evt.stop();
    }
  }
  /**
   * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
   * the fake caret for that widget, depending on the current value of the `widget-type-around` model
   * selection attribute and the direction of the pressed arrow key.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressOnSelectedWidget(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const modelSelection = model.document.selection;
    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
    return model.change((writer) => {
      if (typeAroundFakeCaretPosition) {
        const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? "after" : "before");
        if (!isLeavingWidget) {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
          return true;
        }
      } else {
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
        return true;
      }
      return false;
    });
  }
  /**
   * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
   * to one and upon the fake caret should become active for this widget upon arrow keypress
   * (AKA entering/selecting the widget).
   *
   * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.
   * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the
   * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const schema = model.schema;
    const widgetPlugin = editor.plugins.get("Widget");
    const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);
    const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);
    if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {
      model.change((writer) => {
        widgetPlugin._setSelectionOverElement(modelElementNextToSelection);
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "before" : "after");
      });
      return true;
    }
    return false;
  }
  /**
   * Handles the keyboard navigation on "keydown" when a widget is currently selected (together with some other content)
   * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.
   *
   * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
   * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
   * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
   * process the event any further. Returns `false` otherwise.
   */
  _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {
    const editor = this.editor;
    const model = editor.model;
    const schema = model.schema;
    const mapper = editor.editing.mapper;
    const modelSelection = model.document.selection;
    const selectedModelNode = isForward ? modelSelection.getLastPosition().nodeBefore : modelSelection.getFirstPosition().nodeAfter;
    const selectedViewNode = mapper.toViewElement(selectedModelNode);
    if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {
      model.change((writer) => {
        writer.setSelection(selectedModelNode, "on");
        writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
      });
      return true;
    }
    return false;
  }
  /**
   * Registers a `mousedown` listener for the view document which intercepts events
   * coming from the widget type around UI, which happens when a user clicks one of the buttons
   * that insert a paragraph next to a widget.
   */
  _enableInsertingParagraphsOnButtonClick() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "mousedown", (evt, domEventData) => {
      const button = getClosestTypeAroundDomButton(domEventData.domTarget);
      if (!button) {
        return;
      }
      const buttonPosition = getTypeAroundButtonPosition(button);
      const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);
      const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);
      this._insertParagraph(widgetModelElement, buttonPosition);
      domEventData.preventDefault();
      evt.stop();
    });
  }
  /**
   * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph
   * near the widget when either:
   *
   * * The fake caret was first activated using the arrow keys,
   * * The entire widget is selected in the model.
   *
   * In the first case, the new paragraph is inserted according to the `widget-type-around` selection
   * attribute (see {@link #_handleArrowKeyPress}).
   *
   * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke
   * was pressed or not.
   */
  _enableInsertingParagraphsOnEnterKeypress() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const editingView = editor.editing.view;
    this._listenToIfEnabled(editingView.document, "enter", (evt, domEventData) => {
      if (evt.eventPhase != "atTarget") {
        return;
      }
      const selectedModelElement = selection.getSelectedElement();
      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
      const schema = editor.model.schema;
      let wasHandled;
      if (this._insertParagraphAccordingToFakeCaretPosition()) {
        wasHandled = true;
      } else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
        this._insertParagraph(selectedModelElement, domEventData.isSoft ? "before" : "after");
        wasHandled = true;
      }
      if (wasHandled) {
        domEventData.preventDefault();
        evt.stop();
      }
    }, { context: isWidget });
  }
  /**
   * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
   * to insert a paragraph next to a widget when the fake caret was activated using arrow
   * keys but it responds to typing instead of <kbd>Enter</kbd>.
   *
   * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`
   * model selection attribute as the user simply starts typing, which creates the impression that the fake caret
   * behaves like a real one rendered by the browser (AKA your text appears where the caret was).
   *
   * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command
   * and another one for actual typing. It is not a disaster but this may need to be fixed
   * sooner or later.
   */
  _enableInsertingParagraphsOnTypingKeystroke() {
    const editor = this.editor;
    const viewDocument = editor.editing.view.document;
    this._listenToIfEnabled(viewDocument, "insertText", (evt, data) => {
      if (this._insertParagraphAccordingToFakeCaretPosition()) {
        data.selection = viewDocument.selection;
      }
    }, { priority: "high" });
    if (env_default.isAndroid) {
      this._listenToIfEnabled(viewDocument, "keydown", (evt, data) => {
        if (data.keyCode == 229) {
          this._insertParagraphAccordingToFakeCaretPosition();
        }
      });
    } else {
      this._listenToIfEnabled(viewDocument, "compositionstart", () => {
        this._insertParagraphAccordingToFakeCaretPosition();
      }, { priority: "high" });
    }
  }
  /**
   * It creates a "delete" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>
   * is pressed and the fake caret is currently active.
   *
   * The fake caret should create an illusion of a real browser caret so that when it appears before or after
   * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content
   * before or after a widget (depending on the content surrounding the widget).
   */
  _enableDeleteIntegration() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const model = editor.model;
    const schema = model.schema;
    this._listenToIfEnabled(editingView.document, "delete", (evt, domEventData) => {
      if (evt.eventPhase != "atTarget") {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      const direction = domEventData.direction;
      const selectedModelWidget = model.document.selection.getSelectedElement();
      const isFakeCaretBefore = typeAroundFakeCaretPosition === "before";
      const isDeleteForward = direction == "forward";
      const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;
      if (shouldDeleteEntireWidget) {
        editor.execute("delete", {
          selection: model.createSelection(selectedModelWidget, "on")
        });
      } else {
        const range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction);
        if (range) {
          if (!range.isCollapsed) {
            model.change((writer) => {
              writer.setSelection(range);
              editor.execute(isDeleteForward ? "deleteForward" : "delete");
            });
          } else {
            const probe = model.createSelection(range.start);
            model.modifySelection(probe, { direction });
            if (!probe.focus.isEqual(range.start)) {
              model.change((writer) => {
                writer.setSelection(range);
                editor.execute(isDeleteForward ? "deleteForward" : "delete");
              });
            } else {
              const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);
              model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, "on"), {
                doNotAutoparagraph: true
              });
            }
          }
        }
      }
      domEventData.preventDefault();
      evt.stop();
    }, { context: isWidget });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
   * content near a widget when the fake caret is first activated using the arrow keys.
   *
   * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
   */
  _enableInsertContentIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "insertContent", (evt, [content, selectable]) => {
      if (selectable && !selectable.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      evt.stop();
      return model.change((writer) => {
        const selectedElement = documentSelection.getSelectedElement();
        const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);
        const selection = writer.createSelection(position);
        const result = model.insertContent(content, selection);
        writer.setSelection(selection);
        return result;
      });
    }, { priority: "high" });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the
   * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element
   * to reflect user's intent of desired insertion position.
   *
   * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
   */
  _enableInsertObjectIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "insertObject", (evt, args) => {
      const [, selectable, options = {}] = args;
      if (selectable && !selectable.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (!typeAroundFakeCaretPosition) {
        return;
      }
      options.findOptimalPosition = typeAroundFakeCaretPosition;
      args[3] = options;
    }, { priority: "high" });
  }
  /**
   * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake
   * caret is active.
   *
   * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
   * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,
   * plain text pasting.
   */
  _enableDeleteContentIntegration() {
    const editor = this.editor;
    const model = this.editor.model;
    const documentSelection = model.document.selection;
    this._listenToIfEnabled(editor.model, "deleteContent", (evt, [selection]) => {
      if (selection && !selection.is("documentSelection")) {
        return;
      }
      const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
      if (typeAroundFakeCaretPosition) {
        evt.stop();
      }
    }, { priority: "high" });
  }
};
function injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {
  const typeAroundWrapper = viewWriter.createUIElement("div", {
    class: "ck ck-reset_all ck-widget__type-around"
  }, function(domDocument) {
    const wrapperDomElement = this.toDomElement(domDocument);
    injectButtons(wrapperDomElement, buttonTitles);
    injectFakeCaret(wrapperDomElement);
    return wrapperDomElement;
  });
  viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, "end"), typeAroundWrapper);
}
function injectButtons(wrapperDomElement, buttonTitles) {
  for (const position of POSSIBLE_INSERTION_POSITIONS) {
    const buttonTemplate = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-widget__type-around__button",
          `ck-widget__type-around__button_${position}`
        ],
        title: buttonTitles[position],
        "aria-hidden": "true"
      },
      children: [
        wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)
      ]
    });
    wrapperDomElement.appendChild(buttonTemplate.render());
  }
}
function injectFakeCaret(wrapperDomElement) {
  const caretTemplate = new Template({
    tag: "div",
    attributes: {
      class: [
        "ck",
        "ck-widget__type-around__fake-caret"
      ]
    }
  });
  wrapperDomElement.appendChild(caretTemplate.render());
}
function getDeepestEmptyElementAncestor(schema, element) {
  let deepestEmptyAncestor = element;
  for (const ancestor of element.getAncestors({ parentFirst: true })) {
    if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {
      break;
    }
    deepestEmptyAncestor = ancestor;
  }
  return deepestEmptyAncestor;
}

// node_modules/@ckeditor/ckeditor5-widget/src/verticalnavigation.js
function verticalNavigationHandler(editing) {
  const model = editing.model;
  return (evt, data) => {
    const arrowUpPressed = data.keyCode == keyCodes.arrowup;
    const arrowDownPressed = data.keyCode == keyCodes.arrowdown;
    const expandSelection = data.shiftKey;
    const selection = model.document.selection;
    if (!arrowUpPressed && !arrowDownPressed) {
      return;
    }
    const isForward = arrowDownPressed;
    if (expandSelection && selectionWillShrink(selection, isForward)) {
      return;
    }
    const range = findTextRangeFromSelection(editing, selection, isForward);
    if (!range) {
      return;
    }
    if (range.isCollapsed) {
      if (selection.isCollapsed) {
        return;
      } else if (expandSelection) {
        return;
      }
    }
    if (range.isCollapsed || isSingleLineRange(editing, range, isForward)) {
      model.change((writer) => {
        const newPosition = isForward ? range.end : range.start;
        if (expandSelection) {
          const newSelection = model.createSelection(selection.anchor);
          newSelection.setFocus(newPosition);
          writer.setSelection(newSelection);
        } else {
          writer.setSelection(newPosition);
        }
      });
      evt.stop();
      data.preventDefault();
      data.stopPropagation();
    }
  };
}
function findTextRangeFromSelection(editing, selection, isForward) {
  const model = editing.model;
  if (isForward) {
    const startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();
    const endPosition = getNearestNonInlineLimit(model, startPosition, "forward");
    if (!endPosition) {
      return null;
    }
    const range = model.createRange(startPosition, endPosition);
    const lastRangePosition = getNearestTextPosition(model.schema, range, "backward");
    if (lastRangePosition) {
      return model.createRange(startPosition, lastRangePosition);
    }
    return null;
  } else {
    const endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();
    const startPosition = getNearestNonInlineLimit(model, endPosition, "backward");
    if (!startPosition) {
      return null;
    }
    const range = model.createRange(startPosition, endPosition);
    const firstRangePosition = getNearestTextPosition(model.schema, range, "forward");
    if (firstRangePosition) {
      return model.createRange(firstRangePosition, endPosition);
    }
    return null;
  }
}
function getNearestNonInlineLimit(model, startPosition, direction) {
  const schema = model.schema;
  const range = model.createRangeIn(startPosition.root);
  const walkerValueType = direction == "forward" ? "elementStart" : "elementEnd";
  for (const { previousPosition, item, type } of range.getWalker({ startPosition, direction })) {
    if (schema.isLimit(item) && !schema.isInline(item)) {
      return previousPosition;
    }
    if (type == walkerValueType && schema.isBlock(item)) {
      return null;
    }
  }
  return null;
}
function getNearestTextPosition(schema, range, direction) {
  const position = direction == "backward" ? range.end : range.start;
  if (schema.checkChild(position, "$text")) {
    return position;
  }
  for (const { nextPosition } of range.getWalker({ direction })) {
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  }
  return null;
}
function isSingleLineRange(editing, modelRange, isForward) {
  const model = editing.model;
  const domConverter = editing.view.domConverter;
  if (isForward) {
    const probe = model.createSelection(modelRange.start);
    model.modifySelection(probe);
    if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {
      modelRange = model.createRange(probe.focus, modelRange.end);
    }
  }
  const viewRange = editing.mapper.toViewRange(modelRange);
  const domRange = domConverter.viewRangeToDom(viewRange);
  const rects = Rect.getDomRangeRects(domRange);
  let boundaryVerticalPosition;
  for (const rect of rects) {
    if (boundaryVerticalPosition === void 0) {
      boundaryVerticalPosition = Math.round(rect.bottom);
      continue;
    }
    if (Math.round(rect.top) >= boundaryVerticalPosition) {
      return false;
    }
    boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));
  }
  return true;
}
function selectionWillShrink(selection, isForward) {
  return !selection.isCollapsed && selection.isBackward == isForward;
}

// node_modules/@ckeditor/ckeditor5-widget/src/widget.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-widget/theme/widget.css";
var Widget = class extends Plugin {
  constructor() {
    super(...arguments);
    this._previouslySelected = /* @__PURE__ */ new Set();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Widget";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [WidgetTypeAround, Delete];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const t = editor.t;
    this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
      const viewWriter = conversionApi.writer;
      const modelSelection = data.selection;
      if (modelSelection.isCollapsed) {
        return;
      }
      const selectedModelElement = modelSelection.getSelectedElement();
      if (!selectedModelElement) {
        return;
      }
      const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
      if (!isWidget(selectedViewElement)) {
        return;
      }
      if (!conversionApi.consumable.consume(modelSelection, "selection")) {
        return;
      }
      viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {
        fake: true,
        label: getLabel(selectedViewElement)
      });
    });
    this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
      this._clearPreviouslySelectedWidgets(conversionApi.writer);
      const viewWriter = conversionApi.writer;
      const viewSelection = viewWriter.document.selection;
      let lastMarked = null;
      for (const range of viewSelection.getRanges()) {
        for (const value of range) {
          const node = value.item;
          if (isWidget(node) && !isChild(node, lastMarked)) {
            viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);
            this._previouslySelected.add(node);
            lastMarked = node;
          }
        }
      }
    }, { priority: "low" });
    view.addObserver(MouseObserver);
    this.listenTo(viewDocument, "mousedown", (...args) => this._onMousedown(...args));
    this.listenTo(viewDocument, "arrowKey", (...args) => {
      this._handleSelectionChangeOnArrowKeyPress(...args);
    }, { context: [isWidget, "$text"] });
    this.listenTo(viewDocument, "arrowKey", (...args) => {
      this._preventDefaultOnArrowKeyPress(...args);
    }, { context: "$root" });
    this.listenTo(viewDocument, "arrowKey", verticalNavigationHandler(this.editor.editing), { context: "$text" });
    this.listenTo(viewDocument, "delete", (evt, data) => {
      if (this._handleDelete(data.direction == "forward")) {
        data.preventDefault();
        evt.stop();
      }
    }, { context: "$root" });
    this.listenTo(viewDocument, "tab", (evt, data) => {
      if (evt.eventPhase != "atTarget") {
        return;
      }
      if (data.shiftKey) {
        return;
      }
      if (this._selectFirstNestedEditable()) {
        data.preventDefault();
        evt.stop();
      }
    }, { context: isWidget, priority: "low" });
    this.listenTo(viewDocument, "tab", (evt, data) => {
      if (!data.shiftKey) {
        return;
      }
      if (this._selectAncestorWidget()) {
        data.preventDefault();
        evt.stop();
      }
    }, { priority: "low" });
    this.listenTo(viewDocument, "keydown", (evt, data) => {
      if (data.keystroke != keyCodes.esc) {
        return;
      }
      if (this._selectAncestorWidget()) {
        data.preventDefault();
        evt.stop();
      }
    }, { priority: "low" });
    editor.accessibility.addKeystrokeInfoGroup({
      id: "widget",
      label: t("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"),
      keystrokes: [
        {
          label: t("Move focus from an editable area back to the parent widget"),
          keystroke: "Esc"
        },
        {
          label: t("Insert a new paragraph directly after a widget"),
          keystroke: "Enter"
        },
        {
          label: t("Insert a new paragraph directly before a widget"),
          keystroke: "Shift+Enter"
        },
        {
          label: t("Move the caret to allow typing directly before a widget"),
          keystroke: [["arrowup"], ["arrowleft"]]
        },
        {
          label: t("Move the caret to allow typing directly after a widget"),
          keystroke: [["arrowdown"], ["arrowright"]]
        }
      ]
    });
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
   */
  _onMousedown(eventInfo, domEventData) {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    let element = domEventData.target;
    if (!element) {
      return;
    }
    if (domEventData.domEvent.detail >= 3) {
      if (this._selectBlockContent(element)) {
        domEventData.preventDefault();
      }
      return;
    }
    if (!isWidget(element)) {
      const editableOrWidgetElement = findClosestEditableOrWidgetAncestor(element);
      if (!editableOrWidgetElement) {
        return;
      }
      if (isWidget(editableOrWidgetElement)) {
        element = editableOrWidgetElement;
      } else {
        const clickTargetFromPoint = getElementFromMouseEvent(view, domEventData);
        if (clickTargetFromPoint && isWidget(clickTargetFromPoint)) {
          element = clickTargetFromPoint;
        } else {
          return;
        }
      }
    }
    if (env_default.isAndroid) {
      domEventData.preventDefault();
    }
    if (!viewDocument.isFocused) {
      view.focus();
    }
    const modelElement = editor.editing.mapper.toModelElement(element);
    this._setSelectionOverElement(modelElement);
  }
  /**
   * Selects entire block content, e.g. on triple click it selects entire paragraph.
   */
  _selectBlockContent(element) {
    const editor = this.editor;
    const model = editor.model;
    const mapper = editor.editing.mapper;
    const schema = model.schema;
    const viewElement = mapper.findMappedViewAncestor(this.editor.editing.view.createPositionAt(element, 0));
    const modelElement = findTextBlockAncestor(mapper.toModelElement(viewElement), model.schema);
    if (!modelElement) {
      return false;
    }
    model.change((writer) => {
      const nextTextBlock = !schema.isLimit(modelElement) ? findNextTextBlock(writer.createPositionAfter(modelElement), schema) : null;
      const start = writer.createPositionAt(modelElement, 0);
      const end = nextTextBlock ? writer.createPositionAt(nextTextBlock, 0) : writer.createPositionAt(modelElement, "end");
      writer.setSelection(writer.createRange(start, end));
    });
    return true;
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes
   * the model selection when:
   *
   * * arrow key is pressed when the widget is selected,
   * * the selection is next to a widget and the widget should become selected upon the arrow key press.
   *
   * See {@link #_preventDefaultOnArrowKeyPress}.
   */
  _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {
    const keyCode = domEventData.keyCode;
    const model = this.editor.model;
    const schema = model.schema;
    const modelSelection = model.document.selection;
    const objectElement = modelSelection.getSelectedElement();
    const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);
    const isForward = direction == "down" || direction == "right";
    const isVerticalNavigation = direction == "up" || direction == "down";
    if (objectElement && schema.isObject(objectElement)) {
      const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();
      const newRange = schema.getNearestSelectionRange(position, isForward ? "forward" : "backward");
      if (newRange) {
        model.change((writer) => {
          writer.setSelection(newRange);
        });
        domEventData.preventDefault();
        eventInfo.stop();
      }
      return;
    }
    if (!modelSelection.isCollapsed && !domEventData.shiftKey) {
      const firstPosition = modelSelection.getFirstPosition();
      const lastPosition = modelSelection.getLastPosition();
      const firstSelectedNode = firstPosition.nodeAfter;
      const lastSelectedNode = lastPosition.nodeBefore;
      if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {
        model.change((writer) => {
          writer.setSelection(isForward ? lastPosition : firstPosition);
        });
        domEventData.preventDefault();
        eventInfo.stop();
      }
      return;
    }
    if (!modelSelection.isCollapsed) {
      return;
    }
    const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);
    if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {
      if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {
        return;
      }
      this._setSelectionOverElement(objectElementNextToSelection);
      domEventData.preventDefault();
      eventInfo.stop();
    }
  }
  /**
   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents
   * the default browser behavior to make sure the fake selection is not being moved from a fake selection
   * container.
   *
   * See {@link #_handleSelectionChangeOnArrowKeyPress}.
   */
  _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {
    const model = this.editor.model;
    const schema = model.schema;
    const objectElement = model.document.selection.getSelectedElement();
    if (objectElement && schema.isObject(objectElement)) {
      domEventData.preventDefault();
      eventInfo.stop();
    }
  }
  /**
   * Handles delete keys: backspace and delete.
   *
   * @param isForward Set to true if delete was performed in forward direction.
   * @returns Returns `true` if keys were handled correctly.
   */
  _handleDelete(isForward) {
    const modelDocument = this.editor.model.document;
    const modelSelection = modelDocument.selection;
    if (!this.editor.model.canEditAt(modelSelection)) {
      return;
    }
    if (!modelSelection.isCollapsed) {
      return;
    }
    const objectElement = this._getObjectElementNextToSelection(isForward);
    if (objectElement) {
      this.editor.model.change((writer) => {
        let previousNode = modelSelection.anchor.parent;
        while (previousNode.isEmpty) {
          const nodeToRemove = previousNode;
          previousNode = nodeToRemove.parent;
          writer.remove(nodeToRemove);
        }
        this._setSelectionOverElement(objectElement);
      });
      return true;
    }
  }
  /**
   * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
   *
   * @internal
   */
  _setSelectionOverElement(element) {
    this.editor.model.change((writer) => {
      writer.setSelection(writer.createRangeOn(element));
    });
  }
  /**
   * Checks if {@link module:engine/model/element~Element element} placed next to the current
   * {@link module:engine/model/selection~Selection model selection} exists and is marked in
   * {@link module:engine/model/schema~Schema schema} as `object`.
   *
   * @internal
   * @param forward Direction of checking.
   */
  _getObjectElementNextToSelection(forward) {
    const model = this.editor.model;
    const schema = model.schema;
    const modelSelection = model.document.selection;
    const probe = model.createSelection(modelSelection);
    model.modifySelection(probe, { direction: forward ? "forward" : "backward" });
    if (probe.isEqual(modelSelection)) {
      return null;
    }
    const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;
    if (!!objectElement && schema.isObject(objectElement)) {
      return objectElement;
    }
    return null;
  }
  /**
   * Removes CSS class from previously selected widgets.
   */
  _clearPreviouslySelectedWidgets(writer) {
    for (const widget of this._previouslySelected) {
      writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);
    }
    this._previouslySelected.clear();
  }
  /**
   * Moves the document selection into the first nested editable.
   */
  _selectFirstNestedEditable() {
    const editor = this.editor;
    const view = this.editor.editing.view;
    const viewDocument = view.document;
    for (const item of viewDocument.selection.getFirstRange().getItems()) {
      if (item.is("editableElement")) {
        const modelElement = editor.editing.mapper.toModelElement(item);
        if (!modelElement) {
          continue;
        }
        const position = editor.model.createPositionAt(modelElement, 0);
        const newRange = editor.model.schema.getNearestSelectionRange(position, "forward");
        editor.model.change((writer) => {
          writer.setSelection(newRange);
        });
        return true;
      }
    }
    return false;
  }
  /**
   * Updates the document selection so that it selects first ancestor widget.
   */
  _selectAncestorWidget() {
    const editor = this.editor;
    const mapper = editor.editing.mapper;
    const selection = editor.editing.view.document.selection;
    const positionParent = selection.getFirstPosition().parent;
    const positionParentElement = positionParent.is("$text") ? positionParent.parent : positionParent;
    const viewElement = positionParentElement.findAncestor(isWidget);
    if (!viewElement) {
      return false;
    }
    const modelElement = mapper.toModelElement(viewElement);
    if (!modelElement) {
      return false;
    }
    editor.model.change((writer) => {
      writer.setSelection(modelElement, "on");
    });
    return true;
  }
};
function findClosestEditableOrWidgetAncestor(element) {
  let currentElement = element;
  while (currentElement) {
    if (currentElement.is("editableElement") || isWidget(currentElement)) {
      return currentElement;
    }
    currentElement = currentElement.parent;
  }
  return null;
}
function getElementFromMouseEvent(view, domEventData) {
  const domRange = getRangeFromMouseEvent(domEventData.domEvent);
  let viewRange = null;
  if (domRange) {
    viewRange = view.domConverter.domRangeToView(domRange);
  } else {
    viewRange = view.createRange(view.createPositionAt(domEventData.target, 0));
  }
  if (!viewRange) {
    return null;
  }
  const viewPosition = viewRange.start;
  if (!viewPosition.parent) {
    return null;
  }
  let viewNode = viewPosition.parent;
  if (viewPosition.parent.is("editableElement")) {
    if (viewPosition.isAtEnd && viewPosition.nodeBefore) {
      viewNode = viewPosition.nodeBefore;
    } else if (viewPosition.isAtStart && viewPosition.nodeAfter) {
      viewNode = viewPosition.nodeAfter;
    }
  }
  if (viewNode.is("$text")) {
    return viewNode.parent;
  }
  return viewNode;
}
function isChild(element, parent) {
  if (!parent) {
    return false;
  }
  return Array.from(element.getAncestors()).includes(parent);
}
function findTextBlockAncestor(modelElement, schema) {
  for (const element of modelElement.getAncestors({ includeSelf: true, parentFirst: true })) {
    if (schema.checkChild(element, "$text")) {
      return element;
    }
    if (schema.isLimit(element) && !schema.isObject(element)) {
      break;
    }
  }
  return null;
}
function findNextTextBlock(position, schema) {
  const treeWalker = new TreeWalker({ startPosition: position });
  for (const { item } of treeWalker) {
    if (schema.isLimit(item) || !item.is("element")) {
      return null;
    }
    if (schema.checkChild(item, "$text")) {
      return item;
    }
  }
  return null;
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/resizerstate.js
var ResizeState = class extends ObservableMixin() {
  /**
   * @param options Resizer options.
   */
  constructor(options) {
    super();
    this.set("activeHandlePosition", null);
    this.set("proposedWidthPercents", null);
    this.set("proposedWidth", null);
    this.set("proposedHeight", null);
    this.set("proposedHandleHostWidth", null);
    this.set("proposedHandleHostHeight", null);
    this._options = options;
    this._referenceCoordinates = null;
  }
  /**
   * The original width (pixels) of the resized object when the resize process was started.
   */
  get originalWidth() {
    return this._originalWidth;
  }
  /**
   * The original height (pixels) of the resized object when the resize process was started.
   */
  get originalHeight() {
    return this._originalHeight;
  }
  /**
   * The original width (percents) of the resized object when the resize process was started.
   */
  get originalWidthPercents() {
    return this._originalWidthPercents;
  }
  /**
   * A width to height ratio of the resized image.
   */
  get aspectRatio() {
    return this._aspectRatio;
  }
  /**
   *
   * @param domResizeHandle The handle used to calculate the reference point.
   */
  begin(domResizeHandle, domHandleHost, domResizeHost) {
    const clientRect = new Rect(domHandleHost);
    this.activeHandlePosition = getHandlePosition(domResizeHandle);
    this._referenceCoordinates = getAbsoluteBoundaryPoint(domHandleHost, getOppositePosition(this.activeHandlePosition));
    this._originalWidth = clientRect.width;
    this._originalHeight = clientRect.height;
    this._aspectRatio = clientRect.width / clientRect.height;
    const widthStyle = domResizeHost.style.width;
    if (widthStyle && widthStyle.match(/^\d+(\.\d*)?%$/)) {
      this._originalWidthPercents = parseFloat(widthStyle);
    } else {
      this._originalWidthPercents = calculateResizeHostPercentageWidth(domResizeHost, clientRect);
    }
  }
  update(newSize) {
    this.proposedWidth = newSize.width;
    this.proposedHeight = newSize.height;
    this.proposedWidthPercents = newSize.widthPercents;
    this.proposedHandleHostWidth = newSize.handleHostWidth;
    this.proposedHandleHostHeight = newSize.handleHostHeight;
  }
};
function getAbsoluteBoundaryPoint(element, resizerPosition) {
  const elementRect = new Rect(element);
  const positionParts = resizerPosition.split("-");
  const ret = {
    x: positionParts[1] == "right" ? elementRect.right : elementRect.left,
    y: positionParts[0] == "bottom" ? elementRect.bottom : elementRect.top
  };
  ret.x += element.ownerDocument.defaultView.scrollX;
  ret.y += element.ownerDocument.defaultView.scrollY;
  return ret;
}
function getResizerHandleClass(resizerPosition) {
  return `ck-widget__resizer__handle-${resizerPosition}`;
}
function getHandlePosition(domHandle) {
  const resizerPositions = ["top-left", "top-right", "bottom-right", "bottom-left"];
  for (const position of resizerPositions) {
    if (domHandle.classList.contains(getResizerHandleClass(position))) {
      return position;
    }
  }
}
function getOppositePosition(position) {
  const parts = position.split("-");
  const replacements = {
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
  };
  return `${replacements[parts[0]]}-${replacements[parts[1]]}`;
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/sizeview.js
var SizeView = class extends View {
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-size-view",
          bind.to("_viewPosition", (value) => value ? `ck-orientation-${value}` : "")
        ],
        style: {
          display: bind.if("_isVisible", "none", (visible) => !visible)
        }
      },
      children: [{
        text: bind.to("_label")
      }]
    });
  }
  /**
   * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.
   *
   * @internal
   * @param options An object defining the resizer options, used for setting the proper size label.
   * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.
   */
  _bindToState(options, resizeState) {
    this.bind("_isVisible").to(resizeState, "proposedWidth", resizeState, "proposedHeight", (width, height) => width !== null && height !== null);
    this.bind("_label").to(resizeState, "proposedHandleHostWidth", resizeState, "proposedHandleHostHeight", resizeState, "proposedWidthPercents", (width, height, widthPercents) => {
      if (options.unit === "px") {
        return `${width}Ã—${height}`;
      } else {
        return `${widthPercents}%`;
      }
    });
    this.bind("_viewPosition").to(
      resizeState,
      "activeHandlePosition",
      resizeState,
      "proposedHandleHostWidth",
      resizeState,
      "proposedHandleHostHeight",
      // If the widget is too small to contain the size label, display the label above.
      (position, width, height) => width < 50 || height < 50 ? "above-center" : position
    );
  }
  /**
   * A method used for cleaning up. It removes the bindings and hides the view.
   *
   * @internal
   */
  _dismiss() {
    this.unbind();
    this._isVisible = false;
  }
};

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize/resizer.js
var Resizer = class extends ObservableMixin() {
  /**
   * @param options Resizer options.
   */
  constructor(options) {
    super();
    this._viewResizerWrapper = null;
    this._options = options;
    this.set("isEnabled", true);
    this.set("isSelected", false);
    this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (isEnabled2, isSelected) => isEnabled2 && isSelected);
    this.decorate("begin");
    this.decorate("cancel");
    this.decorate("commit");
    this.decorate("updateSize");
    this.on("commit", (event) => {
      if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
        this._cleanup();
        event.stop();
      }
    }, { priority: "high" });
  }
  /**
   * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.
   *
   * Note that a new state is created for each resize transaction.
   */
  get state() {
    return this._state;
  }
  /**
   * Makes resizer visible in the UI.
   */
  show() {
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.removeClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Hides resizer in the UI.
   */
  hide() {
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.addClass("ck-hidden", this._viewResizerWrapper);
    });
  }
  /**
   * Attaches the resizer to the DOM.
   */
  attach() {
    const that = this;
    const widgetElement = this._options.viewElement;
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      const viewResizerWrapper = writer.createUIElement("div", {
        class: "ck ck-reset_all ck-widget__resizer"
      }, function(domDocument) {
        const domElement = this.toDomElement(domDocument);
        that._appendHandles(domElement);
        that._appendSizeUI(domElement);
        return domElement;
      });
      writer.insert(writer.createPositionAt(widgetElement, "end"), viewResizerWrapper);
      writer.addClass("ck-widget_with-resizer", widgetElement);
      this._viewResizerWrapper = viewResizerWrapper;
      if (!this.isVisible) {
        this.hide();
      }
    });
    this.on("change:isVisible", () => {
      if (this.isVisible) {
        this.show();
        this.redraw();
      } else {
        this.hide();
      }
    });
  }
  /**
   * Starts the resizing process.
   *
   * Creates a new {@link #state} for the current process.
   *
   * @fires begin
   * @param domResizeHandle Clicked handle.
   */
  begin(domResizeHandle) {
    this._state = new ResizeState(this._options);
    this._sizeView._bindToState(this._options, this.state);
    this._initialViewWidth = this._options.viewElement.getStyle("width");
    this.state.begin(domResizeHandle, this._getHandleHost(), this._getResizeHost());
  }
  /**
   * Updates the proposed size based on `domEventData`.
   *
   * @fires updateSize
   */
  updateSize(domEventData) {
    const newSize = this._proposeNewSize(domEventData);
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      const unit = this._options.unit || "%";
      const newWidth = (unit === "%" ? newSize.widthPercents : newSize.width) + unit;
      writer.setStyle("width", newWidth, this._options.viewElement);
    });
    const domHandleHost = this._getHandleHost();
    const domHandleHostRect = new Rect(domHandleHost);
    const handleHostWidth = Math.round(domHandleHostRect.width);
    const handleHostHeight = Math.round(domHandleHostRect.height);
    const domResizeHostRect = new Rect(domHandleHost);
    newSize.width = Math.round(domResizeHostRect.width);
    newSize.height = Math.round(domResizeHostRect.height);
    this.redraw(domHandleHostRect);
    this.state.update({
      ...newSize,
      handleHostWidth,
      handleHostHeight
    });
  }
  /**
   * Applies the geometry proposed with the resizer.
   *
   * @fires commit
   */
  commit() {
    const unit = this._options.unit || "%";
    const newValue = (unit === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + unit;
    this._options.editor.editing.view.change(() => {
      this._cleanup();
      this._options.onCommit(newValue);
    });
  }
  /**
   * Cancels and rejects the proposed resize dimensions, hiding the UI.
   *
   * @fires cancel
   */
  cancel() {
    this._cleanup();
  }
  /**
   * Destroys the resizer.
   */
  destroy() {
    this.cancel();
  }
  /**
   * Redraws the resizer.
   *
   * @param handleHostRect Handle host rectangle might be given to improve performance.
   */
  redraw(handleHostRect) {
    const domWrapper = this._domResizerWrapper;
    if (!existsInDom(domWrapper)) {
      return;
    }
    const widgetWrapper = domWrapper.parentElement;
    const handleHost = this._getHandleHost();
    const resizerWrapper = this._viewResizerWrapper;
    const currentDimensions = [
      resizerWrapper.getStyle("width"),
      resizerWrapper.getStyle("height"),
      resizerWrapper.getStyle("left"),
      resizerWrapper.getStyle("top")
    ];
    let newDimensions;
    if (widgetWrapper.isSameNode(handleHost)) {
      const clientRect = handleHostRect || new Rect(handleHost);
      newDimensions = [
        clientRect.width + "px",
        clientRect.height + "px",
        void 0,
        void 0
      ];
    } else {
      newDimensions = [
        handleHost.offsetWidth + "px",
        handleHost.offsetHeight + "px",
        handleHost.offsetLeft + "px",
        handleHost.offsetTop + "px"
      ];
    }
    if (compareArrays(currentDimensions, newDimensions) !== "same") {
      this._options.editor.editing.view.change((writer) => {
        writer.setStyle({
          width: newDimensions[0],
          height: newDimensions[1],
          left: newDimensions[2],
          top: newDimensions[3]
        }, resizerWrapper);
      });
    }
  }
  containsHandle(domElement) {
    return this._domResizerWrapper.contains(domElement);
  }
  static isResizeHandle(domElement) {
    return domElement.classList.contains("ck-widget__resizer__handle");
  }
  /**
   * Cleans up the context state.
   */
  _cleanup() {
    this._sizeView._dismiss();
    const editingView = this._options.editor.editing.view;
    editingView.change((writer) => {
      writer.setStyle("width", this._initialViewWidth, this._options.viewElement);
    });
  }
  /**
   * Calculates the proposed size as the resize handles are dragged.
   *
   * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.
   */
  _proposeNewSize(domEventData) {
    const state = this.state;
    const currentCoordinates = extractCoordinates(domEventData);
    const isCentered = this._options.isCentered ? this._options.isCentered(this) : true;
    const enlargement = {
      x: state._referenceCoordinates.x - (currentCoordinates.x + state.originalWidth),
      y: currentCoordinates.y - state.originalHeight - state._referenceCoordinates.y
    };
    if (isCentered && state.activeHandlePosition.endsWith("-right")) {
      enlargement.x = currentCoordinates.x - (state._referenceCoordinates.x + state.originalWidth);
    }
    if (isCentered) {
      enlargement.x *= 2;
    }
    let width = Math.abs(state.originalWidth + enlargement.x);
    let height = Math.abs(state.originalHeight + enlargement.y);
    const dominant = width / state.aspectRatio > height ? "width" : "height";
    if (dominant == "width") {
      height = width / state.aspectRatio;
    } else {
      width = height * state.aspectRatio;
    }
    return {
      width: Math.round(width),
      height: Math.round(height),
      widthPercents: Math.min(Math.round(state.originalWidthPercents / state.originalWidth * width * 100) / 100, 100)
    };
  }
  /**
   * Obtains the resize host.
   *
   * Resize host is an object that receives dimensions which are the result of resizing.
   */
  _getResizeHost() {
    const widgetWrapper = this._domResizerWrapper.parentElement;
    return this._options.getResizeHost(widgetWrapper);
  }
  /**
   * Obtains the handle host.
   *
   * Handle host is an object that the handles are aligned to.
   *
   * Handle host will not always be an entire widget itself. Take an image as an example. The image widget
   * contains an image and a caption. Only the image should be surrounded with handles.
   */
  _getHandleHost() {
    const widgetWrapper = this._domResizerWrapper.parentElement;
    return this._options.getHandleHost(widgetWrapper);
  }
  /**
   * DOM container of the entire resize UI.
   *
   * Note that this property will have a value only after the element bound with the resizer is rendered
   * (otherwise `null`).
   */
  get _domResizerWrapper() {
    return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
  }
  /**
   * Renders the resize handles in the DOM.
   *
   * @param domElement The resizer wrapper.
   */
  _appendHandles(domElement) {
    const resizerPositions = ["top-left", "top-right", "bottom-right", "bottom-left"];
    for (const currentPosition of resizerPositions) {
      domElement.appendChild(new Template({
        tag: "div",
        attributes: {
          class: `ck-widget__resizer__handle ${getResizerClass(currentPosition)}`
        }
      }).render());
    }
  }
  /**
   * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.
   */
  _appendSizeUI(domElement) {
    this._sizeView = new SizeView();
    this._sizeView.render();
    domElement.appendChild(this._sizeView.element);
  }
};
function getResizerClass(resizerPosition) {
  return `ck-widget__resizer__handle-${resizerPosition}`;
}
function extractCoordinates(event) {
  return {
    x: event.pageX,
    y: event.pageY
  };
}
function existsInDom(element) {
  return element && element.ownerDocument && element.ownerDocument.contains(element);
}

// node_modules/@ckeditor/ckeditor5-widget/src/widgetresize.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css";

// node_modules/@ckeditor/ckeditor5-clipboard/src/lineview.js
var toPx = toUnit("px");
var LineView = class extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set({
      isVisible: false,
      left: null,
      top: null,
      width: null
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-clipboard-drop-target-line",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ],
        style: {
          left: bind.to("left", (left) => toPx(left)),
          top: bind.to("top", (top) => toPx(top)),
          width: bind.to("width", (width) => toPx(width))
        }
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-clipboard/src/dragdroptarget.js
var DragDropTarget = class extends Plugin {
  constructor() {
    super(...arguments);
    this.removeDropMarkerDelayed = delay(() => this.removeDropMarker(), 40);
    this._updateDropMarkerThrottled = throttle_default((targetRange) => this._updateDropMarker(targetRange), 40);
    this._reconvertMarkerThrottled = throttle_default(() => {
      if (this.editor.model.markers.has("drop-target")) {
        this.editor.editing.reconvertMarker("drop-target");
      }
    }, 0);
    this._dropTargetLineView = new LineView();
    this._domEmitter = new (DomEmitterMixin())();
    this._scrollables = /* @__PURE__ */ new Map();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DragDropTarget";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    this._setupDropMarker();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._domEmitter.stopListening();
    for (const { resizeObserver } of this._scrollables.values()) {
      resizeObserver.destroy();
    }
    this._updateDropMarkerThrottled.cancel();
    this.removeDropMarkerDelayed.cancel();
    this._reconvertMarkerThrottled.cancel();
    return super.destroy();
  }
  /**
   * Finds the drop target range and updates the drop marker.
   *
   * @internal
   */
  updateDropMarker(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
    this.removeDropMarkerDelayed.cancel();
    const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
    if (!targetRange) {
      return;
    }
    if (draggedRange && draggedRange.containsRange(targetRange)) {
      return this.removeDropMarker();
    }
    this._updateDropMarkerThrottled(targetRange);
  }
  /**
   * Finds the final drop target range.
   *
   * @internal
   */
  getFinalDropRange(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
    const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
    this.removeDropMarker();
    return targetRange;
  }
  /**
   * Removes the drop target marker.
   *
   * @internal
   */
  removeDropMarker() {
    const model = this.editor.model;
    this.removeDropMarkerDelayed.cancel();
    this._updateDropMarkerThrottled.cancel();
    this._dropTargetLineView.isVisible = false;
    if (model.markers.has("drop-target")) {
      model.change((writer) => {
        writer.removeMarker("drop-target");
      });
    }
  }
  /**
   * Creates downcast conversion for the drop target marker.
   */
  _setupDropMarker() {
    const editor = this.editor;
    editor.ui.view.body.add(this._dropTargetLineView);
    editor.conversion.for("editingDowncast").markerToHighlight({
      model: "drop-target",
      view: {
        classes: ["ck-clipboard-drop-target-range"]
      }
    });
    editor.conversion.for("editingDowncast").markerToElement({
      model: "drop-target",
      view: (data, { writer }) => {
        if (editor.model.schema.checkChild(data.markerRange.start, "$text")) {
          this._dropTargetLineView.isVisible = false;
          return this._createDropTargetPosition(writer);
        } else {
          if (data.markerRange.isCollapsed) {
            this._updateDropTargetLine(data.markerRange);
          } else {
            this._dropTargetLineView.isVisible = false;
          }
        }
      }
    });
  }
  /**
   * Updates the drop target marker to the provided range.
   *
   * @param targetRange The range to set the marker to.
   */
  _updateDropMarker(targetRange) {
    const editor = this.editor;
    const markers = editor.model.markers;
    editor.model.change((writer) => {
      if (markers.has("drop-target")) {
        if (!markers.get("drop-target").getRange().isEqual(targetRange)) {
          writer.updateMarker("drop-target", { range: targetRange });
        }
      } else {
        writer.addMarker("drop-target", {
          range: targetRange,
          usingOperation: false,
          affectsData: false
        });
      }
    });
  }
  /**
   * Creates the UI element for vertical (in-line) drop target.
   */
  _createDropTargetPosition(writer) {
    return writer.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(domDocument) {
      const domElement = this.toDomElement(domDocument);
      domElement.append("â ", domDocument.createElement("span"), "â ");
      return domElement;
    });
  }
  /**
   * Updates the horizontal drop target line.
   */
  _updateDropTargetLine(range) {
    const editing = this.editor.editing;
    const nodeBefore = range.start.nodeBefore;
    const nodeAfter = range.start.nodeAfter;
    const nodeParent = range.start.parent;
    const viewElementBefore = nodeBefore ? editing.mapper.toViewElement(nodeBefore) : null;
    const domElementBefore = viewElementBefore ? editing.view.domConverter.mapViewToDom(viewElementBefore) : null;
    const viewElementAfter = nodeAfter ? editing.mapper.toViewElement(nodeAfter) : null;
    const domElementAfter = viewElementAfter ? editing.view.domConverter.mapViewToDom(viewElementAfter) : null;
    const viewElementParent = editing.mapper.toViewElement(nodeParent);
    if (!viewElementParent) {
      return;
    }
    const domElementParent = editing.view.domConverter.mapViewToDom(viewElementParent);
    const domScrollableRect = this._getScrollableRect(viewElementParent);
    const { scrollX, scrollY } = global_default.window;
    const rectBefore = domElementBefore ? new Rect(domElementBefore) : null;
    const rectAfter = domElementAfter ? new Rect(domElementAfter) : null;
    const rectParent = new Rect(domElementParent).excludeScrollbarsAndBorders();
    const above = rectBefore ? rectBefore.bottom : rectParent.top;
    const below = rectAfter ? rectAfter.top : rectParent.bottom;
    const parentStyle = global_default.window.getComputedStyle(domElementParent);
    const top = above <= below ? (above + below) / 2 : below;
    if (domScrollableRect.top < top && top < domScrollableRect.bottom) {
      const left = rectParent.left + parseFloat(parentStyle.paddingLeft);
      const right = rectParent.right - parseFloat(parentStyle.paddingRight);
      const leftClamped = Math.max(left + scrollX, domScrollableRect.left);
      const rightClamped = Math.min(right + scrollX, domScrollableRect.right);
      this._dropTargetLineView.set({
        isVisible: true,
        left: leftClamped,
        top: top + scrollY,
        width: rightClamped - leftClamped
      });
    } else {
      this._dropTargetLineView.isVisible = false;
    }
  }
  /**
   * Finds the closest scrollable element rect for the given view element.
   */
  _getScrollableRect(viewElement) {
    const rootName = viewElement.root.rootName;
    let domScrollable;
    if (this._scrollables.has(rootName)) {
      domScrollable = this._scrollables.get(rootName).domElement;
    } else {
      const domElement = this.editor.editing.view.domConverter.mapViewToDom(viewElement);
      domScrollable = findScrollableElement(domElement);
      this._domEmitter.listenTo(domScrollable, "scroll", this._reconvertMarkerThrottled, { usePassive: true });
      const resizeObserver = new resizeobserver_default(domScrollable, this._reconvertMarkerThrottled);
      this._scrollables.set(rootName, {
        domElement: domScrollable,
        resizeObserver
      });
    }
    return new Rect(domScrollable).excludeScrollbarsAndBorders();
  }
};
function findDropTargetRange(editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
  const model = editor.model;
  const mapper = editor.editing.mapper;
  const targetModelElement = getClosestMappedModelElement(editor, targetViewElement);
  let modelElement = targetModelElement;
  while (modelElement) {
    if (!blockMode) {
      if (model.schema.checkChild(modelElement, "$text")) {
        if (targetViewRanges) {
          const targetViewPosition = targetViewRanges[0].start;
          const targetModelPosition = mapper.toModelPosition(targetViewPosition);
          const canDropOnPosition = !draggedRange || Array.from(draggedRange.getItems({ shallow: true })).every((item) => model.schema.checkChild(targetModelPosition, item));
          if (canDropOnPosition) {
            if (model.schema.checkChild(targetModelPosition, "$text")) {
              return model.createRange(targetModelPosition);
            } else if (targetViewPosition) {
              return findDropTargetRangeForElement(editor, getClosestMappedModelElement(editor, targetViewPosition.parent), clientX, clientY);
            }
          }
        }
      } else if (model.schema.isInline(modelElement)) {
        return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);
      }
    }
    if (model.schema.isBlock(modelElement)) {
      return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);
    } else if (model.schema.checkChild(modelElement, "$block")) {
      const childNodes = Array.from(modelElement.getChildren()).filter((node) => node.is("element") && !shouldIgnoreElement(editor, node));
      let startIndex = 0;
      let endIndex = childNodes.length;
      if (endIndex == 0) {
        return model.createRange(model.createPositionAt(modelElement, "end"));
      }
      while (startIndex < endIndex - 1) {
        const middleIndex = Math.floor((startIndex + endIndex) / 2);
        const side = findElementSide(editor, childNodes[middleIndex], clientX, clientY);
        if (side == "before") {
          endIndex = middleIndex;
        } else {
          startIndex = middleIndex;
        }
      }
      return findDropTargetRangeForElement(editor, childNodes[startIndex], clientX, clientY);
    }
    modelElement = modelElement.parent;
  }
  return null;
}
function shouldIgnoreElement(editor, modelElement) {
  const mapper = editor.editing.mapper;
  const domConverter = editor.editing.view.domConverter;
  const viewElement = mapper.toViewElement(modelElement);
  if (!viewElement) {
    return true;
  }
  const domElement = domConverter.mapViewToDom(viewElement);
  return global_default.window.getComputedStyle(domElement).float != "none";
}
function findDropTargetRangeForElement(editor, modelElement, clientX, clientY) {
  const model = editor.model;
  return model.createRange(model.createPositionAt(modelElement, findElementSide(editor, modelElement, clientX, clientY)));
}
function findElementSide(editor, modelElement, clientX, clientY) {
  const mapper = editor.editing.mapper;
  const domConverter = editor.editing.view.domConverter;
  const viewElement = mapper.toViewElement(modelElement);
  const domElement = domConverter.mapViewToDom(viewElement);
  const rect = new Rect(domElement);
  if (editor.model.schema.isInline(modelElement)) {
    return clientX < (rect.left + rect.right) / 2 ? "before" : "after";
  } else {
    return clientY < (rect.top + rect.bottom) / 2 ? "before" : "after";
  }
}
function getClosestMappedModelElement(editor, element) {
  const mapper = editor.editing.mapper;
  const view = editor.editing.view;
  const targetModelElement = mapper.toModelElement(element);
  if (targetModelElement) {
    return targetModelElement;
  }
  const viewPosition = view.createPositionBefore(element);
  const viewElement = mapper.findMappedViewAncestor(viewPosition);
  return mapper.toModelElement(viewElement);
}
function findScrollableElement(domNode) {
  let domElement = domNode;
  do {
    domElement = domElement.parentElement;
    const overflow = global_default.window.getComputedStyle(domElement).overflowY;
    if (overflow == "auto" || overflow == "scroll") {
      break;
    }
  } while (domElement.tagName != "BODY");
  return domElement;
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/dragdropblocktoolbar.js
var DragDropBlockToolbar = class extends Plugin {
  constructor() {
    super(...arguments);
    this._isBlockDragging = false;
    this._domEmitter = new (DomEmitterMixin())();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DragDropBlockToolbar";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => {
      if (isReadOnly) {
        this.forceDisabled("readOnlyMode");
        this._isBlockDragging = false;
      } else {
        this.clearForceDisabled("readOnlyMode");
      }
    });
    if (env_default.isAndroid) {
      this.forceDisabled("noAndroidSupport");
    }
    if (editor.plugins.has("BlockToolbar")) {
      const blockToolbar = editor.plugins.get("BlockToolbar");
      const element = blockToolbar.buttonView.element;
      this._domEmitter.listenTo(element, "dragstart", (evt, data) => this._handleBlockDragStart(data));
      this._domEmitter.listenTo(global_default.document, "dragover", (evt, data) => this._handleBlockDragging(data));
      this._domEmitter.listenTo(global_default.document, "drop", (evt, data) => this._handleBlockDragging(data));
      this._domEmitter.listenTo(global_default.document, "dragend", () => this._handleBlockDragEnd(), { useCapture: true });
      if (this.isEnabled) {
        element.setAttribute("draggable", "true");
      }
      this.on("change:isEnabled", (evt, name, isEnabled2) => {
        element.setAttribute("draggable", isEnabled2 ? "true" : "false");
      });
    }
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._domEmitter.stopListening();
    return super.destroy();
  }
  /**
   * The `dragstart` event handler.
   */
  _handleBlockDragStart(domEvent) {
    if (!this.isEnabled) {
      return;
    }
    const model = this.editor.model;
    const selection = model.document.selection;
    const view = this.editor.editing.view;
    const blocks = Array.from(selection.getSelectedBlocks());
    const draggedRange = model.createRange(model.createPositionBefore(blocks[0]), model.createPositionAfter(blocks[blocks.length - 1]));
    model.change((writer) => writer.setSelection(draggedRange));
    this._isBlockDragging = true;
    view.focus();
    view.getObserver(ClipboardObserver).onDomEvent(domEvent);
  }
  /**
   * The `dragover` and `drop` event handler.
   */
  _handleBlockDragging(domEvent) {
    if (!this.isEnabled || !this._isBlockDragging) {
      return;
    }
    const clientX = domEvent.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100);
    const clientY = domEvent.clientY;
    const target = document.elementFromPoint(clientX, clientY);
    const view = this.editor.editing.view;
    if (!target || !target.closest(".ck-editor__editable")) {
      return;
    }
    view.getObserver(ClipboardObserver).onDomEvent({
      ...domEvent,
      type: domEvent.type,
      dataTransfer: domEvent.dataTransfer,
      target,
      clientX,
      clientY,
      preventDefault: () => domEvent.preventDefault(),
      stopPropagation: () => domEvent.stopPropagation()
    });
  }
  /**
   * The `dragend` event handler.
   */
  _handleBlockDragEnd() {
    this._isBlockDragging = false;
  }
};

// node_modules/@ckeditor/ckeditor5-clipboard/src/dragdrop.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css";
var DragDrop = class extends Plugin {
  constructor() {
    super(...arguments);
    this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40);
    this._blockMode = false;
    this._domEmitter = new (DomEmitterMixin())();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "DragDrop";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardPipeline, Widget, DragDropTarget, DragDropBlockToolbar];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const view = editor.editing.view;
    this._draggedRange = null;
    this._draggingUid = "";
    this._draggableElement = null;
    view.addObserver(ClipboardObserver);
    view.addObserver(MouseObserver);
    this._setupDragging();
    this._setupContentInsertionIntegration();
    this._setupClipboardInputIntegration();
    this._setupDraggableAttributeHandling();
    this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => {
      if (isReadOnly) {
        this.forceDisabled("readOnlyMode");
      } else {
        this.clearForceDisabled("readOnlyMode");
      }
    });
    this.on("change:isEnabled", (evt, name, isEnabled2) => {
      if (!isEnabled2) {
        this._finalizeDragging(false);
      }
    });
    if (env_default.isAndroid) {
      this.forceDisabled("noAndroidSupport");
    }
  }
  /**
   * @inheritDoc
   */
  destroy() {
    if (this._draggedRange) {
      this._draggedRange.detach();
      this._draggedRange = null;
    }
    if (this._previewContainer) {
      this._previewContainer.remove();
    }
    this._domEmitter.stopListening();
    this._clearDraggableAttributesDelayed.cancel();
    return super.destroy();
  }
  /**
   * Drag and drop events handling.
   */
  _setupDragging() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const dragDropTarget = editor.plugins.get(DragDropTarget);
    this.listenTo(viewDocument, "dragstart", (evt, data) => {
      if (data.target && data.target.is("editableElement")) {
        data.preventDefault();
        return;
      }
      this._prepareDraggedRange(data.target);
      if (!this._draggedRange) {
        data.preventDefault();
        return;
      }
      this._draggingUid = uid();
      data.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy";
      data.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
      const draggedSelection = model.createSelection(this._draggedRange.toRange());
      const clipboardPipeline = this.editor.plugins.get("ClipboardPipeline");
      clipboardPipeline._fireOutputTransformationEvent(data.dataTransfer, draggedSelection, "dragstart");
      const { dataTransfer, domTarget, domEvent } = data;
      const { clientX } = domEvent;
      this._updatePreview({ dataTransfer, domTarget, clientX });
      data.stopPropagation();
      if (!this.isEnabled) {
        this._draggedRange.detach();
        this._draggedRange = null;
        this._draggingUid = "";
      }
    }, { priority: "low" });
    this.listenTo(viewDocument, "dragend", (evt, data) => {
      this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == "move");
    }, { priority: "low" });
    this._domEmitter.listenTo(global_default.document, "dragend", () => {
      this._blockMode = false;
    }, { useCapture: true });
    this.listenTo(viewDocument, "dragenter", () => {
      if (!this.isEnabled) {
        return;
      }
      view.focus();
    });
    this.listenTo(viewDocument, "dragleave", () => {
      dragDropTarget.removeDropMarkerDelayed();
    });
    this.listenTo(viewDocument, "dragging", (evt, data) => {
      if (!this.isEnabled) {
        data.dataTransfer.dropEffect = "none";
        return;
      }
      const { clientX, clientY } = data.domEvent;
      dragDropTarget.updateDropMarker(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
      if (!this._draggedRange) {
        data.dataTransfer.dropEffect = "copy";
      }
      if (!env_default.isGecko) {
        if (data.dataTransfer.effectAllowed == "copy") {
          data.dataTransfer.dropEffect = "copy";
        } else if (["all", "copyMove"].includes(data.dataTransfer.effectAllowed)) {
          data.dataTransfer.dropEffect = "move";
        }
      }
      evt.stop();
    }, { priority: "low" });
  }
  /**
   * Integration with the `clipboardInput` event.
   */
  _setupClipboardInputIntegration() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const dragDropTarget = editor.plugins.get(DragDropTarget);
    this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
      if (data.method != "drop") {
        return;
      }
      const { clientX, clientY } = data.domEvent;
      const targetRange = dragDropTarget.getFinalDropRange(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
      if (!targetRange) {
        this._finalizeDragging(false);
        evt.stop();
        return;
      }
      if (this._draggedRange && this._draggingUid != data.dataTransfer.getData("application/ckeditor5-dragging-uid")) {
        this._draggedRange.detach();
        this._draggedRange = null;
        this._draggingUid = "";
      }
      const isMove = getFinalDropEffect(data.dataTransfer) == "move";
      if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {
        this._finalizeDragging(false);
        evt.stop();
        return;
      }
      data.targetRanges = [editor.editing.mapper.toViewRange(targetRange)];
    }, { priority: "high" });
  }
  /**
   * Integration with the `contentInsertion` event of the clipboard pipeline.
   */
  _setupContentInsertionIntegration() {
    const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);
    clipboardPipeline.on("contentInsertion", (evt, data) => {
      if (!this.isEnabled || data.method !== "drop") {
        return;
      }
      const ranges = data.targetRanges.map((viewRange) => this.editor.editing.mapper.toModelRange(viewRange));
      this.editor.model.change((writer) => writer.setSelection(ranges));
    }, { priority: "high" });
    clipboardPipeline.on("contentInsertion", (evt, data) => {
      if (!this.isEnabled || data.method !== "drop") {
        return;
      }
      const isMove = getFinalDropEffect(data.dataTransfer) == "move";
      const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;
      this._finalizeDragging(isSuccess && isMove);
    }, { priority: "lowest" });
  }
  /**
   * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
   */
  _setupDraggableAttributeHandling() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    this.listenTo(viewDocument, "mousedown", (evt, data) => {
      if (env_default.isAndroid || !data) {
        return;
      }
      this._clearDraggableAttributesDelayed.cancel();
      let draggableElement = findDraggableWidget(data.target);
      if (env_default.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {
        const selectedElement = viewDocument.selection.getSelectedElement();
        if (!selectedElement || !isWidget(selectedElement)) {
          draggableElement = viewDocument.selection.editableElement;
        }
      }
      if (draggableElement) {
        view.change((writer) => {
          writer.setAttribute("draggable", "true", draggableElement);
        });
        this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);
      }
    });
    this.listenTo(viewDocument, "mouseup", () => {
      if (!env_default.isAndroid) {
        this._clearDraggableAttributesDelayed();
      }
    });
  }
  /**
   * Removes the `draggable` attribute from the element that was used for dragging.
   */
  _clearDraggableAttributes() {
    const editing = this.editor.editing;
    editing.view.change((writer) => {
      if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
        writer.removeAttribute("draggable", editing.mapper.toViewElement(this._draggableElement));
      }
      this._draggableElement = null;
    });
  }
  /**
   * Deletes the dragged content from its original range and clears the dragging state.
   *
   * @param moved Whether the move succeeded.
   */
  _finalizeDragging(moved) {
    const editor = this.editor;
    const model = editor.model;
    const dragDropTarget = editor.plugins.get(DragDropTarget);
    dragDropTarget.removeDropMarker();
    this._clearDraggableAttributes();
    if (editor.plugins.has("WidgetToolbarRepository")) {
      const widgetToolbarRepository = editor.plugins.get("WidgetToolbarRepository");
      widgetToolbarRepository.clearForceDisabled("dragDrop");
    }
    this._draggingUid = "";
    if (this._previewContainer) {
      this._previewContainer.remove();
      this._previewContainer = void 0;
    }
    if (!this._draggedRange) {
      return;
    }
    if (moved && this.isEnabled) {
      model.change((writer) => {
        const selection = model.createSelection(this._draggedRange);
        model.deleteContent(selection, { doNotAutoparagraph: true });
        const selectionParent = selection.getFirstPosition().parent;
        if (selectionParent.isEmpty && !model.schema.checkChild(selectionParent, "$text") && model.schema.checkChild(selectionParent, "paragraph")) {
          writer.insertElement("paragraph", selectionParent, 0);
        }
      });
    }
    this._draggedRange.detach();
    this._draggedRange = null;
  }
  /**
   * Sets the dragged source range based on event target and document selection.
   */
  _prepareDraggedRange(target) {
    const editor = this.editor;
    const model = editor.model;
    const selection = model.document.selection;
    const draggableWidget = target ? findDraggableWidget(target) : null;
    if (draggableWidget) {
      const modelElement = editor.editing.mapper.toModelElement(draggableWidget);
      this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement));
      this._blockMode = model.schema.isBlock(modelElement);
      if (editor.plugins.has("WidgetToolbarRepository")) {
        const widgetToolbarRepository = editor.plugins.get("WidgetToolbarRepository");
        widgetToolbarRepository.forceDisabled("dragDrop");
      }
      return;
    }
    if (selection.isCollapsed && !selection.getFirstPosition().parent.isEmpty) {
      return;
    }
    const blocks = Array.from(selection.getSelectedBlocks());
    const draggedRange = selection.getFirstRange();
    if (blocks.length == 0) {
      this._draggedRange = LiveRange.fromRange(draggedRange);
      return;
    }
    const blockRange = getRangeIncludingFullySelectedParents(model, blocks);
    if (blocks.length > 1) {
      this._draggedRange = LiveRange.fromRange(blockRange);
      this._blockMode = true;
    } else if (blocks.length == 1) {
      const touchesBlockEdges = draggedRange.start.isTouching(blockRange.start) && draggedRange.end.isTouching(blockRange.end);
      this._draggedRange = LiveRange.fromRange(touchesBlockEdges ? blockRange : draggedRange);
      this._blockMode = touchesBlockEdges;
    }
    model.change((writer) => writer.setSelection(this._draggedRange.toRange()));
  }
  /**
   * Updates the dragged preview image.
   */
  _updatePreview({ dataTransfer, domTarget, clientX }) {
    const view = this.editor.editing.view;
    const editable = view.document.selection.editableElement;
    const domEditable = view.domConverter.mapViewToDom(editable);
    const computedStyle = global_default.window.getComputedStyle(domEditable);
    if (!this._previewContainer) {
      this._previewContainer = createElement(global_default.document, "div", {
        style: "position: fixed; left: -999999px;"
      });
      global_default.document.body.appendChild(this._previewContainer);
    } else if (this._previewContainer.firstElementChild) {
      this._previewContainer.removeChild(this._previewContainer.firstElementChild);
    }
    const domRect = new Rect(domEditable);
    if (domEditable.contains(domTarget)) {
      return;
    }
    const domEditablePaddingLeft = parseFloat(computedStyle.paddingLeft);
    const preview = createElement(global_default.document, "div");
    preview.className = "ck ck-content";
    preview.style.width = computedStyle.width;
    preview.style.paddingLeft = `${domRect.left - clientX + domEditablePaddingLeft}px`;
    if (env_default.isiOS) {
      preview.style.backgroundColor = "white";
    }
    view.domConverter.setContentOf(preview, dataTransfer.getData("text/html"));
    dataTransfer.setDragImage(preview, 0, 0);
    this._previewContainer.appendChild(preview);
  }
};
function getFinalDropEffect(dataTransfer) {
  if (env_default.isGecko) {
    return dataTransfer.dropEffect;
  }
  return ["all", "copyMove"].includes(dataTransfer.effectAllowed) ? "move" : "copy";
}
function findDraggableWidget(target) {
  if (target.is("editableElement")) {
    return null;
  }
  if (target.hasClass("ck-widget__selection-handle")) {
    return target.findAncestor(isWidget);
  }
  if (isWidget(target)) {
    return target;
  }
  const ancestor = target.findAncestor((node) => isWidget(node) || node.is("editableElement"));
  if (isWidget(ancestor)) {
    return ancestor;
  }
  return null;
}
function getRangeIncludingFullySelectedParents(model, elements) {
  const firstElement = elements[0];
  const lastElement = elements[elements.length - 1];
  const parent = firstElement.getCommonAncestor(lastElement);
  const startPosition = model.createPositionBefore(firstElement);
  const endPosition = model.createPositionAfter(lastElement);
  if (parent && parent.is("element") && !model.schema.isLimit(parent)) {
    const parentRange = model.createRangeOn(parent);
    const touchesStart = startPosition.isTouching(parentRange.start);
    const touchesEnd = endPosition.isTouching(parentRange.end);
    if (touchesStart && touchesEnd) {
      return getRangeIncludingFullySelectedParents(model, [parent]);
    }
  }
  return model.createRange(startPosition, endPosition);
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/pasteplaintext.js
var PastePlainText = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PastePlainText";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardPipeline];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    const selection = model.document.selection;
    view.addObserver(ClipboardObserver);
    editor.plugins.get(ClipboardPipeline).on("contentInsertion", (evt, data) => {
      if (!isUnformattedInlineContent(data.content, model)) {
        return;
      }
      model.change((writer) => {
        const textAttributes = Array.from(selection.getAttributes()).filter(([key]) => model.schema.getAttributeProperties(key).isFormatting);
        if (!selection.isCollapsed) {
          model.deleteContent(selection, { doNotAutoparagraph: true });
        }
        textAttributes.push(...selection.getAttributes());
        const range = writer.createRangeIn(data.content);
        for (const item of range.getItems()) {
          for (const attribute of textAttributes) {
            if (model.schema.checkAttribute(item, attribute[0])) {
              writer.setAttribute(attribute[0], attribute[1], item);
            }
          }
        }
      });
    });
  }
};
function isUnformattedInlineContent(documentFragment, model) {
  let range = model.createRangeIn(documentFragment);
  if (documentFragment.childCount == 1) {
    const child = documentFragment.getChild(0);
    if (child.is("element") && model.schema.isBlock(child) && !model.schema.isObject(child) && !model.schema.isLimit(child)) {
      range = model.createRangeIn(child);
    }
  }
  for (const child of range.getItems()) {
    if (!model.schema.isInline(child)) {
      return false;
    }
    const attributeKeys = Array.from(child.getAttributeKeys());
    if (attributeKeys.find((key) => model.schema.getAttributeProperties(key).isFormatting)) {
      return false;
    }
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-clipboard/src/clipboard.js
var Clipboard = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Clipboard";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [ClipboardMarkersUtils, ClipboardPipeline, DragDrop, PastePlainText];
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = this.editor.t;
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Copy selected content"),
          keystroke: "CTRL+C"
        },
        {
          label: t("Paste content"),
          keystroke: "CTRL+V"
        },
        {
          label: t("Paste content as plain text"),
          keystroke: "CTRL+SHIFT+V"
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-select-all/src/selectallcommand.js
var SelectAllCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this.affectsData = false;
  }
  /**
   * @inheritDoc
   */
  execute() {
    const model = this.editor.model;
    const selection = model.document.selection;
    let scopeElement = model.schema.getLimitElement(selection);
    if (selection.containsEntireContent(scopeElement) || !isSelectAllScope(model.schema, scopeElement)) {
      do {
        scopeElement = scopeElement.parent;
        if (!scopeElement) {
          return;
        }
      } while (!isSelectAllScope(model.schema, scopeElement));
    }
    model.change((writer) => {
      writer.setSelection(scopeElement, "in");
    });
  }
};
function isSelectAllScope(schema, element) {
  return schema.isLimit(element) && (schema.checkChild(element, "$text") || schema.checkChild(element, "paragraph"));
}

// node_modules/@ckeditor/ckeditor5-select-all/src/selectallediting.js
var SELECT_ALL_KEYSTROKE = parseKeystroke("Ctrl+A");
var SelectAllEditing = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAllEditing";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    const view = editor.editing.view;
    const viewDocument = view.document;
    editor.commands.add("selectAll", new SelectAllCommand(editor));
    this.listenTo(viewDocument, "keydown", (eventInfo, domEventData) => {
      if (getCode(domEventData) === SELECT_ALL_KEYSTROKE) {
        editor.execute("selectAll");
        domEventData.preventDefault();
      }
    });
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Select all"),
          keystroke: "CTRL+A"
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-select-all/src/selectallui.js
import selectAllIcon from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-select-all/theme/icons/select-all.svg";
var SelectAllUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAllUI";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    editor.ui.componentFactory.add("selectAll", () => {
      const buttonView = this._createButton(ButtonView);
      buttonView.set({
        tooltip: true
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:selectAll", () => {
      return this._createButton(MenuBarMenuListItemButtonView);
    });
  }
  /**
   * Creates a button for select all command to use either in toolbar or in menu bar.
   */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get("selectAll");
    const view = new ButtonClass(editor.locale);
    const t = locale.t;
    view.set({
      label: t("Select all"),
      icon: selectAllIcon,
      keystroke: "Ctrl+A"
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute("selectAll");
      editor.editing.view.focus();
    });
    return view;
  }
};

// node_modules/@ckeditor/ckeditor5-select-all/src/selectall.js
var SelectAll = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [SelectAllEditing, SelectAllUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "SelectAll";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/basecommand.js
var BaseCommand = class extends Command {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    this._stack = [];
    this._createdBatches = /* @__PURE__ */ new WeakSet();
    this.refresh();
    this._isEnabledBasedOnSelection = false;
    this.listenTo(editor.data, "set", (evt, data) => {
      data[1] = { ...data[1] };
      const options = data[1];
      if (!options.batchType) {
        options.batchType = { isUndoable: false };
      }
    }, { priority: "high" });
    this.listenTo(editor.data, "set", (evt, data) => {
      const options = data[1];
      if (!options.batchType.isUndoable) {
        this.clearStack();
      }
    });
  }
  /**
   * @inheritDoc
   */
  refresh() {
    this.isEnabled = this._stack.length > 0;
  }
  /**
   * Returns all batches created by this command.
   */
  get createdBatches() {
    return this._createdBatches;
  }
  /**
   * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
   * created by the editor which this command is registered to.
   *
   * @param batch The batch to add.
   */
  addBatch(batch) {
    const docSelection = this.editor.model.document.selection;
    const selection = {
      ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],
      isBackward: docSelection.isBackward
    };
    this._stack.push({ batch, selection });
    this.refresh();
  }
  /**
   * Removes all items from the stack.
   */
  clearStack() {
    this._stack = [];
    this.refresh();
  }
  /**
   * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
   *
   * @param ranges Ranges to be restored.
   * @param isBackward A flag describing whether the restored range was selected forward or backward.
   * @param operations Operations which has been applied since selection has been stored.
   */
  _restoreSelection(ranges, isBackward, operations) {
    const model = this.editor.model;
    const document2 = model.document;
    const selectionRanges = [];
    const transformedRangeGroups = ranges.map((range) => range.getTransformedByOperations(operations));
    const allRanges = transformedRangeGroups.flat();
    for (const rangeGroup of transformedRangeGroups) {
      const transformed = rangeGroup.filter((range) => range.root != document2.graveyard).filter((range) => !isRangeContainedByAnyOtherRange(range, allRanges));
      if (!transformed.length) {
        continue;
      }
      normalizeRanges(transformed);
      selectionRanges.push(transformed[0]);
    }
    if (selectionRanges.length) {
      model.change((writer) => {
        writer.setSelection(selectionRanges, { backward: isBackward });
      });
    }
  }
  /**
   * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
   * This is a helper method for {@link #execute}.
   *
   * @param batchToUndo The batch to be undone.
   * @param undoingBatch The batch that will contain undoing changes.
   */
  _undo(batchToUndo, undoingBatch) {
    const model = this.editor.model;
    const document2 = model.document;
    this._createdBatches.add(undoingBatch);
    const operationsToUndo = batchToUndo.operations.slice().filter((operation) => operation.isDocumentOperation);
    operationsToUndo.reverse();
    for (const operationToUndo of operationsToUndo) {
      const nextBaseVersion = operationToUndo.baseVersion + 1;
      const historyOperations = Array.from(document2.history.getOperations(nextBaseVersion));
      const transformedSets = transformSets([operationToUndo.getReversed()], historyOperations, {
        useRelations: true,
        document: this.editor.model.document,
        padWithNoOps: false,
        forceWeakRemove: true
      });
      const reversedOperations = transformedSets.operationsA;
      for (let operation of reversedOperations) {
        const affectedSelectable = operation.affectedSelectable;
        if (affectedSelectable && !model.canEditAt(affectedSelectable)) {
          operation = new NoOperation(operation.baseVersion);
        }
        undoingBatch.addOperation(operation);
        model.applyOperation(operation);
        document2.history.setOperationAsUndone(operationToUndo, operation);
      }
    }
  }
};
function normalizeRanges(ranges) {
  ranges.sort((a, b) => a.start.isBefore(b.start) ? -1 : 1);
  for (let i = 1; i < ranges.length; i++) {
    const previousRange = ranges[i - 1];
    const joinedRange = previousRange.getJoined(ranges[i], true);
    if (joinedRange) {
      i--;
      ranges.splice(i, 2, joinedRange);
    }
  }
}
function isRangeContainedByAnyOtherRange(range, ranges) {
  return ranges.some((otherRange) => otherRange !== range && otherRange.containsRange(range, true));
}

// node_modules/@ckeditor/ckeditor5-undo/src/undocommand.js
var UndoCommand = class extends BaseCommand {
  /**
   * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
   * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
   * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
   *
   * @fires execute
   * @fires revert
   * @param batch A batch that should be undone. If not set, the last added batch will be undone.
   */
  execute(batch = null) {
    const batchIndex = batch ? this._stack.findIndex((a) => a.batch == batch) : this._stack.length - 1;
    const item = this._stack.splice(batchIndex, 1)[0];
    const undoingBatch = this.editor.model.createBatch({ isUndo: true });
    this.editor.model.enqueueChange(undoingBatch, () => {
      this._undo(item.batch, undoingBatch);
      const operations = this.editor.model.document.history.getOperations(item.batch.baseVersion);
      this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);
    });
    this.fire("revert", item.batch, undoingBatch);
    this.refresh();
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/redocommand.js
var RedoCommand = class extends BaseCommand {
  /**
   * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
   * the command's stack, applies the reverted and transformed version on the
   * {@link module:engine/model/document~Document document} and removes the batch from the stack.
   * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
   *
   * @fires execute
   */
  execute() {
    const item = this._stack.pop();
    const redoingBatch = this.editor.model.createBatch({ isUndo: true });
    this.editor.model.enqueueChange(redoingBatch, () => {
      const lastOperation = item.batch.operations[item.batch.operations.length - 1];
      const nextBaseVersion = lastOperation.baseVersion + 1;
      const operations = this.editor.model.document.history.getOperations(nextBaseVersion);
      this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);
      this._undo(item.batch, redoingBatch);
    });
    this.refresh();
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/undoediting.js
var UndoEditing = class extends Plugin {
  constructor() {
    super(...arguments);
    this._batchRegistry = /* @__PURE__ */ new WeakSet();
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UndoEditing";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.t;
    this._undoCommand = new UndoCommand(editor);
    this._redoCommand = new RedoCommand(editor);
    editor.commands.add("undo", this._undoCommand);
    editor.commands.add("redo", this._redoCommand);
    this.listenTo(editor.model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (!operation.isDocumentOperation) {
        return;
      }
      const batch = operation.batch;
      const isRedoBatch = this._redoCommand.createdBatches.has(batch);
      const isUndoBatch = this._undoCommand.createdBatches.has(batch);
      const wasProcessed = this._batchRegistry.has(batch);
      if (wasProcessed) {
        return;
      }
      this._batchRegistry.add(batch);
      if (!batch.isUndoable) {
        return;
      }
      if (isRedoBatch) {
        this._undoCommand.addBatch(batch);
      } else if (!isUndoBatch) {
        this._undoCommand.addBatch(batch);
        this._redoCommand.clearStack();
      }
    }, { priority: "highest" });
    this.listenTo(this._undoCommand, "revert", (evt, undoneBatch, undoingBatch) => {
      this._redoCommand.addBatch(undoingBatch);
    });
    editor.keystrokes.set("CTRL+Z", "undo");
    editor.keystrokes.set("CTRL+Y", "redo");
    editor.keystrokes.set("CTRL+SHIFT+Z", "redo");
    editor.accessibility.addKeystrokeInfos({
      keystrokes: [
        {
          label: t("Undo"),
          keystroke: "CTRL+Z"
        },
        {
          label: t("Redo"),
          keystroke: [["CTRL+Y"], ["CTRL+SHIFT+Z"]]
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/undoui.js
var UndoUI = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "UndoUI";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const locale = editor.locale;
    const t = editor.t;
    const localizedUndoIcon = locale.uiLanguageDirection == "ltr" ? icons.undo : icons.redo;
    const localizedRedoIcon = locale.uiLanguageDirection == "ltr" ? icons.redo : icons.undo;
    this._addButtonsToFactory("undo", t("Undo"), "CTRL+Z", localizedUndoIcon);
    this._addButtonsToFactory("redo", t("Redo"), "CTRL+Y", localizedRedoIcon);
  }
  /**
   * Creates a button for the specified command.
   *
   * @param name Command name.
   * @param label Button label.
   * @param keystroke Command keystroke.
   * @param Icon Source of the icon.
   */
  _addButtonsToFactory(name, label, keystroke, Icon) {
    const editor = this.editor;
    editor.ui.componentFactory.add(name, () => {
      const buttonView = this._createButton(ButtonView, name, label, keystroke, Icon);
      buttonView.set({
        tooltip: true
      });
      return buttonView;
    });
    editor.ui.componentFactory.add("menuBar:" + name, () => {
      return this._createButton(MenuBarMenuListItemButtonView, name, label, keystroke, Icon);
    });
  }
  /**
   * TODO
   */
  _createButton(ButtonClass, name, label, keystroke, Icon) {
    const editor = this.editor;
    const locale = editor.locale;
    const command = editor.commands.get(name);
    const view = new ButtonClass(locale);
    view.set({
      label,
      icon: Icon,
      keystroke
    });
    view.bind("isEnabled").to(command, "isEnabled");
    this.listenTo(view, "execute", () => {
      editor.execute(name);
      editor.editing.view.focus();
    });
    return view;
  }
};

// node_modules/@ckeditor/ckeditor5-undo/src/undo.js
var Undo = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [UndoEditing, UndoUI];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Undo";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
};

// node_modules/@ckeditor/ckeditor5-essentials/src/essentials.js
var Essentials = class extends Plugin {
  /**
   * @inheritDoc
   */
  static get requires() {
    return [AccessibilityHelp, Clipboard, Enter, SelectAll, ShiftEnter, Typing, Undo];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Essentials";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
};
export {
  Essentials as default
};
/*! Bundled license information:

@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/clipboardmarkersutils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/utils/changebuffer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/inserttextcommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/inserttextobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/input.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/deletecommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/deleteobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/delete.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/typing.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/utils/getlasttextline.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/textwatcher.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/twostepcaretmovement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/texttransformation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/utils/findattributerange.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/utils/inlinehighlight.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-typing/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/entercommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/enterobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/enter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/shiftentercommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/shiftenter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-enter/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/highlightstack.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgettypearound/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/verticalnavigation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widget.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-widget/src/widgettoolbarrepository.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/resizerstate.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/sizeview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize/resizer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/widgetresize.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-widget/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/lineview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore file -- @preserve *)

@ckeditor/ckeditor5-clipboard/src/dragdroptarget.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-clipboard/src/dragdropblocktoolbar.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/dragdrop.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/pasteplaintext.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/clipboard.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-clipboard/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/clipboard.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/enter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-select-all/src/selectallcommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-select-all/src/selectallediting.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-select-all/src/selectallui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-select-all/src/selectall.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-select-all/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-select-all/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/select-all.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/typing.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/basecommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/undocommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/redocommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/undoediting.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/undoui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/undo.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-undo/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/undo.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-essentials/src/essentials.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-essentials_src_essentials.js.map
