import {
  ButtonLabelView,
  ButtonView,
  Template,
  View,
  ViewCollection,
  iconview_default
} from "./chunk-OWJNOFJW.js";
import {
  Plugin
} from "./chunk-SDF6D7WI.js";
import {
  CKEditorError,
  Collection,
  Config,
  DomEmitterMixin,
  EmitterMixin,
  EventInfo,
  FocusTracker,
  KeystrokeHandler,
  Locale,
  ObservableMixin,
  Rect,
  compareArrays,
  count,
  crc32,
  createElement,
  diff,
  env_default,
  fastDiff,
  first,
  getAncestors,
  getCode,
  getEnvKeystrokeText,
  getOptimalPosition,
  global_default,
  indexOf,
  insertAt,
  isArrowKeyCode,
  isComment,
  isInsideCombinedSymbol,
  isInsideEmojiSequence,
  isInsideSurrogatePair,
  isIterable,
  isNode,
  isRange,
  isText,
  isValidAttributeName,
  isVisible,
  keyCodes,
  logError,
  logWarning,
  parseBase64EncodedObject,
  priorities_default,
  releaseDate,
  remove,
  resizeobserver_default,
  scrollViewportToShowTarget,
  setDataInElement,
  spliceArray,
  toArray,
  toMap,
  toUnit,
  uid
} from "./chunk-3X5M7Q3U.js";
import {
  require_color_convert
} from "./chunk-2KI6HXVW.js";
import {
  __toESM,
  assignIn_default,
  cloneDeepWith_default,
  cloneDeep_default,
  clone_default,
  debounce_default,
  escapeRegExp_default,
  get_default,
  isElement_default,
  isEqualWith_default,
  isEqual_default,
  isFunction_default,
  isObject_default,
  isPlainObject_default,
  merge_default,
  set_default,
  throttle_default,
  unset_default
} from "./chunk-K6UGUURS.js";

// node_modules/@ckeditor/ckeditor5-engine/src/view/placeholder.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css";
var documentPlaceholders = /* @__PURE__ */ new WeakMap();
var hasDisplayedPlaceholderDeprecationWarning = false;
function enablePlaceholder({ view, element, text: text2, isDirectHost = true, keepOnFocus = false }) {
  const doc = view.document;
  if (!documentPlaceholders.has(doc)) {
    documentPlaceholders.set(doc, /* @__PURE__ */ new Map());
    doc.registerPostFixer((writer) => updateDocumentPlaceholders(doc, writer));
    doc.on("change:isComposing", () => {
      view.change((writer) => updateDocumentPlaceholders(doc, writer));
    }, { priority: "high" });
  }
  if (element.is("editableElement")) {
    element.on("change:placeholder", (evtInfo, evt, text3) => {
      setPlaceholder(text3);
    });
  }
  if (element.placeholder) {
    setPlaceholder(element.placeholder);
  } else if (text2) {
    setPlaceholder(text2);
  }
  if (text2) {
    showPlaceholderTextDeprecationWarning();
  }
  function setPlaceholder(text3) {
    documentPlaceholders.get(doc).set(element, {
      text: text3,
      isDirectHost,
      keepOnFocus,
      hostElement: isDirectHost ? element : null
    });
    view.change((writer) => updateDocumentPlaceholders(doc, writer));
  }
}
function showPlaceholder(writer, element) {
  if (!element.hasClass("ck-placeholder")) {
    writer.addClass("ck-placeholder", element);
    return true;
  }
  return false;
}
function hidePlaceholder(writer, element) {
  if (element.hasClass("ck-placeholder")) {
    writer.removeClass("ck-placeholder", element);
    return true;
  }
  return false;
}
function needsPlaceholder(element, keepOnFocus) {
  if (!element.isAttached()) {
    return false;
  }
  const hasContent = Array.from(element.getChildren()).some((element2) => !element2.is("uiElement"));
  if (hasContent) {
    return false;
  }
  const doc = element.document;
  const viewSelection = doc.selection;
  const selectionAnchor = viewSelection.anchor;
  if (doc.isComposing && selectionAnchor && selectionAnchor.parent === element) {
    return false;
  }
  if (keepOnFocus) {
    return true;
  }
  if (!doc.isFocused) {
    return true;
  }
  return !!selectionAnchor && selectionAnchor.parent !== element;
}
function updateDocumentPlaceholders(doc, writer) {
  const placeholders = documentPlaceholders.get(doc);
  const directHostElements = [];
  let wasViewModified = false;
  for (const [element, config] of placeholders) {
    if (config.isDirectHost) {
      directHostElements.push(element);
      if (updatePlaceholder(writer, element, config)) {
        wasViewModified = true;
      }
    }
  }
  for (const [element, config] of placeholders) {
    if (config.isDirectHost) {
      continue;
    }
    const hostElement = getChildPlaceholderHostSubstitute(element);
    if (!hostElement) {
      continue;
    }
    if (directHostElements.includes(hostElement)) {
      continue;
    }
    config.hostElement = hostElement;
    if (updatePlaceholder(writer, element, config)) {
      wasViewModified = true;
    }
  }
  return wasViewModified;
}
function updatePlaceholder(writer, element, config) {
  const { text: text2, isDirectHost, hostElement } = config;
  let wasViewModified = false;
  if (hostElement.getAttribute("data-placeholder") !== text2) {
    writer.setAttribute("data-placeholder", text2, hostElement);
    wasViewModified = true;
  }
  const isOnlyChild = isDirectHost || element.childCount == 1;
  if (isOnlyChild && needsPlaceholder(hostElement, config.keepOnFocus)) {
    if (showPlaceholder(writer, hostElement)) {
      wasViewModified = true;
    }
  } else if (hidePlaceholder(writer, hostElement)) {
    wasViewModified = true;
  }
  return wasViewModified;
}
function getChildPlaceholderHostSubstitute(parent) {
  if (parent.childCount) {
    const firstChild = parent.getChild(0);
    if (firstChild.is("element") && !firstChild.is("uiElement") && !firstChild.is("attributeElement")) {
      return firstChild;
    }
  }
  return null;
}
function showPlaceholderTextDeprecationWarning() {
  if (!hasDisplayedPlaceholderDeprecationWarning) {
    logWarning("enableplaceholder-deprecated-text-option");
  }
  hasDisplayedPlaceholderDeprecationWarning = true;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/typecheckable.js
var TypeCheckable = class {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/node.js
var Node2 = class extends EmitterMixin(TypeCheckable) {
  /**
   * Creates a tree view node.
   *
   * @param document The document instance to which this node belongs.
   */
  constructor(document2) {
    super();
    this.document = document2;
    this.parent = null;
  }
  /**
   * Index of the node in the parent element or null if the node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that view tree got broken.
   */
  get index() {
    let pos;
    if (!this.parent) {
      return null;
    }
    if ((pos = this.parent.getChildIndex(this)) == -1) {
      throw new CKEditorError("view-node-not-found-in-parent", this);
    }
    return pos;
  }
  /**
   * Node's next sibling, or `null` if it is the last child.
   */
  get nextSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index + 1) || null;
  }
  /**
   * Node's previous sibling, or `null` if it is the first child.
   */
  get previousSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index - 1) || null;
  }
  /**
   * Top-most ancestor of the node. If the node has no parent it is the root itself.
   */
  get root() {
    let root = this;
    while (root.parent) {
      root = root.parent;
    }
    return root;
  }
  /**
   * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
   */
  isAttached() {
    return this.root.is("rootElement");
  }
  /**
   * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
   * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.
   *
   * ```ts
   * const abc = downcastWriter.createText( 'abc' );
   * const foo = downcastWriter.createText( 'foo' );
   * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
   * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
   * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
   * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
   * h1.getPath(); // Returns [ 0 ].
   * div.getPath(); // Returns [].
   * ```
   *
   * @returns The path.
   */
  getPath() {
    const path = [];
    let node = this;
    while (node.parent) {
      path.unshift(node.index);
      node = node.parent;
    }
    return path;
  }
  /**
   * Returns ancestors array of this node.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
  /**
   * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of both nodes.
   *
   * @param node The second node.
   * @param options Options object.
   * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
   * Which means that if e.g. node A is inside B, then their common ancestor will be B.
   */
  getCommonAncestor(node, options = {}) {
    const ancestorsA = this.getAncestors(options);
    const ancestorsB = node.getAncestors(options);
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isBefore(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    const thisPath = this.getPath();
    const nodePath = node.getPath();
    const result = compareArrays(thisPath, nodePath);
    switch (result) {
      case "prefix":
        return true;
      case "extension":
        return false;
      default:
        return thisPath[result] < nodePath[result];
    }
  }
  /**
   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isAfter(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    return !this.isBefore(node);
  }
  /**
   * Removes node from parent.
   *
   * @internal
   */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
   * @internal
   * @param type Type of the change.
   * @param node Changed node.
   * @fires change
   */
  _fireChange(type, node) {
    this.fire(`change:${type}`, node);
    if (this.parent) {
      this.parent._fireChange(type, node);
    }
  }
  /**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns Clone of this object with the parent property removed.
   */
  toJSON() {
    const json = clone_default(this);
    delete json.parent;
    return json;
  }
};
Node2.prototype.is = function(type) {
  return type === "node" || type === "view:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/text.js
var Text = class _Text extends Node2 {
  /**
   * Creates a tree view text node.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createText
   * @internal
   * @param document The document instance to which this text node belongs.
   * @param data The text's data.
   */
  constructor(document2, data) {
    super(document2);
    this._textData = data;
  }
  /**
   * The text content.
   */
  get data() {
    return this._textData;
  }
  /**
   * The `_data` property is controlled by a getter and a setter.
   *
   * The getter is required when using the addition assignment operator on protected property:
   *
   * ```ts
   * const foo = downcastWriter.createText( 'foo' );
   * const bar = downcastWriter.createText( 'bar' );
   *
   * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
   * console.log( foo.data ); // prints: 'foobar'
   * ```
   *
   * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
   *
   * The setter sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.
   *
   * @internal
   */
  get _data() {
    return this.data;
  }
  set _data(data) {
    this._fireChange("text", this);
    this._textData = data;
  }
  /**
   * Checks if this text node is similar to other text node.
   * Both nodes should have the same data to be considered as similar.
   *
   * @param otherNode Node to check if it is same as this node.
   */
  isSimilar(otherNode) {
    if (!(otherNode instanceof _Text)) {
      return false;
    }
    return this === otherNode || this.data === otherNode.data;
  }
  /**
   * Clones this node.
   *
   * @internal
   * @returns Text node that is a clone of this node.
   */
  _clone() {
    return new _Text(this.document, this.data);
  }
};
Text.prototype.is = function(type) {
  return type === "$text" || type === "view:$text" || // This are legacy values kept for backward compatibility.
  type === "text" || type === "view:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type === "node" || type === "view:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/textproxy.js
var TextProxy = class extends TypeCheckable {
  /**
   * Creates a text proxy.
   *
   * @internal
   * @param textNode Text node which part is represented by this text proxy.
   * @param offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
   * from which the text proxy starts.
   * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   * @constructor
   */
  constructor(textNode, offsetInText, length) {
    super();
    this.textNode = textNode;
    if (offsetInText < 0 || offsetInText > textNode.data.length) {
      throw new CKEditorError("view-textproxy-wrong-offsetintext", this);
    }
    if (length < 0 || offsetInText + length > textNode.data.length) {
      throw new CKEditorError("view-textproxy-wrong-length", this);
    }
    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    this.offsetInText = offsetInText;
  }
  /**
   * Offset size of this node.
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
   * (`true`) or the whole text node (`false`).
   *
   * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
   * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
   * text node size.
   */
  get isPartial() {
    return this.data.length !== this.textNode.data.length;
  }
  /**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   */
  get parent() {
    return this.textNode.parent;
  }
  /**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   */
  get root() {
    return this.textNode.root;
  }
  /**
   * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   */
  get document() {
    return this.textNode.document;
  }
  /**
   * Returns ancestors array of this text proxy.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
   * root element, otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this.textNode : this.parent;
    while (parent !== null) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
};
TextProxy.prototype.is = function(type) {
  return type === "$textProxy" || type === "view:$textProxy" || // This are legacy values kept for backward compatibility.
  type === "textProxy" || type === "view:textProxy";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/matcher.js
var Matcher = class {
  /**
   * Creates new instance of Matcher.
   *
   * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
   */
  constructor(...pattern) {
    this._patterns = [];
    this.add(...pattern);
  }
  /**
   * Adds pattern or patterns to matcher instance.
   *
   * ```ts
   * // String.
   * matcher.add( 'div' );
   *
   * // Regular expression.
   * matcher.add( /^\w/ );
   *
   * // Single class.
   * matcher.add( {
   * 	classes: 'foobar'
   * } );
   * ```
   *
   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
   *
   * Multiple patterns can be added in one call:
   *
   * ```ts
   * matcher.add( 'div', { classes: 'foobar' } );
   * ```
   *
   * @param pattern Object describing pattern details. If string or regular expression
   * is provided it will be used to match element's name. Pattern can be also provided in a form
   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
   * Function's return value will be stored under `match` key of the object returned from
   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
   */
  add(...pattern) {
    for (let item of pattern) {
      if (typeof item == "string" || item instanceof RegExp) {
        item = { name: item };
      }
      this._patterns.push(item);
    }
  }
  /**
   * Matches elements for currently stored patterns. Returns match information about first found
   * {@link module:engine/view/element~Element element}, otherwise returns `null`.
   *
   * Example of returned object:
   *
   * ```ts
   * {
   * 	element: <instance of found element>,
   * 	pattern: <pattern used to match found element>,
   * 	match: {
   * 		name: true,
   * 		attributes: [ 'title', 'href' ],
   * 		classes: [ 'foo' ],
   * 		styles: [ 'color', 'position' ]
   * 	}
   * }
   * ```
   *
   * @see module:engine/view/matcher~Matcher#add
   * @see module:engine/view/matcher~Matcher#matchAll
   * @param element View element to match against stored patterns.
   */
  match(...element) {
    for (const singleElement of element) {
      for (const pattern of this._patterns) {
        const match = isElementMatching(singleElement, pattern);
        if (match) {
          return {
            element: singleElement,
            pattern,
            match
          };
        }
      }
    }
    return null;
  }
  /**
   * Matches elements for currently stored patterns. Returns array of match information with all found
   * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
   *
   * @see module:engine/view/matcher~Matcher#add
   * @see module:engine/view/matcher~Matcher#match
   * @param element View element to match against stored patterns.
   * @returns Array with match information about found elements or `null`. For more information
   * see {@link module:engine/view/matcher~Matcher#match match method} description.
   */
  matchAll(...element) {
    const results = [];
    for (const singleElement of element) {
      for (const pattern of this._patterns) {
        const match = isElementMatching(singleElement, pattern);
        if (match) {
          results.push({
            element: singleElement,
            pattern,
            match
          });
        }
      }
    }
    return results.length > 0 ? results : null;
  }
  /**
   * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
   * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
   *
   * @returns Element name trying to match.
   */
  getElementName() {
    if (this._patterns.length !== 1) {
      return null;
    }
    const pattern = this._patterns[0];
    const name = pattern.name;
    return typeof pattern != "function" && name && !(name instanceof RegExp) ? name : null;
  }
};
function isElementMatching(element, pattern) {
  if (typeof pattern == "function") {
    return pattern(element);
  }
  const match = {};
  if (pattern.name) {
    match.name = matchName(pattern.name, element.name);
    if (!match.name) {
      return null;
    }
  }
  if (pattern.attributes) {
    match.attributes = matchAttributes(pattern.attributes, element);
    if (!match.attributes) {
      return null;
    }
  }
  if (pattern.classes) {
    match.classes = matchClasses(pattern.classes, element);
    if (!match.classes) {
      return null;
    }
  }
  if (pattern.styles) {
    match.styles = matchStyles(pattern.styles, element);
    if (!match.styles) {
      return null;
    }
  }
  return match;
}
function matchName(pattern, name) {
  if (pattern instanceof RegExp) {
    return !!name.match(pattern);
  }
  return pattern === name;
}
function matchPatterns(patterns, keys, valueGetter) {
  const normalizedPatterns = normalizePatterns(patterns);
  const normalizedItems = Array.from(keys);
  const match = [];
  normalizedPatterns.forEach(([patternKey, patternValue]) => {
    normalizedItems.forEach((itemKey) => {
      if (isKeyMatched(patternKey, itemKey) && isValueMatched(patternValue, itemKey, valueGetter)) {
        match.push(itemKey);
      }
    });
  });
  if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {
    return void 0;
  }
  return match;
}
function normalizePatterns(patterns) {
  if (Array.isArray(patterns)) {
    return patterns.map((pattern) => {
      if (isPlainObject_default(pattern)) {
        if (pattern.key === void 0 || pattern.value === void 0) {
          logWarning("matcher-pattern-missing-key-or-value", pattern);
        }
        return [pattern.key, pattern.value];
      }
      return [pattern, true];
    });
  }
  if (isPlainObject_default(patterns)) {
    return Object.entries(patterns);
  }
  return [[patterns, true]];
}
function isKeyMatched(patternKey, itemKey) {
  return patternKey === true || patternKey === itemKey || patternKey instanceof RegExp && itemKey.match(patternKey);
}
function isValueMatched(patternValue, itemKey, valueGetter) {
  if (patternValue === true) {
    return true;
  }
  const itemValue = valueGetter(itemKey);
  return patternValue === itemValue || patternValue instanceof RegExp && !!String(itemValue).match(patternValue);
}
function matchAttributes(patterns, element) {
  const attributeKeys = new Set(element.getAttributeKeys());
  if (isPlainObject_default(patterns)) {
    if (patterns.style !== void 0) {
      logWarning("matcher-pattern-deprecated-attributes-style-key", patterns);
    }
    if (patterns.class !== void 0) {
      logWarning("matcher-pattern-deprecated-attributes-class-key", patterns);
    }
  } else {
    attributeKeys.delete("style");
    attributeKeys.delete("class");
  }
  return matchPatterns(patterns, attributeKeys, (key) => element.getAttribute(key));
}
function matchClasses(patterns, element) {
  return matchPatterns(
    patterns,
    element.getClassNames(),
    /* istanbul ignore next -- @preserve */
    () => {
    }
  );
}
function matchStyles(patterns, element) {
  return matchPatterns(patterns, element.getStyleNames(true), (key) => element.getStyle(key));
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js
var StylesMap = class {
  /**
   * Creates Styles instance.
   */
  constructor(styleProcessor) {
    this._styles = {};
    this._styleProcessor = styleProcessor;
  }
  /**
   * Returns true if style map has no styles set.
   */
  get isEmpty() {
    const entries = Object.entries(this._styles);
    return !entries.length;
  }
  /**
   * Number of styles defined.
   */
  get size() {
    if (this.isEmpty) {
      return 0;
    }
    return this.getStyleNames().length;
  }
  /**
   * Set styles map to a new value.
   *
   * ```ts
   * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
   * ```
   */
  setTo(inlineStyle) {
    this.clear();
    const parsedStyles = parseInlineStyles(inlineStyle);
    for (const [key, value] of parsedStyles) {
      this._styleProcessor.toNormalizedForm(key, value, this._styles);
    }
  }
  /**
   * Checks if a given style is set.
   *
   * ```ts
   * styles.setTo( 'margin-left:1px;' );
   *
   * styles.has( 'margin-left' );    // -> true
   * styles.has( 'padding' );        // -> false
   * ```
   *
   * **Note**: This check supports normalized style names.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.setTo( 'margin:2px;' );
   *
   * styles.has( 'margin' );         // -> true
   * styles.has( 'margin-top' );     // -> true
   * styles.has( 'margin-left' );    // -> true
   *
   * styles.remove( 'margin-top' );
   *
   * styles.has( 'margin' );         // -> false
   * styles.has( 'margin-top' );     // -> false
   * styles.has( 'margin-left' );    // -> true
   * ```
   *
   * @param name Style name.
   */
  has(name) {
    if (this.isEmpty) {
      return false;
    }
    const styles = this._styleProcessor.getReducedForm(name, this._styles);
    const propertyDescriptor = styles.find(([property]) => property === name);
    return Array.isArray(propertyDescriptor);
  }
  set(nameOrObject, valueOrObject) {
    if (isObject_default(nameOrObject)) {
      for (const [key, value] of Object.entries(nameOrObject)) {
        this._styleProcessor.toNormalizedForm(key, value, this._styles);
      }
    } else {
      this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);
    }
  }
  /**
   * Removes given style.
   *
   * ```ts
   * styles.setTo( 'background:#f00;margin-right:2px;' );
   *
   * styles.remove( 'background' );
   *
   * styles.toString();   // -> 'margin-right:2px;'
   * ```
   *
   * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
   * enabled style processor rules} to normalize passed values.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.setTo( 'margin:1px' );
   *
   * styles.remove( 'margin-top' );
   * styles.remove( 'margin-right' );
   *
   * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
   * ```
   *
   * @param name Style name.
   */
  remove(name) {
    const path = toPath(name);
    unset_default(this._styles, path);
    delete this._styles[name];
    this._cleanEmptyObjectsOnPath(path);
  }
  /**
   * Returns a normalized style object or a single value.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const styles = new Styles();
   * styles.setTo( 'margin:1px 2px 3em;' );
   *
   * styles.getNormalized( 'margin' );
   * // will log:
   * // {
   * //     top: '1px',
   * //     right: '2px',
   * //     bottom: '3em',
   * //     left: '2px'     // normalized value from margin shorthand
   * // }
   *
   * styles.getNormalized( 'margin-left' ); // -> '2px'
   * ```
   *
   * **Note**: This method will only return normalized styles if a style processor was defined.
   *
   * @param name Style name.
   */
  getNormalized(name) {
    return this._styleProcessor.getNormalized(name, this._styles);
  }
  /**
   * Returns a normalized style string. Styles are sorted by name.
   *
   * ```ts
   * styles.set( 'margin' , '1px' );
   * styles.set( 'background', '#f00' );
   *
   * styles.toString(); // -> 'background:#f00;margin:1px;'
   * ```
   *
   * **Note**: This method supports normalized styles if defined.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * styles.set( 'margin' , '1px' );
   * styles.set( 'background', '#f00' );
   * styles.remove( 'margin-top' );
   * styles.remove( 'margin-right' );
   *
   * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
   * ```
   */
  toString() {
    if (this.isEmpty) {
      return "";
    }
    return this.getStylesEntries().map((arr) => arr.join(":")).sort().join(";") + ";";
  }
  /**
   * Returns property as a value string or undefined if property is not set.
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.set( 'margin-bottom', '3em' );
   *
   * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
   * ```
   *
   * Note, however, that all sub-values must be set for the longhand property name to return a value:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.remove( 'margin-bottom' );
   *
   * styles.getAsString( 'margin' ); // -> undefined
   * ```
   *
   * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
   * Instead, you should use:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   * styles.remove( 'margin-bottom' );
   *
   * for ( const styleName of styles.getStyleNames() ) {
   * 	console.log( styleName, styles.getAsString( styleName ) );
   * }
   * // 'margin-top', '1px'
   * // 'margin-right', '1px'
   * // 'margin-left', '1px'
   * ```
   *
   * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
   * the currently set style values. So, if all the 4 margin values would be set
   * the for-of loop above would yield only `'margin'`, `'1px'`:
   *
   * ```ts
   * const styles = new Styles();
   * styles.setTo( 'margin:1px;' );
   *
   * for ( const styleName of styles.getStyleNames() ) {
   * 	console.log( styleName, styles.getAsString( styleName ) );
   * }
   * // 'margin', '1px'
   * ```
   *
   * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
   */
  getAsString(propertyName) {
    if (this.isEmpty) {
      return;
    }
    if (this._styles[propertyName] && !isObject_default(this._styles[propertyName])) {
      return this._styles[propertyName];
    }
    const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);
    const propertyDescriptor = styles.find(([property]) => property === propertyName);
    if (Array.isArray(propertyDescriptor)) {
      return propertyDescriptor[1];
    }
  }
  /**
   * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
   *
   * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
   *
   * ```ts
   * stylesMap.setTo( 'margin: 1em' )
   * ```
   *
   * will be expanded to:
   *
   * ```ts
   * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
   * ```
   *
   * @param expand Expand shorthand style properties and all return equivalent style representations.
   */
  getStyleNames(expand = false) {
    if (this.isEmpty) {
      return [];
    }
    if (expand) {
      return this._styleProcessor.getStyleNames(this._styles);
    }
    const entries = this.getStylesEntries();
    return entries.map(([key]) => key);
  }
  /**
   * Removes all styles.
   */
  clear() {
    this._styles = {};
  }
  /**
   * Returns normalized styles entries for further processing.
   */
  getStylesEntries() {
    const parsed = [];
    const keys = Object.keys(this._styles);
    for (const key of keys) {
      parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));
    }
    return parsed;
  }
  /**
   * Removes empty objects upon removing an entry from internal object.
   */
  _cleanEmptyObjectsOnPath(path) {
    const pathParts = path.split(".");
    const isChildPath = pathParts.length > 1;
    if (!isChildPath) {
      return;
    }
    const parentPath = pathParts.splice(0, pathParts.length - 1).join(".");
    const parentObject = get_default(this._styles, parentPath);
    if (!parentObject) {
      return;
    }
    const isParentEmpty = !Object.keys(parentObject).length;
    if (isParentEmpty) {
      this.remove(parentPath);
    }
  }
};
var StylesProcessor = class {
  /**
   * Creates StylesProcessor instance.
   *
   * @internal
   */
  constructor() {
    this._normalizers = /* @__PURE__ */ new Map();
    this._extractors = /* @__PURE__ */ new Map();
    this._reducers = /* @__PURE__ */ new Map();
    this._consumables = /* @__PURE__ */ new Map();
  }
  /**
   * Parse style string value to a normalized object and appends it to styles object.
   *
   * ```ts
   * const styles = {};
   *
   * stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
   *
   * // styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
   * ```
   *
   * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
   *
   * @param name Name of style property.
   * @param propertyValue Value of style property.
   * @param styles Object holding normalized styles.
   */
  toNormalizedForm(name, propertyValue, styles) {
    if (isObject_default(propertyValue)) {
      appendStyleValue(styles, toPath(name), propertyValue);
      return;
    }
    if (this._normalizers.has(name)) {
      const normalizer = this._normalizers.get(name);
      const { path, value } = normalizer(propertyValue);
      appendStyleValue(styles, path, value);
    } else {
      appendStyleValue(styles, name, propertyValue);
    }
  }
  /**
   * Returns a normalized version of a style property.
   *
   * ```ts
   * const styles = {
   * 	margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
   * 	background: { color: '#f00' }
   * };
   *
   * stylesProcessor.getNormalized( 'background' );
   * // will return: { color: '#f00' }
   *
   * stylesProcessor.getNormalized( 'margin-top' );
   * // will return: '1px'
   * ```
   *
   * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
   *
   * @param name Name of style property.
   * @param styles Object holding normalized styles.
   */
  getNormalized(name, styles) {
    if (!name) {
      return merge_default({}, styles);
    }
    if (styles[name] !== void 0) {
      return styles[name];
    }
    if (this._extractors.has(name)) {
      const extractor = this._extractors.get(name);
      if (typeof extractor === "string") {
        return get_default(styles, extractor);
      }
      const value = extractor(name, styles);
      if (value) {
        return value;
      }
    }
    return get_default(styles, toPath(name));
  }
  /**
   * Returns a reduced form of style property form normalized object.
   *
   * For default margin reducer, the below code:
   *
   * ```ts
   * stylesProcessor.getReducedForm( 'margin', {
   * 	margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
   * } );
   * ```
   *
   * will return:
   *
   * ```ts
   * [
   * 	[ 'margin', '1px 1px 2px' ]
   * ]
   * ```
   *
   * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
   *
   * ```ts
   * [
   * 	[ 'margin-top', '1px' ],
   * 	[ 'margin-right', '1px' ],
   * 	[ 'margin-bottom', '2px' ]
   * 	// the 'left' value is missing - cannot use 'margin' shorthand.
   * ]
   * ```
   *
   * **Note**: To define reducer callbacks use {@link #setReducer}.
   *
   * @param name Name of style property.
   */
  getReducedForm(name, styles) {
    const normalizedValue = this.getNormalized(name, styles);
    if (normalizedValue === void 0) {
      return [];
    }
    if (this._reducers.has(name)) {
      const reducer = this._reducers.get(name);
      return reducer(normalizedValue);
    }
    return [[name, normalizedValue]];
  }
  /**
   * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.
   *
   * @param styles Object holding normalized styles.
   */
  getStyleNames(styles) {
    const styleNamesKeysSet = /* @__PURE__ */ new Set();
    for (const name of this._consumables.keys()) {
      const style = this.getNormalized(name, styles);
      if (style && (typeof style != "object" || Object.keys(style).length)) {
        styleNamesKeysSet.add(name);
      }
    }
    for (const name of Object.keys(styles)) {
      styleNamesKeysSet.add(name);
    }
    return Array.from(styleNamesKeysSet);
  }
  /**
   * Returns related style names.
   *
   * ```ts
   * stylesProcessor.getRelatedStyles( 'margin' );
   * // will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
   *
   * stylesProcessor.getRelatedStyles( 'margin-top' );
   * // will return: [ 'margin' ];
   * ```
   *
   * **Note**: To define new style relations load an existing style processor or use
   * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
   */
  getRelatedStyles(name) {
    return this._consumables.get(name) || [];
  }
  /**
   * Adds a normalizer method for a style property.
   *
   * A normalizer returns describing how the value should be normalized.
   *
   * For instance 'margin' style is a shorthand for four margin values:
   *
   * - 'margin-top'
   * - 'margin-right'
   * - 'margin-bottom'
   * - 'margin-left'
   *
   * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
   * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
   *
   * A normalizer should parse various margin notations as a single object:
   *
   * ```ts
   * const styles = {
   * 	margin: {
   * 		top: '1px',
   * 		right: '2em',
   * 		bottom: '1px',
   * 		left: '2em'
   * 	}
   * };
   * ```
   *
   * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
   *
   * ```ts
   * const returnValue = {
   * 	path: 'margin',
   * 	value: {
   * 		top: '1px',
   * 		right: '2em',
   * 		bottom: '1px',
   * 		left: '2em'
   * 	}
   * };
   * ```
   *
   * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
   * is an example for 'margin-top' style property normalizer:
   *
   * ```ts
   * stylesProcessor.setNormalizer( 'margin-top', valueString => {
   * 	return {
   * 		path: 'margin.top',
   * 		value: valueString
   * 	}
   * } );
   * ```
   */
  setNormalizer(name, callback) {
    this._normalizers.set(name, callback);
  }
  /**
   * Adds a extractor callback for a style property.
   *
   * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
   *
   * ```ts
   * const styles = {
   * 	margin: {
   * 		top: 'value'
   * 	}
   * }
   * ```
   *
   * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
   * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
   * shorthands. The default border styles processors stores styles as:
   *
   * ```ts
   * const styles = {
   * 	border: {
   * 		style: {
   * 			top: 'solid'
   * 		}
   * 	}
   * }
   * ```
   *
   * as it is better to modify border style independently from other values. On the other part the output of the border might be
   * desired as `border-top`, `border-left`, etc notation.
   *
   * In the above example an extractor should return a side border value that combines style, color and width:
   *
   * ```ts
   * styleProcessor.setExtractor( 'border-top', styles => {
   * 	return {
   * 		color: styles.border.color.top,
   * 		style: styles.border.style.top,
   * 		width: styles.border.width.top
   * 	}
   * } );
   * ```
   *
   * @param callbackOrPath Callback that return a requested value or path string for single values.
   */
  setExtractor(name, callbackOrPath) {
    this._extractors.set(name, callbackOrPath);
  }
  /**
   * Adds a reducer callback for a style property.
   *
   * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
   * by default the direct value from style path is taken.
   *
   * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
   * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
   *
   * ```ts
   * const marginShortHandTuple = [
   * 	[ 'margin', '1px 1px 2px' ]
   * ];
   * ```
   *
   * or a longhand tuples for defined values:
   *
   * ```ts
   * // Considering margin.bottom and margin.left are undefined.
   * const marginLonghandsTuples = [
   * 	[ 'margin-top', '1px' ],
   * 	[ 'margin-right', '1px' ]
   * ];
   * ```
   *
   * A reducer obtains a normalized style value:
   *
   * ```ts
   * // Simplified reducer that always outputs 4 values which are always present:
   * stylesProcessor.setReducer( 'margin', margin => {
   * 	return [
   * 		[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
   * 	]
   * } );
   * ```
   */
  setReducer(name, callback) {
    this._reducers.set(name, callback);
  }
  /**
   * Defines a style shorthand relation to other style notations.
   *
   * ```ts
   * stylesProcessor.setStyleRelation( 'margin', [
   * 	'margin-top',
   * 	'margin-right',
   * 	'margin-bottom',
   * 	'margin-left'
   * ] );
   * ```
   *
   * This enables expanding of style names for shorthands. For instance, if defined,
   * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
   * for long-hand margin style notation alongside the `'margin'` item.
   *
   * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
   * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
   * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
   * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
   */
  setStyleRelation(shorthandName, styleNames) {
    this._mapStyleNames(shorthandName, styleNames);
    for (const alsoName of styleNames) {
      this._mapStyleNames(alsoName, [shorthandName]);
    }
  }
  /**
   * Set two-way binding of style names.
   */
  _mapStyleNames(name, styleNames) {
    if (!this._consumables.has(name)) {
      this._consumables.set(name, []);
    }
    this._consumables.get(name).push(...styleNames);
  }
};
function parseInlineStyles(stylesString) {
  let quoteType = null;
  let propertyNameStart = 0;
  let propertyValueStart = 0;
  let propertyName = null;
  const stylesMap = /* @__PURE__ */ new Map();
  if (stylesString === "") {
    return stylesMap;
  }
  if (stylesString.charAt(stylesString.length - 1) != ";") {
    stylesString = stylesString + ";";
  }
  for (let i = 0; i < stylesString.length; i++) {
    const char = stylesString.charAt(i);
    if (quoteType === null) {
      switch (char) {
        case ":":
          if (!propertyName) {
            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart);
            propertyValueStart = i + 1;
          }
          break;
        case '"':
        case "'":
          quoteType = char;
          break;
        case ";": {
          const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);
          if (propertyName) {
            stylesMap.set(propertyName.trim(), propertyValue.trim());
          }
          propertyName = null;
          propertyNameStart = i + 1;
          break;
        }
      }
    } else if (char === quoteType) {
      quoteType = null;
    }
  }
  return stylesMap;
}
function toPath(name) {
  return name.replace("-", ".");
}
function appendStyleValue(stylesObject, nameOrPath, valueOrObject) {
  let valueToSet = valueOrObject;
  if (isObject_default(valueOrObject)) {
    valueToSet = merge_default({}, get_default(stylesObject, nameOrPath), valueOrObject);
  }
  set_default(stylesObject, nameOrPath, valueToSet);
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/element.js
var Element = class _Element extends Node2 {
  /**
   * Creates a view element.
   *
   * Attributes can be passed in various formats:
   *
   * ```ts
   * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
   * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
   * new Element( viewDocument, 'div', mapOfAttributes ); // map
   * ```
   *
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attrs, children) {
    super(document2);
    this._unsafeAttributesToRender = [];
    this._customProperties = /* @__PURE__ */ new Map();
    this.name = name;
    this._attrs = parseAttributes(attrs);
    this._children = [];
    if (children) {
      this._insertChild(0, children);
    }
    this._classes = /* @__PURE__ */ new Set();
    if (this._attrs.has("class")) {
      const classString = this._attrs.get("class");
      parseClasses(this._classes, classString);
      this._attrs.delete("class");
    }
    this._styles = new StylesMap(this.document.stylesProcessor);
    if (this._attrs.has("style")) {
      this._styles.setTo(this._attrs.get("style"));
      this._attrs.delete("style");
    }
  }
  /**
   * Number of element's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   */
  get isEmpty() {
    return this._children.length === 0;
  }
  /**
   * Gets child at the given index.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(index) {
    return this._children[index];
  }
  /**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param node Child node.
   * @returns Index of the child node.
   */
  getChildIndex(node) {
    return this._children.indexOf(node);
  }
  /**
   * Gets child nodes iterator.
   *
   * @returns Child nodes iterator.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
   *
   * @returns Keys for attributes.
   */
  *getAttributeKeys() {
    if (this._classes.size > 0) {
      yield "class";
    }
    if (!this._styles.isEmpty) {
      yield "style";
    }
    yield* this._attrs.keys();
  }
  /**
   * Returns iterator that iterates over this element's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  *getAttributes() {
    yield* this._attrs.entries();
    if (this._classes.size > 0) {
      yield ["class", this.getAttribute("class")];
    }
    if (!this._styles.isEmpty) {
      yield ["style", this.getAttribute("style")];
    }
  }
  /**
   * Gets attribute by key. If attribute is not present - returns undefined.
   *
   * @param key Attribute key.
   * @returns Attribute value.
   */
  getAttribute(key) {
    if (key == "class") {
      if (this._classes.size > 0) {
        return [...this._classes].join(" ");
      }
      return void 0;
    }
    if (key == "style") {
      const inlineStyle = this._styles.toString();
      return inlineStyle == "" ? void 0 : inlineStyle;
    }
    return this._attrs.get(key);
  }
  /**
   * Returns a boolean indicating whether an attribute with the specified key exists in the element.
   *
   * @param key Attribute key.
   * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
   */
  hasAttribute(key) {
    if (key == "class") {
      return this._classes.size > 0;
    }
    if (key == "style") {
      return !this._styles.isEmpty;
    }
    return this._attrs.has(key);
  }
  /**
   * Checks if this element is similar to other element.
   * Both elements should have the same name and attributes to be considered as similar. Two similar elements
   * can contain different set of children nodes.
   */
  isSimilar(otherElement) {
    if (!(otherElement instanceof _Element)) {
      return false;
    }
    if (this === otherElement) {
      return true;
    }
    if (this.name != otherElement.name) {
      return false;
    }
    if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {
      return false;
    }
    for (const [key, value] of this._attrs) {
      if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {
        return false;
      }
    }
    for (const className of this._classes) {
      if (!otherElement._classes.has(className)) {
        return false;
      }
    }
    for (const property of this._styles.getStyleNames()) {
      if (!otherElement._styles.has(property) || otherElement._styles.getAsString(property) !== this._styles.getAsString(property)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns true if class is present.
   * If more then one class is provided - returns true only when all classes are present.
   *
   * ```ts
   * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
   * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
   * ```
   */
  hasClass(...className) {
    for (const name of className) {
      if (!this._classes.has(name)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns iterator that contains all class names.
   */
  getClassNames() {
    return this._classes.keys();
  }
  /**
   * Returns style value for the given property mae.
   * If the style does not exist `undefined` is returned.
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
   *
   * For an element with style set to `'margin:1px'`:
   *
   * ```ts
   * // Enable 'margin' shorthand processing:
   * editor.data.addStyleProcessorRules( addMarginRules );
   *
   * const element = view.change( writer => {
   * 	const element = writer.createElement();
   * 	writer.setStyle( 'margin', '1px' );
   * 	writer.setStyle( 'margin-bottom', '3em' );
   *
   * 	return element;
   * } );
   *
   * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
   * ```
   */
  getStyle(property) {
    return this._styles.getAsString(property);
  }
  /**
   * Returns a normalized style object or single style value.
   *
   * For an element with style set to: margin:1px 2px 3em;
   *
   * ```ts
   * element.getNormalizedStyle( 'margin' ) );
   * ```
   *
   * will return:
   *
   * ```ts
   * {
   * 	top: '1px',
   * 	right: '2px',
   * 	bottom: '3em',
   * 	left: '2px'    // a normalized value from margin shorthand
   * }
   * ```
   *
   * and reading for single style value:
   *
   * ```ts
   * styles.getNormalizedStyle( 'margin-left' );
   * ```
   *
   * Will return a `2px` string.
   *
   * **Note**: This method will return normalized values only if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
   *
   * @param property Name of CSS property
   */
  getNormalizedStyle(property) {
    return this._styles.getNormalized(property);
  }
  /**
   * Returns iterator that contains all style names.
   *
   * @param expand Expand shorthand style properties and return all equivalent style representations.
   */
  getStyleNames(expand) {
    return this._styles.getStyleNames(expand);
  }
  /**
   * Returns true if style keys are present.
   * If more then one style property is provided - returns true only when all properties are present.
   *
   * ```ts
   * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
   * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
   * ```
   */
  hasStyle(...property) {
    for (const name of property) {
      if (!this._styles.has(name)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns ancestor element that match specified pattern.
   * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
   *
   * @see module:engine/view/matcher~Matcher
   * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
   * @returns Found element or `null` if no matching ancestor was found.
   */
  findAncestor(...patterns) {
    const matcher = new Matcher(...patterns);
    let parent = this.parent;
    while (parent && !parent.is("documentFragment")) {
      if (matcher.match(parent)) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
   * Returns the custom property value for the given key.
   */
  getCustomProperty(key) {
    return this._customProperties.get(key);
  }
  /**
   * Returns an iterator which iterates over this element's custom properties.
   * Iterator provides `[ key, value ]` pairs for each stored property.
   */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
   * Returns identity string based on element's name, styles, classes and other attributes.
   * Two elements that {@link #isSimilar are similar} will have same identity string.
   * It has the following format:
   *
   * ```ts
   * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
   * ```
   *
   * For example:
   *
   * ```ts
   * const element = writer.createContainerElement( 'foo', {
   * 	banana: '10',
   * 	apple: '20',
   * 	style: 'color: red; border-color: white;',
   * 	class: 'baz'
   * } );
   *
   * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
   * element.getIdentity();
   * ```
   *
   * **Note**: Classes, styles and other attributes are sorted alphabetically.
   */
  getIdentity() {
    const classes = Array.from(this._classes).sort().join(",");
    const styles = this._styles.toString();
    const attributes = Array.from(this._attrs).map((i) => `${i[0]}="${i[1]}"`).sort().join(" ");
    return this.name + (classes == "" ? "" : ` class="${classes}"`) + (!styles ? "" : ` style="${styles}"`) + (attributes == "" ? "" : ` ${attributes}`);
  }
  /**
   * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
   * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.
   *
   * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.
   *
   * @param attributeName The name of the attribute to be checked.
   */
  shouldRenderUnsafeAttribute(attributeName) {
    return this._unsafeAttributesToRender.includes(attributeName);
  }
  /**
   * Clones provided element.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  _clone(deep = false) {
    const childrenClone = [];
    if (deep) {
      for (const child of this.getChildren()) {
        childrenClone.push(child._clone(deep));
      }
    }
    const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);
    cloned._classes = new Set(this._classes);
    cloned._styles.set(this._styles.getNormalized());
    cloned._customProperties = new Map(this._customProperties);
    cloned.getFillerOffset = this.getFillerOffset;
    cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;
    return cloned;
  }
  /**
   * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node
   * and sets the parent of these nodes to this element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#insert
   * @internal
   * @param items Items to be inserted.
   * @fires change
   * @returns Number of appended nodes.
   */
  _appendChild(items) {
    return this._insertChild(this.childCount, items);
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this element.
   *
   * @internal
   * @see module:engine/view/downcastwriter~DowncastWriter#insert
   * @param index Position where nodes should be inserted.
   * @param items Items to be inserted.
   * @fires change
   * @returns Number of inserted nodes.
   */
  _insertChild(index, items) {
    this._fireChange("children", this);
    let count2 = 0;
    const nodes = normalize(this.document, items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
      node.document = this.document;
      this._children.splice(index, 0, node);
      index++;
      count2++;
    }
    return count2;
  }
  /**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#remove
   * @internal
   * @param index Number of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @fires change
   * @returns The array of removed nodes.
   */
  _removeChildren(index, howMany = 1) {
    this._fireChange("children", this);
    for (let i = index; i < index + howMany; i++) {
      this._children[i].parent = null;
    }
    return this._children.splice(index, howMany);
  }
  /**
   * Adds or overwrite attribute with a specified key and value.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute
   * @internal
   * @param key Attribute key.
   * @param value Attribute value.
   * @fires change
   */
  _setAttribute(key, value) {
    const stringValue = String(value);
    this._fireChange("attributes", this);
    if (key == "class") {
      parseClasses(this._classes, stringValue);
    } else if (key == "style") {
      this._styles.setTo(stringValue);
    } else {
      this._attrs.set(key, stringValue);
    }
  }
  /**
   * Removes attribute from the element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute
   * @internal
   * @param key Attribute key.
   * @returns Returns true if an attribute existed and has been removed.
   * @fires change
   */
  _removeAttribute(key) {
    this._fireChange("attributes", this);
    if (key == "class") {
      if (this._classes.size > 0) {
        this._classes.clear();
        return true;
      }
      return false;
    }
    if (key == "style") {
      if (!this._styles.isEmpty) {
        this._styles.clear();
        return true;
      }
      return false;
    }
    return this._attrs.delete(key);
  }
  /**
   * Adds specified class.
   *
   * ```ts
   * element._addClass( 'foo' ); // Adds 'foo' class.
   * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
   * ```
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#addClass
   * @internal
   * @fires change
   */
  _addClass(className) {
    this._fireChange("attributes", this);
    for (const name of toArray(className)) {
      this._classes.add(name);
    }
  }
  /**
   * Removes specified class.
   *
   * ```ts
   * element._removeClass( 'foo' );  // Removes 'foo' class.
   * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
   * ```
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeClass
   * @internal
   * @fires change
   */
  _removeClass(className) {
    this._fireChange("attributes", this);
    for (const name of toArray(className)) {
      this._classes.delete(name);
    }
  }
  _setStyle(property, value) {
    this._fireChange("attributes", this);
    if (typeof property != "string") {
      this._styles.set(property);
    } else {
      this._styles.set(property, value);
    }
  }
  /**
   * Removes specified style.
   *
   * ```ts
   * element._removeStyle( 'color' );  // Removes 'color' style.
   * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle
   * @internal
   * @fires change
   */
  _removeStyle(property) {
    this._fireChange("attributes", this);
    for (const name of toArray(property)) {
      this._styles.remove(name);
    }
  }
  /**
   * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
   * @internal
   */
  _setCustomProperty(key, value) {
    this._customProperties.set(key, value);
  }
  /**
   * Removes the custom property stored under the given key.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
   * @internal
   * @returns Returns true if property was removed.
   */
  _removeCustomProperty(key) {
    return this._customProperties.delete(key);
  }
};
Element.prototype.is = function(type, name) {
  if (!name) {
    return type === "element" || type === "view:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "element" || type === "view:element");
  }
};
function parseAttributes(attrs) {
  const attrsMap = toMap(attrs);
  for (const [key, value] of attrsMap) {
    if (value === null) {
      attrsMap.delete(key);
    } else if (typeof value != "string") {
      attrsMap.set(key, String(value));
    }
  }
  return attrsMap;
}
function parseClasses(classesSet, classesString) {
  const classArray = classesString.split(/\s+/);
  classesSet.clear();
  classArray.forEach((name) => classesSet.add(name));
}
function normalize(document2, nodes) {
  if (typeof nodes == "string") {
    return [new Text(document2, nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new Text(document2, node);
    }
    if (node instanceof TextProxy) {
      return new Text(document2, node.data);
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/containerelement.js
var ContainerElement = class extends Element {
  /**
   * Creates a container element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement
   * @see module:engine/view/element~Element
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this.getFillerOffset = getFillerOffset;
  }
};
ContainerElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element");
  }
};
function getFillerOffset() {
  const children = [...this.getChildren()];
  const lastChild = children[this.childCount - 1];
  if (lastChild && lastChild.is("element", "br")) {
    return this.childCount;
  }
  for (const child of children) {
    if (!child.is("uiElement")) {
      return null;
    }
  }
  return this.childCount;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/editableelement.js
var EditableElement = class extends ObservableMixin(ContainerElement) {
  /**
   * Creates an editable element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attributes, children) {
    super(document2, name, attributes, children);
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("placeholder", void 0);
    this.bind("isReadOnly").to(document2);
    this.bind("isFocused").to(document2, "isFocused", (isFocused) => isFocused && document2.selection.editableElement == this);
    this.listenTo(document2.selection, "change", () => {
      this.isFocused = document2.isFocused && document2.selection.editableElement == this;
    });
  }
  destroy() {
    this.stopListening();
  }
};
EditableElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/rooteditableelement.js
var rootNameSymbol = Symbol("rootName");
var RootEditableElement = class extends EditableElement {
  /**
   * Creates root editable element.
   *
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   */
  constructor(document2, name) {
    super(document2, name);
    this.rootName = "main";
  }
  /**
   * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no
   * other name is set, `main` name is used.
   *
   * @readonly
   */
  get rootName() {
    return this.getCustomProperty(rootNameSymbol);
  }
  set rootName(rootName) {
    this._setCustomProperty(rootNameSymbol, rootName);
  }
  /**
   * Overrides old element name and sets new one.
   * This is needed because view roots are created before they are attached to the DOM.
   * The name of the root element is temporary at this stage. It has to be changed when the
   * view root element is attached to the DOM element.
   *
   * @internal
   * @param name The new name of element.
   */
  set _name(name) {
    this.name = name;
  }
};
RootEditableElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rootElement" || type === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "rootElement" || type === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js
var TreeWalker = class {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @param options Object with configuration.
   */
  constructor(options = {}) {
    if (!options.boundaries && !options.startPosition) {
      throw new CKEditorError("view-tree-walker-no-start-position", null);
    }
    if (options.direction && options.direction != "forward" && options.direction != "backward") {
      throw new CKEditorError("view-tree-walker-unknown-direction", options.startPosition, { direction: options.direction });
    }
    this.boundaries = options.boundaries || null;
    if (options.startPosition) {
      this._position = Position._createAt(options.startPosition);
    } else {
      this._position = Position._createAt(options.boundaries[options.direction == "backward" ? "end" : "start"]);
    }
    this.direction = options.direction || "forward";
    this.singleCharacters = !!options.singleCharacters;
    this.shallow = !!options.shallow;
    this.ignoreElementEnd = !!options.ignoreElementEnd;
    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
   * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
   */
  get position() {
    return this._position;
  }
  /**
   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
   *
   * For example:
   *
   * ```ts
   * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
   * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
   * walker.skip( value => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   */
  skip(skip) {
    let nextResult;
    let prevPosition;
    do {
      prevPosition = this.position;
      nextResult = this.next();
    } while (!nextResult.done && skip(nextResult.value));
    if (!nextResult.done) {
      this._position = prevPosition;
    }
  }
  /**
   * Gets the next tree walker's value.
   *
   * @returns Object implementing iterator interface, returning
   * information about taken step.
   */
  next() {
    if (this.direction == "forward") {
      return this._next();
    } else {
      return this._previous();
    }
  }
  /**
   * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
   */
  _next() {
    let position = this.position.clone();
    const previousPosition = this.position;
    const parent = position.parent;
    if (parent.parent === null && position.offset === parent.childCount) {
      return { done: true, value: void 0 };
    }
    if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
      return { done: true, value: void 0 };
    }
    let node;
    if (parent instanceof Text) {
      if (position.isAtEnd) {
        this._position = Position._createAfter(parent);
        return this._next();
      }
      node = parent.data[position.offset];
    } else {
      node = parent.getChild(position.offset);
    }
    if (node instanceof Element) {
      if (!this.shallow) {
        position = new Position(node, 0);
      } else {
        if (this.boundaries && this.boundaries.end.isBefore(position)) {
          return { done: true, value: void 0 };
        }
        position.offset++;
      }
      this._position = position;
      return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
    }
    if (node instanceof Text) {
      if (this.singleCharacters) {
        position = new Position(node, 0);
        this._position = position;
        return this._next();
      }
      let charactersCount = node.data.length;
      let item;
      if (node == this._boundaryEndParent) {
        charactersCount = this.boundaries.end.offset;
        item = new TextProxy(node, 0, charactersCount);
        position = Position._createAfter(item);
      } else {
        item = new TextProxy(node, 0, node.data.length);
        position.offset++;
      }
      this._position = position;
      return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    if (typeof node == "string") {
      let textLength;
      if (this.singleCharacters) {
        textLength = 1;
      } else {
        const endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;
        textLength = endOffset - position.offset;
      }
      const textProxy = new TextProxy(parent, position.offset, textLength);
      position.offset += textLength;
      this._position = position;
      return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
    }
    position = Position._createAfter(parent);
    this._position = position;
    if (this.ignoreElementEnd) {
      return this._next();
    }
    return this._formatReturnValue("elementEnd", parent, previousPosition, position);
  }
  /**
   * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
   */
  _previous() {
    let position = this.position.clone();
    const previousPosition = this.position;
    const parent = position.parent;
    if (parent.parent === null && position.offset === 0) {
      return { done: true, value: void 0 };
    }
    if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
      return { done: true, value: void 0 };
    }
    let node;
    if (parent instanceof Text) {
      if (position.isAtStart) {
        this._position = Position._createBefore(parent);
        return this._previous();
      }
      node = parent.data[position.offset - 1];
    } else {
      node = parent.getChild(position.offset - 1);
    }
    if (node instanceof Element) {
      if (this.shallow) {
        position.offset--;
        this._position = position;
        return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
      }
      position = new Position(node, node.childCount);
      this._position = position;
      if (this.ignoreElementEnd) {
        return this._previous();
      }
      return this._formatReturnValue("elementEnd", node, previousPosition, position);
    }
    if (node instanceof Text) {
      if (this.singleCharacters) {
        position = new Position(node, node.data.length);
        this._position = position;
        return this._previous();
      }
      let charactersCount = node.data.length;
      let item;
      if (node == this._boundaryStartParent) {
        const offset = this.boundaries.start.offset;
        item = new TextProxy(node, offset, node.data.length - offset);
        charactersCount = item.data.length;
        position = Position._createBefore(item);
      } else {
        item = new TextProxy(node, 0, node.data.length);
        position.offset--;
      }
      this._position = position;
      return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    if (typeof node == "string") {
      let textLength;
      if (!this.singleCharacters) {
        const startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;
        textLength = position.offset - startOffset;
      } else {
        textLength = 1;
      }
      position.offset -= textLength;
      const textProxy = new TextProxy(parent, position.offset, textLength);
      this._position = position;
      return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
    }
    position = Position._createBefore(parent);
    this._position = position;
    return this._formatReturnValue("elementStart", parent, previousPosition, position, 1);
  }
  /**
   * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
   *
   * @param type Type of step.
   * @param item Item between old and new position.
   * @param previousPosition Previous position of iterator.
   * @param nextPosition Next position of iterator.
   * @param length Length of the item.
   */
  _formatReturnValue(type, item, previousPosition, nextPosition, length) {
    if (item instanceof TextProxy) {
      if (item.offsetInText + item.data.length == item.textNode.data.length) {
        if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
          nextPosition = Position._createAfter(item.textNode);
          this._position = nextPosition;
        } else {
          previousPosition = Position._createAfter(item.textNode);
        }
      }
      if (item.offsetInText === 0) {
        if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
          nextPosition = Position._createBefore(item.textNode);
          this._position = nextPosition;
        } else {
          previousPosition = Position._createBefore(item.textNode);
        }
      }
    }
    return {
      done: false,
      value: {
        type,
        item,
        previousPosition,
        nextPosition,
        length
      }
    };
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/position.js
var Position = class _Position extends TypeCheckable {
  /**
   * Creates a position.
   *
   * @param parent Position parent.
   * @param offset Position offset.
   */
  constructor(parent, offset) {
    super();
    this.parent = parent;
    this.offset = offset;
  }
  /**
   * Node directly after the position. Equals `null` when there is no node after position or position is located
   * inside text node.
   */
  get nodeAfter() {
    if (this.parent.is("$text")) {
      return null;
    }
    return this.parent.getChild(this.offset) || null;
  }
  /**
   * Node directly before the position. Equals `null` when there is no node before position or position is located
   * inside text node.
   */
  get nodeBefore() {
    if (this.parent.is("$text")) {
      return null;
    }
    return this.parent.getChild(this.offset - 1) || null;
  }
  /**
   * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
   */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
   * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
   */
  get isAtEnd() {
    const endOffset = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
    return this.offset === endOffset;
  }
  /**
   * Position's root, that is the root of the position's parent element.
   */
  get root() {
    return this.parent.root;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
   * position is not inside an editable element.
   */
  get editableElement() {
    let editable = this.parent;
    while (!(editable instanceof EditableElement)) {
      if (editable.parent) {
        editable = editable.parent;
      } else {
        return null;
      }
    }
    return editable;
  }
  /**
   * Returns a new instance of Position with offset incremented by `shift` value.
   *
   * @param shift How position offset should get changed. Accepts negative values.
   * @returns Shifted position.
   */
  getShiftedBy(shift) {
    const shifted = _Position._createAt(this);
    const offset = shifted.offset + shift;
    shifted.offset = offset < 0 ? 0 : offset;
    return shifted;
  }
  /**
   * Gets the farthest position which matches the callback using
   * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
   *
   * For example:
   *
   * ```ts
   * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
   * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
   * getLastMatchingPosition( value => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   * @returns The position after the last item which matches the `skip` callback test.
   */
  getLastMatchingPosition(skip, options = {}) {
    options.startPosition = this;
    const treeWalker = new TreeWalker(options);
    treeWalker.skip(skip);
    return treeWalker.position;
  }
  /**
   * Returns ancestors array of this position, that is this position's parent and it's ancestors.
   *
   * @returns Array with ancestors.
   */
  getAncestors() {
    if (this.parent.is("documentFragment")) {
      return [this.parent];
    } else {
      return this.parent.getAncestors({ includeSelf: true });
    }
  }
  /**
   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of both positions.
   */
  getCommonAncestor(position) {
    const ancestorsA = this.getAncestors();
    const ancestorsB = position.getAncestors();
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
   * Checks whether this position equals given position.
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions are same.
   */
  isEqual(otherPosition) {
    return this.parent == otherPosition.parent && this.offset == otherPosition.offset;
  }
  /**
   * Checks whether this position is located before given position. When method returns `false` it does not mean that
   * this position is after give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see module:engine/view/position~Position#isAfter
   * @see module:engine/view/position~Position#compareWith
   * @param otherPosition Position to compare with.
   * @returns Returns `true` if this position is before given position.
   */
  isBefore(otherPosition) {
    return this.compareWith(otherPosition) == "before";
  }
  /**
   * Checks whether this position is located after given position. When method returns `false` it does not mean that
   * this position is before give one. Two positions may be located inside separate roots and in that situation this
   * method will still return `false`.
   *
   * @see module:engine/view/position~Position#isBefore
   * @see module:engine/view/position~Position#compareWith
   * @param otherPosition Position to compare with.
   * @returns Returns `true` if this position is after given position.
   */
  isAfter(otherPosition) {
    return this.compareWith(otherPosition) == "after";
  }
  /**
   * Checks whether this position is before, after or in same position that other position. Two positions may be also
   * different when they are located in separate roots.
   *
   * @param otherPosition Position to compare with.
   */
  compareWith(otherPosition) {
    if (this.root !== otherPosition.root) {
      return "different";
    }
    if (this.isEqual(otherPosition)) {
      return "same";
    }
    const thisPath = this.parent.is("node") ? this.parent.getPath() : [];
    const otherPath = otherPosition.parent.is("node") ? otherPosition.parent.getPath() : [];
    thisPath.push(this.offset);
    otherPath.push(otherPosition.offset);
    const result = compareArrays(thisPath, otherPath);
    switch (result) {
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return thisPath[result] < otherPath[result] ? "before" : "after";
    }
  }
  /**
   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}
   */
  getWalker(options = {}) {
    options.startPosition = this;
    return new TreeWalker(options);
  }
  /**
   * Clones this position.
   */
  clone() {
    return new _Position(this.parent, this.offset);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link module:engine/view/position~Position._createBefore},
   * * {@link module:engine/view/position~Position._createAfter}.
   *
   * @internal
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  static _createAt(itemOrPosition, offset) {
    if (itemOrPosition instanceof _Position) {
      return new this(itemOrPosition.parent, itemOrPosition.offset);
    } else {
      const node = itemOrPosition;
      if (offset == "end") {
        offset = node.is("$text") ? node.data.length : node.childCount;
      } else if (offset == "before") {
        return this._createBefore(node);
      } else if (offset == "after") {
        return this._createAfter(node);
      } else if (offset !== 0 && !offset) {
        throw new CKEditorError("view-createpositionat-offset-required", node);
      }
      return new _Position(node, offset);
    }
  }
  /**
   * Creates a new position after given view item.
   *
   * @internal
   * @param item View item after which the position should be located.
   */
  static _createAfter(item) {
    if (item.is("$textProxy")) {
      return new _Position(item.textNode, item.offsetInText + item.data.length);
    }
    if (!item.parent) {
      throw new CKEditorError("view-position-after-root", item, { root: item });
    }
    return new _Position(item.parent, item.index + 1);
  }
  /**
   * Creates a new position before given view item.
   *
   * @internal
   * @param item View item before which the position should be located.
   */
  static _createBefore(item) {
    if (item.is("$textProxy")) {
      return new _Position(item.textNode, item.offsetInText);
    }
    if (!item.parent) {
      throw new CKEditorError("view-position-before-root", item, { root: item });
    }
    return new _Position(item.parent, item.index);
  }
};
Position.prototype.is = function(type) {
  return type === "position" || type === "view:position";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/range.js
var Range = class _Range extends TypeCheckable {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at the `start` position.
   */
  constructor(start, end = null) {
    super();
    this.start = start.clone();
    this.end = end ? end.clone() : start.clone();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/view/position~Position positions},
   * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
   * `ignoreElementEnd` option
   * set to `true`.
   */
  *[Symbol.iterator]() {
    yield* new TreeWalker({ boundaries: this, ignoreElementEnd: true });
  }
  /**
   * Returns whether the range is collapsed, that is it start and end positions are equal.
   */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
   * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
   * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
   */
  get isFlat() {
    return this.start.parent === this.end.parent;
  }
  /**
   * Range root element.
   */
  get root() {
    return this.start.root;
  }
  /**
   * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
   * and at the end).
   *
   * For example:
   *
   * ```html
   * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
   * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
   * ```
   *
   * Note that in the sample above:
   *
   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
   *
   * @returns Enlarged range.
   */
  getEnlarged() {
    let start = this.start.getLastMatchingPosition(enlargeTrimSkip, { direction: "backward" });
    let end = this.end.getLastMatchingPosition(enlargeTrimSkip);
    if (start.parent.is("$text") && start.isAtStart) {
      start = Position._createBefore(start.parent);
    }
    if (end.parent.is("$text") && end.isAtEnd) {
      end = Position._createAfter(end.parent);
    }
    return new _Range(start, end);
  }
  /**
   * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
   * and at the end).
   *
   * For example:
   *
   * ```html
   * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
   * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
   * ```
   *
   * Note that in the sample above:
   *
   * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
   * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
   * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
   *
   * @returns Shrunk range.
   */
  getTrimmed() {
    let start = this.start.getLastMatchingPosition(enlargeTrimSkip);
    if (start.isAfter(this.end) || start.isEqual(this.end)) {
      return new _Range(start, start);
    }
    let end = this.end.getLastMatchingPosition(enlargeTrimSkip, { direction: "backward" });
    const nodeAfterStart = start.nodeAfter;
    const nodeBeforeEnd = end.nodeBefore;
    if (nodeAfterStart && nodeAfterStart.is("$text")) {
      start = new Position(nodeAfterStart, 0);
    }
    if (nodeBeforeEnd && nodeBeforeEnd.is("$text")) {
      end = new Position(nodeBeforeEnd, nodeBeforeEnd.data.length);
    }
    return new _Range(start, end);
  }
  /**
   * Two ranges are equal if their start and end positions are equal.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges are equal, `false` otherwise
   */
  isEqual(otherRange) {
    return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
  }
  /**
   * Checks whether this range contains given {@link module:engine/view/position~Position position}.
   *
   * @param position Position to check.
   * @returns `true` if given {@link module:engine/view/position~Position position} is contained in this range, `false` otherwise.
   */
  containsPosition(position) {
    return position.isAfter(this.start) && position.isBefore(this.end);
  }
  /**
   * Checks whether this range contains given {@link module:engine/view/range~Range range}.
   *
   * @param otherRange Range to check.
   * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
   * @returns `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
   * otherwise.
   */
  containsRange(otherRange, loose = false) {
    if (otherRange.isCollapsed) {
      loose = false;
    }
    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
    return containsStart && containsEnd;
  }
  /**
   * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
   * {@link module:engine/view/range~Range range}.
   * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
   *
   * Examples:
   *
   * ```ts
   * let foo = downcastWriter.createText( 'foo' );
   * let img = downcastWriter.createContainerElement( 'img' );
   * let bar = downcastWriter.createText( 'bar' );
   * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
   *
   * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
   * let otherRange = view.createRange( // "oo", img, "ba" are in range.
   * 	view.createPositionAt( foo, 1 ),
   * 	view.createPositionAt( bar, 2 )
   * );
   * let transformed = range.getDifference( otherRange );
   * // transformed array has no ranges because `otherRange` contains `range`
   *
   * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
   * transformed = range.getDifference( otherRange );
   * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
   *
   * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
   * transformed = range.getDifference( otherRange );
   * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
   * ```
   *
   * @param otherRange Range to differentiate against.
   * @returns The difference between ranges.
   */
  getDifference(otherRange) {
    const ranges = [];
    if (this.isIntersecting(otherRange)) {
      if (this.containsPosition(otherRange.start)) {
        ranges.push(new _Range(this.start, otherRange.start));
      }
      if (this.containsPosition(otherRange.end)) {
        ranges.push(new _Range(otherRange.end, this.end));
      }
    } else {
      ranges.push(this.clone());
    }
    return ranges;
  }
  /**
   * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let foo = downcastWriter.createText( 'foo' );
   * let img = downcastWriter.createContainerElement( 'img' );
   * let bar = downcastWriter.createText( 'bar' );
   * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
   *
   * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
   * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
   * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
   *
   * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
   * transformed = range.getIntersection( otherRange ); // null - no common part.
   * ```
   *
   * @param otherRange Range to check for intersection.
   * @returns A common part of given ranges or `null` if ranges have no common part.
   */
  getIntersection(otherRange) {
    if (this.isIntersecting(otherRange)) {
      let commonRangeStart = this.start;
      let commonRangeEnd = this.end;
      if (this.containsPosition(otherRange.start)) {
        commonRangeStart = otherRange.start;
      }
      if (this.containsPosition(otherRange.end)) {
        commonRangeEnd = otherRange.end;
      }
      return new _Range(commonRangeStart, commonRangeEnd);
    }
    return null;
  }
  /**
   * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  getWalker(options = {}) {
    options.boundaries = this;
    return new TreeWalker(options);
  }
  /**
   * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
   * which is a common ancestor of range's both ends (in which the entire range is contained).
   */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
   * Returns an {@link module:engine/view/element~Element Element} contained by the range.
   * The element will be returned when it is the **only** node within the range and **fullycontained**
   * at the same time.
   */
  getContainedElement() {
    if (this.isCollapsed) {
      return null;
    }
    let nodeAfterStart = this.start.nodeAfter;
    let nodeBeforeEnd = this.end.nodeBefore;
    if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
      nodeAfterStart = this.start.parent.nextSibling;
    }
    if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
      nodeBeforeEnd = this.end.parent.previousSibling;
    }
    if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
      return nodeAfterStart;
    }
    return null;
  }
  /**
   * Clones this range.
   */
  clone() {
    return new _Range(this.start, this.end);
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them.
   *
   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link module:engine/view/item~Item items},
   * not {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  *getItems(options = {}) {
    options.boundaries = this;
    options.ignoreElementEnd = true;
    const treeWalker = new TreeWalker(options);
    for (const value of treeWalker) {
      yield value.item;
    }
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
   */
  *getPositions(options = {}) {
    options.boundaries = this;
    const treeWalker = new TreeWalker(options);
    yield treeWalker.position;
    for (const value of treeWalker) {
      yield value.nextPosition;
    }
  }
  /**
   * Checks and returns whether this range intersects with the given range.
   *
   * @param otherRange Range to compare with.
   * @returns True if ranges intersect.
   */
  isIntersecting(otherRange) {
    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
  }
  /**
   * Creates a range from the given parents and offsets.
   *
   * @internal
   * @param startElement Start position parent element.
   * @param startOffset Start position offset.
   * @param endElement End position parent element.
   * @param endOffset End position offset.
   * @returns Created range.
   */
  static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
    return new this(new Position(startElement, startOffset), new Position(endElement, endOffset));
  }
  /**
   * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @internal
   * @param position Beginning of the range.
   * @param shift How long the range should be.
   */
  static _createFromPositionAndShift(position, shift) {
    const start = position;
    const end = position.getShiftedBy(shift);
    return shift > 0 ? new this(start, end) : new this(end, start);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @internal
   * @param element Element which is a parent for the range.
   */
  static _createIn(element) {
    return this._createFromParentsAndOffsets(element, 0, element, element.childCount);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   *
   * @internal
   */
  static _createOn(item) {
    const size = item.is("$textProxy") ? item.offsetSize : 1;
    return this._createFromPositionAndShift(Position._createBefore(item), size);
  }
};
Range.prototype.is = function(type) {
  return type === "range" || type === "view:range";
};
function enlargeTrimSkip(value) {
  if (value.item.is("attributeElement") || value.item.is("uiElement")) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/selection.js
var Selection = class _Selection extends EmitterMixin(TypeCheckable) {
  /**
   * Creates new selection instance.
   *
   * **Note**: The selection constructor is available as a factory method:
   *
   * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
   * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
   *
   * ```ts
   * // Creates empty selection without ranges.
   * const selection = writer.createSelection();
   *
   * // Creates selection at the given range.
   * const range = writer.createRange( start, end );
   * const selection = writer.createSelection( range );
   *
   * // Creates selection at the given ranges
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * const selection = writer.createSelection( ranges );
   *
   * // Creates selection from the other selection.
   * const otherSelection = writer.createSelection();
   * const selection = writer.createSelection( otherSelection );
   *
   * // Creates selection from the document selection.
   * const selection = writer.createSelection( editor.editing.view.document.selection );
   *
   * // Creates selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * const selection = writer.createSelection( position );
   *
   * // Creates collapsed selection at the position of given item and offset.
   * const paragraph = writer.createContainerElement( 'paragraph' );
   * const selection = writer.createSelection( paragraph, offset );
   *
   * // Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
   * // first child of that element and ends after the last child of that element.
   * const selection = writer.createSelection( paragraph, 'in' );
   *
   * // Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
   * // just after the item.
   * const selection = writer.createSelection( paragraph, 'on' );
   * ```
   *
   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Creates backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @internal
   */
  constructor(...args) {
    super();
    this._ranges = [];
    this._lastRangeBackward = false;
    this._isFake = false;
    this._fakeSelectionLabel = "";
    if (args.length) {
      this.setTo(...args);
    }
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #setTo
   */
  get isFake() {
    return this._isFake;
  }
  /**
   * Returns fake selection label.
   *
   * @see #setTo
   */
  get fakeSelectionLabel() {
    return this._fakeSelectionLabel;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link #focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    if (!this._ranges.length) {
      return null;
    }
    const range = this._ranges[this._ranges.length - 1];
    const anchor = this._lastRangeBackward ? range.end : range.start;
    return anchor.clone();
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see #anchor
   */
  get focus() {
    if (!this._ranges.length) {
      return null;
    }
    const range = this._ranges[this._ranges.length - 1];
    const focus = this._lastRangeBackward ? range.start : range.end;
    return focus.clone();
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this.rangeCount === 1 && this._ranges[0].isCollapsed;
  }
  /**
   * Returns number of ranges in selection.
   */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
   * Specifies whether the {@link #focus} precedes {@link #anchor}.
   */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   */
  get editableElement() {
    if (this.anchor) {
      return this.anchor.editableElement;
    }
    return null;
  }
  /**
   * Returns an iterable that contains copies of all ranges added to the selection.
   */
  *getRanges() {
    for (const range of this._ranges) {
      yield range.clone();
    }
  }
  /**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   */
  getFirstRange() {
    let first2 = null;
    for (const range of this._ranges) {
      if (!first2 || range.start.isBefore(first2.start)) {
        first2 = range;
      }
    }
    return first2 ? first2.clone() : null;
  }
  /**
   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   */
  getLastRange() {
    let last = null;
    for (const range of this._ranges) {
      if (!last || range.end.isAfter(last.end)) {
        last = range;
      }
    }
    return last ? last.clone() : null;
  }
  /**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getFirstPosition() {
    const firstRange = this.getFirstRange();
    return firstRange ? firstRange.start.clone() : null;
  }
  /**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getLastPosition() {
    const lastRange = this.getLastRange();
    return lastRange ? lastRange.end.clone() : null;
  }
  /**
   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
   * same number of ranges and all ranges from one selection equal to a range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(otherSelection) {
    if (this.isFake != otherSelection.isFake) {
      return false;
    }
    if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
      return false;
    }
    if (this.rangeCount != otherSelection.rangeCount) {
      return false;
    } else if (this.rangeCount === 0) {
      return true;
    }
    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
      return false;
    }
    for (const thisRange of this._ranges) {
      let found = false;
      for (const otherRange of otherSelection._ranges) {
        if (thisRange.isEqual(otherRange)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
   * equal to any trimmed range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are similar, `false` otherwise.
   */
  isSimilar(otherSelection) {
    if (this.isBackward != otherSelection.isBackward) {
      return false;
    }
    const numOfRangesA = count(this.getRanges());
    const numOfRangesB = count(otherSelection.getRanges());
    if (numOfRangesA != numOfRangesB) {
      return false;
    }
    if (numOfRangesA == 0) {
      return true;
    }
    for (let rangeA of this.getRanges()) {
      rangeA = rangeA.getTrimmed();
      let found = false;
      for (let rangeB of otherSelection.getRanges()) {
        rangeB = rangeB.getTrimmed();
        if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    if (this.rangeCount !== 1) {
      return null;
    }
    return this.getFirstRange().getContainedElement();
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/view/selection~Selectable selectable}.
   *
   * ```ts
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * selection.setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * selection.setTo( range );
   *
   * // Sets selection to the other selection.
   * const otherSelection = writer.createSelection();
   * selection.setTo( otherSelection );
   *
   * // Sets selection to contents of DocumentSelection.
   * selection.setTo( editor.editing.view.document.selection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionAt( root, path );
   * selection.setTo( position );
   *
   * // Sets collapsed selection at the position of given item and offset.
   * selection.setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * selection.setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * selection.setTo( paragraph, 'on' );
   *
   * // Clears selection. Removes all ranges.
   * selection.setTo( null );
   * ```
   *
   * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Sets selection as backward.
   * selection.setTo( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * selection.setTo( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @fires change
   */
  setTo(...args) {
    let [selectable, placeOrOffset, options] = args;
    if (typeof placeOrOffset == "object") {
      options = placeOrOffset;
      placeOrOffset = void 0;
    }
    if (selectable === null) {
      this._setRanges([]);
      this._setFakeOptions(options);
    } else if (selectable instanceof _Selection || selectable instanceof DocumentSelection) {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
      this._setFakeOptions({ fake: selectable.isFake, label: selectable.fakeSelectionLabel });
    } else if (selectable instanceof Range) {
      this._setRanges([selectable], options && options.backward);
      this._setFakeOptions(options);
    } else if (selectable instanceof Position) {
      this._setRanges([new Range(selectable)]);
      this._setFakeOptions(options);
    } else if (selectable instanceof Node2) {
      const backward = !!options && !!options.backward;
      let range;
      if (placeOrOffset === void 0) {
        throw new CKEditorError("view-selection-setto-required-second-parameter", this);
      } else if (placeOrOffset == "in") {
        range = Range._createIn(selectable);
      } else if (placeOrOffset == "on") {
        range = Range._createOn(selectable);
      } else {
        range = new Range(Position._createAt(selectable, placeOrOffset));
      }
      this._setRanges([range], backward);
      this._setFakeOptions(options);
    } else if (isIterable(selectable)) {
      this._setRanges(selectable, options && options.backward);
      this._setFakeOptions(options);
    } else {
      throw new CKEditorError("view-selection-setto-not-selectable", this);
    }
    this.fire("change");
  }
  /**
   * Moves {@link #focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @fires change
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  setFocus(itemOrPosition, offset) {
    if (this.anchor === null) {
      throw new CKEditorError("view-selection-setfocus-no-ranges", this);
    }
    const newFocus = Position._createAt(itemOrPosition, offset);
    if (newFocus.compareWith(this.focus) == "same") {
      return;
    }
    const anchor = this.anchor;
    this._ranges.pop();
    if (newFocus.compareWith(anchor) == "before") {
      this._addRange(new Range(newFocus, anchor), true);
    } else {
      this._addRange(new Range(anchor, newFocus));
    }
    this.fire("change");
  }
  /**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
   * Accepts a flag describing in which way the selection is made.
   *
   * @param newRanges Iterable object of ranges to set.
   * @param isLastBackward Flag describing if last added range was selected forward - from start to end
   * (`false`) or backward - from end to start (`true`). Defaults to `false`.
   */
  _setRanges(newRanges, isLastBackward = false) {
    newRanges = Array.from(newRanges);
    this._ranges = [];
    for (const range of newRanges) {
      this._addRange(range);
    }
    this._lastRangeBackward = !!isLastBackward;
  }
  /**
   * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
   * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
   * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
   * properly handled by screen readers).
   */
  _setFakeOptions(options = {}) {
    this._isFake = !!options.fake;
    this._fakeSelectionLabel = options.fake ? options.label || "" : "";
  }
  /**
   * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
   * selection instance and you can safely operate on it.
   *
   * Accepts a flag describing in which way the selection is made - passed range might be selected from
   * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
   * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
   * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in Selection instance.
   */
  _addRange(range, isBackward = false) {
    if (!(range instanceof Range)) {
      throw new CKEditorError("view-selection-add-range-not-range", this);
    }
    this._pushRange(range);
    this._lastRangeBackward = !!isBackward;
  }
  /**
   * Adds range to selection - creates copy of given range so it can be safely used and modified.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
   * with ranges already stored in selection instance.
   */
  _pushRange(range) {
    for (const storedRange of this._ranges) {
      if (range.isIntersecting(storedRange)) {
        throw new CKEditorError("view-selection-range-intersects", this, { addedRange: range, intersectingRange: storedRange });
      }
    }
    this._ranges.push(new Range(range.start, range.end));
  }
};
Selection.prototype.is = function(type) {
  return type === "selection" || type === "view:selection";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/documentselection.js
var DocumentSelection = class extends EmitterMixin(TypeCheckable) {
  constructor(...args) {
    super();
    this._selection = new Selection();
    this._selection.delegate("change").to(this);
    if (args.length) {
      this._selection.setTo(...args);
    }
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #_setTo
   */
  get isFake() {
    return this._selection.isFake;
  }
  /**
   * Returns fake selection label.
   *
   * @see #_setTo
   */
  get fakeSelectionLabel() {
    return this._selection.fakeSelectionLabel;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the selection starts. Together with
   * {@link #focus focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
   * It may be a bit unintuitive when there are multiple ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    return this._selection.anchor;
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * @see #anchor
   */
  get focus() {
    return this._selection.focus;
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
   * Returns number of ranges in selection.
   */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
   * Specifies whether the {@link #focus} precedes {@link #anchor}.
   */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
   * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
   * if the selection is not inside an editable element.
   */
  get editableElement() {
    return this._selection.editableElement;
  }
  /**
   * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.
   *
   * @internal
   */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
   * Returns an iterable that contains copies of all ranges added to the selection.
   */
  *getRanges() {
    yield* this._selection.getRanges();
  }
  /**
   * Returns copy of the first range in the selection. First range is the one which
   * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
   * position of all other ranges (not to confuse with the first range added to the selection).
   * Returns `null` if no ranges are added to selection.
   */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
   * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
   * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
   * with the last range added to the selection). Returns `null` if no ranges are added to selection.
   */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
   * Returns copy of the first position in the selection. First position is the position that
   * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
   * Returns copy of the last position in the selection. Last position is the position that
   * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
   * Returns `null` if no ranges are added to selection.
   */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
   * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
   * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
   * same number of ranges and all ranges from one selection equal to a range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(otherSelection) {
    return this._selection.isEqual(otherSelection);
  }
  /**
   * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
   * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
   * equal to any trimmed range from other selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are similar, `false` otherwise.
   */
  isSimilar(otherSelection) {
    return this._selection.isSimilar(otherSelection);
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/view/selection~Selectable selectable}.
   *
   * ```ts
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * documentSelection._setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
   * documentSelection._setTo( range );
   *
   * // Sets selection to the other selection.
   * const otherSelection = writer.createSelection();
   * documentSelection._setTo( otherSelection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionAt( root, offset );
   * documentSelection._setTo( position );
   *
   * // Sets collapsed selection at the position of given item and offset.
   * documentSelection._setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * documentSelection._setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * documentSelection._setTo( paragraph, 'on' );
   *
   * // Clears selection. Removes all ranges.
   * documentSelection._setTo( null );
   * ```
   *
   * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   * ```ts
   * // Sets selection as backward.
   * documentSelection._setTo( range, { backward: true } );
   * ```
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   * ```ts
   * // Creates fake selection with label.
   * documentSelection._setTo( range, { fake: true, label: 'foo' } );
   * ```
   *
   * @internal
   * @fires change
   */
  _setTo(...args) {
    this._selection.setTo(...args);
  }
  /**
   * Moves {@link #focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @internal
   * @fires change
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  _setFocus(itemOrPosition, offset) {
    this._selection.setFocus(itemOrPosition, offset);
  }
};
DocumentSelection.prototype.is = function(type) {
  return type === "selection" || type == "documentSelection" || type == "view:selection" || type == "view:documentSelection";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/bubblingeventinfo.js
var BubblingEventInfo = class extends EventInfo {
  /**
   * @param source The emitter.
   * @param name The event name.
   * @param startRange The view range that the bubbling should start from.
   */
  constructor(source, name, startRange) {
    super(source, name);
    this.startRange = startRange;
    this._eventPhase = "none";
    this._currentTarget = null;
  }
  /**
   * The current event phase.
   */
  get eventPhase() {
    return this._eventPhase;
  }
  /**
   * The current bubbling target.
   */
  get currentTarget() {
    return this._currentTarget;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/bubblingemittermixin.js
var contextsSymbol = Symbol("bubbling contexts");
function BubblingEmitterMixin(base) {
  class Mixin extends base {
    fire(eventOrInfo, ...eventArgs) {
      try {
        const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
        const eventContexts = getBubblingContexts(this);
        if (!eventContexts.size) {
          return;
        }
        updateEventInfo(eventInfo, "capturing", this);
        if (fireListenerFor(eventContexts, "$capture", eventInfo, ...eventArgs)) {
          return eventInfo.return;
        }
        const startRange = eventInfo.startRange || this.selection.getFirstRange();
        const selectedElement = startRange ? startRange.getContainedElement() : null;
        const isCustomContext = selectedElement ? Boolean(getCustomContext(eventContexts, selectedElement)) : false;
        let node = selectedElement || getDeeperRangeParent(startRange);
        updateEventInfo(eventInfo, "atTarget", node);
        if (!isCustomContext) {
          if (fireListenerFor(eventContexts, "$text", eventInfo, ...eventArgs)) {
            return eventInfo.return;
          }
          updateEventInfo(eventInfo, "bubbling", node);
        }
        while (node) {
          if (node.is("rootElement")) {
            if (fireListenerFor(eventContexts, "$root", eventInfo, ...eventArgs)) {
              return eventInfo.return;
            }
          } else if (node.is("element")) {
            if (fireListenerFor(eventContexts, node.name, eventInfo, ...eventArgs)) {
              return eventInfo.return;
            }
          }
          if (fireListenerFor(eventContexts, node, eventInfo, ...eventArgs)) {
            return eventInfo.return;
          }
          node = node.parent;
          updateEventInfo(eventInfo, "bubbling", node);
        }
        updateEventInfo(eventInfo, "bubbling", this);
        fireListenerFor(eventContexts, "$document", eventInfo, ...eventArgs);
        return eventInfo.return;
      } catch (err) {
        CKEditorError.rethrowUnexpectedError(err, this);
      }
    }
    _addEventListener(event, callback, options) {
      const contexts = toArray(options.context || "$document");
      const eventContexts = getBubblingContexts(this);
      for (const context of contexts) {
        let emitter = eventContexts.get(context);
        if (!emitter) {
          emitter = new (EmitterMixin())();
          eventContexts.set(context, emitter);
        }
        this.listenTo(emitter, event, callback, options);
      }
    }
    _removeEventListener(event, callback) {
      const eventContexts = getBubblingContexts(this);
      for (const emitter of eventContexts.values()) {
        this.stopListening(emitter, event, callback);
      }
    }
  }
  return Mixin;
}
{
  const mixin = BubblingEmitterMixin(Object);
  ["fire", "_addEventListener", "_removeEventListener"].forEach((key) => {
    BubblingEmitterMixin[key] = mixin.prototype[key];
  });
}
function updateEventInfo(eventInfo, eventPhase, currentTarget) {
  if (eventInfo instanceof BubblingEventInfo) {
    eventInfo._eventPhase = eventPhase;
    eventInfo._currentTarget = currentTarget;
  }
}
function fireListenerFor(eventContexts, context, eventInfo, ...eventArgs) {
  const emitter = typeof context == "string" ? eventContexts.get(context) : getCustomContext(eventContexts, context);
  if (!emitter) {
    return false;
  }
  emitter.fire(eventInfo, ...eventArgs);
  return eventInfo.stop.called;
}
function getCustomContext(eventContexts, node) {
  for (const [context, emitter] of eventContexts) {
    if (typeof context == "function" && context(node)) {
      return emitter;
    }
  }
  return null;
}
function getBubblingContexts(source) {
  if (!source[contextsSymbol]) {
    source[contextsSymbol] = /* @__PURE__ */ new Map();
  }
  return source[contextsSymbol];
}
function getDeeperRangeParent(range) {
  if (!range) {
    return null;
  }
  const startParent = range.start.parent;
  const endParent = range.end.parent;
  const startPath = startParent.getPath();
  const endPath = endParent.getPath();
  return startPath.length > endPath.length ? startParent : endParent;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/document.js
var Document = class extends BubblingEmitterMixin(ObservableMixin()) {
  /**
   * Creates a Document instance.
   *
   * @param stylesProcessor The styles processor instance.
   */
  constructor(stylesProcessor) {
    super();
    this._postFixers = /* @__PURE__ */ new Set();
    this.selection = new DocumentSelection();
    this.roots = new Collection({ idProperty: "rootName" });
    this.stylesProcessor = stylesProcessor;
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("isSelecting", false);
    this.set("isComposing", false);
  }
  /**
   * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not
   * specific "main" root is returned.
   *
   * @param name Name of the root.
   * @returns The view root element with the specified name or null when there is no root of given name.
   */
  getRoot(name = "main") {
    return this.roots.get(name);
  }
  /**
   * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
   * to the DOM.
   *
   * Post-fixers are executed right after all changes from the outermost change block were applied but
   * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made
   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
   * not be fixed in the new document tree state.
   *
   * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
   * changes executed in a view post-fixer should not break model-view mapping.
   *
   * The types of changes which should be safe:
   *
   * * adding or removing attribute from elements,
   * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},
   * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be
   * re-converted}.
   *
   * Try to avoid changes which touch view structure:
   *
   * * you should not add or remove nor wrap or unwrap any view elements,
   * * you should not change the editor data model in a view post-fixer.
   *
   * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.
   *
   * Typically, a post-fixer will look like this:
   *
   * ```ts
   * editor.editing.view.document.registerPostFixer( writer => {
   * 	if ( checkSomeCondition() ) {
   * 		writer.doSomething();
   *
   * 		// Let other post-fixers know that something changed.
   * 		return true;
   * 	}
   *
   * 	return false;
   * } );
   * ```
   *
   * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
   * That is because adding a post-fixer does not execute it.
   * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
   * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
   * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.
   *
   * If you need to register a callback which is executed when DOM elements are already updated,
   * use {@link module:engine/view/view~View#event:render render event}.
   */
  registerPostFixer(postFixer) {
    this._postFixers.add(postFixer);
  }
  /**
   * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
   */
  destroy() {
    this.roots.forEach((root) => root.destroy());
    this.stopListening();
  }
  /**
   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
   *
   * @internal
   */
  _callPostFixers(writer) {
    let wasFixed = false;
    do {
      for (const callback of this._postFixers) {
        wasFixed = callback(writer);
        if (wasFixed) {
          break;
        }
      }
    } while (wasFixed);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/attributeelement.js
var DEFAULT_PRIORITY = 10;
var AttributeElement = class extends Element {
  /**
   * Creates an attribute element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createAttributeElement
   * @see module:engine/view/element~Element
   * @protected
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this._priority = DEFAULT_PRIORITY;
    this._id = null;
    this._clonesGroup = null;
    this.getFillerOffset = getFillerOffset2;
  }
  /**
   * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
   */
  get priority() {
    return this._priority;
  }
  /**
   * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
   * and then two elements are considered similar if, and only if they have the same `id`.
   */
  get id() {
    return this._id;
  }
  /**
   * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the
   * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).
   *
   * Note: If this element has been removed from the tree, returned set will not include it.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
   * if this element has no `id`.
   *
   * @returns Set containing all the attribute elements
   * with the same `id` that were added and not removed from the view tree.
   */
  getElementsWithSameId() {
    if (this.id === null) {
      throw new CKEditorError("attribute-element-get-elements-with-same-id-no-id", this);
    }
    return new Set(this._clonesGroup);
  }
  /**
   * Checks if this element is similar to other element.
   *
   * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements
   * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
   * different set of children nodes.
   *
   * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both
   * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be
   * considered similar.
   *
   * Similarity is important for {@link module:engine/view/downcastwriter~DowncastWriter}. For example:
   *
   * * two following similar elements can be merged together into one, longer element,
   * * {@link module:engine/view/downcastwriter~DowncastWriter#unwrap} checks similarity of passed element and processed element to
   * decide whether processed element should be unwrapped,
   * * etc.
   */
  isSimilar(otherElement) {
    if (this.id !== null || otherElement.id !== null) {
      return this.id === otherElement.id;
    }
    return super.isSimilar(otherElement) && this.priority == otherElement.priority;
  }
  /**
   * Clones provided element with priority.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any children.
   * @returns Clone of this element.
   */
  _clone(deep = false) {
    const cloned = super._clone(deep);
    cloned._priority = this._priority;
    cloned._id = this._id;
    return cloned;
  }
};
AttributeElement.DEFAULT_PRIORITY = DEFAULT_PRIORITY;
var attributeelement_default = AttributeElement;
AttributeElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "attributeElement" || type === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "attributeElement" || type === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element");
  }
};
function getFillerOffset2() {
  if (nonUiChildrenCount(this)) {
    return null;
  }
  let element = this.parent;
  while (element && element.is("attributeElement")) {
    if (nonUiChildrenCount(element) > 1) {
      return null;
    }
    element = element.parent;
  }
  if (!element || nonUiChildrenCount(element) > 1) {
    return null;
  }
  return this.childCount;
}
function nonUiChildrenCount(element) {
  return Array.from(element.getChildren()).filter((element2) => !element2.is("uiElement")).length;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/emptyelement.js
var EmptyElement = class extends Element {
  /**
   * Creates new instance of EmptyElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
   * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEmptyElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attributes, children) {
    super(document2, name, attributes, children);
    this.getFillerOffset = getFillerOffset3;
  }
  /**
   * Overrides {@link module:engine/view/element~Element#_insertChild} method.
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
   * adding any child nodes to EmptyElement.
   *
   * @internal
   */
  _insertChild(index, items) {
    if (items && (items instanceof Node2 || Array.from(items).length > 0)) {
      throw new CKEditorError("view-emptyelement-cannot-add", [this, items]);
    }
    return 0;
  }
};
EmptyElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "emptyElement" || type === "view:emptyElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "emptyElement" || type === "view:emptyElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset3() {
  return null;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/uielement.js
var UIElement = class extends Element {
  /**
   * Creates new instance of UIElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
   * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this.getFillerOffset = getFillerOffset4;
  }
  /**
   * Overrides {@link module:engine/view/element~Element#_insertChild} method.
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
   * to UIElement.
   *
   * @internal
   */
  _insertChild(index, items) {
    if (items && (items instanceof Node2 || Array.from(items).length > 0)) {
      throw new CKEditorError("view-uielement-cannot-add", [this, items]);
    }
    return 0;
  }
  /**
   * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
   * {@link module:engine/view/domconverter~DomConverter}.
   * Do not use inheritance to create custom rendering method, replace `render()` method instead:
   *
   * ```ts
   * const myUIElement = downcastWriter.createUIElement( 'span' );
   * myUIElement.render = function( domDocument, domConverter ) {
   * 	const domElement = this.toDomElement( domDocument );
   *
   * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
   *
   * 	return domElement;
   * };
   * ```
   *
   * If changes in your UI element should trigger some editor UI update you should call
   * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
   * after rendering your UI element.
   *
   * @param domConverter Instance of the DomConverter used to optimize the output.
   */
  render(domDocument, domConverter) {
    return this.toDomElement(domDocument);
  }
  /**
   * Creates DOM element based on this view UIElement.
   * Note that each time this method is called new DOM element is created.
   */
  toDomElement(domDocument) {
    const domElement = domDocument.createElement(this.name);
    for (const key of this.getAttributeKeys()) {
      domElement.setAttribute(key, this.getAttribute(key));
    }
    return domElement;
  }
};
UIElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "uiElement" || type === "view:uiElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "uiElement" || type === "view:uiElement" || type === "element" || type === "view:element");
  }
};
function injectUiElementHandling(view) {
  view.document.on("arrowKey", (evt, data) => jumpOverUiElement(evt, data, view.domConverter), { priority: "low" });
}
function getFillerOffset4() {
  return null;
}
function jumpOverUiElement(evt, data, domConverter) {
  if (data.keyCode == keyCodes.arrowright) {
    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
    const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed;
    if (domSelectionCollapsed || data.shiftKey) {
      const domParent = domSelection.focusNode;
      const domOffset = domSelection.focusOffset;
      const viewPosition = domConverter.domPositionToView(domParent, domOffset);
      if (viewPosition === null) {
        return;
      }
      let jumpedOverAnyUiElement = false;
      const nextViewPosition = viewPosition.getLastMatchingPosition((value) => {
        if (value.item.is("uiElement")) {
          jumpedOverAnyUiElement = true;
        }
        if (value.item.is("uiElement") || value.item.is("attributeElement")) {
          return true;
        }
        return false;
      });
      if (jumpedOverAnyUiElement) {
        const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);
        if (domSelectionCollapsed) {
          domSelection.collapse(newDomPosition.parent, newDomPosition.offset);
        } else {
          domSelection.extend(newDomPosition.parent, newDomPosition.offset);
        }
      }
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/rawelement.js
var RawElement = class extends Element {
  /**
   * Creates a new instance of a raw element.
   *
   * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} when the `children`
   * parameter is passed to inform that the usage of `RawElement` is incorrect (adding child nodes to `RawElement` is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createRawElement
   * @internal
   * @param document The document instance to which this element belongs.
   * @param name Node name.
   * @param attrs Collection of attributes.
   * @param children A list of nodes to be inserted into created element.
   */
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this.getFillerOffset = getFillerOffset5;
  }
  /**
   * Overrides the {@link module:engine/view/element~Element#_insertChild} method.
   * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} to prevent
   * adding any child nodes to a raw element.
   *
   * @internal
   */
  _insertChild(index, items) {
    if (items && (items instanceof Node2 || Array.from(items).length > 0)) {
      throw new CKEditorError("view-rawelement-cannot-add", [this, items]);
    }
    return 0;
  }
  /**
   * This allows rendering the children of a {@link module:engine/view/rawelement~RawElement} on the DOM level.
   * This method is called by the {@link module:engine/view/domconverter~DomConverter} with the raw DOM element
   * passed as an argument, leaving the number and shape of the children up to the integrator.
   *
   * This method **must be defined** for the raw element to work:
   *
   * ```ts
   * const myRawElement = downcastWriter.createRawElement( 'div' );
   *
   * myRawElement.render = function( domElement, domConverter ) {
   * 	domConverter.setContentOf( domElement, '<b>This is the raw content of myRawElement.</b>' );
   * };
   * ```
   *
   * @param domElement The native DOM element representing the raw view element.
   * @param domConverter Instance of the DomConverter used to optimize the output.
   */
  render(domElement, domConverter) {
  }
};
RawElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rawElement" || type === "view:rawElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === this.name || type === "view:" + this.name || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "rawElement" || type === "view:rawElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset5() {
  return null;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/documentfragment.js
var DocumentFragment = class extends EmitterMixin(TypeCheckable) {
  /**
   * Creates new DocumentFragment instance.
   *
   * @internal
   * @param document The document to which this document fragment belongs.
   * @param children A list of nodes to be inserted into the created document fragment.
   */
  constructor(document2, children) {
    super();
    this._children = [];
    this._customProperties = /* @__PURE__ */ new Map();
    this.document = document2;
    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
   * Iterable interface.
   *
   * Iterates over nodes added to this document fragment.
   */
  [Symbol.iterator]() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Number of child nodes in this document fragment.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   */
  get root() {
    return this;
  }
  /**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get parent() {
    return null;
  }
  /**
   * Artificial element name. Returns `undefined`. Added for compatibility reasons.
   */
  get name() {
    return void 0;
  }
  /**
   * Artificial element getFillerOffset. Returns `undefined`. Added for compatibility reasons.
   */
  get getFillerOffset() {
    return void 0;
  }
  /**
   * Returns the custom property value for the given key.
   */
  getCustomProperty(key) {
    return this._customProperties.get(key);
  }
  /**
   * Returns an iterator which iterates over this document fragment's custom properties.
   * Iterator provides `[ key, value ]` pairs for each stored property.
   */
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  /**
   * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
   * and sets the parent of these nodes to this fragment.
   *
   * @internal
   * @param items Items to be inserted.
   * @returns Number of appended nodes.
   */
  _appendChild(items) {
    return this._insertChild(this.childCount, items);
  }
  /**
   * Gets child at the given index.
   *
   * @param index Index of child.
   * @returns Child node.
   */
  getChild(index) {
    return this._children[index];
  }
  /**
   * Gets index of the given child node. Returns `-1` if child node is not found.
   *
   * @param node Child node.
   * @returns Index of the child node.
   */
  getChildIndex(node) {
    return this._children.indexOf(node);
  }
  /**
   * Gets child nodes iterator.
   *
   * @returns Child nodes iterator.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
   * this fragment.
   *
   * @internal
   * @param index Position where nodes should be inserted.
   * @param items Items to be inserted.
   * @returns Number of inserted nodes.
   */
  _insertChild(index, items) {
    this._fireChange("children", this);
    let count2 = 0;
    const nodes = normalize2(this.document, items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
      this._children.splice(index, 0, node);
      index++;
      count2++;
    }
    return count2;
  }
  /**
   * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
   *
   * @internal
   * @param index Number of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns The array of removed nodes.
   */
  _removeChildren(index, howMany = 1) {
    this._fireChange("children", this);
    for (let i = index; i < index + howMany; i++) {
      this._children[i].parent = null;
    }
    return this._children.splice(index, howMany);
  }
  /**
   * Fires `change` event with given type of the change.
   *
   * @internal
   * @param type Type of the change.
   * @param node Changed node.
   */
  _fireChange(type, node) {
    this.fire("change:" + type, node);
  }
  /**
   * Sets a custom property. They can be used to add special data to elements.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
   * @internal
   */
  _setCustomProperty(key, value) {
    this._customProperties.set(key, value);
  }
  /**
   * Removes the custom property stored under the given key.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
   * @internal
   * @returns Returns true if property was removed.
   */
  _removeCustomProperty(key) {
    return this._customProperties.delete(key);
  }
};
DocumentFragment.prototype.is = function(type) {
  return type === "documentFragment" || type === "view:documentFragment";
};
function normalize2(document2, nodes) {
  if (typeof nodes == "string") {
    return [new Text(document2, nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new Text(document2, node);
    }
    if (node instanceof TextProxy) {
      return new Text(document2, node.data);
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js
var DowncastWriter = class {
  /**
   * @param document The view document instance.
   */
  constructor(document2) {
    this._cloneGroups = /* @__PURE__ */ new Map();
    this._slotFactory = null;
    this.document = document2;
  }
  setSelection(...args) {
    this.document.selection._setTo(...args);
  }
  /**
   * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.
   *
   * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
   * parameters.
   *
   * @param Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
   */
  setSelectionFocus(itemOrPosition, offset) {
    this.document.selection._setFocus(itemOrPosition, offset);
  }
  /**
   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
   *
   * @param children A list of nodes to be inserted into the created document fragment.
   * @returns The created document fragment.
   */
  createDocumentFragment(children) {
    return new DocumentFragment(this.document, children);
  }
  /**
   * Creates a new {@link module:engine/view/text~Text text node}.
   *
   * ```ts
   * writer.createText( 'foo' );
   * ```
   *
   * @param data The text's data.
   * @returns The created text node.
   */
  createText(data) {
    return new Text(this.document, data);
  }
  /**
   * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.
   *
   * ```ts
   * writer.createAttributeElement( 'strong' );
   * writer.createAttributeElement( 'a', { href: 'foo.bar' } );
   *
   * // Make `<a>` element contain other attributes element so the `<a>` element is not broken.
   * writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
   *
   * // Set `id` of a marker element so it is not joined or merged with "normal" elements.
   * writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Element's attributes.
   * @param options Element's options.
   * @param options.priority Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.
   * @param options.id Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createAttributeElement(name, attributes, options = {}) {
    const attributeElement = new attributeelement_default(this.document, name, attributes);
    if (typeof options.priority === "number") {
      attributeElement._priority = options.priority;
    }
    if (options.id) {
      attributeElement._id = options.id;
    }
    if (options.renderUnsafeAttributes) {
      attributeElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return attributeElement;
  }
  createContainerElement(name, attributes, childrenOrOptions = {}, options = {}) {
    let children = null;
    if (isPlainObject_default(childrenOrOptions)) {
      options = childrenOrOptions;
    } else {
      children = childrenOrOptions;
    }
    const containerElement = new ContainerElement(this.document, name, attributes, children);
    if (options.renderUnsafeAttributes) {
      containerElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return containerElement;
  }
  /**
   * Creates a new {@link module:engine/view/editableelement~EditableElement}.
   *
   * ```ts
   * writer.createEditableElement( 'div' );
   * writer.createEditableElement( 'div', { id: 'foo-1234' } );
   * ```
   *
   * Note: The editable element is to be used in the editing pipeline. Usually, together with
   * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createEditableElement(name, attributes, options = {}) {
    const editableElement = new EditableElement(this.document, name, attributes);
    if (options.renderUnsafeAttributes) {
      editableElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return editableElement;
  }
  /**
   * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.
   *
   * ```ts
   * writer.createEmptyElement( 'img' );
   * writer.createEmptyElement( 'img', { id: 'foo-1234' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns Created element.
   */
  createEmptyElement(name, attributes, options = {}) {
    const emptyElement = new EmptyElement(this.document, name, attributes);
    if (options.renderUnsafeAttributes) {
      emptyElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return emptyElement;
  }
  /**
   * Creates a new {@link module:engine/view/uielement~UIElement}.
   *
   * ```ts
   * writer.createUIElement( 'span' );
   * writer.createUIElement( 'span', { id: 'foo-1234' } );
   * ```
   *
   * A custom render function can be provided as the third parameter:
   *
   * ```ts
   * writer.createUIElement( 'span', null, function( domDocument ) {
   * 	const domElement = this.toDomElement( domDocument );
   * 	domElement.innerHTML = '<b>this is ui element</b>';
   *
   * 	return domElement;
   * } );
   * ```
   *
   * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,
   * they are ignored by the editor selection system.
   *
   * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.
   *
   * @param name The name of the element.
   * @param attributes Element attributes.
   * @param renderFunction A custom render function.
   * @returns The created element.
   */
  createUIElement(name, attributes, renderFunction) {
    const uiElement = new UIElement(this.document, name, attributes);
    if (renderFunction) {
      uiElement.render = renderFunction;
    }
    return uiElement;
  }
  /**
   * Creates a new {@link module:engine/view/rawelement~RawElement}.
   *
   * ```ts
   * writer.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {
   * 	domElement.innerHTML = '<b>This is the raw content of the raw element.</b>';
   * } );
   * ```
   *
   * Raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
   * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
   * in the editor content without, for instance, worrying about compatibility with other editor features.
   * Raw elements are a perfect tool for integration with external frameworks and data sources.
   *
   * Unlike {@link #createUIElement UI elements}, raw elements act like "real" editor content (similar to
   * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),
   * and they are considered by the editor selection.
   *
   * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}
   * instead.
   *
   * @param name The name of the element.
   * @param attributes Element attributes.
   * @param renderFunction A custom render function.
   * @param options Element's options.
   * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
   * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
   * @returns The created element.
   */
  createRawElement(name, attributes, renderFunction, options = {}) {
    const rawElement = new RawElement(this.document, name, attributes);
    if (renderFunction) {
      rawElement.render = renderFunction;
    }
    if (options.renderUnsafeAttributes) {
      rawElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return rawElement;
  }
  /**
   * Adds or overwrites the element's attribute with a specified key and value.
   *
   * ```ts
   * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
   * ```
   *
   * @param key The attribute key.
   * @param value The attribute value.
   */
  setAttribute(key, value, element) {
    element._setAttribute(key, value);
  }
  /**
   * Removes attribute from the element.
   *
   * ```ts
   * writer.removeAttribute( 'href', linkElement );
   * ```
   *
   * @param key Attribute key.
   */
  removeAttribute(key, element) {
    element._removeAttribute(key);
  }
  /**
   * Adds specified class to the element.
   *
   * ```ts
   * writer.addClass( 'foo', linkElement );
   * writer.addClass( [ 'foo', 'bar' ], linkElement );
   * ```
   */
  addClass(className, element) {
    element._addClass(className);
  }
  /**
   * Removes specified class from the element.
   *
   * ```ts
   * writer.removeClass( 'foo', linkElement );
   * writer.removeClass( [ 'foo', 'bar' ], linkElement );
   * ```
   */
  removeClass(className, element) {
    element._removeClass(className);
  }
  setStyle(property, value, element) {
    if (isPlainObject_default(property) && element === void 0) {
      value._setStyle(property);
    } else {
      element._setStyle(property, value);
    }
  }
  /**
   * Removes specified style from the element.
   *
   * ```ts
   * writer.removeStyle( 'color', element ); // Removes 'color' style.
   * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
   * ```
   *
   * **Note**: This method can work with normalized style names if
   * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
   * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
   */
  removeStyle(property, element) {
    element._removeStyle(property);
  }
  /**
   * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
   * so they can be used to add special data to elements.
   */
  setCustomProperty(key, value, element) {
    element._setCustomProperty(key, value);
  }
  /**
   * Removes a custom property stored under the given key.
   *
   * @returns Returns true if property was removed.
   */
  removeCustomProperty(key, element) {
    return element._removeCustomProperty(key);
  }
  /**
   * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements
   * up to their first ancestor that is a container element.
   *
   * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:
   *
   * ```html
   * <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
   * <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
   * <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
   * <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
   * ```
   *
   * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
   *
   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
   * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.
   *
   * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when the {@link module:engine/view/range~Range#start start}
   * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.
   *
   * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
   *
   * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
   * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer
   * @param positionOrRange The position where to break attribute elements.
   * @returns The new position or range, after breaking the attribute elements.
   */
  breakAttributes(positionOrRange) {
    if (positionOrRange instanceof Position) {
      return this._breakAttributes(positionOrRange);
    } else {
      return this._breakAttributesRange(positionOrRange);
    }
  }
  /**
   * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.
   * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element
   * if the position is at the beginning or at the end of its parent element.
   *
   * ```html
   * <p>foo^bar</p> -> <p>foo</p><p>bar</p>
   * <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
   * <p>^foobar</p> -> ^<p>foobar</p>
   * <p>foobar^</p> -> <p>foobar</p>^
   * ```
   *
   * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
   * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
   * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes
   * @param position The position where to break the element.
   * @returns The position between broken elements. If an element has not been broken,
   * the returned position is placed either before or after it.
   */
  breakContainer(position) {
    const element = position.parent;
    if (!element.is("containerElement")) {
      throw new CKEditorError("view-writer-break-non-container-element", this.document);
    }
    if (!element.parent) {
      throw new CKEditorError("view-writer-break-root", this.document);
    }
    if (position.isAtStart) {
      return Position._createBefore(element);
    } else if (!position.isAtEnd) {
      const newElement = element._clone(false);
      this.insert(Position._createAfter(element), newElement);
      const sourceRange = new Range(position, Position._createAt(element, "end"));
      const targetPosition = new Position(newElement, 0);
      this.move(sourceRange, targetPosition);
    }
    return Position._createAfter(element);
  }
  /**
   * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.
   * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.
   *
   * In following examples `<p>` is a container and `<b>` is an attribute element:
   *
   * ```html
   * <p>foo[]bar</p> -> <p>foo{}bar</p>
   * <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
   * <p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
   * ```
   *
   * It will also take care about empty attributes when merging:
   *
   * ```html
   * <p><b>[]</b></p> -> <p>[]</p>
   * <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
   * ```
   *
   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers
   * @param position Merge position.
   * @returns Position after merge.
   */
  mergeAttributes(position) {
    const positionOffset = position.offset;
    const positionParent = position.parent;
    if (positionParent.is("$text")) {
      return position;
    }
    if (positionParent.is("attributeElement") && positionParent.childCount === 0) {
      const parent = positionParent.parent;
      const offset = positionParent.index;
      positionParent._remove();
      this._removeFromClonedElementsGroup(positionParent);
      return this.mergeAttributes(new Position(parent, offset));
    }
    const nodeBefore = positionParent.getChild(positionOffset - 1);
    const nodeAfter = positionParent.getChild(positionOffset);
    if (!nodeBefore || !nodeAfter) {
      return position;
    }
    if (nodeBefore.is("$text") && nodeAfter.is("$text")) {
      return mergeTextNodes(nodeBefore, nodeAfter);
    } else if (nodeBefore.is("attributeElement") && nodeAfter.is("attributeElement") && nodeBefore.isSimilar(nodeAfter)) {
      const count2 = nodeBefore.childCount;
      nodeBefore._appendChild(nodeAfter.getChildren());
      nodeAfter._remove();
      this._removeFromClonedElementsGroup(nodeAfter);
      return this.mergeAttributes(new Position(nodeBefore, count2));
    }
    return position;
  }
  /**
   * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.
   * Precisely, the element after the position is removed and it's contents are moved to element before the position.
   *
   * ```html
   * <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
   * <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
   * ```
   *
   * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
   * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
   * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
   * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
   *
   * @see module:engine/view/attributeelement~AttributeElement
   * @see module:engine/view/containerelement~ContainerElement
   * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes
   * @param position Merge position.
   * @returns Position after merge.
   */
  mergeContainers(position) {
    const prev = position.nodeBefore;
    const next = position.nodeAfter;
    if (!prev || !next || !prev.is("containerElement") || !next.is("containerElement")) {
      throw new CKEditorError("view-writer-merge-containers-invalid-position", this.document);
    }
    const lastChild = prev.getChild(prev.childCount - 1);
    const newPosition = lastChild instanceof Text ? Position._createAt(lastChild, "end") : Position._createAt(prev, "end");
    this.move(Range._createIn(next), Position._createAt(prev, "end"));
    this.remove(Range._createOn(next));
    return newPosition;
  }
  /**
   * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion
   * and merging them afterwards.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
   * contains instances that are not {@link module:engine/view/text~Text Texts},
   * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},
   * {@link module:engine/view/containerelement~ContainerElement ContainerElements},
   * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},
   * {@link module:engine/view/rawelement~RawElement RawElements} or
   * {@link module:engine/view/uielement~UIElement UIElements}.
   *
   * @param position Insertion position.
   * @param nodes Node or nodes to insert.
   * @returns Range around inserted nodes.
   */
  insert(position, nodes) {
    nodes = isIterable(nodes) ? [...nodes] : [nodes];
    validateNodesToInsert(nodes, this.document);
    const nodeGroups = nodes.reduce((groups, node) => {
      const lastGroup = groups[groups.length - 1];
      const breakAttributes = !node.is("uiElement");
      if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {
        groups.push({
          breakAttributes,
          nodes: [node]
        });
      } else {
        lastGroup.nodes.push(node);
      }
      return groups;
    }, []);
    let start = null;
    let end = position;
    for (const { nodes: nodes2, breakAttributes } of nodeGroups) {
      const range = this._insertNodes(end, nodes2, breakAttributes);
      if (!start) {
        start = range.start;
      }
      end = range.end;
    }
    if (!start) {
      return new Range(position);
    }
    return new Range(start, end);
  }
  /**
   * Removes provided range from the container.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param rangeOrItem Range to remove from container
   * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated
   * to a collapsed range showing the new position.
   * @returns Document fragment containing removed nodes.
   */
  remove(rangeOrItem) {
    const range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn(rangeOrItem);
    validateRangeContainer(range, this.document);
    if (range.isCollapsed) {
      return new DocumentFragment(this.document);
    }
    const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
    const parentContainer = breakStart.parent;
    const count2 = breakEnd.offset - breakStart.offset;
    const removed = parentContainer._removeChildren(breakStart.offset, count2);
    for (const node of removed) {
      this._removeFromClonedElementsGroup(node);
    }
    const mergePosition = this.mergeAttributes(breakStart);
    range.start = mergePosition;
    range.end = mergePosition.clone();
    return new DocumentFragment(this.document, removed);
  }
  /**
   * Removes matching elements from given range.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param range Range to clear.
   * @param element Element to remove.
   */
  clear(range, element) {
    validateRangeContainer(range, this.document);
    const walker = range.getWalker({
      direction: "backward",
      ignoreElementEnd: true
    });
    for (const current of walker) {
      const item = current.item;
      let rangeToRemove;
      if (item.is("element") && element.isSimilar(item)) {
        rangeToRemove = Range._createOn(item);
      } else if (!current.nextPosition.isAfter(range.start) && item.is("$textProxy")) {
        const parentElement = item.getAncestors().find((ancestor) => {
          return ancestor.is("element") && element.isSimilar(ancestor);
        });
        if (parentElement) {
          rangeToRemove = Range._createIn(parentElement);
        }
      }
      if (rangeToRemove) {
        if (rangeToRemove.end.isAfter(range.end)) {
          rangeToRemove.end = range.end;
        }
        if (rangeToRemove.start.isBefore(range.start)) {
          rangeToRemove.start = range.start;
        }
        this.remove(rangeToRemove);
      }
    }
  }
  /**
   * Moves nodes from provided range to target position.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   *
   * @param sourceRange Range containing nodes to move.
   * @param targetPosition Position to insert.
   * @returns Range in target container. Inserted nodes are placed between
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.
   */
  move(sourceRange, targetPosition) {
    let nodes;
    if (targetPosition.isAfter(sourceRange.end)) {
      targetPosition = this._breakAttributes(targetPosition, true);
      const parent = targetPosition.parent;
      const countBefore = parent.childCount;
      sourceRange = this._breakAttributesRange(sourceRange, true);
      nodes = this.remove(sourceRange);
      targetPosition.offset += parent.childCount - countBefore;
    } else {
      nodes = this.remove(sourceRange);
    }
    return this.insert(targetPosition, nodes);
  }
  /**
   * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
   *
   * If a collapsed range was passed and is same as selection, the selection
   * will be moved to the inside of the wrapped attribute element.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
   * when {@link module:engine/view/range~Range#start}
   * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
   * is collapsed and different than view selection.
   *
   * @param range Range to wrap.
   * @param attribute Attribute element to use as wrapper.
   * @returns range Range after wrapping, spanning over wrapping attribute element.
   */
  wrap(range, attribute) {
    if (!(attribute instanceof attributeelement_default)) {
      throw new CKEditorError("view-writer-wrap-invalid-attribute", this.document);
    }
    validateRangeContainer(range, this.document);
    if (!range.isCollapsed) {
      return this._wrapRange(range, attribute);
    } else {
      let position = range.start;
      if (position.parent.is("element") && !_hasNonUiChildren(position.parent)) {
        position = position.getLastMatchingPosition((value) => value.item.is("uiElement"));
      }
      position = this._wrapPosition(position, attribute);
      const viewSelection = this.document.selection;
      if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {
        this.setSelection(position);
      }
      return new Range(position);
    }
  }
  /**
   * Unwraps nodes within provided range from attribute element.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
   * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
   * same parent container.
   */
  unwrap(range, attribute) {
    if (!(attribute instanceof attributeelement_default)) {
      throw new CKEditorError("view-writer-unwrap-invalid-attribute", this.document);
    }
    validateRangeContainer(range, this.document);
    if (range.isCollapsed) {
      return range;
    }
    const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
    const parentContainer = breakStart.parent;
    const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
    const start = this.mergeAttributes(newRange.start);
    if (!start.isEqual(newRange.start)) {
      newRange.end.offset--;
    }
    const end = this.mergeAttributes(newRange.end);
    return new Range(start, end);
  }
  /**
   * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
   * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which
   * has renamed element as {@link module:engine/view/position~Position#parent a parent}.
   *
   * New element has to be created because `Element#tagName` property in DOM is readonly.
   *
   * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
   *
   * @param newName New name for element.
   * @param viewElement Element to be renamed.
   * @returns Element created due to rename.
   */
  rename(newName, viewElement) {
    const newElement = new ContainerElement(this.document, newName, viewElement.getAttributes());
    this.insert(Position._createAfter(viewElement), newElement);
    this.move(Range._createIn(viewElement), Position._createAt(newElement, 0));
    this.remove(Range._createOn(viewElement));
    return newElement;
  }
  /**
   * Cleans up memory by removing obsolete cloned elements group from the writer.
   *
   * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}
   * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and
   * the group will no longer be needed.
   *
   * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
   * were removed from the view.
   *
   * Keep in mind that group names are equal to the `id` property of the attribute element.
   *
   * @param groupName Name of the group to clear.
   */
  clearClonedElementsGroup(groupName) {
    this._cloneGroups.delete(groupName);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(itemOrPosition, offset) {
    return Position._createAt(itemOrPosition, offset);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(item) {
    return Position._createAfter(item);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(item) {
    return Position._createBefore(item);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(start, end) {
    return new Range(start, end);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(item) {
    return Range._createOn(item);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(element) {
    return Range._createIn(element);
  }
  createSelection(...args) {
    return new Selection(...args);
  }
  /**
   * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
   * `elementToStructure()`} conversion helper.
   *
   * ```ts
   * const viewSlot = conversionApi.writer.createSlot();
   * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
   *
   * conversionApi.writer.insert( viewPosition, viewSlot );
   * ```
   *
   * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):
   *
   * ```ts
   * const viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );
   * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
   *
   * conversionApi.writer.insert( viewPosition, viewSlot );
   * ```
   *
   * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into
   * multiple slots.
   *
   * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.
   *
   * @param modeOrFilter The filter for child nodes.
   * @returns The slot element to be placed in to the view structure while processing
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.
   */
  createSlot(modeOrFilter = "children") {
    if (!this._slotFactory) {
      throw new CKEditorError("view-writer-invalid-create-slot-context", this.document);
    }
    return this._slotFactory(this, modeOrFilter);
  }
  /**
   * Registers a slot factory.
   *
   * @internal
   * @param slotFactory The slot factory.
   */
  _registerSlotFactory(slotFactory) {
    this._slotFactory = slotFactory;
  }
  /**
   * Clears the registered slot factory.
   *
   * @internal
   */
  _clearSlotFactory() {
    this._slotFactory = null;
  }
  /**
   * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion
   * and merging them afterwards if requested by the breakAttributes param.
   *
   * @param position Insertion position.
   * @param nodes Node or nodes to insert.
   * @param breakAttributes Whether attributes should be broken.
   * @returns Range around inserted nodes.
   */
  _insertNodes(position, nodes, breakAttributes) {
    let parentElement;
    if (breakAttributes) {
      parentElement = getParentContainer(position);
    } else {
      parentElement = position.parent.is("$text") ? position.parent.parent : position.parent;
    }
    if (!parentElement) {
      throw new CKEditorError("view-writer-invalid-position-container", this.document);
    }
    let insertionPosition;
    if (breakAttributes) {
      insertionPosition = this._breakAttributes(position, true);
    } else {
      insertionPosition = position.parent.is("$text") ? breakTextNode(position) : position;
    }
    const length = parentElement._insertChild(insertionPosition.offset, nodes);
    for (const node of nodes) {
      this._addToClonedElementsGroup(node);
    }
    const endPosition = insertionPosition.getShiftedBy(length);
    const start = this.mergeAttributes(insertionPosition);
    if (!start.isEqual(insertionPosition)) {
      endPosition.offset--;
    }
    const end = this.mergeAttributes(endPosition);
    return new Range(start, end);
  }
  /**
   * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
   * `startOffset` and `endOffset` will be wrapped.
   */
  _wrapChildren(parent, startOffset, endOffset, wrapElement) {
    let i = startOffset;
    const wrapPositions = [];
    while (i < endOffset) {
      const child = parent.getChild(i);
      const isText2 = child.is("$text");
      const isAttribute = child.is("attributeElement");
      if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {
        wrapPositions.push(new Position(parent, i));
      } else if (isText2 || !isAttribute || shouldABeOutsideB(wrapElement, child)) {
        const newAttribute = wrapElement._clone();
        child._remove();
        newAttribute._appendChild(child);
        parent._insertChild(i, newAttribute);
        this._addToClonedElementsGroup(newAttribute);
        wrapPositions.push(new Position(parent, i));
      } else {
        this._wrapChildren(child, 0, child.childCount, wrapElement);
      }
      i++;
    }
    let offsetChange = 0;
    for (const position of wrapPositions) {
      position.offset -= offsetChange;
      if (position.offset == startOffset) {
        continue;
      }
      const newPosition = this.mergeAttributes(position);
      if (!newPosition.isEqual(position)) {
        offsetChange++;
        endOffset--;
      }
    }
    return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
  }
  /**
   * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
   * `startOffset` and `endOffset` will be unwrapped.
   */
  _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {
    let i = startOffset;
    const unwrapPositions = [];
    while (i < endOffset) {
      const child = parent.getChild(i);
      if (!child.is("attributeElement")) {
        i++;
        continue;
      }
      if (child.isSimilar(unwrapElement)) {
        const unwrapped = child.getChildren();
        const count2 = child.childCount;
        child._remove();
        parent._insertChild(i, unwrapped);
        this._removeFromClonedElementsGroup(child);
        unwrapPositions.push(new Position(parent, i), new Position(parent, i + count2));
        i += count2;
        endOffset += count2 - 1;
        continue;
      }
      if (this._unwrapAttributeElement(unwrapElement, child)) {
        unwrapPositions.push(new Position(parent, i), new Position(parent, i + 1));
        i++;
        continue;
      }
      this._unwrapChildren(child, 0, child.childCount, unwrapElement);
      i++;
    }
    let offsetChange = 0;
    for (const position of unwrapPositions) {
      position.offset -= offsetChange;
      if (position.offset == startOffset || position.offset == endOffset) {
        continue;
      }
      const newPosition = this.mergeAttributes(position);
      if (!newPosition.isEqual(position)) {
        offsetChange++;
        endOffset--;
      }
    }
    return Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
  }
  /**
   * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
   * This method will also merge newly added attribute element with its siblings whenever possible.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * @returns New range after wrapping, spanning over wrapping attribute element.
   */
  _wrapRange(range, attribute) {
    const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
    const parentContainer = breakStart.parent;
    const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
    const start = this.mergeAttributes(newRange.start);
    if (!start.isEqual(newRange.start)) {
      newRange.end.offset--;
    }
    const end = this.mergeAttributes(newRange.end);
    return new Range(start, end);
  }
  /**
   * Helper function for {@link #wrap}. Wraps position with provided attribute element.
   * This method will also merge newly added attribute element with its siblings whenever possible.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
   * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
   *
   * @returns New position after wrapping.
   */
  _wrapPosition(position, attribute) {
    if (attribute.isSimilar(position.parent)) {
      return movePositionToTextNode(position.clone());
    }
    if (position.parent.is("$text")) {
      position = breakTextNode(position);
    }
    const fakeElement = this.createAttributeElement("_wrapPosition-fake-element");
    fakeElement._priority = Number.POSITIVE_INFINITY;
    fakeElement.isSimilar = () => false;
    position.parent._insertChild(position.offset, fakeElement);
    const wrapRange = new Range(position, position.getShiftedBy(1));
    this.wrap(wrapRange, attribute);
    const newPosition = new Position(fakeElement.parent, fakeElement.index);
    fakeElement._remove();
    const nodeBefore = newPosition.nodeBefore;
    const nodeAfter = newPosition.nodeAfter;
    if (nodeBefore instanceof Text && nodeAfter instanceof Text) {
      return mergeTextNodes(nodeBefore, nodeAfter);
    }
    return movePositionToTextNode(newPosition);
  }
  /**
   * Wraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by
   * merging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper
   * element to element being wrapped.
   *
   * @param wrapper Wrapper AttributeElement.
   * @param toWrap AttributeElement to wrap using wrapper element.
   * @returns Returns `true` if elements are merged.
   */
  _wrapAttributeElement(wrapper, toWrap) {
    if (!canBeJoined(wrapper, toWrap)) {
      return false;
    }
    if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {
      return false;
    }
    for (const key of wrapper.getAttributeKeys()) {
      if (key === "class" || key === "style") {
        continue;
      }
      if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {
        return false;
      }
    }
    for (const key of wrapper.getStyleNames()) {
      if (toWrap.hasStyle(key) && toWrap.getStyle(key) !== wrapper.getStyle(key)) {
        return false;
      }
    }
    for (const key of wrapper.getAttributeKeys()) {
      if (key === "class" || key === "style") {
        continue;
      }
      if (!toWrap.hasAttribute(key)) {
        this.setAttribute(key, wrapper.getAttribute(key), toWrap);
      }
    }
    for (const key of wrapper.getStyleNames()) {
      if (!toWrap.hasStyle(key)) {
        this.setStyle(key, wrapper.getStyle(key), toWrap);
      }
    }
    for (const key of wrapper.getClassNames()) {
      if (!toWrap.hasClass(key)) {
        this.addClass(key, toWrap);
      }
    }
    return true;
  }
  /**
   * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing
   * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present
   * inside element being unwrapped.
   *
   * @param wrapper Wrapper AttributeElement.
   * @param toUnwrap AttributeElement to unwrap using wrapper element.
   * @returns Returns `true` if elements are unwrapped.
   **/
  _unwrapAttributeElement(wrapper, toUnwrap) {
    if (!canBeJoined(wrapper, toUnwrap)) {
      return false;
    }
    if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {
      return false;
    }
    for (const key of wrapper.getAttributeKeys()) {
      if (key === "class" || key === "style") {
        continue;
      }
      if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {
        return false;
      }
    }
    if (!toUnwrap.hasClass(...wrapper.getClassNames())) {
      return false;
    }
    for (const key of wrapper.getStyleNames()) {
      if (!toUnwrap.hasStyle(key) || toUnwrap.getStyle(key) !== wrapper.getStyle(key)) {
        return false;
      }
    }
    for (const key of wrapper.getAttributeKeys()) {
      if (key === "class" || key === "style") {
        continue;
      }
      this.removeAttribute(key, toUnwrap);
    }
    this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap);
    this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);
    return true;
  }
  /**
   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
   *
   * @param range Range which `start` and `end` positions will be used to break attributes.
   * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
   * @returns New range with located at break positions.
   */
  _breakAttributesRange(range, forceSplitText = false) {
    const rangeStart = range.start;
    const rangeEnd = range.end;
    validateRangeContainer(range, this.document);
    if (range.isCollapsed) {
      const position = this._breakAttributes(range.start, forceSplitText);
      return new Range(position, position);
    }
    const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);
    const count2 = breakEnd.parent.childCount;
    const breakStart = this._breakAttributes(rangeStart, forceSplitText);
    breakEnd.offset += breakEnd.parent.childCount - count2;
    return new Range(breakStart, breakEnd);
  }
  /**
   * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
   * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
   * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.
   *
   * @param position Position where to break attributes.
   * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
   * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
   * @returns New position after breaking the attributes.
   */
  _breakAttributes(position, forceSplitText = false) {
    const positionOffset = position.offset;
    const positionParent = position.parent;
    if (position.parent.is("emptyElement")) {
      throw new CKEditorError("view-writer-cannot-break-empty-element", this.document);
    }
    if (position.parent.is("uiElement")) {
      throw new CKEditorError("view-writer-cannot-break-ui-element", this.document);
    }
    if (position.parent.is("rawElement")) {
      throw new CKEditorError("view-writer-cannot-break-raw-element", this.document);
    }
    if (!forceSplitText && positionParent.is("$text") && isContainerOrFragment(positionParent.parent)) {
      return position.clone();
    }
    if (isContainerOrFragment(positionParent)) {
      return position.clone();
    }
    if (positionParent.is("$text")) {
      return this._breakAttributes(breakTextNode(position), forceSplitText);
    }
    const length = positionParent.childCount;
    if (positionOffset == length) {
      const newPosition = new Position(positionParent.parent, positionParent.index + 1);
      return this._breakAttributes(newPosition, forceSplitText);
    } else {
      if (positionOffset === 0) {
        const newPosition = new Position(positionParent.parent, positionParent.index);
        return this._breakAttributes(newPosition, forceSplitText);
      } else {
        const offsetAfter = positionParent.index + 1;
        const clonedNode = positionParent._clone();
        positionParent.parent._insertChild(offsetAfter, clonedNode);
        this._addToClonedElementsGroup(clonedNode);
        const count2 = positionParent.childCount - positionOffset;
        const nodesToMove = positionParent._removeChildren(positionOffset, count2);
        clonedNode._appendChild(nodesToMove);
        const newPosition = new Position(positionParent.parent, offsetAfter);
        return this._breakAttributes(newPosition, forceSplitText);
      }
    }
  }
  /**
   * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was
   * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
   * from the group now keep a reference to the given attribute element.
   *
   * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.
   *
   * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
   *
   * @param element Attribute element to save.
   */
  _addToClonedElementsGroup(element) {
    if (!element.root.is("rootElement")) {
      return;
    }
    if (element.is("element")) {
      for (const child of element.getChildren()) {
        this._addToClonedElementsGroup(child);
      }
    }
    const id = element.id;
    if (!id) {
      return;
    }
    let group = this._cloneGroups.get(id);
    if (!group) {
      group = /* @__PURE__ */ new Set();
      this._cloneGroups.set(id, group);
    }
    group.add(element);
    element._clonesGroup = group;
  }
  /**
   * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}
   * from its clones group.
   *
   * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
   * This allows to reference the whole group even if the element was already removed from the tree.
   *
   * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
   *
   * @param element Attribute element to remove.
   */
  _removeFromClonedElementsGroup(element) {
    if (element.is("element")) {
      for (const child of element.getChildren()) {
        this._removeFromClonedElementsGroup(child);
      }
    }
    const id = element.id;
    if (!id) {
      return;
    }
    const group = this._cloneGroups.get(id);
    if (!group) {
      return;
    }
    group.delete(element);
  }
};
function _hasNonUiChildren(parent) {
  return Array.from(parent.getChildren()).some((child) => !child.is("uiElement"));
}
function getParentContainer(position) {
  let parent = position.parent;
  while (!isContainerOrFragment(parent)) {
    if (!parent) {
      return void 0;
    }
    parent = parent.parent;
  }
  return parent;
}
function shouldABeOutsideB(a, b) {
  if (a.priority < b.priority) {
    return true;
  } else if (a.priority > b.priority) {
    return false;
  }
  return a.getIdentity() < b.getIdentity();
}
function movePositionToTextNode(position) {
  const nodeBefore = position.nodeBefore;
  if (nodeBefore && nodeBefore.is("$text")) {
    return new Position(nodeBefore, nodeBefore.data.length);
  }
  const nodeAfter = position.nodeAfter;
  if (nodeAfter && nodeAfter.is("$text")) {
    return new Position(nodeAfter, 0);
  }
  return position;
}
function breakTextNode(position) {
  if (position.offset == position.parent.data.length) {
    return new Position(position.parent.parent, position.parent.index + 1);
  }
  if (position.offset === 0) {
    return new Position(position.parent.parent, position.parent.index);
  }
  const textToMove = position.parent.data.slice(position.offset);
  position.parent._data = position.parent.data.slice(0, position.offset);
  position.parent.parent._insertChild(position.parent.index + 1, new Text(position.root.document, textToMove));
  return new Position(position.parent.parent, position.parent.index + 1);
}
function mergeTextNodes(t1, t2) {
  const nodeBeforeLength = t1.data.length;
  t1._data += t2.data;
  t2._remove();
  return new Position(t1, nodeBeforeLength);
}
var validNodesToInsert = [Text, attributeelement_default, ContainerElement, EmptyElement, RawElement, UIElement];
function validateNodesToInsert(nodes, errorContext) {
  for (const node of nodes) {
    if (!validNodesToInsert.some((validNode) => node instanceof validNode)) {
      throw new CKEditorError("view-writer-insert-invalid-node-type", errorContext);
    }
    if (!node.is("$text")) {
      validateNodesToInsert(node.getChildren(), errorContext);
    }
  }
}
function isContainerOrFragment(node) {
  return node && (node.is("containerElement") || node.is("documentFragment"));
}
function validateRangeContainer(range, errorContext) {
  const startContainer = getParentContainer(range.start);
  const endContainer = getParentContainer(range.end);
  if (!startContainer || !endContainer || startContainer !== endContainer) {
    throw new CKEditorError("view-writer-invalid-range-container", errorContext);
  }
}
function canBeJoined(a, b) {
  return a.id === null && b.id === null;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/filler.js
var NBSP_FILLER = (domDocument) => domDocument.createTextNode("");
var MARKED_NBSP_FILLER = (domDocument) => {
  const span = domDocument.createElement("span");
  span.dataset.ckeFiller = "true";
  span.innerText = "";
  return span;
};
var BR_FILLER = (domDocument) => {
  const fillerBr = domDocument.createElement("br");
  fillerBr.dataset.ckeFiller = "true";
  return fillerBr;
};
var INLINE_FILLER_LENGTH = 7;
var INLINE_FILLER = "".repeat(INLINE_FILLER_LENGTH);
function startsWithFiller(domNode) {
  if (typeof domNode == "string") {
    return domNode.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
  }
  return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
}
function isInlineFiller(domText) {
  return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
}
function getDataWithoutFiller(domText) {
  const data = typeof domText == "string" ? domText : domText.data;
  if (startsWithFiller(domText)) {
    return data.slice(INLINE_FILLER_LENGTH);
  }
  return data;
}
function injectQuirksHandling(view) {
  view.document.on("arrowKey", jumpOverInlineFiller, { priority: "low" });
}
function jumpOverInlineFiller(evt, data) {
  if (data.keyCode == keyCodes.arrowleft) {
    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
    if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
      const domParent = domSelection.getRangeAt(0).startContainer;
      const domOffset = domSelection.getRangeAt(0).startOffset;
      if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {
        domSelection.collapse(domParent, 0);
      }
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/renderer.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css";
var Renderer = class extends ObservableMixin() {
  /**
   * Creates a renderer instance.
   *
   * @param domConverter Converter instance.
   * @param selection View selection.
   */
  constructor(domConverter, selection) {
    super();
    this.domDocuments = /* @__PURE__ */ new Set();
    this.markedAttributes = /* @__PURE__ */ new Set();
    this.markedChildren = /* @__PURE__ */ new Set();
    this.markedTexts = /* @__PURE__ */ new Set();
    this._inlineFiller = null;
    this._fakeSelectionContainer = null;
    this.domConverter = domConverter;
    this.selection = selection;
    this.set("isFocused", false);
    this.set("isSelecting", false);
    this.set("isComposing", false);
    if (env_default.isBlink && !env_default.isAndroid) {
      this.on("change:isSelecting", () => {
        if (!this.isSelecting) {
          this.render();
        }
      });
    }
  }
  /**
   * Marks a view node to be updated in the DOM by {@link #render `render()`}.
   *
   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.
   *
   * @see #markedAttributes
   * @see #markedChildren
   * @see #markedTexts
   *
   * @param type Type of the change.
   * @param node ViewNode to be marked.
   */
  markToSync(type, node) {
    if (type === "text") {
      if (this.domConverter.mapViewToDom(node.parent)) {
        this.markedTexts.add(node);
      }
    } else {
      if (!this.domConverter.mapViewToDom(node)) {
        return;
      }
      if (type === "attributes") {
        this.markedAttributes.add(node);
      } else if (type === "children") {
        this.markedChildren.add(node);
      } else {
        const unreachable = type;
        throw new CKEditorError("view-renderer-unknown-type", this);
      }
    }
  }
  /**
   * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and
   * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.
   *
   * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,
   * so it does as little as it is needed to update the DOM.
   *
   * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
   * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be
   * removed as long as the selection is in the text node which needed it at first.
   */
  render() {
    if (this.isComposing && !env_default.isAndroid) {
      return;
    }
    let inlineFillerPosition = null;
    const isInlineFillerRenderingPossible = env_default.isBlink && !env_default.isAndroid ? !this.isSelecting : true;
    for (const element of this.markedChildren) {
      this._updateChildrenMappings(element);
    }
    if (isInlineFillerRenderingPossible) {
      if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
        this._removeInlineFiller();
      }
      if (this._inlineFiller) {
        inlineFillerPosition = this._getInlineFillerPosition();
      } else if (this._needsInlineFillerAtSelection()) {
        inlineFillerPosition = this.selection.getFirstPosition();
        this.markedChildren.add(inlineFillerPosition.parent);
      }
    } else if (this._inlineFiller && this._inlineFiller.parentNode) {
      inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);
      if (inlineFillerPosition && inlineFillerPosition.parent.is("$text")) {
        inlineFillerPosition = Position._createBefore(inlineFillerPosition.parent);
      }
    }
    for (const element of this.markedAttributes) {
      this._updateAttrs(element);
    }
    for (const element of this.markedChildren) {
      this._updateChildren(element, { inlineFillerPosition });
    }
    for (const node of this.markedTexts) {
      if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {
        this._updateText(node, { inlineFillerPosition });
      }
    }
    if (isInlineFillerRenderingPossible) {
      if (inlineFillerPosition) {
        const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);
        const domDocument = fillerDomPosition.parent.ownerDocument;
        if (!startsWithFiller(fillerDomPosition.parent)) {
          this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);
        } else {
          this._inlineFiller = fillerDomPosition.parent;
        }
      } else {
        this._inlineFiller = null;
      }
    }
    this._updateFocus();
    this._updateSelection();
    this.domConverter._clearTemporaryCustomProperties();
    this.markedTexts.clear();
    this.markedAttributes.clear();
    this.markedChildren.clear();
  }
  /**
   * Updates mappings of view element's children.
   *
   * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.
   * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.
   * Thanks to that these elements do not need to be re-rendered completely.
   *
   * @param viewElement The view element whose children mappings will be updated.
   */
  _updateChildrenMappings(viewElement) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    const actualDomChildren = Array.from(domElement.childNodes);
    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, { withChildren: false }));
    const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
    const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areSimilarElements);
    if (actions.indexOf("update") !== -1) {
      const counter = { equal: 0, insert: 0, delete: 0 };
      for (const action of actions) {
        if (action === "update") {
          const insertIndex = counter.equal + counter.insert;
          const deleteIndex = counter.equal + counter.delete;
          const viewChild = viewElement.getChild(insertIndex);
          if (viewChild && !viewChild.is("uiElement") && !viewChild.is("rawElement")) {
            this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);
          }
          remove(expectedDomChildren[insertIndex]);
          counter.equal++;
        } else {
          counter[action]++;
        }
      }
    }
  }
  /**
   * Updates mappings of a given view element.
   *
   * @param viewElement The view element whose mappings will be updated.
   * @param domElement The DOM element representing the given view element.
   */
  _updateElementMappings(viewElement, domElement) {
    this.domConverter.unbindDomElement(domElement);
    this.domConverter.bindElements(domElement, viewElement);
    this.markedChildren.add(viewElement);
    this.markedAttributes.add(viewElement);
  }
  /**
   * Gets the position of the inline filler based on the current selection.
   * Here, we assume that we know that the filler is needed and
   * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,
   * it is somewhere at the selection position.
   *
   * Note: The filler position cannot be restored based on the filler's DOM text node, because
   * when this method is called (before rendering), the bindings will often be broken. View-to-DOM
   * bindings are only dependable after rendering.
   */
  _getInlineFillerPosition() {
    const firstPos = this.selection.getFirstPosition();
    if (firstPos.parent.is("$text")) {
      return Position._createBefore(firstPos.parent);
    } else {
      return firstPos;
    }
  }
  /**
   * Returns `true` if the selection has not left the inline filler's text node.
   * If it is `true`, it means that the filler had been added for a reason and the selection did not
   * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.
   *
   * @returns `true` if the inline filler and selection are in the same place.
   */
  _isSelectionInInlineFiller() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
      return false;
    }
    const selectionPosition = this.selection.getFirstPosition();
    const position = this.domConverter.viewPositionToDom(selectionPosition);
    if (position && isText(position.parent) && startsWithFiller(position.parent)) {
      return true;
    }
    return false;
  }
  /**
   * Removes the inline filler.
   */
  _removeInlineFiller() {
    const domFillerNode = this._inlineFiller;
    if (!startsWithFiller(domFillerNode)) {
      throw new CKEditorError("view-renderer-filler-was-lost", this);
    }
    if (isInlineFiller(domFillerNode)) {
      domFillerNode.remove();
    } else {
      domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);
    }
    this._inlineFiller = null;
  }
  /**
   * Checks if the inline {@link module:engine/view/filler filler} should be added.
   *
   * @returns `true` if the inline filler should be added.
   */
  _needsInlineFillerAtSelection() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
      return false;
    }
    const selectionPosition = this.selection.getFirstPosition();
    const selectionParent = selectionPosition.parent;
    const selectionOffset = selectionPosition.offset;
    if (!this.domConverter.mapViewToDom(selectionParent.root)) {
      return false;
    }
    if (!selectionParent.is("element")) {
      return false;
    }
    if (!isEditable(selectionParent)) {
      return false;
    }
    const nodeBefore = selectionPosition.nodeBefore;
    const nodeAfter = selectionPosition.nodeAfter;
    if (nodeBefore instanceof Text || nodeAfter instanceof Text) {
      return false;
    }
    if (selectionOffset === selectionParent.getFillerOffset() && (!nodeBefore || !nodeBefore.is("element", "br"))) {
      return false;
    }
    if (env_default.isAndroid && (nodeBefore || nodeAfter)) {
      return false;
    }
    return true;
  }
  /**
   * Checks if text needs to be updated and possibly updates it.
   *
   * @param viewText View text to update.
   * @param options.inlineFillerPosition The position where the inline filler should be rendered.
   */
  _updateText(viewText, options) {
    const domText = this.domConverter.findCorrespondingDomText(viewText);
    const newDomText = this.domConverter.viewToDom(viewText);
    let expectedText = newDomText.data;
    const filler = options.inlineFillerPosition;
    if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {
      expectedText = INLINE_FILLER + expectedText;
    }
    this._updateTextNode(domText, expectedText);
  }
  /**
   * Checks if attribute list needs to be updated and possibly updates it.
   *
   * @param viewElement The view element to update.
   */
  _updateAttrs(viewElement) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    for (const domAttr of Array.from(domElement.attributes)) {
      const key = domAttr.name;
      if (!viewElement.hasAttribute(key)) {
        this.domConverter.removeDomElementAttribute(domElement, key);
      }
    }
    for (const key of viewElement.getAttributeKeys()) {
      this.domConverter.setDomElementAttribute(domElement, key, viewElement.getAttribute(key), viewElement);
    }
  }
  /**
   * Checks if elements child list needs to be updated and possibly updates it.
   *
   * Note that on Android, to reduce the risk of composition breaks, it tries to update data of an existing
   * child text nodes instead of replacing them completely.
   *
   * @param viewElement View element to update.
   * @param options.inlineFillerPosition The position where the inline filler should be rendered.
   */
  _updateChildren(viewElement, options) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    if (env_default.isAndroid) {
      let previousDomNode = null;
      for (const domNode of Array.from(domElement.childNodes)) {
        if (previousDomNode && isText(previousDomNode) && isText(domNode)) {
          domElement.normalize();
          break;
        }
        previousDomNode = domNode;
      }
    }
    const inlineFillerPosition = options.inlineFillerPosition;
    const actualDomChildren = domElement.childNodes;
    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, { bind: true }));
    if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {
      addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);
    }
    const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
    const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areTextNodes);
    let i = 0;
    const nodesToUnbind = /* @__PURE__ */ new Set();
    for (const action of actions) {
      if (action === "delete") {
        nodesToUnbind.add(actualDomChildren[i]);
        remove(actualDomChildren[i]);
      } else if (action === "equal" || action === "update") {
        i++;
      }
    }
    i = 0;
    for (const action of actions) {
      if (action === "insert") {
        insertAt(domElement, i, expectedDomChildren[i]);
        i++;
      } else if (action === "update") {
        this._updateTextNode(actualDomChildren[i], expectedDomChildren[i].data);
        i++;
      } else if (action === "equal") {
        this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));
        i++;
      }
    }
    for (const node of nodesToUnbind) {
      if (!node.parentNode) {
        this.domConverter.unbindDomElement(node);
      }
    }
  }
  /**
   * Shorthand for diffing two arrays or node lists of DOM nodes.
   *
   * @param actualDomChildren Actual DOM children
   * @param expectedDomChildren Expected DOM children.
   * @returns The list of actions based on the {@link module:utils/diff~diff} function.
   */
  _diffNodeLists(actualDomChildren, expectedDomChildren) {
    actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);
    return diff(actualDomChildren, expectedDomChildren, sameNodes.bind(null, this.domConverter));
  }
  /**
   * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared
   * within one `insert`/`delete` action group, for example:
   *
   * ```
   * Actual DOM:		<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>
   * Expected DOM:	<p>Bar<b>123</b><i>Baz</i><b>456</b></p>
   * Input actions:	[ insert, insert, delete, delete, equal, insert, delete ]
   * Output actions:	[ insert, replace, delete, equal, replace ]
   * ```
   *
   * @param actions Actions array which is a result of the {@link module:utils/diff~diff} function.
   * @param actualDom Actual DOM children
   * @param expectedDom Expected DOM children.
   * @param comparator A comparator function that should return `true` if the given node should be reused
   * (either by the update of a text node data or an element children list for similar elements).
   * @returns Actions array modified with the `update` actions.
   */
  _findUpdateActions(actions, actualDom, expectedDom, comparator) {
    if (actions.indexOf("insert") === -1 || actions.indexOf("delete") === -1) {
      return actions;
    }
    let newActions = [];
    let actualSlice = [];
    let expectedSlice = [];
    const counter = { equal: 0, insert: 0, delete: 0 };
    for (const action of actions) {
      if (action === "insert") {
        expectedSlice.push(expectedDom[counter.equal + counter.insert]);
      } else if (action === "delete") {
        actualSlice.push(actualDom[counter.equal + counter.delete]);
      } else {
        newActions = newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action2) => action2 === "equal" ? "update" : action2));
        newActions.push("equal");
        actualSlice = [];
        expectedSlice = [];
      }
      counter[action]++;
    }
    return newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action) => action === "equal" ? "update" : action));
  }
  /**
   * Checks if text needs to be updated and possibly updates it by removing and inserting only parts
   * of the data from the existing text node to reduce impact on the IME composition.
   *
   * @param domText DOM text node to update.
   * @param expectedText The expected data of a text node.
   */
  _updateTextNode(domText, expectedText) {
    const actualText = domText.data;
    if (actualText == expectedText) {
      return;
    }
    if (env_default.isAndroid && this.isComposing && actualText.replace(/\u00A0/g, " ") == expectedText.replace(/\u00A0/g, " ")) {
      return;
    }
    this._updateTextNodeInternal(domText, expectedText);
  }
  /**
   * Part of the `_updateTextNode` method extracted for easier testing.
   */
  _updateTextNodeInternal(domText, expectedText) {
    const actions = fastDiff(domText.data, expectedText);
    for (const action of actions) {
      if (action.type === "insert") {
        domText.insertData(action.index, action.values.join(""));
      } else {
        domText.deleteData(action.index, action.howMany);
      }
    }
  }
  /**
   * Marks text nodes to be synchronized.
   *
   * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.
   *
   * @param viewNode View node to sync.
   */
  _markDescendantTextToSync(viewNode) {
    if (!viewNode) {
      return;
    }
    if (viewNode.is("$text")) {
      this.markedTexts.add(viewNode);
    } else if (viewNode.is("element")) {
      for (const child of viewNode.getChildren()) {
        this._markDescendantTextToSync(child);
      }
    }
  }
  /**
   * Checks if the selection needs to be updated and possibly updates it.
   */
  _updateSelection() {
    if (env_default.isBlink && !env_default.isAndroid && this.isSelecting && !this.markedChildren.size) {
      return;
    }
    if (this.selection.rangeCount === 0) {
      this._removeDomSelection();
      this._removeFakeSelection();
      return;
    }
    const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement);
    if (!this.isFocused || !domRoot) {
      return;
    }
    if (this.selection.isFake) {
      this._updateFakeSelection(domRoot);
    } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
      this._removeFakeSelection();
      this._updateDomSelection(domRoot);
    } else if (!(this.isComposing && env_default.isAndroid)) {
      this._updateDomSelection(domRoot);
    }
  }
  /**
   * Updates the fake selection.
   *
   * @param domRoot A valid DOM root where the fake selection container should be added.
   */
  _updateFakeSelection(domRoot) {
    const domDocument = domRoot.ownerDocument;
    if (!this._fakeSelectionContainer) {
      this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);
    }
    const container = this._fakeSelectionContainer;
    this.domConverter.bindFakeSelection(container, this.selection);
    if (!this._fakeSelectionNeedsUpdate(domRoot)) {
      return;
    }
    if (!container.parentElement || container.parentElement != domRoot) {
      domRoot.appendChild(container);
    }
    container.textContent = this.selection.fakeSelectionLabel || "";
    const domSelection = domDocument.getSelection();
    const domRange = domDocument.createRange();
    domSelection.removeAllRanges();
    domRange.selectNodeContents(container);
    domSelection.addRange(domRange);
  }
  /**
   * Updates the DOM selection.
   *
   * @param domRoot A valid DOM root where the DOM selection should be rendered.
   */
  _updateDomSelection(domRoot) {
    const domSelection = domRoot.ownerDocument.defaultView.getSelection();
    if (!this._domSelectionNeedsUpdate(domSelection)) {
      return;
    }
    const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);
    const focus = this.domConverter.viewPositionToDom(this.selection.focus);
    domSelection.setBaseAndExtent(anchor.parent, anchor.offset, focus.parent, focus.offset);
    if (env_default.isGecko) {
      fixGeckoSelectionAfterBr(focus, domSelection);
    }
  }
  /**
   * Checks whether a given DOM selection needs to be updated.
   *
   * @param domSelection The DOM selection to check.
   */
  _domSelectionNeedsUpdate(domSelection) {
    if (!this.domConverter.isDomSelectionCorrect(domSelection)) {
      return true;
    }
    const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);
    if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {
      return false;
    }
    if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {
      return false;
    }
    return true;
  }
  /**
   * Checks whether the fake selection needs to be updated.
   *
   * @param domRoot A valid DOM root where a new fake selection container should be added.
   */
  _fakeSelectionNeedsUpdate(domRoot) {
    const container = this._fakeSelectionContainer;
    const domSelection = domRoot.ownerDocument.getSelection();
    if (!container || container.parentElement !== domRoot) {
      return true;
    }
    if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {
      return true;
    }
    return container.textContent !== this.selection.fakeSelectionLabel;
  }
  /**
   * Removes the DOM selection.
   */
  _removeDomSelection() {
    for (const doc of this.domDocuments) {
      const domSelection = doc.getSelection();
      if (domSelection.rangeCount) {
        const activeDomElement = doc.activeElement;
        const viewElement = this.domConverter.mapDomToView(activeDomElement);
        if (activeDomElement && viewElement) {
          domSelection.removeAllRanges();
        }
      }
    }
  }
  /**
   * Removes the fake selection.
   */
  _removeFakeSelection() {
    const container = this._fakeSelectionContainer;
    if (container) {
      container.remove();
    }
  }
  /**
   * Checks if focus needs to be updated and possibly updates it.
   */
  _updateFocus() {
    if (this.isFocused) {
      const editable = this.selection.editableElement;
      if (editable) {
        this.domConverter.focus(editable);
      }
    }
  }
};
function isEditable(element) {
  if (element.getAttribute("contenteditable") == "false") {
    return false;
  }
  const parent = element.findAncestor((element2) => element2.hasAttribute("contenteditable"));
  return !parent || parent.getAttribute("contenteditable") == "true";
}
function addInlineFiller(domDocument, domParentOrArray, offset) {
  const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;
  const nodeAfterFiller = childNodes[offset];
  if (isText(nodeAfterFiller)) {
    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;
    return nodeAfterFiller;
  } else {
    const fillerNode = domDocument.createTextNode(INLINE_FILLER);
    if (Array.isArray(domParentOrArray)) {
      childNodes.splice(offset, 0, fillerNode);
    } else {
      insertAt(domParentOrArray, offset, fillerNode);
    }
    return fillerNode;
  }
}
function areSimilarElements(node1, node2) {
  return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && !isComment(node1) && !isComment(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();
}
function areTextNodes(node1, node2) {
  return isNode(node1) && isNode(node2) && isText(node1) && isText(node2);
}
function sameNodes(domConverter, actualDomChild, expectedDomChild) {
  if (actualDomChild === expectedDomChild) {
    return true;
  } else if (isText(actualDomChild) && isText(expectedDomChild)) {
    return actualDomChild.data === expectedDomChild.data;
  } else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {
    return true;
  }
  return false;
}
function fixGeckoSelectionAfterBr(focus, domSelection) {
  let parent = focus.parent;
  let offset = focus.offset;
  if (isText(parent) && isInlineFiller(parent)) {
    offset = indexOf(parent) + 1;
    parent = parent.parentNode;
  }
  if (parent.nodeType != Node.ELEMENT_NODE || offset != parent.childNodes.length - 1) {
    return;
  }
  const childAtOffset = parent.childNodes[offset];
  if (childAtOffset && childAtOffset.tagName == "BR") {
    domSelection.addRange(domSelection.getRangeAt(0));
  }
}
function filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {
  const childList = Array.from(domChildList);
  if (childList.length == 0 || !fakeSelectionContainer) {
    return childList;
  }
  const last = childList[childList.length - 1];
  if (last == fakeSelectionContainer) {
    childList.pop();
  }
  return childList;
}
function createFakeSelectionContainer(domDocument) {
  const container = domDocument.createElement("div");
  container.className = "ck-fake-selection-container";
  Object.assign(container.style, {
    position: "fixed",
    top: 0,
    left: "-9999px",
    // See https://github.com/ckeditor/ckeditor5/issues/752.
    width: "42px"
  });
  container.textContent = "";
  return container;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js
var BR_FILLER_REF = BR_FILLER(global_default.document);
var NBSP_FILLER_REF = NBSP_FILLER(global_default.document);
var MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(global_default.document);
var UNSAFE_ATTRIBUTE_NAME_PREFIX = "data-ck-unsafe-attribute-";
var UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = "data-ck-unsafe-element";
var DomConverter = class {
  /**
   * Creates a DOM converter.
   *
   * @param document The view document instance.
   * @param options An object with configuration options.
   * @param options.blockFillerMode The type of the block filler to use.
   * Default value depends on the options.renderingMode:
   *  'nbsp' when options.renderingMode == 'data',
   *  'br' when options.renderingMode == 'editing'.
   * @param options.renderingMode Whether to leave the View-to-DOM conversion result unchanged
   * or improve editing experience by filtering out interactive data.
   */
  constructor(document2, { blockFillerMode, renderingMode = "editing" } = {}) {
    this._domToViewMapping = /* @__PURE__ */ new WeakMap();
    this._viewToDomMapping = /* @__PURE__ */ new WeakMap();
    this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap();
    this._rawContentElementMatcher = new Matcher();
    this._inlineObjectElementMatcher = new Matcher();
    this._elementsWithTemporaryCustomProperties = /* @__PURE__ */ new Set();
    this.document = document2;
    this.renderingMode = renderingMode;
    this.blockFillerMode = blockFillerMode || (renderingMode === "editing" ? "br" : "nbsp");
    this.preElements = ["pre", "textarea"];
    this.blockElements = [
      "address",
      "article",
      "aside",
      "blockquote",
      "caption",
      "center",
      "dd",
      "details",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "legend",
      "li",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr",
      "ul"
    ];
    this.inlineObjectElements = [
      "object",
      "iframe",
      "input",
      "button",
      "textarea",
      "select",
      "option",
      "video",
      "embed",
      "audio",
      "img",
      "canvas"
    ];
    this.unsafeElements = ["script", "style"];
    this._domDocument = this.renderingMode === "editing" ? global_default.document : global_default.document.implementation.createHTMLDocument("");
  }
  /**
   * Binds a given DOM element that represents fake selection to a **position** of a
   * {@link module:engine/view/documentselection~DocumentSelection document selection}.
   * Document selection copy is stored and can be retrieved by the
   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.
   */
  bindFakeSelection(domElement, viewDocumentSelection) {
    this._fakeSelectionMapping.set(domElement, new Selection(viewDocumentSelection));
  }
  /**
   * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given
   * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.
   */
  fakeSelectionToView(domElement) {
    return this._fakeSelectionMapping.get(domElement);
  }
  /**
   * Binds DOM and view elements, so it will be possible to get corresponding elements using
   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
   *
   * @param domElement The DOM element to bind.
   * @param viewElement The view element to bind.
   */
  bindElements(domElement, viewElement) {
    this._domToViewMapping.set(domElement, viewElement);
    this._viewToDomMapping.set(viewElement, domElement);
  }
  /**
   * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of
   * the DOM element will be unbound too.
   *
   * @param domElement The DOM element to unbind.
   */
  unbindDomElement(domElement) {
    const viewElement = this._domToViewMapping.get(domElement);
    if (viewElement) {
      this._domToViewMapping.delete(domElement);
      this._viewToDomMapping.delete(viewElement);
      for (const child of domElement.children) {
        this.unbindDomElement(child);
      }
    }
  }
  /**
   * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using
   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
   *
   * @param domFragment The DOM document fragment to bind.
   * @param viewFragment The view document fragment to bind.
   */
  bindDocumentFragments(domFragment, viewFragment) {
    this._domToViewMapping.set(domFragment, viewFragment);
    this._viewToDomMapping.set(viewFragment, domFragment);
  }
  /**
   * Decides whether a given pair of attribute key and value should be passed further down the pipeline.
   *
   * @param elementName Element name in lower case.
   */
  shouldRenderAttribute(attributeKey, attributeValue, elementName) {
    if (this.renderingMode === "data") {
      return true;
    }
    attributeKey = attributeKey.toLowerCase();
    if (attributeKey.startsWith("on")) {
      return false;
    }
    if (attributeKey === "srcdoc" && attributeValue.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
      return false;
    }
    if (elementName === "img" && (attributeKey === "src" || attributeKey === "srcset")) {
      return true;
    }
    if (elementName === "source" && attributeKey === "srcset") {
      return true;
    }
    if (attributeValue.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
      return false;
    }
    return true;
  }
  /**
   * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.
   *
   * @param domElement DOM element that should have `html` set as its content.
   * @param html Textual representation of the HTML that will be set on `domElement`.
   */
  setContentOf(domElement, html2) {
    if (this.renderingMode === "data") {
      domElement.innerHTML = html2;
      return;
    }
    const document2 = new DOMParser().parseFromString(html2, "text/html");
    const fragment = document2.createDocumentFragment();
    const bodyChildNodes = document2.body.childNodes;
    while (bodyChildNodes.length > 0) {
      fragment.appendChild(bodyChildNodes[0]);
    }
    const treeWalker = document2.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);
    const nodes = [];
    let currentNode;
    while (currentNode = treeWalker.nextNode()) {
      nodes.push(currentNode);
    }
    for (const currentNode2 of nodes) {
      for (const attributeName of currentNode2.getAttributeNames()) {
        this.setDomElementAttribute(currentNode2, attributeName, currentNode2.getAttribute(attributeName));
      }
      const elementName = currentNode2.tagName.toLowerCase();
      if (this._shouldRenameElement(elementName)) {
        _logUnsafeElement(elementName);
        currentNode2.replaceWith(this._createReplacementDomElement(elementName, currentNode2));
      }
    }
    while (domElement.firstChild) {
      domElement.firstChild.remove();
    }
    domElement.append(fragment);
  }
  /**
   * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments the method will return corresponding items.
   *
   * @param viewNode View node or document fragment to transform.
   * @param options Conversion options.
   * @param options.bind Determines whether new elements will be bound.
   * @param options.withChildren If `false`, node's and document fragment's children will not be converted.
   * @returns Converted node or DocumentFragment.
   */
  viewToDom(viewNode, options = {}) {
    if (viewNode.is("$text")) {
      const textData = this._processDataFromViewText(viewNode);
      return this._domDocument.createTextNode(textData);
    } else {
      const viewElementOrFragment = viewNode;
      if (this.mapViewToDom(viewElementOrFragment)) {
        if (viewElementOrFragment.getCustomProperty("editingPipeline:doNotReuseOnce")) {
          this._elementsWithTemporaryCustomProperties.add(viewElementOrFragment);
        } else {
          return this.mapViewToDom(viewElementOrFragment);
        }
      }
      let domElement;
      if (viewElementOrFragment.is("documentFragment")) {
        domElement = this._domDocument.createDocumentFragment();
        if (options.bind) {
          this.bindDocumentFragments(domElement, viewElementOrFragment);
        }
      } else if (viewElementOrFragment.is("uiElement")) {
        if (viewElementOrFragment.name === "$comment") {
          domElement = this._domDocument.createComment(viewElementOrFragment.getCustomProperty("$rawContent"));
        } else {
          domElement = viewElementOrFragment.render(this._domDocument, this);
        }
        if (options.bind) {
          this.bindElements(domElement, viewElementOrFragment);
        }
        return domElement;
      } else {
        if (this._shouldRenameElement(viewElementOrFragment.name)) {
          _logUnsafeElement(viewElementOrFragment.name);
          domElement = this._createReplacementDomElement(viewElementOrFragment.name);
        } else if (viewElementOrFragment.hasAttribute("xmlns")) {
          domElement = this._domDocument.createElementNS(viewElementOrFragment.getAttribute("xmlns"), viewElementOrFragment.name);
        } else {
          domElement = this._domDocument.createElement(viewElementOrFragment.name);
        }
        if (viewElementOrFragment.is("rawElement")) {
          viewElementOrFragment.render(domElement, this);
        }
        if (options.bind) {
          this.bindElements(domElement, viewElementOrFragment);
        }
        for (const key of viewElementOrFragment.getAttributeKeys()) {
          this.setDomElementAttribute(domElement, key, viewElementOrFragment.getAttribute(key), viewElementOrFragment);
        }
      }
      if (options.withChildren !== false) {
        for (const child of this.viewChildrenToDom(viewElementOrFragment, options)) {
          if (domElement instanceof HTMLTemplateElement) {
            domElement.content.appendChild(child);
          } else {
            domElement.appendChild(child);
          }
        }
      }
      return domElement;
    }
  }
  /**
   * Sets the attribute on a DOM element.
   *
   * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.
   *
   * @param domElement The DOM element the attribute should be set on.
   * @param key The name of the attribute.
   * @param value The value of the attribute.
   * @param relatedViewElement The view element related to the `domElement` (if there is any).
   * It helps decide whether the attribute set is unsafe. For instance, view elements created via the
   * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.
   */
  setDomElementAttribute(domElement, key, value, relatedViewElement) {
    const shouldRenderAttribute = this.shouldRenderAttribute(key, value, domElement.tagName.toLowerCase()) || relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key);
    if (!shouldRenderAttribute) {
      logWarning("domconverter-unsafe-attribute-detected", { domElement, key, value });
    }
    if (!isValidAttributeName(key)) {
      logWarning("domconverter-invalid-attribute-detected", { domElement, key, value });
      return;
    }
    if (domElement.hasAttribute(key) && !shouldRenderAttribute) {
      domElement.removeAttribute(key);
    } else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key) && shouldRenderAttribute) {
      domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
    }
    domElement.setAttribute(shouldRenderAttribute ? key : UNSAFE_ATTRIBUTE_NAME_PREFIX + key, value);
  }
  /**
   * Removes an attribute from a DOM element.
   *
   * **Note**: To set the attribute, use {@link #setDomElementAttribute}.
   *
   * @param domElement The DOM element the attribute should be removed from.
   * @param key The name of the attribute.
   */
  removeDomElementAttribute(domElement, key) {
    if (key == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {
      return;
    }
    domElement.removeAttribute(key);
    domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
  }
  /**
   * Converts children of the view element to DOM using the
   * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
   * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
   *
   * @param viewElement Parent view element.
   * @param options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
   * @returns DOM nodes.
   */
  *viewChildrenToDom(viewElement, options = {}) {
    const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
    let offset = 0;
    for (const childView of viewElement.getChildren()) {
      if (fillerPositionOffset === offset) {
        yield this._getBlockFiller();
      }
      const transparentRendering = childView.is("element") && !!childView.getCustomProperty("dataPipeline:transparentRendering") && !first(childView.getAttributes());
      if (transparentRendering && this.renderingMode == "data") {
        if (childView.is("rawElement")) {
          const tempElement = this._domDocument.createElement(childView.name);
          childView.render(tempElement, this);
          yield* [...tempElement.childNodes];
        } else {
          yield* this.viewChildrenToDom(childView, options);
        }
      } else {
        if (transparentRendering) {
          logWarning("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: childView });
        }
        yield this.viewToDom(childView, options);
      }
      offset++;
    }
    if (fillerPositionOffset === offset) {
      yield this._getBlockFiller();
    }
  }
  /**
   * Converts view {@link module:engine/view/range~Range} to DOM range.
   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
   *
   * @param viewRange View range.
   * @returns DOM range.
   */
  viewRangeToDom(viewRange) {
    const domStart = this.viewPositionToDom(viewRange.start);
    const domEnd = this.viewPositionToDom(viewRange.end);
    const domRange = this._domDocument.createRange();
    domRange.setStart(domStart.parent, domStart.offset);
    domRange.setEnd(domEnd.parent, domEnd.offset);
    return domRange;
  }
  /**
   * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
   *
   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
   * If the converted position is directly before inline filler it is moved inside the filler.
   *
   * @param viewPosition View position.
   * @returns DOM position or `null` if view position could not be converted to DOM.
   * DOM position has two properties:
   * * `parent` - DOM position parent.
   * * `offset` - DOM position offset.
   */
  viewPositionToDom(viewPosition) {
    const viewParent = viewPosition.parent;
    if (viewParent.is("$text")) {
      const domParent = this.findCorrespondingDomText(viewParent);
      if (!domParent) {
        return null;
      }
      let offset = viewPosition.offset;
      if (startsWithFiller(domParent)) {
        offset += INLINE_FILLER_LENGTH;
      }
      return { parent: domParent, offset };
    } else {
      let domParent, domBefore, domAfter;
      if (viewPosition.offset === 0) {
        domParent = this.mapViewToDom(viewParent);
        if (!domParent) {
          return null;
        }
        domAfter = domParent.childNodes[0];
      } else {
        const nodeBefore = viewPosition.nodeBefore;
        domBefore = nodeBefore.is("$text") ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(nodeBefore);
        if (!domBefore) {
          return null;
        }
        domParent = domBefore.parentNode;
        domAfter = domBefore.nextSibling;
      }
      if (isText(domAfter) && startsWithFiller(domAfter)) {
        return { parent: domAfter, offset: INLINE_FILLER_LENGTH };
      }
      const offset = domBefore ? indexOf(domBefore) + 1 : 0;
      return { parent: domParent, offset };
    }
  }
  /**
   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
   * be created. For bound elements and document fragments function will return corresponding items. For
   * {@link module:engine/view/filler fillers} `null` will be returned.
   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
   *
   * @param domNode DOM node or document fragment to transform.
   * @param options Conversion options.
   * @param options.bind Determines whether new elements will be bound. False by default.
   * @param options.withChildren If `true`, node's and document fragment's children will be converted too. True by default.
   * @param options.keepOriginalCase If `false`, node's tag name will be converted to lower case. False by default.
   * @param options.skipComments If `false`, comment nodes will be converted to `$comment`
   * {@link module:engine/view/uielement~UIElement view UI elements}. False by default.
   * @returns Converted node or document fragment or `null` if DOM node is a {@link module:engine/view/filler filler}
   * or the given node is an empty text node.
   */
  domToView(domNode, options = {}) {
    const inlineNodes = [];
    const generator = this._domToView(domNode, options, inlineNodes);
    const node = generator.next().value;
    if (!node) {
      return null;
    }
    generator.next();
    this._processDomInlineNodes(null, inlineNodes, options);
    if (node.is("$text") && node.data.length == 0) {
      return null;
    }
    return node;
  }
  /**
   * Converts children of the DOM element to view nodes using
   * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
   * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
   *
   * @param domElement Parent DOM element.
   * @param options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   * @param inlineNodes An array that will be populated with inline nodes. It's used internally for whitespace processing.
   * @returns View nodes.
   */
  *domChildrenToView(domElement, options = {}, inlineNodes = []) {
    let childNodes = [];
    if (domElement instanceof HTMLTemplateElement) {
      childNodes = [...domElement.content.childNodes];
    } else {
      childNodes = [...domElement.childNodes];
    }
    for (let i = 0; i < childNodes.length; i++) {
      const domChild = childNodes[i];
      const generator = this._domToView(domChild, options, inlineNodes);
      const viewChild = generator.next().value;
      if (viewChild !== null) {
        if (this._isBlockViewElement(viewChild)) {
          this._processDomInlineNodes(domElement, inlineNodes, options);
        }
        yield viewChild;
        generator.next();
      }
    }
    this._processDomInlineNodes(domElement, inlineNodes, options);
  }
  /**
   * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
   * Ranges which cannot be converted will be omitted.
   *
   * @param domSelection DOM selection.
   * @returns View selection.
   */
  domSelectionToView(domSelection) {
    if (isGeckoRestrictedDomSelection(domSelection)) {
      return new Selection([]);
    }
    if (domSelection.rangeCount === 1) {
      let container = domSelection.getRangeAt(0).startContainer;
      if (isText(container)) {
        container = container.parentNode;
      }
      const viewSelection = this.fakeSelectionToView(container);
      if (viewSelection) {
        return viewSelection;
      }
    }
    const isBackward = this.isDomSelectionBackward(domSelection);
    const viewRanges = [];
    for (let i = 0; i < domSelection.rangeCount; i++) {
      const domRange = domSelection.getRangeAt(i);
      const viewRange = this.domRangeToView(domRange);
      if (viewRange) {
        viewRanges.push(viewRange);
      }
    }
    return new Selection(viewRanges, { backward: isBackward });
  }
  /**
   * Converts DOM Range to view {@link module:engine/view/range~Range}.
   * If the start or end position can not be converted `null` is returned.
   *
   * @param domRange DOM range.
   * @returns View range.
   */
  domRangeToView(domRange) {
    const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
    const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);
    if (viewStart && viewEnd) {
      return new Range(viewStart, viewEnd);
    }
    return null;
  }
  /**
   * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
   *
   * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
   * position of the filler will be converted and returned.
   *
   * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
   * that position will be converted to view position before that UIElement.
   *
   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
   *
   * @param domParent DOM position parent.
   * @param domOffset DOM position offset. You can skip it when converting the inline filler node.
   * @returns View position.
   */
  domPositionToView(domParent, domOffset = 0) {
    if (this.isBlockFiller(domParent)) {
      return this.domPositionToView(domParent.parentNode, indexOf(domParent));
    }
    const viewElement = this.mapDomToView(domParent);
    if (viewElement && (viewElement.is("uiElement") || viewElement.is("rawElement"))) {
      return Position._createBefore(viewElement);
    }
    if (isText(domParent)) {
      if (isInlineFiller(domParent)) {
        return this.domPositionToView(domParent.parentNode, indexOf(domParent));
      }
      const viewParent = this.findCorrespondingViewText(domParent);
      let offset = domOffset;
      if (!viewParent) {
        return null;
      }
      if (startsWithFiller(domParent)) {
        offset -= INLINE_FILLER_LENGTH;
        offset = offset < 0 ? 0 : offset;
      }
      return new Position(viewParent, offset);
    } else {
      if (domOffset === 0) {
        const viewParent = this.mapDomToView(domParent);
        if (viewParent) {
          return new Position(viewParent, 0);
        }
      } else {
        const domBefore = domParent.childNodes[domOffset - 1];
        if (isText(domBefore) && isInlineFiller(domBefore) || domBefore && this.isBlockFiller(domBefore)) {
          return this.domPositionToView(domBefore.parentNode, indexOf(domBefore));
        }
        const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore);
        if (viewBefore && viewBefore.parent) {
          return new Position(viewBefore.parent, viewBefore.index + 1);
        }
      }
      return null;
    }
  }
  /**
   * Returns corresponding view {@link module:engine/view/element~Element Element} or
   * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
   * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * to the given DOM - `undefined` is returned.
   *
   * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or
   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
   *
   * @param domElementOrDocumentFragment DOM element or document fragment.
   * @returns Corresponding view element, document fragment or `undefined` if no element was bound.
   */
  mapDomToView(domElementOrDocumentFragment) {
    const hostElement = this.getHostViewElement(domElementOrDocumentFragment);
    return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);
  }
  /**
   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or
   * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
   *
   * Otherwise `null` is returned.
   *
   * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
   *
   * @param domText DOM text node.
   * @returns Corresponding view text node or `null`, if it was not possible to find a corresponding node.
   */
  findCorrespondingViewText(domText) {
    if (isInlineFiller(domText)) {
      return null;
    }
    const hostElement = this.getHostViewElement(domText);
    if (hostElement) {
      return hostElement;
    }
    const previousSibling = domText.previousSibling;
    if (previousSibling) {
      if (!this.isElement(previousSibling)) {
        return null;
      }
      const viewElement = this.mapDomToView(previousSibling);
      if (viewElement) {
        const nextSibling = viewElement.nextSibling;
        if (nextSibling instanceof Text) {
          return nextSibling;
        } else {
          return null;
        }
      }
    } else {
      const viewElement = this.mapDomToView(domText.parentNode);
      if (viewElement) {
        const firstChild = viewElement.getChild(0);
        if (firstChild instanceof Text) {
          return firstChild;
        } else {
          return null;
        }
      }
    }
    return null;
  }
  mapViewToDom(documentFragmentOrElement) {
    return this._viewToDomMapping.get(documentFragmentOrElement);
  }
  /**
   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
   * corresponding text node is returned based on the sibling or parent.
   *
   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
   * to find the corresponding text node.
   *
   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
   * element, it is used to find the corresponding text node.
   *
   * Otherwise `null` is returned.
   *
   * @param viewText View text node.
   * @returns Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
   */
  findCorrespondingDomText(viewText) {
    const previousSibling = viewText.previousSibling;
    if (previousSibling && this.mapViewToDom(previousSibling)) {
      return this.mapViewToDom(previousSibling).nextSibling;
    }
    if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {
      return this.mapViewToDom(viewText.parent).childNodes[0];
    }
    return null;
  }
  /**
   * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
   */
  focus(viewEditable) {
    const domEditable = this.mapViewToDom(viewEditable);
    if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {
      const { scrollX, scrollY } = global_default.window;
      const scrollPositions = [];
      forEachDomElementAncestor(domEditable, (node) => {
        const { scrollLeft, scrollTop } = node;
        scrollPositions.push([scrollLeft, scrollTop]);
      });
      domEditable.focus();
      forEachDomElementAncestor(domEditable, (node) => {
        const [scrollLeft, scrollTop] = scrollPositions.shift();
        node.scrollLeft = scrollLeft;
        node.scrollTop = scrollTop;
      });
      global_default.window.scrollTo(scrollX, scrollY);
    }
  }
  /**
   * Remove DOM selection from blurred editable, so it won't interfere with clicking on dropdowns (especially on iOS).
   *
   * @internal
   */
  _clearDomSelection() {
    const domEditable = this.mapViewToDom(this.document.selection.editableElement);
    if (!domEditable) {
      return;
    }
    const domSelection = domEditable.ownerDocument.defaultView.getSelection();
    const newViewSelection = this.domSelectionToView(domSelection);
    const selectionInEditable = newViewSelection && newViewSelection.rangeCount > 0;
    if (selectionInEditable) {
      domSelection.removeAllRanges();
    }
  }
  /**
   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
   *
   * @param node Node to check.
   */
  isElement(node) {
    return node && node.nodeType == Node.ELEMENT_NODE;
  }
  /**
   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
   *
   * @param node Node to check.
   */
  isDocumentFragment(node) {
    return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
  }
  /**
   * Checks if the node is an instance of the block filler for this DOM converter.
   *
   * ```ts
   * const converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );
   *
   * converter.isBlockFiller( BR_FILLER( document ) ); // true
   * converter.isBlockFiller( NBSP_FILLER( document ) ); // false
   * ```
   *
   * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
   *
   * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
   *
   * @param domNode DOM node to check.
   * @returns True if a node is considered a block filler for given mode.
   */
  isBlockFiller(domNode) {
    if (this.blockFillerMode == "br") {
      return domNode.isEqualNode(BR_FILLER_REF);
    }
    if (domNode.tagName === "BR" && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {
      return true;
    }
    return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);
  }
  /**
   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
   *
   * @param DOM Selection instance to check.
   */
  isDomSelectionBackward(selection) {
    if (selection.isCollapsed) {
      return false;
    }
    const range = this._domDocument.createRange();
    try {
      range.setStart(selection.anchorNode, selection.anchorOffset);
      range.setEnd(selection.focusNode, selection.focusOffset);
    } catch (e) {
      return false;
    }
    const backward = range.collapsed;
    range.detach();
    return backward;
  }
  /**
   * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}
   * that hosts the provided DOM node. Returns `null` if there is no such parent.
   */
  getHostViewElement(domNode) {
    const ancestors = getAncestors(domNode);
    ancestors.pop();
    while (ancestors.length) {
      const domNode2 = ancestors.pop();
      const viewNode = this._domToViewMapping.get(domNode2);
      if (viewNode && (viewNode.is("uiElement") || viewNode.is("rawElement"))) {
        return viewNode;
      }
    }
    return null;
  }
  /**
   * Checks if the given selection's boundaries are at correct places.
   *
   * The following places are considered as incorrect for selection boundaries:
   *
   * * before or in the middle of an inline filler sequence,
   * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},
   * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.
   *
   * @param domSelection The DOM selection object to be checked.
   * @returns `true` if the given selection is at a correct place, `false` otherwise.
   */
  isDomSelectionCorrect(domSelection) {
    return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from DOM nodes to view elements.
   *
   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching a view element whose content should
   * be treated as raw data.
   */
  registerRawContentMatcher(pattern) {
    this._rawContentElementMatcher.add(pattern);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for inline object view elements.
   *
   * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
   * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
   *
   * This is an extension of a simple {@link #inlineObjectElements} array of element names.
   *
   * @param pattern Pattern matching a view element which should be treated as an inline object.
   */
  registerInlineObjectMatcher(pattern) {
    this._inlineObjectElementMatcher.add(pattern);
  }
  /**
   * Clear temporary custom properties.
   *
   * @internal
   */
  _clearTemporaryCustomProperties() {
    for (const element of this._elementsWithTemporaryCustomProperties) {
      element._removeCustomProperty("editingPipeline:doNotReuseOnce");
    }
    this._elementsWithTemporaryCustomProperties.clear();
  }
  /**
   * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.
   */
  _getBlockFiller() {
    switch (this.blockFillerMode) {
      case "nbsp":
        return NBSP_FILLER(this._domDocument);
      case "markedNbsp":
        return MARKED_NBSP_FILLER(this._domDocument);
      case "br":
        return BR_FILLER(this._domDocument);
    }
  }
  /**
   * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
   *
   * @param domParent Position parent.
   * @param offset Position offset.
   * @returns `true` if given position is at a correct place for selection boundary, `false` otherwise.
   */
  _isDomSelectionPositionCorrect(domParent, offset) {
    if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {
      return false;
    }
    if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {
      return false;
    }
    const viewParent = this.mapDomToView(domParent);
    if (viewParent && (viewParent.is("uiElement") || viewParent.is("rawElement"))) {
      return false;
    }
    return true;
  }
  /**
   * Internal generator for {@link #domToView}. Also used by {@link #domChildrenToView}.
   * Separates DOM nodes conversion from whitespaces processing.
   *
   * @param domNode DOM node or document fragment to transform.
   * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
   * Used later to process whitespaces.
   */
  *_domToView(domNode, options, inlineNodes) {
    if (this.isBlockFiller(domNode)) {
      return null;
    }
    const hostElement = this.getHostViewElement(domNode);
    if (hostElement) {
      return hostElement;
    }
    if (isComment(domNode) && options.skipComments) {
      return null;
    }
    if (isText(domNode)) {
      if (isInlineFiller(domNode)) {
        return null;
      } else {
        const textData = domNode.data;
        if (textData === "") {
          return null;
        }
        const textNode = new Text(this.document, textData);
        inlineNodes.push(textNode);
        return textNode;
      }
    } else {
      let viewElement = this.mapDomToView(domNode);
      if (viewElement) {
        if (this._isInlineObjectElement(viewElement)) {
          inlineNodes.push(viewElement);
        }
        return viewElement;
      }
      if (this.isDocumentFragment(domNode)) {
        viewElement = new DocumentFragment(this.document);
        if (options.bind) {
          this.bindDocumentFragments(domNode, viewElement);
        }
      } else {
        viewElement = this._createViewElement(domNode, options);
        if (options.bind) {
          this.bindElements(domNode, viewElement);
        }
        const attrs = domNode.attributes;
        if (attrs) {
          for (let l = attrs.length, i = 0; i < l; i++) {
            viewElement._setAttribute(attrs[i].name, attrs[i].value);
          }
        }
        if (this._isViewElementWithRawContent(viewElement, options)) {
          viewElement._setCustomProperty("$rawContent", domNode.innerHTML);
          if (!this._isBlockViewElement(viewElement)) {
            inlineNodes.push(viewElement);
          }
          return viewElement;
        }
        if (isComment(domNode)) {
          viewElement._setCustomProperty("$rawContent", domNode.data);
          return viewElement;
        }
      }
      yield viewElement;
      const nestedInlineNodes = [];
      if (options.withChildren !== false) {
        for (const child of this.domChildrenToView(domNode, options, nestedInlineNodes)) {
          viewElement._appendChild(child);
        }
      }
      if (this._isInlineObjectElement(viewElement)) {
        inlineNodes.push(viewElement);
        this._processDomInlineNodes(null, nestedInlineNodes, options);
      } else {
        for (const inlineNode of nestedInlineNodes) {
          inlineNodes.push(inlineNode);
        }
      }
    }
  }
  /**
   * Internal helper that walks the list of inline view nodes already generated from DOM nodes
   * and handles whitespaces and NBSPs.
   *
   * @param domParent The DOM parent of the given inline nodes. This should be a document fragment or
   * a block element to whitespace processing start cleaning.
   * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
   */
  _processDomInlineNodes(domParent, inlineNodes, options) {
    if (!inlineNodes.length) {
      return;
    }
    if (domParent && !this.isDocumentFragment(domParent) && !this._isBlockDomElement(domParent)) {
      return;
    }
    let prevNodeEndsWithSpace = false;
    for (let i = 0; i < inlineNodes.length; i++) {
      const node = inlineNodes[i];
      if (!node.is("$text")) {
        prevNodeEndsWithSpace = false;
        continue;
      }
      let data;
      let nodeEndsWithSpace = false;
      if (this._isPreFormatted(node)) {
        data = getDataWithoutFiller(node.data);
      } else {
        data = node.data.replace(/[ \n\t\r]{1,}/g, " ");
        nodeEndsWithSpace = /[^\S\u00A0]/.test(data.charAt(data.length - 1));
        const prevNode = i > 0 ? inlineNodes[i - 1] : null;
        const nextNode = i + 1 < inlineNodes.length ? inlineNodes[i + 1] : null;
        const shouldLeftTrim = !prevNode || prevNode.is("element") && prevNode.name == "br" || prevNodeEndsWithSpace;
        const shouldRightTrim = nextNode ? false : !startsWithFiller(node.data);
        if (options.withChildren !== false) {
          if (shouldLeftTrim) {
            data = data.replace(/^ /, "");
          }
          if (shouldRightTrim) {
            data = data.replace(/ $/, "");
          }
        }
        data = getDataWithoutFiller(data);
        data = data.replace(/ \u00A0/g, "  ");
        const isNextNodeInlineObjectElement = nextNode && nextNode.is("element") && nextNode.name != "br";
        const isNextNodeStartingWithSpace = nextNode && nextNode.is("$text") && nextNode.data.charAt(0) == " ";
        if (/[ \u00A0]\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {
          data = data.replace(/\u00A0$/, " ");
        }
        if (shouldLeftTrim || prevNode && prevNode.is("element") && prevNode.name != "br") {
          data = data.replace(/^\u00A0/, " ");
        }
      }
      if (data.length == 0 && node.parent) {
        node._remove();
        inlineNodes.splice(i, 1);
        i--;
      } else {
        node._data = data;
        prevNodeEndsWithSpace = nodeEndsWithSpace;
      }
    }
    inlineNodes.length = 0;
  }
  /**
   * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
   * it is correctly displayed in the DOM.
   *
   * Following changes are done:
   *
   * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
   * element or if a previous text node ends with a space character,
   * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
   * starts with a space or if it is the last text node in its container,
   * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
   *
   * Content of {@link #preElements} is not processed.
   *
   * @param node View text node to process.
   * @returns Processed text data.
   */
  _processDataFromViewText(node) {
    let data = node.data;
    if (this._isPreFormatted(node)) {
      return data;
    }
    if (data.charAt(0) == " ") {
      const prevNode = this._getTouchingInlineViewNode(node, false);
      const prevEndsWithSpace = prevNode && prevNode.is("$textProxy") && this._nodeEndsWithSpace(prevNode);
      if (prevEndsWithSpace || !prevNode) {
        data = "" + data.substr(1);
      }
    }
    if (data.charAt(data.length - 1) == " ") {
      const nextNode = this._getTouchingInlineViewNode(node, true);
      const nextStartsWithSpace = nextNode && nextNode.is("$textProxy") && nextNode.data.charAt(0) == " ";
      if (data.charAt(data.length - 2) == " " || !nextNode || nextStartsWithSpace) {
        data = data.substr(0, data.length - 1) + "";
      }
    }
    return data.replace(/ {2}/g, " ");
  }
  /**
   * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
   *
   * @param  node Node to check.
   * @returns `true` if given `node` ends with space, `false` otherwise.
   */
  _nodeEndsWithSpace(node) {
    if (this._isPreFormatted(node)) {
      return false;
    }
    const data = this._processDataFromViewText(node);
    return data.charAt(data.length - 1) == " ";
  }
  /**
   * Checks whether given text contains preformatted white space. This is the case if
   * * any of node ancestors has a name which is in `preElements` array, or
   * * the closest ancestor that has the `white-space` CSS property sets it to a value that preserves spaces
   *
   * @param node Node to check
   * @returns `true` if given node contains preformatted white space, `false` otherwise.
   */
  _isPreFormatted(node) {
    if (_hasViewParentOfType(node, this.preElements)) {
      return true;
    }
    for (const ancestor of node.getAncestors({ parentFirst: true })) {
      if (!ancestor.is("element") || !ancestor.hasStyle("white-space") || ancestor.getStyle("white-space") === "inherit") {
        continue;
      }
      return ["pre", "pre-wrap", "break-spaces"].includes(ancestor.getStyle("white-space"));
    }
    return false;
  }
  /**
   * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
   * that is contained in the same container element. If there is no such sibling, `null` is returned.
   *
   * @param node Reference node.
   * @returns Touching text node, an inline object
   * or `null` if there is no next or previous touching text node.
   */
  _getTouchingInlineViewNode(node, getNext) {
    const treeWalker = new TreeWalker({
      startPosition: getNext ? Position._createAfter(node) : Position._createBefore(node),
      direction: getNext ? "forward" : "backward"
    });
    for (const { item } of treeWalker) {
      if (item.is("$textProxy")) {
        return item;
      } else if (item.is("element") && item.getCustomProperty("dataPipeline:transparentRendering")) {
        continue;
      } else if (item.is("element", "br")) {
        return null;
      } else if (this._isInlineObjectElement(item)) {
        return item;
      } else if (item.is("containerElement")) {
        return null;
      }
    }
    return null;
  }
  /**
   * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.
   */
  _isBlockDomElement(node) {
    return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());
  }
  /**
   * Returns `true` if a view node belongs to {@link #blockElements}. `false` otherwise.
   */
  _isBlockViewElement(node) {
    return node.is("element") && this.blockElements.includes(node.name);
  }
  /**
   * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.
   */
  _isInlineObjectElement(node) {
    if (!node.is("element")) {
      return false;
    }
    return node.name == "br" || this.inlineObjectElements.includes(node.name) || !!this._inlineObjectElementMatcher.match(node);
  }
  /**
   * Creates view element basing on the node type.
   *
   * @param node DOM node to check.
   * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   */
  _createViewElement(node, options) {
    if (isComment(node)) {
      return new UIElement(this.document, "$comment");
    }
    const viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();
    return new Element(this.document, viewName);
  }
  /**
   * Checks if view element's content should be treated as a raw data.
   *
   * @param viewElement View element to check.
   * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
   */
  _isViewElementWithRawContent(viewElement, options) {
    return options.withChildren !== false && viewElement.is("element") && !!this._rawContentElementMatcher.match(viewElement);
  }
  /**
   * Checks whether a given element name should be renamed in a current rendering mode.
   *
   * @param elementName The name of view element.
   */
  _shouldRenameElement(elementName) {
    const name = elementName.toLowerCase();
    return this.renderingMode === "editing" && this.unsafeElements.includes(name);
  }
  /**
   * Return a <span> element with a special attribute holding the name of the original element.
   * Optionally, copy all the attributes of the original element if that element is provided.
   *
   * @param elementName The name of view element.
   * @param originalDomElement The original DOM element to copy attributes and content from.
   */
  _createReplacementDomElement(elementName, originalDomElement) {
    const newDomElement = this._domDocument.createElement("span");
    newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);
    if (originalDomElement) {
      while (originalDomElement.firstChild) {
        newDomElement.appendChild(originalDomElement.firstChild);
      }
      for (const attributeName of originalDomElement.getAttributeNames()) {
        newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));
      }
    }
    return newDomElement;
  }
};
function _hasViewParentOfType(node, types) {
  return node.getAncestors().some((parent) => parent.is("element") && types.includes(parent.name));
}
function forEachDomElementAncestor(element, callback) {
  let node = element;
  while (node) {
    callback(node);
    node = node.parentElement;
  }
}
function isNbspBlockFiller(domNode, blockElements) {
  const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);
  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;
}
function hasBlockParent(domNode, blockElements) {
  const parent = domNode.parentNode;
  return !!parent && !!parent.tagName && blockElements.includes(parent.tagName.toLowerCase());
}
function _logUnsafeElement(elementName) {
  if (elementName === "script") {
    logWarning("domconverter-unsafe-script-element-detected");
  }
  if (elementName === "style") {
    logWarning("domconverter-unsafe-style-element-detected");
  }
}
function isGeckoRestrictedDomSelection(domSelection) {
  if (!env_default.isGecko) {
    return false;
  }
  if (!domSelection.rangeCount) {
    return false;
  }
  const container = domSelection.getRangeAt(0).startContainer;
  try {
    Object.prototype.toString.call(container);
  } catch (error) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/observer.js
var Observer = class extends DomEmitterMixin() {
  /**
   * Creates an instance of the observer.
   */
  constructor(view) {
    super();
    this._isEnabled = false;
    this.view = view;
    this.document = view.document;
  }
  /**
   * The state of the observer. If it is disabled, no events will be fired.
   */
  get isEnabled() {
    return this._isEnabled;
  }
  /**
   * Enables the observer. This method is called when the observer is registered to the
   * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
   * (all observers are {@link #disable disabled} before rendering).
   *
   * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
   * However, a child class may not need to be disabled, so it can implement an empty method.
   *
   * @see module:engine/view/observer/observer~Observer#disable
   */
  enable() {
    this._isEnabled = true;
  }
  /**
   * Disables the observer. This method is called before
   * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
   *
   * @see module:engine/view/observer/observer~Observer#enable
   */
  disable() {
    this._isEnabled = false;
  }
  /**
   * Disables and destroys the observer, among others removes event listeners created by the observer.
   */
  destroy() {
    this.disable();
    this.stopListening();
  }
  /**
   * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
   *
   * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
   * This attribute can be used inside the structures generated by
   * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `DowncastWriter#createUIElement()`} to ignore events
   * fired within a UI that should be excluded from CKEditor 5's realms.
   *
   * @param domTarget The DOM event target to check (usually an element, sometimes a text node and
   * potentially sometimes a document, too).
   * @returns Whether this event should be ignored by the observer.
   */
  checkShouldIgnoreEventFromTarget(domTarget) {
    if (domTarget && domTarget.nodeType === 3) {
      domTarget = domTarget.parentNode;
    }
    if (!domTarget || domTarget.nodeType !== 1) {
      return false;
    }
    return domTarget.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/domeventdata.js
var DomEventData = class {
  /**
   * @param view The instance of the view controller.
   * @param domEvent The DOM event.
   * @param additionalData Additional properties that the instance should contain.
   */
  constructor(view, domEvent, additionalData) {
    this.view = view;
    this.document = view.document;
    this.domEvent = domEvent;
    this.domTarget = domEvent.target;
    assignIn_default(this, additionalData);
  }
  /**
   * The tree view element representing the target.
   */
  get target() {
    return this.view.domConverter.mapDomToView(this.domTarget);
  }
  /**
   * Prevents the native's event default action.
   */
  preventDefault() {
    this.domEvent.preventDefault();
  }
  /**
   * Stops native event propagation.
   */
  stopPropagation() {
    this.domEvent.stopPropagation();
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/domeventobserver.js
var DomEventObserver = class extends Observer {
  constructor() {
    super(...arguments);
    this.useCapture = false;
    this.usePassive = false;
  }
  /**
   * @inheritDoc
   */
  observe(domElement) {
    const types = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
    types.forEach((type) => {
      this.listenTo(domElement, type, (eventInfo, domEvent) => {
        if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(domEvent.target)) {
          this.onDomEvent(domEvent);
        }
      }, { useCapture: this.useCapture, usePassive: this.usePassive });
    });
  }
  /**
   * @inheritDoc
   */
  stopObserving(domElement) {
    this.stopListening(domElement);
  }
  /**
   * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
   *
   * @see module:utils/emittermixin~Emitter#fire
   * @param eventType The event type (name).
   * @param domEvent The DOM event.
   * @param additionalData The additional data which should extend the
   * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
   */
  fire(eventType, domEvent, additionalData) {
    if (this.isEnabled) {
      this.document.fire(eventType, new DomEventData(this.view, domEvent, additionalData));
    }
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/keyobserver.js
var KeyObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    this.domEventType = ["keydown", "keyup"];
  }
  /**
   * @inheritDoc
   */
  onDomEvent(domEvt) {
    const data = {
      keyCode: domEvt.keyCode,
      altKey: domEvt.altKey,
      ctrlKey: domEvt.ctrlKey,
      shiftKey: domEvt.shiftKey,
      metaKey: domEvt.metaKey,
      get keystroke() {
        return getCode(this);
      }
    };
    this.fire(domEvt.type, domEvt, data);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/fakeselectionobserver.js
var FakeSelectionObserver = class extends Observer {
  /**
   * Creates new FakeSelectionObserver instance.
   */
  constructor(view) {
    super(view);
    this._fireSelectionChangeDoneDebounced = debounce_default((data) => {
      this.document.fire("selectionChangeDone", data);
    }, 200);
  }
  /**
   * @inheritDoc
   */
  observe() {
    const document2 = this.document;
    document2.on("arrowKey", (eventInfo, data) => {
      const selection = document2.selection;
      if (selection.isFake && this.isEnabled) {
        data.preventDefault();
      }
    }, { context: "$capture" });
    document2.on("arrowKey", (eventInfo, data) => {
      const selection = document2.selection;
      if (selection.isFake && this.isEnabled) {
        this._handleSelectionMove(data.keyCode);
      }
    }, { priority: "lowest" });
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._fireSelectionChangeDoneDebounced.cancel();
  }
  /**
   * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
   * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
   *
   * This method fires {@link module:engine/view/document~Document#event:selectionChange} and
   * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of
   * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
   */
  _handleSelectionMove(keyCode) {
    const selection = this.document.selection;
    const newSelection = new Selection(selection.getRanges(), { backward: selection.isBackward, fake: false });
    if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {
      newSelection.setTo(newSelection.getFirstPosition());
    }
    if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {
      newSelection.setTo(newSelection.getLastPosition());
    }
    const data = {
      oldSelection: selection,
      newSelection,
      domSelection: null
    };
    this.document.fire("selectionChange", data);
    this._fireSelectionChangeDoneDebounced(data);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mutationobserver.js
var MutationObserver2 = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    this._config = {
      childList: true,
      characterData: true,
      subtree: true
    };
    this.domConverter = view.domConverter;
    this._domElements = /* @__PURE__ */ new Set();
    this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
  }
  /**
   * Synchronously handles mutations and empties the queue.
   */
  flush() {
    this._onMutations(this._mutationObserver.takeRecords());
  }
  /**
   * @inheritDoc
   */
  observe(domElement) {
    this._domElements.add(domElement);
    if (this.isEnabled) {
      this._mutationObserver.observe(domElement, this._config);
    }
  }
  /**
   * @inheritDoc
   */
  stopObserving(domElement) {
    this._domElements.delete(domElement);
    if (this.isEnabled) {
      this._mutationObserver.disconnect();
      for (const domElement2 of this._domElements) {
        this._mutationObserver.observe(domElement2, this._config);
      }
    }
  }
  /**
   * @inheritDoc
   */
  enable() {
    super.enable();
    for (const domElement of this._domElements) {
      this._mutationObserver.observe(domElement, this._config);
    }
  }
  /**
   * @inheritDoc
   */
  disable() {
    super.disable();
    this._mutationObserver.disconnect();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._mutationObserver.disconnect();
  }
  /**
   * Handles mutations. Mark view elements to sync and call render.
   *
   * @param domMutations Array of native mutations.
   */
  _onMutations(domMutations) {
    if (domMutations.length === 0) {
      return;
    }
    const domConverter = this.domConverter;
    const mutatedTextNodes = /* @__PURE__ */ new Set();
    const elementsWithMutatedChildren = /* @__PURE__ */ new Set();
    for (const mutation of domMutations) {
      const element = domConverter.mapDomToView(mutation.target);
      if (!element) {
        continue;
      }
      if (element.is("uiElement") || element.is("rawElement")) {
        continue;
      }
      if (mutation.type === "childList" && !this._isBogusBrMutation(mutation)) {
        elementsWithMutatedChildren.add(element);
      }
    }
    for (const mutation of domMutations) {
      const element = domConverter.mapDomToView(mutation.target);
      if (element && (element.is("uiElement") || element.is("rawElement"))) {
        continue;
      }
      if (mutation.type === "characterData") {
        const text2 = domConverter.findCorrespondingViewText(mutation.target);
        if (text2 && !elementsWithMutatedChildren.has(text2.parent)) {
          mutatedTextNodes.add(text2);
        } else if (!text2 && startsWithFiller(mutation.target)) {
          elementsWithMutatedChildren.add(domConverter.mapDomToView(mutation.target.parentNode));
        }
      }
    }
    const mutations = [];
    for (const textNode of mutatedTextNodes) {
      mutations.push({ type: "text", node: textNode });
    }
    for (const viewElement of elementsWithMutatedChildren) {
      const domElement = domConverter.mapViewToDom(viewElement);
      const viewChildren = Array.from(viewElement.getChildren());
      const newViewChildren = Array.from(domConverter.domChildrenToView(domElement, { withChildren: false }));
      if (!isEqualWith_default(viewChildren, newViewChildren, sameNodes2)) {
        mutations.push({ type: "children", node: viewElement });
      }
    }
    if (mutations.length) {
      this.document.fire("mutations", { mutations });
    }
  }
  /**
   * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
   * Such mutations are generated while pressing space or performing native spellchecker correction
   * on the end of the block element in Firefox browser.
   *
   * @param mutation Native mutation object.
   */
  _isBogusBrMutation(mutation) {
    let addedNode = null;
    if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {
      addedNode = this.domConverter.domToView(mutation.addedNodes[0], {
        withChildren: false
      });
    }
    return addedNode && addedNode.is("element", "br");
  }
};
function sameNodes2(child1, child2) {
  if (Array.isArray(child1)) {
    return;
  }
  if (child1 === child2) {
    return true;
  } else if (child1.is("$text") && child2.is("$text")) {
    return child1.data === child2.data;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/focusobserver.js
var FocusObserver = class extends DomEventObserver {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    this._renderTimeoutId = null;
    this._isFocusChanging = false;
    this.domEventType = ["focus", "blur"];
    this.useCapture = true;
    const document2 = this.document;
    document2.on("focus", () => this._handleFocus());
    document2.on("blur", (evt, data) => this._handleBlur(data));
    document2.on("beforeinput", () => {
      if (!document2.isFocused) {
        this._handleFocus();
      }
    }, { priority: "highest" });
  }
  /**
   * Finishes setting the document focus state.
   */
  flush() {
    if (this._isFocusChanging) {
      this._isFocusChanging = false;
      this.document.isFocused = true;
    }
  }
  /**
   * @inheritDoc
   */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._clearTimeout();
    super.destroy();
  }
  /**
   * The `focus` event handler.
   */
  _handleFocus() {
    this._clearTimeout();
    this._isFocusChanging = true;
    this._renderTimeoutId = setTimeout(() => {
      this._renderTimeoutId = null;
      this.flush();
      this.view.change(() => {
      });
    }, 50);
  }
  /**
   * The `blur` event handler.
   */
  _handleBlur(data) {
    const selectedEditable = this.document.selection.editableElement;
    if (selectedEditable === null || selectedEditable === data.target) {
      this.document.isFocused = false;
      this._isFocusChanging = false;
      this.view.change(() => {
      });
    }
  }
  /**
   * Clears timeout.
   */
  _clearTimeout() {
    if (this._renderTimeoutId) {
      clearTimeout(this._renderTimeoutId);
      this._renderTimeoutId = null;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/selectionobserver.js
var SelectionObserver = class extends Observer {
  constructor(view) {
    super(view);
    this.mutationObserver = view.getObserver(MutationObserver2);
    this.focusObserver = view.getObserver(FocusObserver);
    this.selection = this.document.selection;
    this.domConverter = view.domConverter;
    this._documents = /* @__PURE__ */ new WeakSet();
    this._fireSelectionChangeDoneDebounced = debounce_default((data) => {
      this.document.fire("selectionChangeDone", data);
    }, 200);
    this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3);
    this._documentIsSelectingInactivityTimeoutDebounced = debounce_default(() => this.document.isSelecting = false, 5e3);
    this._loopbackCounter = 0;
  }
  /**
   * @inheritDoc
   */
  observe(domElement) {
    const domDocument = domElement.ownerDocument;
    const startDocumentIsSelecting = () => {
      this.document.isSelecting = true;
      this._documentIsSelectingInactivityTimeoutDebounced();
    };
    const endDocumentIsSelecting = () => {
      if (!this.document.isSelecting) {
        return;
      }
      this._handleSelectionChange(domDocument);
      this.document.isSelecting = false;
      this._documentIsSelectingInactivityTimeoutDebounced.cancel();
    };
    this.listenTo(domElement, "selectstart", startDocumentIsSelecting, { priority: "highest" });
    this.listenTo(domElement, "keydown", endDocumentIsSelecting, { priority: "highest", useCapture: true });
    this.listenTo(domElement, "keyup", endDocumentIsSelecting, { priority: "highest", useCapture: true });
    if (this._documents.has(domDocument)) {
      return;
    }
    this.listenTo(domDocument, "mouseup", endDocumentIsSelecting, { priority: "highest", useCapture: true });
    this.listenTo(domDocument, "selectionchange", () => {
      if (this.document.isComposing && !env_default.isAndroid) {
        return;
      }
      this._handleSelectionChange(domDocument);
      this._documentIsSelectingInactivityTimeoutDebounced();
    });
    this.listenTo(this.view.document, "compositionstart", () => {
      this._handleSelectionChange(domDocument);
    }, { priority: "lowest" });
    this._documents.add(domDocument);
  }
  /**
   * @inheritDoc
   */
  stopObserving(domElement) {
    this.stopListening(domElement);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    clearInterval(this._clearInfiniteLoopInterval);
    this._fireSelectionChangeDoneDebounced.cancel();
    this._documentIsSelectingInactivityTimeoutDebounced.cancel();
  }
  /* istanbul ignore next -- @preserve */
  _reportInfiniteLoop() {
  }
  /**
   * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
   * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change
   * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.
   *
   * @param domDocument DOM document.
   */
  _handleSelectionChange(domDocument) {
    if (!this.isEnabled) {
      return;
    }
    const domSelection = domDocument.defaultView.getSelection();
    if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {
      return;
    }
    this.mutationObserver.flush();
    const newViewSelection = this.domConverter.domSelectionToView(domSelection);
    if (newViewSelection.rangeCount == 0) {
      this.view.hasDomSelection = false;
      return;
    }
    this.view.hasDomSelection = true;
    this.focusObserver.flush();
    if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {
      return;
    }
    if (++this._loopbackCounter > 60) {
      this._reportInfiniteLoop();
      return;
    }
    if (this.selection.isSimilar(newViewSelection)) {
      this.view.forceRender();
    } else {
      const data = {
        oldSelection: this.selection,
        newSelection: newViewSelection,
        domSelection
      };
      this.document.fire("selectionChange", data);
      this._fireSelectionChangeDoneDebounced(data);
    }
  }
  /**
   * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
   */
  _clearInfiniteLoop() {
    this._loopbackCounter = 0;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/compositionobserver.js
var CompositionObserver = class extends DomEventObserver {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
    const document2 = this.document;
    document2.on("compositionstart", () => {
      document2.isComposing = true;
    }, { priority: "low" });
    document2.on("compositionend", () => {
      document2.isComposing = false;
    }, { priority: "low" });
  }
  /**
   * @inheritDoc
   */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent, {
      data: domEvent.data
    });
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/datatransfer.js
var DataTransfer = class {
  /**
   * @param nativeDataTransfer The native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
   * @param options.cacheFiles Whether `files` list should be initialized in the constructor.
   */
  constructor(nativeDataTransfer, options = {}) {
    this._files = options.cacheFiles ? getFiles(nativeDataTransfer) : null;
    this._native = nativeDataTransfer;
  }
  /**
   * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
   */
  get files() {
    if (!this._files) {
      this._files = getFiles(this._native);
    }
    return this._files;
  }
  /**
   * Returns an array of available native content types.
   */
  get types() {
    return this._native.types;
  }
  /**
   * Gets the data from the data transfer by its MIME type.
   *
   * ```ts
   * dataTransfer.getData( 'text/plain' );
   * ```
   *
   * @param type The MIME type. E.g. `text/html` or `text/plain`.
   */
  getData(type) {
    return this._native.getData(type);
  }
  /**
   * Sets the data in the data transfer.
   *
   * @param type The MIME type. E.g. `text/html` or `text/plain`.
   */
  setData(type, data) {
    this._native.setData(type, data);
  }
  /**
   * The effect that is allowed for a drag operation.
   */
  set effectAllowed(value) {
    this._native.effectAllowed = value;
  }
  get effectAllowed() {
    return this._native.effectAllowed;
  }
  /**
   * The actual drop effect.
   */
  set dropEffect(value) {
    this._native.dropEffect = value;
  }
  get dropEffect() {
    return this._native.dropEffect;
  }
  /**
   * Set a preview image of the dragged content.
   */
  setDragImage(image2, x, y) {
    this._native.setDragImage(image2, x, y);
  }
  /**
   * Whether the dragging operation was canceled.
   */
  get isCanceled() {
    return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
  }
};
function getFiles(nativeDataTransfer) {
  const files = Array.from(nativeDataTransfer.files || []);
  const items = Array.from(nativeDataTransfer.items || []);
  if (files.length) {
    return files;
  }
  return items.filter((item) => item.kind === "file").map((item) => item.getAsFile());
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/inputobserver.js
var InputObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    this.domEventType = "beforeinput";
  }
  /**
   * @inheritDoc
   */
  onDomEvent(domEvent) {
    const domTargetRanges = domEvent.getTargetRanges();
    const view = this.view;
    const viewDocument = view.document;
    let dataTransfer = null;
    let data = null;
    let targetRanges = [];
    if (domEvent.dataTransfer) {
      dataTransfer = new DataTransfer(domEvent.dataTransfer);
    }
    if (domEvent.data !== null) {
      data = domEvent.data;
    } else if (dataTransfer) {
      data = dataTransfer.getData("text/plain");
    }
    if (viewDocument.selection.isFake) {
      targetRanges = Array.from(viewDocument.selection.getRanges());
    } else if (domTargetRanges.length) {
      targetRanges = domTargetRanges.map((domRange) => {
        const viewStart = view.domConverter.domPositionToView(domRange.startContainer, domRange.startOffset);
        const viewEnd = view.domConverter.domPositionToView(domRange.endContainer, domRange.endOffset);
        if (viewStart) {
          return view.createRange(viewStart, viewEnd);
        } else if (viewEnd) {
          return view.createRange(viewEnd);
        }
      }).filter((range) => !!range);
    } else if (env_default.isAndroid) {
      const domSelection = domEvent.target.ownerDocument.defaultView.getSelection();
      targetRanges = Array.from(view.domConverter.domSelectionToView(domSelection).getRanges());
    }
    if (env_default.isAndroid && domEvent.inputType == "insertCompositionText" && data && data.endsWith("\n")) {
      this.fire(domEvent.type, domEvent, {
        inputType: "insertParagraph",
        targetRanges: [view.createRange(targetRanges[0].end)]
      });
      return;
    }
    if (domEvent.inputType == "insertText" && data && data.includes("\n")) {
      const parts = data.split(/\n{1,2}/g);
      let partTargetRanges = targetRanges;
      for (let i = 0; i < parts.length; i++) {
        const dataPart = parts[i];
        if (dataPart != "") {
          this.fire(domEvent.type, domEvent, {
            data: dataPart,
            dataTransfer,
            targetRanges: partTargetRanges,
            inputType: domEvent.inputType,
            isComposing: domEvent.isComposing
          });
          partTargetRanges = [viewDocument.selection.getFirstRange()];
        }
        if (i + 1 < parts.length) {
          this.fire(domEvent.type, domEvent, {
            inputType: "insertParagraph",
            targetRanges: partTargetRanges
          });
          partTargetRanges = [viewDocument.selection.getFirstRange()];
        }
      }
      return;
    }
    this.fire(domEvent.type, domEvent, {
      data,
      dataTransfer,
      targetRanges,
      inputType: domEvent.inputType,
      isComposing: domEvent.isComposing
    });
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/arrowkeysobserver.js
var ArrowKeysObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    this.document.on("keydown", (event, data) => {
      if (this.isEnabled && isArrowKeyCode(data.keyCode)) {
        const eventInfo = new BubblingEventInfo(this.document, "arrowKey", this.document.selection.getFirstRange());
        this.document.fire(eventInfo, data);
        if (eventInfo.stop.called) {
          event.stop();
        }
      }
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/tabobserver.js
var TabObserver = class extends Observer {
  /**
   * @inheritDoc
   */
  constructor(view) {
    super(view);
    const doc = this.document;
    doc.on("keydown", (evt, data) => {
      if (!this.isEnabled || data.keyCode != keyCodes.tab || data.ctrlKey) {
        return;
      }
      const event = new BubblingEventInfo(doc, "tab", doc.selection.getFirstRange());
      doc.fire(event, data);
      if (event.stop.called) {
        evt.stop();
      }
    });
  }
  /**
   * @inheritDoc
   */
  observe() {
  }
  /**
   * @inheritDoc
   */
  stopObserving() {
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/view.js
var View2 = class extends ObservableMixin() {
  /**
   * @param stylesProcessor The styles processor instance.
   */
  constructor(stylesProcessor) {
    super();
    this.domRoots = /* @__PURE__ */ new Map();
    this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap();
    this._observers = /* @__PURE__ */ new Map();
    this._ongoingChange = false;
    this._postFixersInProgress = false;
    this._renderingDisabled = false;
    this._hasChangedSinceTheLastRendering = false;
    this.document = new Document(stylesProcessor);
    this.domConverter = new DomConverter(this.document);
    this.set("isRenderingInProgress", false);
    this.set("hasDomSelection", false);
    this._renderer = new Renderer(this.domConverter, this.document.selection);
    this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing");
    this._writer = new DowncastWriter(this.document);
    this.addObserver(MutationObserver2);
    this.addObserver(FocusObserver);
    this.addObserver(SelectionObserver);
    this.addObserver(KeyObserver);
    this.addObserver(FakeSelectionObserver);
    this.addObserver(CompositionObserver);
    this.addObserver(ArrowKeysObserver);
    this.addObserver(InputObserver);
    this.addObserver(TabObserver);
    injectQuirksHandling(this);
    injectUiElementHandling(this);
    this.on("render", () => {
      this._render();
      this.document.fire("layoutChanged");
      this._hasChangedSinceTheLastRendering = false;
    });
    this.listenTo(this.document.selection, "change", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    this.listenTo(this.document, "change:isFocused", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    if (env_default.isiOS) {
      this.listenTo(this.document, "blur", (evt, data) => {
        const relatedViewElement = this.domConverter.mapDomToView(data.domEvent.relatedTarget);
        if (!relatedViewElement) {
          this.domConverter._clearDomSelection();
        }
      });
    }
    this.listenTo(this.document, "mutations", (evt, { mutations }) => {
      mutations.forEach((mutation) => this._renderer.markToSync(mutation.type, mutation.node));
    }, { priority: "low" });
    this.listenTo(this.document, "mutations", () => {
      this.forceRender();
    }, { priority: "lowest" });
  }
  /**
   * Attaches a DOM root element to the view element and enable all observers on that element.
   * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized
   * with the view what means that all child nodes will be removed and replaced with content of the view root.
   *
   * This method also will change view element name as the same as tag name of given dom root.
   * Name is always transformed to lower case.
   *
   * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.
   *
   * @param domRoot DOM root element.
   * @param name Name of the root.
   */
  attachDomRoot(domRoot, name = "main") {
    const viewRoot = this.document.getRoot(name);
    viewRoot._name = domRoot.tagName.toLowerCase();
    const initialDomRootAttributes = {};
    for (const { name: name2, value } of Array.from(domRoot.attributes)) {
      initialDomRootAttributes[name2] = value;
      if (name2 === "class") {
        this._writer.addClass(value.split(" "), viewRoot);
      } else {
        if (!viewRoot.hasAttribute(name2)) {
          this._writer.setAttribute(name2, value, viewRoot);
        }
      }
    }
    this._initialDomRootAttributes.set(domRoot, initialDomRootAttributes);
    const updateContenteditableAttribute = () => {
      this._writer.setAttribute("contenteditable", (!viewRoot.isReadOnly).toString(), viewRoot);
      if (viewRoot.isReadOnly) {
        this._writer.addClass("ck-read-only", viewRoot);
      } else {
        this._writer.removeClass("ck-read-only", viewRoot);
      }
    };
    updateContenteditableAttribute();
    this.domRoots.set(name, domRoot);
    this.domConverter.bindElements(domRoot, viewRoot);
    this._renderer.markToSync("children", viewRoot);
    this._renderer.markToSync("attributes", viewRoot);
    this._renderer.domDocuments.add(domRoot.ownerDocument);
    viewRoot.on("change:children", (evt, node) => this._renderer.markToSync("children", node));
    viewRoot.on("change:attributes", (evt, node) => this._renderer.markToSync("attributes", node));
    viewRoot.on("change:text", (evt, node) => this._renderer.markToSync("text", node));
    viewRoot.on("change:isReadOnly", () => this.change(updateContenteditableAttribute));
    viewRoot.on("change", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    for (const observer of this._observers.values()) {
      observer.observe(domRoot, name);
    }
  }
  /**
   * Detaches a DOM root element from the view element and restores its attributes to the state before
   * {@link #attachDomRoot `attachDomRoot()`}.
   *
   * @param name Name of the root to detach.
   */
  detachDomRoot(name) {
    const domRoot = this.domRoots.get(name);
    Array.from(domRoot.attributes).forEach(({ name: name2 }) => domRoot.removeAttribute(name2));
    const initialDomRootAttributes = this._initialDomRootAttributes.get(domRoot);
    for (const attribute in initialDomRootAttributes) {
      domRoot.setAttribute(attribute, initialDomRootAttributes[attribute]);
    }
    this.domRoots.delete(name);
    this.domConverter.unbindDomElement(domRoot);
    for (const observer of this._observers.values()) {
      observer.stopObserving(domRoot);
    }
  }
  /**
   * Gets DOM root element.
   *
   * @param name  Name of the root.
   * @returns DOM root element instance.
   */
  getDomRoot(name = "main") {
    return this.domRoots.get(name);
  }
  /**
   * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
   * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
   * {@link #domRoots DOM roots}.
   *
   * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
   * when registered for the first time. This means that features and other components can register a single observer
   * multiple times without caring whether it has been already added or not.
   *
   * @param ObserverConstructor The constructor of an observer to add.
   * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
   * @returns Added observer instance.
   */
  addObserver(ObserverConstructor) {
    let observer = this._observers.get(ObserverConstructor);
    if (observer) {
      return observer;
    }
    observer = new ObserverConstructor(this);
    this._observers.set(ObserverConstructor, observer);
    for (const [name, domElement] of this.domRoots) {
      observer.observe(domElement, name);
    }
    observer.enable();
    return observer;
  }
  /**
   * Returns observer of the given type or `undefined` if such observer has not been added yet.
   *
   * @param ObserverConstructor The constructor of an observer to get.
   * @returns Observer instance or undefined.
   */
  getObserver(ObserverConstructor) {
    return this._observers.get(ObserverConstructor);
  }
  /**
   * Disables all added observers.
   */
  disableObservers() {
    for (const observer of this._observers.values()) {
      observer.disable();
    }
  }
  /**
   * Enables all added observers.
   */
  enableObservers() {
    for (const observer of this._observers.values()) {
      observer.enable();
    }
  }
  /**
   * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
   * caret, **if not already visible to the user**.
   *
   * **Note**: Calling this method fires the {@link module:engine/view/view~ViewScrollToTheSelectionEvent} event that
   * allows custom behaviors.
   *
   * @param options Additional configuration of the scrolling behavior.
   * @param options.viewportOffset A distance between the DOM selection and the viewport boundary to be maintained
   * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
   * the viewport boundary.
   * @param options.ancestorOffset A distance between the DOM selection and scrollable DOM root ancestor(s) to be maintained
   * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
   * the scrollable ancestor(s) boundary.
   * @param options.alignToTop When set `true`, the DOM selection will be aligned to the top of the viewport if not already visible
   * (see `forceScroll` to learn more).
   * @param options.forceScroll When set `true`, the DOM selection will be aligned to the top of the viewport and scrollable ancestors
   * whether it is already visible or not. This option will only work when `alignToTop` is `true`.
   */
  scrollToTheSelection({ alignToTop, forceScroll, viewportOffset = 20, ancestorOffset = 20 } = {}) {
    const range = this.document.selection.getFirstRange();
    if (!range) {
      return;
    }
    const originalArgs = cloneDeep_default({ alignToTop, forceScroll, viewportOffset, ancestorOffset });
    if (typeof viewportOffset === "number") {
      viewportOffset = {
        top: viewportOffset,
        bottom: viewportOffset,
        left: viewportOffset,
        right: viewportOffset
      };
    }
    const options = {
      target: this.domConverter.viewRangeToDom(range),
      viewportOffset,
      ancestorOffset,
      alignToTop,
      forceScroll
    };
    this.fire("scrollToTheSelection", options, originalArgs);
    scrollViewportToShowTarget(options);
  }
  /**
   * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}
   * that is currently having selection inside.
   */
  focus() {
    if (!this.document.isFocused) {
      const editable = this.document.selection.editableElement;
      if (editable) {
        this.domConverter.focus(editable);
        this.forceRender();
      } else {
      }
    }
  }
  /**
   * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.
   * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed
   * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows
   * to nest calls one inside another and still performs a single rendering after all those changes are made.
   * It also returns the return value of its callback.
   *
   * ```ts
   * const text = view.change( writer => {
   * 	const newText = writer.createText( 'foo' );
   * 	writer.insert( position1, newText );
   *
   * 	view.change( writer => {
   * 		writer.insert( position2, writer.createText( 'bar' ) );
   * 	} );
   *
   * 	writer.remove( range );
   *
   * 	return newText;
   * } );
   * ```
   *
   * When the outermost change block is done and rendering to the DOM is over the
   * {@link module:engine/view/view~View#event:render `View#render`} event is fired.
   *
   * This method throws a `applying-view-changes-on-rendering` error when
   * the change block is used after rendering to the DOM has started.
   *
   * @param callback Callback function which may modify the view.
   * @returns Value returned by the callback.
   */
  change(callback) {
    if (this.isRenderingInProgress || this._postFixersInProgress) {
      throw new CKEditorError("cannot-change-view-tree", this);
    }
    try {
      if (this._ongoingChange) {
        return callback(this._writer);
      }
      this._ongoingChange = true;
      const callbackResult = callback(this._writer);
      this._ongoingChange = false;
      if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
        this._postFixersInProgress = true;
        this.document._callPostFixers(this._writer);
        this._postFixersInProgress = false;
        this.fire("render");
      }
      return callbackResult;
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  /**
   * Forces rendering {@link module:engine/view/document~Document view document} to DOM. If any view changes are
   * currently in progress, rendering will start after all {@link #change change blocks} are processed.
   *
   * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}
   * block and the view will automatically check whether it needs to render DOM or not.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when
   * trying to re-render when rendering to DOM has already started.
   */
  forceRender() {
    this._hasChangedSinceTheLastRendering = true;
    this.getObserver(FocusObserver).flush();
    this.change(() => {
    });
  }
  /**
   * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
   */
  destroy() {
    for (const observer of this._observers.values()) {
      observer.destroy();
    }
    this.document.destroy();
    this.stopListening();
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/view/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
   *
   * This method is a shortcut to other constructors such as:
   *
   * * {@link #createPositionBefore},
   * * {@link #createPositionAfter},
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
   */
  createPositionAt(itemOrPosition, offset) {
    return Position._createAt(itemOrPosition, offset);
  }
  /**
   * Creates a new position after given view item.
   *
   * @param item View item after which the position should be located.
   */
  createPositionAfter(item) {
    return Position._createAfter(item);
  }
  /**
   * Creates a new position before given view item.
   *
   * @param item View item before which the position should be located.
   */
  createPositionBefore(item) {
    return Position._createBefore(item);
  }
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(start, end) {
    return new Range(start, end);
  }
  /**
   * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
   */
  createRangeOn(item) {
    return Range._createOn(item);
  }
  /**
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(element) {
    return Range._createIn(element);
  }
  createSelection(...args) {
    return new Selection(...args);
  }
  /**
   * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.
   * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.
   *
   * @internal
   * @param flag A flag indicates whether the rendering should be disabled.
   */
  _disableRendering(flag) {
    this._renderingDisabled = flag;
    if (flag == false) {
      this.change(() => {
      });
    }
  }
  /**
   * Renders all changes. In order to avoid triggering the observers (e.g. selection) all observers are disabled
   * before rendering and re-enabled after that.
   */
  _render() {
    this.isRenderingInProgress = true;
    this.disableObservers();
    this._renderer.render();
    this.enableObservers();
    this.isRenderingInProgress = false;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/typecheckable.js
var TypeCheckable2 = class {
  /* istanbul ignore next -- @preserve */
  is() {
    throw new Error("is() method is abstract");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/node.js
var Node3 = class extends TypeCheckable2 {
  /**
   * Creates a model node.
   *
   * This is an abstract class, so this constructor should not be used directly.
   *
   * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  constructor(attrs) {
    super();
    this.parent = null;
    this._index = null;
    this._startOffset = null;
    this._attrs = toMap(attrs);
  }
  /**
   * {@link module:engine/model/document~Document Document} that owns this root element.
   */
  get document() {
    return null;
  }
  /**
   * Index of this node in its parent or `null` if the node has no parent.
   */
  get index() {
    return this._index;
  }
  /**
   * Offset at which this node starts in its parent. It is equal to the sum of {@link #offsetSize offsetSize}
   * of all its previous siblings. Equals to `null` if node has no parent.
   */
  get startOffset() {
    return this._startOffset;
  }
  /**
   * Offset size of this node.
   *
   * Represents how much "offset space" is occupied by the node in its parent. It is important for
   * {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position can be placed between
   * that node start and end. `offsetSize` greater than `1` is for nodes that represents more than one entity, i.e.
   * a {@link module:engine/model/text~Text text node}.
   */
  get offsetSize() {
    return 1;
  }
  /**
   * Offset at which this node ends in its parent. It is equal to the sum of this node's
   * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.
   * Equals to `null` if the node has no parent.
   */
  get endOffset() {
    if (this.startOffset === null) {
      return null;
    }
    return this.startOffset + this.offsetSize;
  }
  /**
   * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
   */
  get nextSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index + 1) || null;
  }
  /**
   * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
   */
  get previousSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index - 1) || null;
  }
  /**
   * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
   * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
   */
  get root() {
    let root = this;
    while (root.parent) {
      root = root.parent;
    }
    return root;
  }
  /**
   * Returns `true` if the node is inside a document root that is attached to the document.
   */
  isAttached() {
    return this.parent === null ? false : this.root.isAttached();
  }
  /**
   * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
   * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to
   * create {@link module:engine/model/position~Position Position} instance.
   *
   * ```ts
   * const abc = new Text( 'abc' );
   * const foo = new Text( 'foo' );
   * const h1 = new Element( 'h1', null, new Text( 'header' ) );
   * const p = new Element( 'p', null, [ abc, foo ] );
   * const div = new Element( 'div', null, [ h1, p ] );
   * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
   * h1.getPath(); // Returns [ 0 ].
   * div.getPath(); // Returns [].
   * ```
   */
  getPath() {
    const path = [];
    let node = this;
    while (node.parent) {
      path.unshift(node.startOffset);
      node = node.parent;
    }
    return path;
  }
  /**
   * Returns ancestors array of this node.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
  /**
   * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of both nodes.
   *
   * @param node The second node.
   * @param options Options object.
   * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
   * Which means that if e.g. node A is inside B, then their common ancestor will be B.
   */
  getCommonAncestor(node, options = {}) {
    const ancestorsA = this.getAncestors(options);
    const ancestorsB = node.getAncestors(options);
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
   * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isBefore(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    const thisPath = this.getPath();
    const nodePath = node.getPath();
    const result = compareArrays(thisPath, nodePath);
    switch (result) {
      case "prefix":
        return true;
      case "extension":
        return false;
      default:
        return thisPath[result] < nodePath[result];
    }
  }
  /**
   * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
   * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
   *
   * @param node Node to compare with.
   */
  isAfter(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    return !this.isBefore(node);
  }
  /**
   * Checks if the node has an attribute with given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on node, `false` otherwise.
   */
  hasAttribute(key) {
    return this._attrs.has(key);
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(key) {
    return this._attrs.get(key);
  }
  /**
   * Returns iterator that iterates over this node's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._attrs.entries();
  }
  /**
   * Returns iterator that iterates over this node's attribute keys.
   */
  getAttributeKeys() {
    return this._attrs.keys();
  }
  /**
   * Converts `Node` to plain object and returns it.
   *
   * @returns `Node` converted to plain object.
   */
  toJSON() {
    const json = {};
    if (this._attrs.size) {
      json.attributes = Array.from(this._attrs).reduce((result, attr) => {
        result[attr[0]] = attr[1];
        return result;
      }, {});
    }
    return json;
  }
  /**
   * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
   *
   * @internal
   * @returns Node with same attributes as this node.
   */
  _clone(_deep) {
    return new this.constructor(this._attrs);
  }
  /**
   * Removes this node from its parent.
   *
   * @internal
   * @see module:engine/model/writer~Writer#remove
   */
  _remove() {
    this.parent._removeChildren(this.index);
  }
  /**
   * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
   *
   * @see module:engine/model/writer~Writer#setAttribute
   * @internal
   * @param key Key of attribute to set.
   * @param value Attribute value.
   */
  _setAttribute(key, value) {
    this._attrs.set(key, value);
  }
  /**
   * Removes all attributes from the node and sets given attributes.
   *
   * @see module:engine/model/writer~Writer#setAttributes
   * @internal
   * @param attrs Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  _setAttributesTo(attrs) {
    this._attrs = toMap(attrs);
  }
  /**
   * Removes an attribute with given key from the node.
   *
   * @see module:engine/model/writer~Writer#removeAttribute
   * @internal
   * @param key Key of attribute to remove.
   * @returns `true` if the attribute was set on the element, `false` otherwise.
   */
  _removeAttribute(key) {
    return this._attrs.delete(key);
  }
  /**
   * Removes all attributes from the node.
   *
   * @see module:engine/model/writer~Writer#clearAttributes
   * @internal
   */
  _clearAttributes() {
    this._attrs.clear();
  }
};
Node3.prototype.is = function(type) {
  return type === "node" || type === "model:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/nodelist.js
var NodeList = class {
  /**
   * Creates a node list.
   *
   * @internal
   * @param nodes Nodes contained in this node list.
   */
  constructor(nodes) {
    this._nodes = [];
    this._offsetToNode = [];
    if (nodes) {
      this._insertNodes(0, nodes);
    }
  }
  /**
   * Iterable interface.
   *
   * Iterates over all nodes contained inside this node list.
   */
  [Symbol.iterator]() {
    return this._nodes[Symbol.iterator]();
  }
  /**
   * Number of nodes contained inside this node list.
   */
  get length() {
    return this._nodes.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.
   */
  get maxOffset() {
    return this._offsetToNode.length;
  }
  /**
   * Gets the node at the given index. Returns `null` if incorrect index was passed.
   */
  getNode(index) {
    return this._nodes[index] || null;
  }
  /**
   * Gets the node at the given offset. Returns `null` if incorrect offset was passed.
   */
  getNodeAtOffset(offset) {
    return this._offsetToNode[offset] || null;
  }
  /**
   * Returns an index of the given node or `null` if given node does not have a parent.
   *
   * This is an alias to {@link module:engine/model/node~Node#index}.
   */
  getNodeIndex(node) {
    return node.index;
  }
  /**
   * Returns the offset at which given node is placed in its parent or `null` if given node does not have a parent.
   *
   * This is an alias to {@link module:engine/model/node~Node#startOffset}.
   */
  getNodeStartOffset(node) {
    return node.startOffset;
  }
  /**
   * Converts index to offset in node list.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `model-nodelist-index-out-of-bounds` if given index is less
   * than `0` or more than {@link #length}.
   */
  indexToOffset(index) {
    if (index == this._nodes.length) {
      return this.maxOffset;
    }
    const node = this._nodes[index];
    if (!node) {
      throw new CKEditorError("model-nodelist-index-out-of-bounds", this);
    }
    return this.getNodeStartOffset(node);
  }
  /**
   * Converts offset in node list to index.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `model-nodelist-offset-out-of-bounds` if given offset is less
   * than `0` or more than {@link #maxOffset}.
   */
  offsetToIndex(offset) {
    if (offset == this._offsetToNode.length) {
      return this._nodes.length;
    }
    const node = this._offsetToNode[offset];
    if (!node) {
      throw new CKEditorError("model-nodelist-offset-out-of-bounds", this, {
        offset,
        nodeList: this
      });
    }
    return this.getNodeIndex(node);
  }
  /**
   * Inserts given nodes at given index.
   *
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param nodes Nodes to be inserted.
   */
  _insertNodes(index, nodes) {
    for (const node of nodes) {
      if (!(node instanceof Node3)) {
        throw new CKEditorError("model-nodelist-insertnodes-not-node", this);
      }
    }
    const nodesArray = Array.from(nodes);
    const offsetsArray = makeOffsetsArray(nodesArray);
    let offset = this.indexToOffset(index);
    this._nodes = spliceArray(this._nodes, nodesArray, index, 0);
    this._offsetToNode = spliceArray(this._offsetToNode, offsetsArray, offset, 0);
    for (let i = index; i < this._nodes.length; i++) {
      this._nodes[i]._index = i;
      this._nodes[i]._startOffset = offset;
      offset += this._nodes[i].offsetSize;
    }
  }
  /**
   * Removes one or more nodes starting at the given index.
   *
   * @internal
   * @param indexStart Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeNodes(indexStart, howMany = 1) {
    if (howMany == 0) {
      return [];
    }
    let offset = this.indexToOffset(indexStart);
    const nodes = this._nodes.splice(indexStart, howMany);
    const lastNode = nodes[nodes.length - 1];
    const removedOffsetSum = lastNode.startOffset + lastNode.offsetSize - offset;
    this._offsetToNode.splice(offset, removedOffsetSum);
    for (const node of nodes) {
      node._index = null;
      node._startOffset = null;
    }
    for (let i = indexStart; i < this._nodes.length; i++) {
      this._nodes[i]._index = i;
      this._nodes[i]._startOffset = offset;
      offset += this._nodes[i].offsetSize;
    }
    return nodes;
  }
  /**
   * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
   * are also converted to their plain object representation.
   *
   * @returns `NodeList` instance converted to `Array`.
   */
  toJSON() {
    return this._nodes.map((node) => node.toJSON());
  }
};
function makeOffsetsArray(nodes) {
  const offsets = [];
  for (const node of nodes) {
    const start = offsets.length;
    offsets.length += node.offsetSize;
    offsets.fill(node, start);
  }
  return offsets;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/text.js
var Text2 = class _Text extends Node3 {
  /**
   * Creates a text node.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createText} method instead.
   *
   * @internal
   * @param data Node's text.
   * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  constructor(data, attrs) {
    super(attrs);
    this._data = data || "";
  }
  /**
   * @inheritDoc
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Returns a text data contained in the node.
   */
  get data() {
    return this._data;
  }
  /**
   * Converts `Text` instance to plain object and returns it.
   *
   * @returns`Text` instance converted to plain object.
   */
  toJSON() {
    const json = super.toJSON();
    json.data = this.data;
    return json;
  }
  /**
   * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
   *
   * @internal
   * @returns `Text` instance created using given plain object.
   */
  _clone() {
    return new _Text(this.data, this.getAttributes());
  }
  /**
   * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Text`.
   * @returns `Text` instance created using given plain object.
   */
  static fromJSON(json) {
    return new _Text(json.data, json.attributes);
  }
};
Text2.prototype.is = function(type) {
  return type === "$text" || type === "model:$text" || // This are legacy values kept for backward compatibility.
  type === "text" || type === "model:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type === "node" || type === "model:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/textproxy.js
var TextProxy2 = class extends TypeCheckable2 {
  /**
   * Creates a text proxy.
   *
   * @internal
   * @param textNode Text node which part is represented by this text proxy.
   * @param offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy
   * starts.
   * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   */
  constructor(textNode, offsetInText, length) {
    super();
    this.textNode = textNode;
    if (offsetInText < 0 || offsetInText > textNode.offsetSize) {
      throw new CKEditorError("model-textproxy-wrong-offsetintext", this);
    }
    if (length < 0 || offsetInText + length > textNode.offsetSize) {
      throw new CKEditorError("model-textproxy-wrong-length", this);
    }
    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    this.offsetInText = offsetInText;
  }
  /**
   * Offset at which this text proxy starts in it's parent.
   *
   * @see module:engine/model/node~Node#startOffset
   */
  get startOffset() {
    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
  }
  /**
   * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
   *
   * @see module:engine/model/node~Node#offsetSize
   */
  get offsetSize() {
    return this.data.length;
  }
  /**
   * Offset at which this text proxy ends in it's parent.
   *
   * @see module:engine/model/node~Node#endOffset
   */
  get endOffset() {
    return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
  }
  /**
   * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}
   * (`true`) or the whole text node (`false`).
   *
   * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}
   * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
   * text node size.
   */
  get isPartial() {
    return this.offsetSize !== this.textNode.offsetSize;
  }
  /**
   * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
   */
  get parent() {
    return this.textNode.parent;
  }
  /**
   * Root of this text proxy, which is same as root of text node represented by this text proxy.
   */
  get root() {
    return this.textNode.root;
  }
  /**
   * Gets path to this text proxy.
   *
   * @see module:engine/model/node~Node#getPath
   */
  getPath() {
    const path = this.textNode.getPath();
    if (path.length > 0) {
      path[path.length - 1] += this.offsetInText;
    }
    return path;
  }
  /**
   * Returns ancestors array of this text proxy.
   *
   * @param options Options object.
   * @param options.includeSelf When set to `true` this text proxy will be also included in parent's array.
   * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to root element,
   * otherwise root element will be the first item in the array.
   * @returns Array with ancestors.
   */
  getAncestors(options = {}) {
    const ancestors = [];
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent);
      parent = parent.parent;
    }
    return ancestors;
  }
  /**
   * Checks if this text proxy has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on text proxy, `false` otherwise.
   */
  hasAttribute(key) {
    return this.textNode.hasAttribute(key);
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(key) {
    return this.textNode.getAttribute(key);
  }
  /**
   * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
   * items. First one is attribute key and second is attribute value.
   *
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this.textNode.getAttributes();
  }
  /**
   * Returns iterator that iterates over this node's attribute keys.
   */
  getAttributeKeys() {
    return this.textNode.getAttributeKeys();
  }
};
TextProxy2.prototype.is = function(type) {
  return type === "$textProxy" || type === "model:$textProxy" || // This are legacy values kept for backward compatibility.
  type === "textProxy" || type === "model:textProxy";
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/element.js
var Element2 = class _Element extends Node3 {
  /**
   * Creates a model element.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createElement} method instead.
   *
   * @internal
   * @param name Element's name.
   * @param attrs Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   * @param children One or more nodes to be inserted as children of created element.
   */
  constructor(name, attrs, children) {
    super(attrs);
    this._children = new NodeList();
    this.name = name;
    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
   * Number of this element's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.
   */
  get maxOffset() {
    return this._children.maxOffset;
  }
  /**
   * Is `true` if there are no nodes inside this element, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Gets the child at the given index. Returns `null` if incorrect index was passed.
   *
   * @param index Index in this element.
   * @returns Child node.
   */
  getChild(index) {
    return this._children.getNode(index);
  }
  /**
   * Gets the child at the given offset. Returns `null` if incorrect index was passed.
   *
   * @param offset Offset in this element.
   * @returns Child node.
   */
  getChildAtOffset(offset) {
    return this._children.getNodeAtOffset(offset);
  }
  /**
   * Returns an iterator that iterates over all of this element's children.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
   *
   * @param node Child node to look for.
   * @returns Child node's index in this element.
   */
  getChildIndex(node) {
    return this._children.getNodeIndex(node);
  }
  /**
   * Returns the starting offset of given child. Starting offset is equal to the sum of
   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
   * given node is not a child of this element.
   *
   * @param node Child node to look for.
   * @returns Child node's starting offset.
   */
  getChildStartOffset(node) {
    return this._children.getNodeStartOffset(node);
  }
  /**
   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
   * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.
   *
   * ```ts
   * const textNode = new Text( 'foo' );
   * const pElement = new Element( 'p' );
   * const divElement = new Element( [ textNode, pElement ] );
   * divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
   * divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
   * divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
   * divElement.offsetToIndex( 2 ); // Returns 0.
   * divElement.offsetToIndex( 3 ); // Returns 1.
   * divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
   * ```
   */
  offsetToIndex(offset) {
    return this._children.offsetToIndex(offset);
  }
  /**
   * Returns a descendant node by its path relative to this element.
   *
   * ```ts
   * // <this>a<b>c</b></this>
   * this.getNodeByPath( [ 0 ] );     // -> "a"
   * this.getNodeByPath( [ 1 ] );     // -> <b>
   * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
   * ```
   *
   * @param relativePath Path of the node to find, relative to this element.
   */
  getNodeByPath(relativePath) {
    let node = this;
    for (const offset of relativePath) {
      node = node.getChildAtOffset(offset);
    }
    return node;
  }
  /**
   * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.
   *
   * @param parentName The name of the parent element to find.
   * @param options Options object.
   * @param options.includeSelf When set to `true` this node will be also included while searching.
   */
  findAncestor(parentName, options = {}) {
    let parent = options.includeSelf ? this : this.parent;
    while (parent) {
      if (parent.name === parentName) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
   * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
   *
   * @returns `Element` instance converted to plain object.
   */
  toJSON() {
    const json = super.toJSON();
    json.name = this.name;
    if (this._children.length > 0) {
      json.children = [];
      for (const node of this._children) {
        json.children.push(node.toJSON());
      }
    }
    return json;
  }
  /**
   * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
   *
   * @internal
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any child.
   */
  _clone(deep = false) {
    const children = deep ? Array.from(this._children).map((node) => node._clone(true)) : void 0;
    return new _Element(this.name, this.getAttributes(), children);
  }
  /**
   * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.
   *
   * @see module:engine/model/writer~Writer#append
   * @internal
   * @param nodes Nodes to be inserted.
   */
  _appendChild(nodes) {
    this._insertChild(this.childCount, nodes);
  }
  /**
   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
   * to this element.
   *
   * @see module:engine/model/writer~Writer#insert
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param items Items to be inserted.
   */
  _insertChild(index, items) {
    const nodes = normalize3(items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
    }
    this._children._insertNodes(index, nodes);
  }
  /**
   * Removes one or more nodes starting at the given index and sets
   * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
   *
   * @see module:engine/model/writer~Writer#remove
   * @internal
   * @param index Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeChildren(index, howMany = 1) {
    const nodes = this._children._removeNodes(index, howMany);
    for (const node of nodes) {
      node.parent = null;
    }
    return nodes;
  }
  /**
   * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
   * Converts `Element` children to proper nodes.
   *
   * @param json Plain object to be converted to `Element`.
   * @returns `Element` instance created using given plain object.
   */
  static fromJSON(json) {
    let children;
    if (json.children) {
      children = [];
      for (const child of json.children) {
        if (child.name) {
          children.push(_Element.fromJSON(child));
        } else {
          children.push(Text2.fromJSON(child));
        }
      }
    }
    return new _Element(json.name, json.attributes, children);
  }
};
Element2.prototype.is = function(type, name) {
  if (!name) {
    return type === "element" || type === "model:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "node" || type === "model:node";
  }
  return name === this.name && (type === "element" || type === "model:element");
};
function normalize3(nodes) {
  if (typeof nodes == "string") {
    return [new Text2(nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new Text2(node);
    }
    if (node instanceof TextProxy2) {
      return new Text2(node.data, node.getAttributes());
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js
var TreeWalker2 = class {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @param options Object with configuration.
   */
  constructor(options) {
    if (!options || !options.boundaries && !options.startPosition) {
      throw new CKEditorError("model-tree-walker-no-start-position", null);
    }
    const direction = options.direction || "forward";
    if (direction != "forward" && direction != "backward") {
      throw new CKEditorError("model-tree-walker-unknown-direction", options, { direction });
    }
    this.direction = direction;
    this.boundaries = options.boundaries || null;
    if (options.startPosition) {
      this._position = options.startPosition.clone();
    } else {
      this._position = Position2._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]);
    }
    this.position.stickiness = "toNone";
    this.singleCharacters = !!options.singleCharacters;
    this.shallow = !!options.shallow;
    this.ignoreElementEnd = !!options.ignoreElementEnd;
    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
    this._visitedParent = this.position.parent;
  }
  /**
   * Iterable interface.
   *
   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
   */
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Iterator position. This is always static position, even if the initial position was a
   * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
   * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
   * is `'backward'` position starts from the end.
   */
  get position() {
    return this._position;
  }
  /**
   * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
   *
   * For example:
   *
   * ```ts
   * walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
   * walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
   * walker.skip( () => false ); // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   */
  skip(skip) {
    let done, value, prevPosition, prevVisitedParent;
    do {
      prevPosition = this.position;
      prevVisitedParent = this._visitedParent;
      ({ done, value } = this.next());
    } while (!done && skip(value));
    if (!done) {
      this._position = prevPosition;
      this._visitedParent = prevVisitedParent;
    }
  }
  /**
   * Gets the next tree walker's value.
   */
  next() {
    if (this.direction == "forward") {
      return this._next();
    } else {
      return this._previous();
    }
  }
  /**
   * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
   */
  _next() {
    const previousPosition = this.position;
    const position = this.position.clone();
    const parent = this._visitedParent;
    if (parent.parent === null && position.offset === parent.maxOffset) {
      return { done: true, value: void 0 };
    }
    if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
      return { done: true, value: void 0 };
    }
    const textNodeAtPosition = getTextNodeAtPosition(position, parent);
    const node = textNodeAtPosition || getNodeAfterPosition(position, parent, textNodeAtPosition);
    if (node instanceof Element2) {
      if (!this.shallow) {
        position.path.push(0);
        this._visitedParent = node;
      } else {
        if (this.boundaries && this.boundaries.end.isBefore(position)) {
          return { done: true, value: void 0 };
        }
        position.offset++;
      }
      this._position = position;
      return formatReturnValue("elementStart", node, previousPosition, position, 1);
    }
    if (node instanceof Text2) {
      let charactersCount;
      if (this.singleCharacters) {
        charactersCount = 1;
      } else {
        let offset = node.endOffset;
        if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {
          offset = this.boundaries.end.offset;
        }
        charactersCount = offset - position.offset;
      }
      const offsetInTextNode = position.offset - node.startOffset;
      const item = new TextProxy2(node, offsetInTextNode, charactersCount);
      position.offset += charactersCount;
      this._position = position;
      return formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    position.path.pop();
    position.offset++;
    this._position = position;
    this._visitedParent = parent.parent;
    if (this.ignoreElementEnd) {
      return this._next();
    }
    return formatReturnValue("elementEnd", parent, previousPosition, position);
  }
  /**
   * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
   */
  _previous() {
    const previousPosition = this.position;
    const position = this.position.clone();
    const parent = this._visitedParent;
    if (parent.parent === null && position.offset === 0) {
      return { done: true, value: void 0 };
    }
    if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
      return { done: true, value: void 0 };
    }
    const positionParent = position.parent;
    const textNodeAtPosition = getTextNodeAtPosition(position, positionParent);
    const node = textNodeAtPosition || getNodeBeforePosition(position, positionParent, textNodeAtPosition);
    if (node instanceof Element2) {
      position.offset--;
      if (this.shallow) {
        this._position = position;
        return formatReturnValue("elementStart", node, previousPosition, position, 1);
      }
      position.path.push(node.maxOffset);
      this._position = position;
      this._visitedParent = node;
      if (this.ignoreElementEnd) {
        return this._previous();
      }
      return formatReturnValue("elementEnd", node, previousPosition, position);
    }
    if (node instanceof Text2) {
      let charactersCount;
      if (this.singleCharacters) {
        charactersCount = 1;
      } else {
        let offset = node.startOffset;
        if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {
          offset = this.boundaries.start.offset;
        }
        charactersCount = position.offset - offset;
      }
      const offsetInTextNode = position.offset - node.startOffset;
      const item = new TextProxy2(node, offsetInTextNode - charactersCount, charactersCount);
      position.offset -= charactersCount;
      this._position = position;
      return formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    position.path.pop();
    this._position = position;
    this._visitedParent = parent.parent;
    return formatReturnValue("elementStart", parent, previousPosition, position, 1);
  }
};
function formatReturnValue(type, item, previousPosition, nextPosition, length) {
  return {
    done: false,
    value: {
      type,
      item,
      previousPosition,
      nextPosition,
      length
    }
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/position.js
var Position2 = class _Position extends TypeCheckable2 {
  /**
   * Creates a position.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  constructor(root, path, stickiness = "toNone") {
    super();
    if (!root.is("element") && !root.is("documentFragment")) {
      throw new CKEditorError("model-position-root-invalid", root);
    }
    if (!(path instanceof Array) || path.length === 0) {
      throw new CKEditorError("model-position-path-incorrect-format", root, { path });
    }
    if (root.is("rootElement")) {
      path = path.slice();
    } else {
      path = [...root.getPath(), ...path];
      root = root.root;
    }
    this.root = root;
    this.path = path;
    this.stickiness = stickiness;
  }
  /**
   * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal
   * to the last item in position {@link module:engine/model/position~Position#path path}.
   *
   * @type {Number}
   */
  get offset() {
    return this.path[this.path.length - 1];
  }
  set offset(newOffset) {
    this.path[this.path.length - 1] = newOffset;
  }
  /**
   * Parent element of this position.
   *
   * Keep in mind that `parent` value is calculated when the property is accessed.
   * If {@link module:engine/model/position~Position#path position path}
   * leads to a non-existing element, `parent` property will throw error.
   *
   * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
   */
  get parent() {
    let parent = this.root;
    for (let i = 0; i < this.path.length - 1; i++) {
      parent = parent.getChildAtOffset(this.path[i]);
      if (!parent) {
        throw new CKEditorError("model-position-path-incorrect", this, { position: this });
      }
    }
    if (parent.is("$text")) {
      throw new CKEditorError("model-position-path-incorrect", this, { position: this });
    }
    return parent;
  }
  /**
   * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is
   * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed
   * in text node, position index is equal to the index of that text node.
   */
  get index() {
    return this.parent.offsetToIndex(this.offset);
  }
  /**
   * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this
   * position is not in a text node.
   */
  get textNode() {
    return getTextNodeAtPosition(this, this.parent);
  }
  /**
   * Node directly after this position. Returns `null` if this position is at the end of its parent, or if it is in a text node.
   */
  get nodeAfter() {
    const parent = this.parent;
    return getNodeAfterPosition(this, parent, getTextNodeAtPosition(this, parent));
  }
  /**
   * Node directly before this position. Returns `null` if this position is at the start of its parent, or if it is in a text node.
   */
  get nodeBefore() {
    const parent = this.parent;
    return getNodeBeforePosition(this, parent, getTextNodeAtPosition(this, parent));
  }
  /**
   * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
   */
  get isAtStart() {
    return this.offset === 0;
  }
  /**
   * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
   */
  get isAtEnd() {
    return this.offset == this.parent.maxOffset;
  }
  /**
   * Checks whether the position is valid in current model tree, that is whether it points to an existing place in the model.
   */
  isValid() {
    if (this.offset < 0) {
      return false;
    }
    let parent = this.root;
    for (let i = 0; i < this.path.length - 1; i++) {
      parent = parent.getChildAtOffset(this.path[i]);
      if (!parent) {
        return false;
      }
    }
    return this.offset <= parent.maxOffset;
  }
  /**
   * Checks whether this position is before or after given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   */
  compareWith(otherPosition) {
    if (this.root != otherPosition.root) {
      return "different";
    }
    const result = compareArrays(this.path, otherPosition.path);
    switch (result) {
      case "same":
        return "same";
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return this.path[result] < otherPosition.path[result] ? "before" : "after";
    }
  }
  /**
   * Gets the farthest position which matches the callback using
   * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.
   *
   * For example:
   *
   * ```ts
   * getLastMatchingPosition( value => value.type == 'text' );
   * // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
   *
   * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
   * // <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
   *
   * getLastMatchingPosition( value => false );
   * // Do not move the position.
   * ```
   *
   * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
   * return `true` if the value should be skipped or `false` if not.
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   *
   * @returns The position after the last item which matches the `skip` callback test.
   */
  getLastMatchingPosition(skip, options = {}) {
    options.startPosition = this;
    const treeWalker = new TreeWalker2(options);
    treeWalker.skip(skip);
    return treeWalker.position;
  }
  /**
   * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}
   * but without the last item.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @returns Path to the parent.
   */
  getParentPath() {
    return this.path.slice(0, -1);
  }
  /**
   * Returns ancestors array of this position, that is this position's parent and its ancestors.
   *
   * @returns Array with ancestors.
   */
  getAncestors() {
    const parent = this.parent;
    if (parent.is("documentFragment")) {
      return [parent];
    } else {
      return parent.getAncestors({ includeSelf: true });
    }
  }
  /**
   * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.
   *
   * @param parentName The name of the parent element to find.
   */
  findAncestor(parentName) {
    const parent = this.parent;
    if (parent.is("element")) {
      return parent.findAncestor(parentName, { includeSelf: true });
    }
    return null;
  }
  /**
   * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
   * of these two paths must be identical.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param position The second position.
   * @returns The common path.
   */
  getCommonPath(position) {
    if (this.root != position.root) {
      return [];
    }
    const cmp = compareArrays(this.path, position.path);
    const diffAt = typeof cmp == "string" ? Math.min(this.path.length, position.path.length) : cmp;
    return this.path.slice(0, diffAt);
  }
  /**
   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
   *
   * @param position The second position.
   */
  getCommonAncestor(position) {
    const ancestorsA = this.getAncestors();
    const ancestorsB = position.getAncestors();
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  /**
   * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
   * is shifted by `shift` value (can be a negative value).
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param shift Offset shift. Can be a negative value.
   * @returns Shifted position.
   */
  getShiftedBy(shift) {
    const shifted = this.clone();
    const offset = shifted.offset + shift;
    shifted.offset = offset < 0 ? 0 : offset;
    return shifted;
  }
  /**
   * Checks whether this position is after given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @see module:engine/model/position~Position#isBefore
   * @param  otherPosition Position to compare with.
   * @returns True if this position is after given position.
   */
  isAfter(otherPosition) {
    return this.compareWith(otherPosition) == "after";
  }
  /**
   * Checks whether this position is before given position.
   *
   * **Note:** watch out when using negation of the value returned by this method, because the negation will also
   * be `true` if positions are in different roots and you might not expect this. You should probably use
   * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
   * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
   *
   * ```ts
   * if ( a.isBefore( b ) && c.isAfter( d ) ) {
   * 	// do A.
   * } else {
   * 	// do B.
   * }
   * ```
   *
   * or, if you have only one if-branch:
   *
   * ```ts
   * if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
   * 	// do B.
   * }
   * ```
   *
   * rather than:
   *
   * ```ts
   * if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
   * 	// do B.
   * } else {
   * 	// do A.
   * }
   * ```
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param otherPosition Position to compare with.
   * @returns True if this position is before given position.
   */
  isBefore(otherPosition) {
    return this.compareWith(otherPosition) == "before";
  }
  /**
   * Checks whether this position is equal to given position.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions are same.
   */
  isEqual(otherPosition) {
    return this.compareWith(otherPosition) == "same";
  }
  /**
   * Checks whether this position is touching given position. Positions touch when there are no text nodes
   * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
   * they are very similar or even indistinguishable.
   *
   * @param otherPosition Position to compare with.
   * @returns True if positions touch.
   */
  isTouching(otherPosition) {
    if (this.root !== otherPosition.root) {
      return false;
    }
    const commonLevel = Math.min(this.path.length, otherPosition.path.length);
    for (let level = 0; level < commonLevel; level++) {
      const diff2 = this.path[level] - otherPosition.path[level];
      if (diff2 < -1 || diff2 > 1) {
        return false;
      } else if (diff2 === 1) {
        return checkTouchingBranch(otherPosition, this, level);
      } else if (diff2 === -1) {
        return checkTouchingBranch(this, otherPosition, level);
      }
    }
    if (this.path.length === otherPosition.path.length) {
      return true;
    } else if (this.path.length > otherPosition.path.length) {
      return checkOnlyZeroes(this.path, commonLevel);
    } else {
      return checkOnlyZeroes(otherPosition.path, commonLevel);
    }
  }
  /**
   * Checks if two positions are in the same parent.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param position Position to compare with.
   * @returns `true` if positions have the same parent, `false` otherwise.
   */
  hasSameParentAs(position) {
    if (this.root !== position.root) {
      return false;
    }
    const thisParentPath = this.getParentPath();
    const posParentPath = position.getParentPath();
    return compareArrays(thisParentPath, posParentPath) == "same";
  }
  /**
   * Returns a copy of this position that is transformed by given `operation`.
   *
   * The new position's parameters are updated accordingly to the effect of the `operation`.
   *
   * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be
   * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.
   *
   * This method is safe to use it on non-existing positions (for example during operational transformation).
   *
   * @param operation Operation to transform by.
   * @returns Transformed position.
   */
  getTransformedByOperation(operation) {
    let result;
    switch (operation.type) {
      case "insert":
        result = this._getTransformedByInsertOperation(operation);
        break;
      case "move":
      case "remove":
      case "reinsert":
        result = this._getTransformedByMoveOperation(operation);
        break;
      case "split":
        result = this._getTransformedBySplitOperation(operation);
        break;
      case "merge":
        result = this._getTransformedByMergeOperation(operation);
        break;
      default:
        result = _Position._createAt(this);
        break;
    }
    return result;
  }
  /**
   * Returns a copy of this position transformed by an insert operation.
   *
   * @internal
   */
  _getTransformedByInsertOperation(operation) {
    return this._getTransformedByInsertion(operation.position, operation.howMany);
  }
  /**
   * Returns a copy of this position transformed by a move operation.
   *
   * @internal
   */
  _getTransformedByMoveOperation(operation) {
    return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);
  }
  /**
   * Returns a copy of this position transformed by a split operation.
   *
   * @internal
   */
  _getTransformedBySplitOperation(operation) {
    const movedRange = operation.movedRange;
    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == "toNext";
    if (isContained) {
      return this._getCombined(operation.splitPosition, operation.moveTargetPosition);
    } else {
      if (operation.graveyardPosition) {
        return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);
      } else {
        return this._getTransformedByInsertion(operation.insertionPosition, 1);
      }
    }
  }
  /**
   * Returns a copy of this position transformed by merge operation.
   *
   * @internal
   */
  _getTransformedByMergeOperation(operation) {
    const movedRange = operation.movedRange;
    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);
    let pos;
    if (isContained) {
      pos = this._getCombined(operation.sourcePosition, operation.targetPosition);
      if (operation.sourcePosition.isBefore(operation.targetPosition)) {
        pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);
      }
    } else if (this.isEqual(operation.deletionPosition)) {
      pos = _Position._createAt(operation.deletionPosition);
    } else {
      pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);
    }
    return pos;
  }
  /**
   * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
   * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
   *
   * @internal
   * @param deletePosition Position before the first removed node.
   * @param howMany How many nodes are removed.
   * @returns Transformed position or `null`.
   */
  _getTransformedByDeletion(deletePosition, howMany) {
    const transformed = _Position._createAt(this);
    if (this.root != deletePosition.root) {
      return transformed;
    }
    if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "same") {
      if (deletePosition.offset < this.offset) {
        if (deletePosition.offset + howMany > this.offset) {
          return null;
        } else {
          transformed.offset -= howMany;
        }
      }
    } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "prefix") {
      const i = deletePosition.path.length - 1;
      if (deletePosition.offset <= this.path[i]) {
        if (deletePosition.offset + howMany > this.path[i]) {
          return null;
        } else {
          transformed.path[i] -= howMany;
        }
      }
    }
    return transformed;
  }
  /**
   * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
   *
   * @internal
   * @param insertPosition Position where nodes are inserted.
   * @param howMany How many nodes are inserted.
   * @returns Transformed position.
   */
  _getTransformedByInsertion(insertPosition, howMany) {
    const transformed = _Position._createAt(this);
    if (this.root != insertPosition.root) {
      return transformed;
    }
    if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "same") {
      if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != "toPrevious") {
        transformed.offset += howMany;
      }
    } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "prefix") {
      const i = insertPosition.path.length - 1;
      if (insertPosition.offset <= this.path[i]) {
        transformed.path[i] += howMany;
      }
    }
    return transformed;
  }
  /**
   * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
   *
   * @internal
   * @param sourcePosition Position before the first element to move.
   * @param targetPosition Position where moved elements will be inserted.
   * @param howMany How many consecutive nodes to move, starting from `sourcePosition`.
   * @returns Transformed position.
   */
  _getTransformedByMove(sourcePosition, targetPosition, howMany) {
    targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
    if (sourcePosition.isEqual(targetPosition)) {
      return _Position._createAt(this);
    }
    const transformed = this._getTransformedByDeletion(sourcePosition, howMany);
    const isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == "toNext" || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == "toPrevious";
    if (isMoved) {
      return this._getCombined(sourcePosition, targetPosition);
    } else {
      return transformed._getTransformedByInsertion(targetPosition, howMany);
    }
  }
  /**
   * Returns a new position that is a combination of this position and given positions.
   *
   * The combined position is a copy of this position transformed by moving a range starting at `source` position
   * to the `target` position. It is expected that this position is inside the moved range.
   *
   * Example:
   *
   * ```ts
   * let original = model.createPositionFromPath( root, [ 2, 3, 1 ] );
   * let source = model.createPositionFromPath( root, [ 2, 2 ] );
   * let target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );
   * original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
   * ```
   *
   * Explanation:
   *
   * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
   * was inside moved nodes and now should point to the new place. The moved nodes will be after
   * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
   * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
   * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
   * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
   *
   * @internal
   * @param source Beginning of the moved range.
   * @param target Position where the range is moved.
   * @returns Combined position.
   */
  _getCombined(source, target) {
    const i = source.path.length - 1;
    const combined = _Position._createAt(target);
    combined.stickiness = this.stickiness;
    combined.offset = combined.offset + this.path[i] - source.offset;
    combined.path = [...combined.path, ...this.path.slice(i + 1)];
    return combined;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    return {
      root: this.root.toJSON(),
      path: Array.from(this.path),
      stickiness: this.stickiness
    };
  }
  /**
   * Returns a new position that is equal to current position.
   */
  clone() {
    return new this.constructor(this.root, this.path, this.stickiness);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/model/position~Position position},
   * * parent element and offset (offset defaults to `0`),
   * * parent element and `'end'` (sets position at the end of that element),
   * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).
   *
   * This method is a shortcut to other factory methods such as:
   *
   * * {@link module:engine/model/position~Position._createBefore},
   * * {@link module:engine/model/position~Position._createAfter}.
   *
   * @internal
   * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
   * @param stickiness Position stickiness. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
   */
  static _createAt(itemOrPosition, offset, stickiness = "toNone") {
    if (itemOrPosition instanceof _Position) {
      return new _Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);
    } else {
      const node = itemOrPosition;
      if (offset == "end") {
        offset = node.maxOffset;
      } else if (offset == "before") {
        return this._createBefore(node, stickiness);
      } else if (offset == "after") {
        return this._createAfter(node, stickiness);
      } else if (offset !== 0 && !offset) {
        throw new CKEditorError("model-createpositionat-offset-required", [this, itemOrPosition]);
      }
      if (!node.is("element") && !node.is("documentFragment")) {
        throw new CKEditorError("model-position-parent-incorrect", [this, itemOrPosition]);
      }
      const path = node.getPath();
      path.push(offset);
      return new this(node.root, path, stickiness);
    }
  }
  /**
   * Creates a new position, after given {@link module:engine/model/item~Item model item}.
   *
   * @internal
   * @param item Item after which the position should be placed.
   * @param stickiness Position stickiness.
   */
  static _createAfter(item, stickiness) {
    if (!item.parent) {
      throw new CKEditorError("model-position-after-root", [this, item], { root: item });
    }
    return this._createAt(item.parent, item.endOffset, stickiness);
  }
  /**
   * Creates a new position, before the given {@link module:engine/model/item~Item model item}.
   *
   * @internal
   * @param item Item before which the position should be placed.
   * @param stickiness Position stickiness.
   */
  static _createBefore(item, stickiness) {
    if (!item.parent) {
      throw new CKEditorError("model-position-before-root", item, { root: item });
    }
    return this._createAt(item.parent, item.startOffset, stickiness);
  }
  /**
   * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Position`.
   * @param doc Document object that will be position owner.
   * @returns `Position` instance created using given plain object.
   */
  static fromJSON(json, doc) {
    if (json.root === "$graveyard") {
      const pos = new _Position(doc.graveyard, json.path);
      pos.stickiness = json.stickiness;
      return pos;
    }
    if (!doc.getRoot(json.root)) {
      throw new CKEditorError("model-position-fromjson-no-root", doc, { rootName: json.root });
    }
    return new _Position(doc.getRoot(json.root), json.path, json.stickiness);
  }
};
Position2.prototype.is = function(type) {
  return type === "position" || type === "model:position";
};
function getTextNodeAtPosition(position, positionParent) {
  const node = positionParent.getChildAtOffset(position.offset);
  if (node && node.is("$text") && node.startOffset < position.offset) {
    return node;
  }
  return null;
}
function getNodeAfterPosition(position, positionParent, textNode) {
  if (textNode !== null) {
    return null;
  }
  return positionParent.getChildAtOffset(position.offset);
}
function getNodeBeforePosition(position, positionParent, textNode) {
  if (textNode !== null) {
    return null;
  }
  return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);
}
function checkTouchingBranch(left, right, level) {
  if (level + 1 === left.path.length) {
    return false;
  }
  if (!checkOnlyZeroes(right.path, level + 1)) {
    return false;
  }
  if (!checkOnlyMaxOffset(left, level + 1)) {
    return false;
  }
  return true;
}
function checkOnlyZeroes(arr, idx) {
  while (idx < arr.length) {
    if (arr[idx] !== 0) {
      return false;
    }
    idx++;
  }
  return true;
}
function checkOnlyMaxOffset(pos, level) {
  let parent = pos.parent;
  let idx = pos.path.length - 1;
  let add = 0;
  while (idx >= level) {
    if (pos.path[idx] + add !== parent.maxOffset) {
      return false;
    }
    add = 1;
    idx--;
    parent = parent.parent;
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/range.js
var Range2 = class _Range extends TypeCheckable2 {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * @param start The start position.
   * @param end The end position. If not set, the range will be collapsed at the `start` position.
   */
  constructor(start, end) {
    super();
    this.start = Position2._createAt(start);
    this.end = end ? Position2._createAt(end) : Position2._createAt(start);
    this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
    this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/model/position~Position positions},
   * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.
   * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range
   * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.
   *
   * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range
   * and `ignoreElementEnd` option set to `true`.
   */
  *[Symbol.iterator]() {
    yield* new TreeWalker2({ boundaries: this, ignoreElementEnd: true });
  }
  /**
   * Describes whether the range is collapsed, that is if {@link #start} and
   * {@link #end} positions are equal.
   */
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  /**
   * Describes whether this range is flat, that is if {@link #start} position and
   * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.
   */
  get isFlat() {
    const startParentPath = this.start.getParentPath();
    const endParentPath = this.end.getParentPath();
    return compareArrays(startParentPath, endParentPath) == "same";
  }
  /**
   * Range root element.
   */
  get root() {
    return this.start.root;
  }
  /**
   * Checks whether this range contains given {@link module:engine/model/position~Position position}.
   *
   * @param position Position to check.
   * @returns `true` if given {@link module:engine/model/position~Position position} is contained
   * in this range,`false` otherwise.
   */
  containsPosition(position) {
    return position.isAfter(this.start) && position.isBefore(this.end);
  }
  /**
   * Checks whether this range contains given {@link ~Range range}.
   *
   * @param otherRange Range to check.
   * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
   * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
   * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
   * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.
   */
  containsRange(otherRange, loose = false) {
    if (otherRange.isCollapsed) {
      loose = false;
    }
    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
    return containsStart && containsEnd;
  }
  /**
   * Checks whether given {@link module:engine/model/item~Item} is inside this range.
   */
  containsItem(item) {
    const pos = Position2._createBefore(item);
    return this.containsPosition(pos) || this.start.isEqual(pos);
  }
  /**
   * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges are equal, `false` otherwise.
   */
  isEqual(otherRange) {
    return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
  }
  /**
   * Checks and returns whether this range intersects with given range.
   *
   * @param otherRange Range to compare with.
   * @returns `true` if ranges intersect, `false` otherwise.
   */
  isIntersecting(otherRange) {
    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
  }
  /**
   * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.
   * Returned array contains zero, one or two {@link ~Range ranges}.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );
   * let transformed = range.getDifference( otherRange );
   * // transformed array has no ranges because `otherRange` contains `range`
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );
   * transformed = range.getDifference( otherRange );
   * // transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );
   * transformed = range.getDifference( otherRange );
   * // transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
   * ```
   *
   * @param otherRange Range to differentiate against.
   * @returns The difference between ranges.
   */
  getDifference(otherRange) {
    const ranges = [];
    if (this.isIntersecting(otherRange)) {
      if (this.containsPosition(otherRange.start)) {
        ranges.push(new _Range(this.start, otherRange.start));
      }
      if (this.containsPosition(otherRange.end)) {
        ranges.push(new _Range(otherRange.end, this.end));
      }
    } else {
      ranges.push(new _Range(this.start, this.end));
    }
    return ranges;
  }
  /**
   * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.
   * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );
   * let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
   *
   * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );
   * transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
   * ```
   *
   * @param otherRange Range to check for intersection.
   * @returns A common part of given ranges or `null` if ranges have no common part.
   */
  getIntersection(otherRange) {
    if (this.isIntersecting(otherRange)) {
      let commonRangeStart = this.start;
      let commonRangeEnd = this.end;
      if (this.containsPosition(otherRange.start)) {
        commonRangeStart = otherRange.start;
      }
      if (this.containsPosition(otherRange.end)) {
        commonRangeEnd = otherRange.end;
      }
      return new _Range(commonRangeStart, commonRangeEnd);
    }
    return null;
  }
  /**
   * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.
   * If ranges have no common part, returns `null`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let otherRange = model.createRange(
   * 	model.createPositionFromPath( root, [ 1 ] ),
   * 	model.createPositionFromPath( root, [ 2 ] )
   * );
   * let transformed = range.getJoined( otherRange ); // null - ranges have no common part
   *
   * otherRange = model.createRange(
   * 	model.createPositionFromPath( root, [ 3 ] ),
   * 	model.createPositionFromPath( root, [ 5 ] )
   * );
   * transformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]
   * ```
   *
   * @param otherRange Range to be joined.
   * @param loose Whether the intersection check is loose or strict. If the check is strict (`false`),
   * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),
   * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.
   * @returns A sum of given ranges or `null` if ranges have no common part.
   */
  getJoined(otherRange, loose = false) {
    let shouldJoin = this.isIntersecting(otherRange);
    if (!shouldJoin) {
      if (this.start.isBefore(otherRange.start)) {
        shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);
      } else {
        shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);
      }
    }
    if (!shouldJoin) {
      return null;
    }
    let startPosition = this.start;
    let endPosition = this.end;
    if (otherRange.start.isBefore(startPosition)) {
      startPosition = otherRange.start;
    }
    if (otherRange.end.isAfter(endPosition)) {
      endPosition = otherRange.end;
    }
    return new _Range(startPosition, endPosition);
  }
  /**
   * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
   *
   * See an example of a model structure (`[` and `]` are range boundaries):
   *
   * ```
   * root                                                            root
   *  |- element DIV                         DIV             P2              P3             DIV
   *  |   |- element H                   H        P1        f o o           b a r       H         P4
   *  |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
   *  |   |- element P1
   *  |   |   |- "lorem"                                              ||
   *  |- element P2                                                   ||
   *  |   |- "foo"                                                    VV
   *  |- element P3
   *  |   |- "bar"                                                   root
   *  |- element DIV                         DIV             [P2             P3]             DIV
   *  |   |- element H                   H       [P1]       f o o           b a r        H         P4
   *  |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
   *  |   |- element P4
   *  |   |   |- "ipsum"
   * ```
   *
   * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
   * We are looking for minimal set of flat ranges that contains the same nodes.
   *
   * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
   *
   * ```
   * ( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
   * ( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
   * ( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
   * ( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
   * ```
   *
   * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned
   * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
   * were omitted. Only their parts that were wholly in the range were returned.
   *
   * **Note:** this method is not returning flat ranges that contain no nodes.
   *
   * @returns Array of flat ranges covering this range.
   */
  getMinimalFlatRanges() {
    const ranges = [];
    const diffAt = this.start.getCommonPath(this.end).length;
    const pos = Position2._createAt(this.start);
    let posParent = pos.parent;
    while (pos.path.length > diffAt + 1) {
      const howMany = posParent.maxOffset - pos.offset;
      if (howMany !== 0) {
        ranges.push(new _Range(pos, pos.getShiftedBy(howMany)));
      }
      pos.path = pos.path.slice(0, -1);
      pos.offset++;
      posParent = posParent.parent;
    }
    while (pos.path.length <= this.end.path.length) {
      const offset = this.end.path[pos.path.length - 1];
      const howMany = offset - pos.offset;
      if (howMany !== 0) {
        ranges.push(new _Range(pos, pos.getShiftedBy(howMany)));
      }
      pos.offset = offset;
      pos.path.push(0);
    }
    return ranges;
  }
  /**
   * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
   *
   * For example, to iterate over all items in the entire document root:
   *
   * ```ts
   * // Create a range spanning over the entire root content:
   * const range = editor.model.createRangeIn( editor.model.document.getRoot() );
   *
   * // Iterate over all items in this range:
   * for ( const value of range.getWalker() ) {
   * 	console.log( value.item );
   * }
   * ```
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  getWalker(options = {}) {
    options.boundaries = this;
    return new TreeWalker2(options);
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
   * them.
   *
   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
   * set to `true`. However it returns only {@link module:engine/model/item~Item model items},
   * not {@link module:engine/model/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  *getItems(options = {}) {
    options.boundaries = this;
    options.ignoreElementEnd = true;
    const treeWalker = new TreeWalker2(options);
    for (const value of treeWalker) {
      yield value.item;
    }
  }
  /**
   * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or
   * contained in this range.
   *
   * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
   * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.
   *
   * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
   * a full list of available options.
   *
   * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
   */
  *getPositions(options = {}) {
    options.boundaries = this;
    const treeWalker = new TreeWalker2(options);
    yield treeWalker.position;
    for (const value of treeWalker) {
      yield value.nextPosition;
    }
  }
  /**
   * Returns a range that is a result of transforming this range by given `operation`.
   *
   * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is
   * moved to a different part of document tree). For this reason, an array is returned by this method and it
   * may contain one or more `Range` instances.
   *
   * @param operation Operation to transform range by.
   * @returns Range which is the result of transformation.
   */
  getTransformedByOperation(operation) {
    switch (operation.type) {
      case "insert":
        return this._getTransformedByInsertOperation(operation);
      case "move":
      case "remove":
      case "reinsert":
        return this._getTransformedByMoveOperation(operation);
      case "split":
        return [this._getTransformedBySplitOperation(operation)];
      case "merge":
        return [this._getTransformedByMergeOperation(operation)];
    }
    return [new _Range(this.start, this.end)];
  }
  /**
   * Returns a range that is a result of transforming this range by multiple `operations`.
   *
   * @see ~Range#getTransformedByOperation
   * @param operations Operations to transform the range by.
   * @returns Range which is the result of transformation.
   */
  getTransformedByOperations(operations2) {
    const ranges = [new _Range(this.start, this.end)];
    for (const operation of operations2) {
      for (let i = 0; i < ranges.length; i++) {
        const result = ranges[i].getTransformedByOperation(operation);
        ranges.splice(i, 1, ...result);
        i += result.length - 1;
      }
    }
    for (let i = 0; i < ranges.length; i++) {
      const range = ranges[i];
      for (let j = i + 1; j < ranges.length; j++) {
        const next = ranges[j];
        if (range.containsRange(next) || next.containsRange(range) || range.isEqual(next)) {
          ranges.splice(j, 1);
        }
      }
    }
    return ranges;
  }
  /**
   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
   * which is a common ancestor of the range's both ends (in which the entire range is contained).
   */
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  /**
   * Returns an {@link module:engine/model/element~Element Element} contained by the range.
   * The element will be returned when it is the **only** node within the range and **fullycontained**
   * at the same time.
   */
  getContainedElement() {
    if (this.isCollapsed) {
      return null;
    }
    const nodeAfterStart = this.start.nodeAfter;
    const nodeBeforeEnd = this.end.nodeBefore;
    if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
      return nodeAfterStart;
    }
    return null;
  }
  /**
   * Converts `Range` to plain object and returns it.
   *
   * @returns `Node` converted to plain object.
   */
  toJSON() {
    return {
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  /**
   * Returns a new range that is equal to current range.
   */
  clone() {
    return new this.constructor(this.start, this.end);
  }
  /**
   * Returns a result of transforming a copy of this range by insert operation.
   *
   * One or more ranges may be returned as a result of this transformation.
   *
   * @internal
   */
  _getTransformedByInsertOperation(operation, spread = false) {
    return this._getTransformedByInsertion(operation.position, operation.howMany, spread);
  }
  /**
   * Returns a result of transforming a copy of this range by move operation.
   *
   * One or more ranges may be returned as a result of this transformation.
   *
   * @internal
   */
  _getTransformedByMoveOperation(operation, spread = false) {
    const sourcePosition = operation.sourcePosition;
    const howMany = operation.howMany;
    const targetPosition = operation.targetPosition;
    return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread);
  }
  /**
   * Returns a result of transforming a copy of this range by split operation.
   *
   * Always one range is returned. The transformation is done in a way to not break the range.
   *
   * @internal
   */
  _getTransformedBySplitOperation(operation) {
    const start = this.start._getTransformedBySplitOperation(operation);
    let end = this.end._getTransformedBySplitOperation(operation);
    if (this.end.isEqual(operation.insertionPosition)) {
      end = this.end.getShiftedBy(1);
    }
    if (start.root != end.root) {
      end = this.end.getShiftedBy(-1);
    }
    return new _Range(start, end);
  }
  /**
   * Returns a result of transforming a copy of this range by merge operation.
   *
   * Always one range is returned. The transformation is done in a way to not break the range.
   *
   * @internal
   */
  _getTransformedByMergeOperation(operation) {
    if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {
      return new _Range(this.start);
    }
    let start = this.start._getTransformedByMergeOperation(operation);
    let end = this.end._getTransformedByMergeOperation(operation);
    if (start.root != end.root) {
      end = this.end.getShiftedBy(-1);
    }
    if (start.isAfter(end)) {
      if (operation.sourcePosition.isBefore(operation.targetPosition)) {
        start = Position2._createAt(end);
        start.offset = 0;
      } else {
        if (!operation.deletionPosition.isEqual(start)) {
          end = operation.deletionPosition;
        }
        start = operation.targetPosition;
      }
      return new _Range(start, end);
    }
    return new _Range(start, end);
  }
  /**
   * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this
   * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are
   * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.
   *
   * Examples:
   *
   * ```ts
   * let range = model.createRange(
   * 	model.createPositionFromPath( root, [ 2, 7 ] ),
   * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
   * );
   * let transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );
   * // transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );
   * // transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );
   * // transformed array has one range, which is equal to original range
   *
   * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );
   * // transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
   * ```
   *
   * @internal
   * @param insertPosition Position where nodes are inserted.
   * @param howMany How many nodes are inserted.
   * @param spread Flag indicating whether this range should be spread if insertion
   * was inside the range. Defaults to `false`.
   * @returns Result of the transformation.
   */
  _getTransformedByInsertion(insertPosition, howMany, spread = false) {
    if (spread && this.containsPosition(insertPosition)) {
      return [
        new _Range(this.start, insertPosition),
        new _Range(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))
      ];
    } else {
      const range = new _Range(this.start, this.end);
      range.start = range.start._getTransformedByInsertion(insertPosition, howMany);
      range.end = range.end._getTransformedByInsertion(insertPosition, howMany);
      return [range];
    }
  }
  /**
   * Returns an array containing {@link ~Range ranges} that are a result of transforming this
   * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
   *
   * @internal
   * @param sourcePosition Position from which nodes are moved.
   * @param targetPosition Position to where nodes are moved.
   * @param howMany How many nodes are moved.
   * @param spread Whether the range should be spread if the move points inside the range.
   * @returns  Result of the transformation.
   */
  _getTransformedByMove(sourcePosition, targetPosition, howMany, spread = false) {
    if (this.isCollapsed) {
      const newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
      return [new _Range(newPos)];
    }
    const moveRange = _Range._createFromPositionAndShift(sourcePosition, howMany);
    const insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
    if (this.containsPosition(targetPosition) && !spread) {
      if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {
        const start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
        const end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);
        return [new _Range(start, end)];
      }
    }
    let result;
    const differenceSet = this.getDifference(moveRange);
    let difference = null;
    const common = this.getIntersection(moveRange);
    if (differenceSet.length == 1) {
      difference = new _Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));
    } else if (differenceSet.length == 2) {
      difference = new _Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));
    }
    if (difference) {
      result = difference._getTransformedByInsertion(insertPosition, howMany, common !== null || spread);
    } else {
      result = [];
    }
    if (common) {
      const transformedCommon = new _Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));
      if (result.length == 2) {
        result.splice(1, 0, transformedCommon);
      } else {
        result.push(transformedCommon);
      }
    }
    return result;
  }
  /**
   * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.
   *
   * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.
   *
   * If the deleted range contains transformed range, `null` will be returned.
   *
   * @internal
   * @param deletionPosition Position from which nodes are removed.
   * @param howMany How many nodes are removed.
   * @returns Result of the transformation.
   */
  _getTransformedByDeletion(deletePosition, howMany) {
    let newStart = this.start._getTransformedByDeletion(deletePosition, howMany);
    let newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);
    if (newStart == null && newEnd == null) {
      return null;
    }
    if (newStart == null) {
      newStart = deletePosition;
    }
    if (newEnd == null) {
      newEnd = deletePosition;
    }
    return new _Range(newStart, newEnd);
  }
  /**
   * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by
   * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
   *
   * @internal
   * @param position Beginning of the range.
   * @param shift How long the range should be.
   */
  static _createFromPositionAndShift(position, shift) {
    const start = position;
    const end = position.getShiftedBy(shift);
    return shift > 0 ? new this(start, end) : new this(end, start);
  }
  /**
   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * @internal
   * @param element Element which is a parent for the range.
   */
  static _createIn(element) {
    return new this(Position2._createAt(element, 0), Position2._createAt(element, element.maxOffset));
  }
  /**
   * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.
   *
   * @internal
   */
  static _createOn(item) {
    return this._createFromPositionAndShift(Position2._createBefore(item), item.offsetSize);
  }
  /**
   * Combines all ranges from the passed array into a one range. At least one range has to be passed.
   * Passed ranges must not have common parts.
   *
   * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
   * the reference range, they get combined into one range.
   *
   * ```
   * [  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
   * [    ]                                       // The result of the function if the first range was a reference range.
   *         [                           ]        // The result of the function if the third-to-seventh range was a reference range.
   *                                        [  ]  // The result of the function if the last range was a reference range.
   * ```
   *
   * @internal
   * @param ranges Ranges to combine.
   * @returns Combined range.
   */
  static _createFromRanges(ranges) {
    if (ranges.length === 0) {
      throw new CKEditorError("range-create-from-ranges-empty-array", null);
    } else if (ranges.length == 1) {
      return ranges[0].clone();
    }
    const ref = ranges[0];
    ranges.sort((a, b) => {
      return a.start.isAfter(b.start) ? 1 : -1;
    });
    const refIndex = ranges.indexOf(ref);
    const result = new this(ref.start, ref.end);
    for (let i = refIndex - 1; i >= 0; i--) {
      if (ranges[i].end.isEqual(result.start)) {
        result.start = Position2._createAt(ranges[i].start);
      } else {
        break;
      }
    }
    for (let i = refIndex + 1; i < ranges.length; i++) {
      if (ranges[i].start.isEqual(result.end)) {
        result.end = Position2._createAt(ranges[i].end);
      } else {
        break;
      }
    }
    return result;
  }
  /**
   * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
   *
   * @param json Plain object to be converted to `Range`.
   * @param doc Document object that will be range owner.
   * @returns `Range` instance created using given plain object.
   */
  static fromJSON(json, doc) {
    return new this(Position2.fromJSON(json.start, doc), Position2.fromJSON(json.end, doc));
  }
};
Range2.prototype.is = function(type) {
  return type === "range" || type === "model:range";
};

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js
var Mapper = class extends EmitterMixin() {
  /**
   * Creates an instance of the mapper.
   */
  constructor() {
    super();
    this._modelToViewMapping = /* @__PURE__ */ new WeakMap();
    this._viewToModelMapping = /* @__PURE__ */ new WeakMap();
    this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map();
    this._markerNameToElements = /* @__PURE__ */ new Map();
    this._elementToMarkerNames = /* @__PURE__ */ new Map();
    this._deferredBindingRemovals = /* @__PURE__ */ new Map();
    this._unboundMarkerNames = /* @__PURE__ */ new Set();
    this.on("modelToViewPosition", (evt, data) => {
      if (data.viewPosition) {
        return;
      }
      const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);
      if (!viewContainer) {
        throw new CKEditorError("mapping-model-position-view-parent-not-found", this, { modelPosition: data.modelPosition });
      }
      data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);
    }, { priority: "low" });
    this.on("viewToModelPosition", (evt, data) => {
      if (data.modelPosition) {
        return;
      }
      const viewBlock = this.findMappedViewAncestor(data.viewPosition);
      const modelParent = this._viewToModelMapping.get(viewBlock);
      const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);
      data.modelPosition = Position2._createAt(modelParent, modelOffset);
    }, { priority: "low" });
  }
  /**
   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
   * The information that elements are bound is also used to translate positions.
   *
   * @param modelElement Model element.
   * @param viewElement View element.
   */
  bindElements(modelElement, viewElement) {
    this._modelToViewMapping.set(modelElement, viewElement);
    this._viewToModelMapping.set(viewElement, modelElement);
  }
  /**
   * Unbinds the given {@link module:engine/view/element~Element view element} from the map.
   *
   * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding
   * will be removed only if model element is still bound to the passed `viewElement`.
   *
   * This behavior allows for re-binding model element to another view element without fear of losing the new binding
   * when the previously bound view element is unbound.
   *
   * @param viewElement View element to unbind.
   * @param options The options object.
   * @param options.defer Controls whether the binding should be removed immediately or deferred until a
   * {@link #flushDeferredBindings `flushDeferredBindings()`} call.
   */
  unbindViewElement(viewElement, options = {}) {
    const modelElement = this.toModelElement(viewElement);
    if (this._elementToMarkerNames.has(viewElement)) {
      for (const markerName of this._elementToMarkerNames.get(viewElement)) {
        this._unboundMarkerNames.add(markerName);
      }
    }
    if (options.defer) {
      this._deferredBindingRemovals.set(viewElement, viewElement.root);
    } else {
      this._viewToModelMapping.delete(viewElement);
      if (this._modelToViewMapping.get(modelElement) == viewElement) {
        this._modelToViewMapping.delete(modelElement);
      }
    }
  }
  /**
   * Unbinds the given {@link module:engine/model/element~Element model element} from the map.
   *
   * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding
   * will be removed only if the view element is still bound to the passed `modelElement`.
   *
   * This behavior lets for re-binding view element to another model element without fear of losing the new binding
   * when the previously bound model element is unbound.
   *
   * @param modelElement Model element to unbind.
   */
  unbindModelElement(modelElement) {
    const viewElement = this.toViewElement(modelElement);
    this._modelToViewMapping.delete(modelElement);
    if (this._viewToModelMapping.get(viewElement) == modelElement) {
      this._viewToModelMapping.delete(viewElement);
    }
  }
  /**
   * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element
   * will be added to the current set of elements bound with the given marker name.
   *
   * @param element Element to bind.
   * @param name Marker name.
   */
  bindElementToMarker(element, name) {
    const elements = this._markerNameToElements.get(name) || /* @__PURE__ */ new Set();
    elements.add(element);
    const names = this._elementToMarkerNames.get(element) || /* @__PURE__ */ new Set();
    names.add(name);
    this._markerNameToElements.set(name, elements);
    this._elementToMarkerNames.set(element, names);
  }
  /**
   * Unbinds an element from given marker name.
   *
   * @param element Element to unbind.
   * @param name Marker name.
   */
  unbindElementFromMarkerName(element, name) {
    const nameToElements = this._markerNameToElements.get(name);
    if (nameToElements) {
      nameToElements.delete(element);
      if (nameToElements.size == 0) {
        this._markerNameToElements.delete(name);
      }
    }
    const elementToNames = this._elementToMarkerNames.get(element);
    if (elementToNames) {
      elementToNames.delete(name);
      if (elementToNames.size == 0) {
        this._elementToMarkerNames.delete(element);
      }
    }
  }
  /**
   * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
   * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.
   */
  flushUnboundMarkerNames() {
    const markerNames = Array.from(this._unboundMarkerNames);
    this._unboundMarkerNames.clear();
    return markerNames;
  }
  /**
   * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.
   *
   * See: {@link #unbindViewElement `unbindViewElement()`}.
   */
  flushDeferredBindings() {
    for (const [viewElement, root] of this._deferredBindingRemovals) {
      if (viewElement.root == root) {
        this.unbindViewElement(viewElement);
      }
    }
    this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  /**
   * Removes all model to view and view to model bindings.
   */
  clearBindings() {
    this._modelToViewMapping = /* @__PURE__ */ new WeakMap();
    this._viewToModelMapping = /* @__PURE__ */ new WeakMap();
    this._markerNameToElements = /* @__PURE__ */ new Map();
    this._elementToMarkerNames = /* @__PURE__ */ new Map();
    this._unboundMarkerNames = /* @__PURE__ */ new Set();
    this._deferredBindingRemovals = /* @__PURE__ */ new Map();
  }
  toModelElement(viewElement) {
    return this._viewToModelMapping.get(viewElement);
  }
  toViewElement(modelElement) {
    return this._modelToViewMapping.get(modelElement);
  }
  /**
   * Gets the corresponding model range.
   *
   * @param viewRange View range.
   * @returns Corresponding model range.
   */
  toModelRange(viewRange) {
    return new Range2(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));
  }
  /**
   * Gets the corresponding view range.
   *
   * @param modelRange Model range.
   * @returns Corresponding view range.
   */
  toViewRange(modelRange) {
    return new Range(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));
  }
  /**
   * Gets the corresponding model position.
   *
   * @fires viewToModelPosition
   * @param viewPosition View position.
   * @returns Corresponding model position.
   */
  toModelPosition(viewPosition) {
    const data = {
      viewPosition,
      mapper: this
    };
    this.fire("viewToModelPosition", data);
    return data.modelPosition;
  }
  /**
   * Gets the corresponding view position.
   *
   * @fires modelToViewPosition
   * @param modelPosition Model position.
   * @param options Additional options for position mapping process.
   * @param options.isPhantom Should be set to `true` if the model position to map is pointing to a place
   * in model tree which no longer exists. For example, it could be an end of a removed model range.
   * @returns Corresponding view position.
   */
  toViewPosition(modelPosition, options = {}) {
    const data = {
      modelPosition,
      mapper: this,
      isPhantom: options.isPhantom
    };
    this.fire("modelToViewPosition", data);
    return data.viewPosition;
  }
  /**
   * Gets all view elements bound to the given marker name.
   *
   * @param name Marker name.
   * @returns View elements bound with the given marker name or `null`
   * if no elements are bound to the given marker name.
   */
  markerNameToElements(name) {
    const boundElements = this._markerNameToElements.get(name);
    if (!boundElements) {
      return null;
    }
    const elements = /* @__PURE__ */ new Set();
    for (const element of boundElements) {
      if (element.is("attributeElement")) {
        for (const clone of element.getElementsWithSameId()) {
          elements.add(clone);
        }
      } else {
        elements.add(element);
      }
    }
    return elements;
  }
  /**
   * Registers a callback that evaluates the length in the model of a view element with the given name.
   *
   * The callback is fired with one argument, which is a view element instance. The callback is expected to return
   * a number representing the length of the view element in the model.
   *
   * ```ts
   * // List item in view may contain nested list, which have other list items. In model though,
   * // the lists are represented by flat structure. Because of those differences, length of list view element
   * // may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
   *
   * function getViewListItemLength( element ) {
   * 	let length = 1;
   *
   * 	for ( let child of element.getChildren() ) {
   * 		if ( child.name == 'ul' || child.name == 'ol' ) {
   * 			for ( let item of child.getChildren() ) {
   * 				length += getViewListItemLength( item );
   * 			}
   * 		}
   * 	}
   *
   * 	return length;
   * }
   *
   * mapper.registerViewToModelLength( 'li', getViewListItemLength );
   * ```
   *
   * @param viewElementName Name of view element for which callback is registered.
   * @param lengthCallback Function return a length of view element instance in model.
   */
  registerViewToModelLength(viewElementName, lengthCallback) {
    this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);
  }
  /**
   * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to
   * the model.
   *
   * @param viewPosition Position for which a mapped ancestor should be found.
   */
  findMappedViewAncestor(viewPosition) {
    let parent = viewPosition.parent;
    while (!this._viewToModelMapping.has(parent)) {
      parent = parent.parent;
    }
    return parent;
  }
  /**
   * Calculates model offset based on the view position and the block element.
   *
   * Example:
   *
   * ```html
   * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
   * ```
   *
   * Is a sum of:
   *
   * ```html
   * <p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
   * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
   * ```
   *
   * @param viewParent Position parent.
   * @param viewOffset Position offset.
   * @param viewBlock Block used as a base to calculate offset.
   * @returns Offset in the model.
   */
  _toModelOffset(viewParent, viewOffset, viewBlock) {
    if (viewBlock != viewParent) {
      const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);
      const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);
      return offsetToParentStart + offsetInParent;
    }
    if (viewParent.is("$text")) {
      return viewOffset;
    }
    let modelOffset = 0;
    for (let i = 0; i < viewOffset; i++) {
      modelOffset += this.getModelLength(viewParent.getChild(i));
    }
    return modelOffset;
  }
  /**
   * Gets the length of the view element in the model.
   *
   * The length is calculated as follows:
   * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to
   * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),
   * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its
   * {@link module:engine/view/text~Text#data data},
   * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,
   * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,
   * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.
   *
   * Examples:
   *
   * ```
   * foo                          -> 3 // Text length is equal to its data length.
   * <p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
   * <b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
   * <div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
   * ```
   *
   * @param viewNode View node.
   * @returns Length of the node in the tree model.
   */
  getModelLength(viewNode) {
    if (this._viewToModelLengthCallbacks.get(viewNode.name)) {
      const callback = this._viewToModelLengthCallbacks.get(viewNode.name);
      return callback(viewNode);
    } else if (this._viewToModelMapping.has(viewNode)) {
      return 1;
    } else if (viewNode.is("$text")) {
      return viewNode.data.length;
    } else if (viewNode.is("uiElement")) {
      return 0;
    } else {
      let len = 0;
      for (const child of viewNode.getChildren()) {
        len += this.getModelLength(child);
      }
      return len;
    }
  }
  /**
   * Finds the position in the view node (or in its children) with the expected model offset.
   *
   * Example:
   *
   * ```
   * <p>fo<b>bar</b>bom</p> -> expected offset: 4
   *
   * findPositionIn( p, 4 ):
   * <p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
   * <p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
   * <p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
   *
   * findPositionIn( b, 4 - ( 5 - 3 ) ):
   * <p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
   * <p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
   *
   * findPositionIn( bar, 2 - ( 3 - 3 ) ):
   * We are in the text node so we can simple find the offset.
   * <p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
   * ```
   *
   * @param viewParent Tree view element in which we are looking for the position.
   * @param expectedOffset Expected offset.
   * @returns Found position.
   */
  findPositionIn(viewParent, expectedOffset) {
    let viewNode;
    let lastLength = 0;
    let modelOffset = 0;
    let viewOffset = 0;
    if (viewParent.is("$text")) {
      return new Position(viewParent, expectedOffset);
    }
    while (modelOffset < expectedOffset) {
      viewNode = viewParent.getChild(viewOffset);
      lastLength = this.getModelLength(viewNode);
      modelOffset += lastLength;
      viewOffset++;
    }
    if (modelOffset == expectedOffset) {
      return this._moveViewPositionToTextNode(new Position(viewParent, viewOffset));
    } else {
      return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));
    }
  }
  /**
   * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,
   * it moves it into the text node instead.
   *
   * ```
   * <p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
   * <p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
   * <p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
   * ```
   *
   * @param viewPosition Position potentially next to the text node.
   * @returns Position in the text node if possible.
   */
  _moveViewPositionToTextNode(viewPosition) {
    const nodeBefore = viewPosition.nodeBefore;
    const nodeAfter = viewPosition.nodeAfter;
    if (nodeBefore instanceof Text) {
      return new Position(nodeBefore, nodeBefore.data.length);
    } else if (nodeAfter instanceof Text) {
      return new Position(nodeAfter, 0);
    }
    return viewPosition;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js
var ModelConsumable = class {
  constructor() {
    this._consumable = /* @__PURE__ */ new Map();
    this._textProxyRegistry = /* @__PURE__ */ new Map();
  }
  /**
   * Adds a consumable value to the consumables list and links it with a given model item.
   *
   * ```ts
   * modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
   * modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
   * modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
   * modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
   * modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
   * ```
   *
   * @param item Model item, range or selection that has the consumable.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   */
  add(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof TextProxy2) {
      item = this._getSymbolForTextProxy(item);
    }
    if (!this._consumable.has(item)) {
      this._consumable.set(item, /* @__PURE__ */ new Map());
    }
    this._consumable.get(item).set(type, true);
  }
  /**
   * Removes a given consumable value from a given model item.
   *
   * ```ts
   * modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
   * modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
   * modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
   * modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
   * modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
   * ```
   *
   * @param item Model item, range or selection from which consumable will be consumed.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   * @returns `true` if consumable value was available and was consumed, `false` otherwise.
   */
  consume(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof TextProxy2) {
      item = this._getSymbolForTextProxy(item);
    }
    if (this.test(item, type)) {
      this._consumable.get(item).set(type, false);
      return true;
    } else {
      return false;
    }
  }
  /**
   * Tests whether there is a consumable value of a given type connected with a given model item.
   *
   * ```ts
   * modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
   * modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
   * modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
   * modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
   * modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
   * ```
   *
   * @param item Model item, range or selection to be tested.
   * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   * @returns `null` if such consumable was never added, `false` if the consumable values was
   * already consumed or `true` if it was added and not consumed yet.
   */
  test(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof TextProxy2) {
      item = this._getSymbolForTextProxy(item);
    }
    const itemConsumables = this._consumable.get(item);
    if (itemConsumables === void 0) {
      return null;
    }
    const value = itemConsumables.get(type);
    if (value === void 0) {
      return null;
    }
    return value;
  }
  /**
   * Reverts consuming of a consumable value.
   *
   * ```ts
   * modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
   * modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
   * modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
   * modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
   * modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
   * ```
   *
   * @param item Model item, range or selection to be reverted.
   * @param type Consumable type.
   * @returns `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
   * never been added.
   */
  revert(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof TextProxy2) {
      item = this._getSymbolForTextProxy(item);
    }
    const test = this.test(item, type);
    if (test === false) {
      this._consumable.get(item).set(type, true);
      return true;
    } else if (test === true) {
      return false;
    }
    return null;
  }
  /**
   * Verifies if all events from the specified group were consumed.
   *
   * @param eventGroup The events group to verify.
   */
  verifyAllConsumed(eventGroup) {
    const items = [];
    for (const [item, consumables] of this._consumable) {
      for (const [event, canConsume] of consumables) {
        const eventPrefix = event.split(":")[0];
        if (canConsume && eventGroup == eventPrefix) {
          items.push({
            event,
            item: item.name || item.description
          });
        }
      }
    }
    if (items.length) {
      throw new CKEditorError("conversion-model-consumable-not-consumed", null, { items });
    }
  }
  /**
   * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that
   * have same parent, same start index and same end index will get the same symbol.
   *
   * Used internally to correctly consume `TextProxy` instances.
   *
   * @internal
   * @param textProxy `TextProxy` instance to get a symbol for.
   * @returns Symbol representing all equal instances of `TextProxy`.
   */
  _getSymbolForTextProxy(textProxy) {
    let symbol = null;
    const startMap = this._textProxyRegistry.get(textProxy.startOffset);
    if (startMap) {
      const endMap = startMap.get(textProxy.endOffset);
      if (endMap) {
        symbol = endMap.get(textProxy.parent);
      }
    }
    if (!symbol) {
      symbol = this._addSymbolForTextProxy(textProxy);
    }
    return symbol;
  }
  /**
   * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.
   *
   * Used internally to correctly consume `TextProxy` instances.
   *
   * @param textProxy Text proxy instance.
   * @returns Symbol generated for given `TextProxy`.
   */
  _addSymbolForTextProxy(textProxy) {
    const start = textProxy.startOffset;
    const end = textProxy.endOffset;
    const parent = textProxy.parent;
    const symbol = Symbol("$textProxy:" + textProxy.data);
    let startMap;
    let endMap;
    startMap = this._textProxyRegistry.get(start);
    if (!startMap) {
      startMap = /* @__PURE__ */ new Map();
      this._textProxyRegistry.set(start, startMap);
    }
    endMap = startMap.get(end);
    if (!endMap) {
      endMap = /* @__PURE__ */ new Map();
      startMap.set(end, endMap);
    }
    endMap.set(parent, symbol);
    return symbol;
  }
};
function _normalizeConsumableType(type) {
  const parts = type.split(":");
  if (parts[0] == "insert") {
    return parts[0];
  }
  if (parts[0] == "addMarker" || parts[0] == "removeMarker") {
    return type;
  }
  return parts.length > 1 ? parts[0] + ":" + parts[1] : parts[0];
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js
var DowncastDispatcher = class extends EmitterMixin() {
  /**
   * Creates a downcast dispatcher instance.
   *
   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi
   *
   * @param conversionApi Additional properties for an interface that will be passed to events fired
   * by the downcast dispatcher.
   */
  constructor(conversionApi) {
    super();
    this._conversionApi = { dispatcher: this, ...conversionApi };
    this._firedEventsMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}
   * and fires conversion events based on it.
   *
   * @fires insert
   * @fires remove
   * @fires attribute
   * @fires addMarker
   * @fires removeMarker
   * @fires reduceChanges
   * @param differ The differ object with buffered changes.
   * @param markers Markers related to the model fragment to convert.
   * @param writer The view writer that should be used to modify the view document.
   */
  convertChanges(differ, markers, writer) {
    const conversionApi = this._createConversionApi(writer, differ.getRefreshedItems());
    for (const change of differ.getMarkersToRemove()) {
      this._convertMarkerRemove(change.name, change.range, conversionApi);
    }
    const changes = this._reduceChanges(differ.getChanges());
    for (const entry of changes) {
      if (entry.type === "insert") {
        this._convertInsert(Range2._createFromPositionAndShift(entry.position, entry.length), conversionApi);
      } else if (entry.type === "reinsert") {
        this._convertReinsert(Range2._createFromPositionAndShift(entry.position, entry.length), conversionApi);
      } else if (entry.type === "remove") {
        this._convertRemove(entry.position, entry.length, entry.name, conversionApi);
      } else {
        this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);
      }
    }
    conversionApi.mapper.flushDeferredBindings();
    for (const markerName of conversionApi.mapper.flushUnboundMarkerNames()) {
      const markerRange = markers.get(markerName).getRange();
      this._convertMarkerRemove(markerName, markerRange, conversionApi);
      this._convertMarkerAdd(markerName, markerRange, conversionApi);
    }
    for (const change of differ.getMarkersToAdd()) {
      this._convertMarkerAdd(change.name, change.range, conversionApi);
    }
    conversionApi.consumable.verifyAllConsumed("insert");
  }
  /**
   * Starts a conversion of a model range and the provided markers.
   *
   * @fires insert
   * @fires attribute
   * @fires addMarker
   * @param range The inserted range.
   * @param markers The map of markers that should be down-casted.
   * @param writer The view writer that should be used to modify the view document.
   * @param options Optional options object passed to `convertionApi.options`.
   */
  convert(range, markers, writer, options = {}) {
    const conversionApi = this._createConversionApi(writer, void 0, options);
    this._convertInsert(range, conversionApi);
    for (const [name, range2] of markers) {
      this._convertMarkerAdd(name, range2, conversionApi);
    }
    conversionApi.consumable.verifyAllConsumed("insert");
  }
  /**
   * Starts the model selection conversion.
   *
   * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.
   *
   * @fires selection
   * @fires addMarker
   * @fires attribute
   * @param selection The selection to convert.
   * @param markers Markers connected with the converted model.
   * @param writer View writer that should be used to modify the view document.
   */
  convertSelection(selection, markers, writer) {
    const conversionApi = this._createConversionApi(writer);
    this.fire("cleanSelection", { selection }, conversionApi);
    const modelRoot = selection.getFirstPosition().root;
    if (!conversionApi.mapper.toViewElement(modelRoot)) {
      return;
    }
    const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));
    this._addConsumablesForSelection(conversionApi.consumable, selection, markersAtSelection);
    this.fire("selection", { selection }, conversionApi);
    if (!selection.isCollapsed) {
      return;
    }
    for (const marker of markersAtSelection) {
      if (conversionApi.consumable.test(selection, "addMarker:" + marker.name)) {
        const markerRange = marker.getRange();
        if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, conversionApi.mapper)) {
          continue;
        }
        const data = {
          item: selection,
          markerName: marker.name,
          markerRange
        };
        this.fire(`addMarker:${marker.name}`, data, conversionApi);
      }
    }
    for (const key of selection.getAttributeKeys()) {
      if (conversionApi.consumable.test(selection, "attribute:" + key)) {
        const data = {
          item: selection,
          range: selection.getFirstRange(),
          attributeKey: key,
          attributeOldValue: null,
          attributeNewValue: selection.getAttribute(key)
        };
        this.fire(`attribute:${key}:$text`, data, conversionApi);
      }
    }
  }
  /**
   * Fires insertion conversion of a range of nodes.
   *
   * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,
   * {@link #event:attribute `attribute` event is fired}.
   *
   * @fires insert
   * @fires attribute
   * @param range The inserted range.
   * @param conversionApi The conversion API object.
   * @param options.doNotAddConsumables Whether the ModelConsumable should not get populated
   * for items in the provided range.
   */
  _convertInsert(range, conversionApi, options = {}) {
    if (!options.doNotAddConsumables) {
      this._addConsumablesForInsert(conversionApi.consumable, range);
    }
    for (const data of Array.from(range.getWalker({ shallow: true })).map(walkerValueToEventData)) {
      this._testAndFire("insert", data, conversionApi);
    }
  }
  /**
   * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.
   *
   * @param position Position from which node was removed.
   * @param length Offset size of removed node.
   * @param name Name of removed node.
   * @param conversionApi The conversion API object.
   */
  _convertRemove(position, length, name, conversionApi) {
    this.fire(`remove:${name}`, { position, length }, conversionApi);
  }
  /**
   * Starts a conversion of an attribute change on a given `range`.
   *
   * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.
   *
   * @fires attribute
   * @param range Changed range.
   * @param key Key of the attribute that has changed.
   * @param oldValue Attribute value before the change or `null` if the attribute has not been set before.
   * @param newValue New attribute value or `null` if the attribute has been removed.
   * @param conversionApi The conversion API object.
   */
  _convertAttribute(range, key, oldValue, newValue, conversionApi) {
    this._addConsumablesForRange(conversionApi.consumable, range, `attribute:${key}`);
    for (const value of range) {
      const data = {
        item: value.item,
        range: Range2._createFromPositionAndShift(value.previousPosition, value.length),
        attributeKey: key,
        attributeOldValue: oldValue,
        attributeNewValue: newValue
      };
      this._testAndFire(`attribute:${key}`, data, conversionApi);
    }
  }
  /**
   * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)
   * of a range of elements (only elements on the range depth, without children).
   *
   * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.
   * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.
   *
   * @fires insert
   * @fires attribute
   * @param range The range to reinsert.
   * @param conversionApi The conversion API object.
   */
  _convertReinsert(range, conversionApi) {
    const walkerValues = Array.from(range.getWalker({ shallow: true }));
    this._addConsumablesForInsert(conversionApi.consumable, walkerValues);
    for (const data of walkerValues.map(walkerValueToEventData)) {
      this._testAndFire("insert", { ...data, reconversion: true }, conversionApi);
    }
  }
  /**
   * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item
   * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.
   *
   * @fires addMarker
   * @param markerName Marker name.
   * @param markerRange The marker range.
   * @param conversionApi The conversion API object.
   */
  _convertMarkerAdd(markerName, markerRange, conversionApi) {
    if (markerRange.root.rootName == "$graveyard") {
      return;
    }
    const eventName = `addMarker:${markerName}`;
    conversionApi.consumable.add(markerRange, eventName);
    this.fire(eventName, { markerName, markerRange }, conversionApi);
    if (!conversionApi.consumable.consume(markerRange, eventName)) {
      return;
    }
    this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);
    for (const item of markerRange.getItems()) {
      if (!conversionApi.consumable.test(item, eventName)) {
        continue;
      }
      const data = { item, range: Range2._createOn(item), markerName, markerRange };
      this.fire(eventName, data, conversionApi);
    }
  }
  /**
   * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.
   *
   * @fires removeMarker
   * @param markerName Marker name.
   * @param markerRange The marker range.
   * @param conversionApi The conversion API object.
   */
  _convertMarkerRemove(markerName, markerRange, conversionApi) {
    if (markerRange.root.rootName == "$graveyard") {
      return;
    }
    this.fire(`removeMarker:${markerName}`, { markerName, markerRange }, conversionApi);
  }
  /**
   * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.
   *
   * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger
   * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
   * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.
   *
   * @fires reduceChanges
   */
  _reduceChanges(changes) {
    const data = { changes };
    this.fire("reduceChanges", data);
    return data.changes;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,
   * assuming that the range has just been inserted to the model.
   *
   * @param consumable The consumable.
   * @param walkerValues The walker values for the inserted range.
   * @returns The values to consume.
   */
  _addConsumablesForInsert(consumable, walkerValues) {
    for (const value of walkerValues) {
      const item = value.item;
      if (consumable.test(item, "insert") === null) {
        consumable.add(item, "insert");
        for (const key of item.getAttributeKeys()) {
          consumable.add(item, "attribute:" + key);
        }
      }
    }
    return consumable;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.
   *
   * @param consumable The consumable.
   * @param range The affected range.
   * @param type Consumable type.
   * @returns The values to consume.
   */
  _addConsumablesForRange(consumable, range, type) {
    for (const item of range.getItems()) {
      consumable.add(item, type);
    }
    return consumable;
  }
  /**
   * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
   *
   * @param consumable The consumable.
   * @param selection The selection to create the consumable from.
   * @param markers Markers that contain the selection.
   * @returns The values to consume.
   */
  _addConsumablesForSelection(consumable, selection, markers) {
    consumable.add(selection, "selection");
    for (const marker of markers) {
      consumable.add(selection, "addMarker:" + marker.name);
    }
    for (const key of selection.getAttributeKeys()) {
      consumable.add(selection, "attribute:" + key);
    }
    return consumable;
  }
  /**
   * Tests whether given event wasn't already fired and if so, fires it.
   *
   * @fires insert
   * @fires attribute
   * @param type Event type.
   * @param data Event data.
   * @param conversionApi The conversion API object.
   */
  _testAndFire(type, data, conversionApi) {
    const eventName = getEventName(type, data);
    const itemKey = data.item.is("$textProxy") ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;
    const eventsFiredForConversion = this._firedEventsMap.get(conversionApi);
    const eventsFiredForItem = eventsFiredForConversion.get(itemKey);
    if (!eventsFiredForItem) {
      eventsFiredForConversion.set(itemKey, /* @__PURE__ */ new Set([eventName]));
    } else if (!eventsFiredForItem.has(eventName)) {
      eventsFiredForItem.add(eventName);
    } else {
      return;
    }
    this.fire(eventName, data, conversionApi);
  }
  /**
   * Fires not already fired events for setting attributes on just inserted item.
   *
   * @param item The model item to convert attributes for.
   * @param conversionApi The conversion API object.
   */
  _testAndFireAddAttributes(item, conversionApi) {
    const data = {
      item,
      range: Range2._createOn(item)
    };
    for (const key of data.item.getAttributeKeys()) {
      data.attributeKey = key;
      data.attributeOldValue = null;
      data.attributeNewValue = data.item.getAttribute(key);
      this._testAndFire(`attribute:${key}`, data, conversionApi);
    }
  }
  /**
   * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given
   * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.
   *
   * @param writer View writer that should be used to modify the view document.
   * @param refreshedItems A set of model elements that should not reuse their
   * previous view representations.
   * @param options Optional options passed to `convertionApi.options`.
   * @return The conversion API object.
   */
  _createConversionApi(writer, refreshedItems = /* @__PURE__ */ new Set(), options = {}) {
    const conversionApi = {
      ...this._conversionApi,
      consumable: new ModelConsumable(),
      writer,
      options,
      convertItem: (item) => this._convertInsert(Range2._createOn(item), conversionApi),
      convertChildren: (element) => this._convertInsert(Range2._createIn(element), conversionApi, { doNotAddConsumables: true }),
      convertAttributes: (item) => this._testAndFireAddAttributes(item, conversionApi),
      canReuseView: (viewElement) => !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement))
    };
    this._firedEventsMap.set(conversionApi, /* @__PURE__ */ new Map());
    return conversionApi;
  }
};
function shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {
  const range = marker.getRange();
  const ancestors = Array.from(modelPosition.getAncestors());
  ancestors.shift();
  ancestors.reverse();
  const hasCustomHandling = ancestors.some((element) => {
    if (range.containsItem(element)) {
      const viewElement = mapper.toViewElement(element);
      return !!viewElement.getCustomProperty("addHighlight");
    }
  });
  return !hasCustomHandling;
}
function getEventName(type, data) {
  const name = data.item.is("element") ? data.item.name : "$text";
  return `${type}:${name}`;
}
function walkerValueToEventData(value) {
  const item = value.item;
  const itemRange = Range2._createFromPositionAndShift(value.previousPosition, value.length);
  return {
    item,
    range: itemRange
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/selection.js
var Selection2 = class _Selection extends EmitterMixin(TypeCheckable2) {
  /**
   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}
   * or creates an empty selection if no arguments were passed.
   *
   * ```ts
   * // Creates empty selection without ranges.
   * const selection = writer.createSelection();
   *
   * // Creates selection at the given range.
   * const range = writer.createRange( start, end );
   * const selection = writer.createSelection( range );
   *
   * // Creates selection at the given ranges
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * const selection = writer.createSelection( ranges );
   *
   * // Creates selection from the other selection.
   * // Note: It doesn't copy selection attributes.
   * const otherSelection = writer.createSelection();
   * const selection = writer.createSelection( otherSelection );
   *
   * // Creates selection from the given document selection.
   * // Note: It doesn't copy selection attributes.
   * const documentSelection = model.document.selection;
   * const selection = writer.createSelection( documentSelection );
   *
   * // Creates selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * const selection = writer.createSelection( position );
   *
   * // Creates selection at the given offset in the given element.
   * const paragraph = writer.createElement( 'paragraph' );
   * const selection = writer.createSelection( paragraph, offset );
   *
   * // Creates a range inside an {@link module:engine/model/element~Element element} which starts before the
   * // first child of that element and ends after the last child of that element.
   * const selection = writer.createSelection( paragraph, 'in' );
   *
   * // Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends
   * // just after the item.
   * const selection = writer.createSelection( paragraph, 'on' );
   * ```
   *
   * Selection's constructor allow passing additional options (`'backward'`) as the last argument.
   *
   * ```ts
   * // Creates backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   *
   * @internal
   */
  constructor(...args) {
    super();
    this._lastRangeBackward = false;
    this._attrs = /* @__PURE__ */ new Map();
    this._ranges = [];
    if (args.length) {
      this.setTo(...args);
    }
  }
  /**
   * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection
   * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).
   *
   * Anchor and {@link #focus} define the direction of the selection, which is important
   * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.
   *
   * Anchor is always set to the {@link module:engine/model/range~Range#start start} or
   * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is
   * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.
   *
   * May be set to `null` if there are no ranges in the selection.
   *
   * @see #focus
   */
  get anchor() {
    if (this._ranges.length > 0) {
      const range = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? range.end : range.start;
    }
    return null;
  }
  /**
   * Selection focus. Focus is the position where the selection ends. If a user is making a selection
   * by dragging the mouse, the focus is where the mouse cursor is.
   *
   * May be set to `null` if there are no ranges in the selection.
   *
   * @see #anchor
   */
  get focus() {
    if (this._ranges.length > 0) {
      const range = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? range.start : range.end;
    }
    return null;
  }
  /**
   * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it
   * and it is collapsed.
   */
  get isCollapsed() {
    const length = this._ranges.length;
    if (length === 1) {
      return this._ranges[0].isCollapsed;
    } else {
      return false;
    }
  }
  /**
   * Returns the number of ranges in the selection.
   */
  get rangeCount() {
    return this._ranges.length;
  }
  /**
   * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.
   */
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  /**
   * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,
   * the same number of ranges and all ranges from one selection equal to ranges from the another selection.
   *
   * @param otherSelection Selection to compare with.
   * @returns `true` if selections are equal, `false` otherwise.
   */
  isEqual(otherSelection) {
    if (this.rangeCount != otherSelection.rangeCount) {
      return false;
    } else if (this.rangeCount === 0) {
      return true;
    }
    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
      return false;
    }
    for (const thisRange of this._ranges) {
      let found = false;
      for (const otherRange of otherSelection._ranges) {
        if (thisRange.isEqual(otherRange)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns an iterable object that iterates over copies of selection ranges.
   */
  *getRanges() {
    for (const range of this._ranges) {
      yield new Range2(range.start, range.end);
    }
  }
  /**
   * Returns a copy of the first range in the selection.
   * First range is the one which {@link module:engine/model/range~Range#start start} position
   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
   * (not to confuse with the first range added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstRange() {
    let first2 = null;
    for (const range of this._ranges) {
      if (!first2 || range.start.isBefore(first2.start)) {
        first2 = range;
      }
    }
    return first2 ? new Range2(first2.start, first2.end) : null;
  }
  /**
   * Returns a copy of the last range in the selection.
   * Last range is the one which {@link module:engine/model/range~Range#end end} position
   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
   * recently added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastRange() {
    let last = null;
    for (const range of this._ranges) {
      if (!last || range.end.isAfter(last.end)) {
        last = range;
      }
    }
    return last ? new Range2(last.start, last.end) : null;
  }
  /**
   * Returns the first position in the selection.
   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstPosition() {
    const first2 = this.getFirstRange();
    return first2 ? first2.start.clone() : null;
  }
  /**
   * Returns the last position in the selection.
   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastPosition() {
    const lastRange = this.getLastRange();
    return lastRange ? lastRange.end.clone() : null;
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/model/selection~Selectable selectable}.
   *
   * ```ts
   * // Removes all selection's ranges.
   * selection.setTo( null );
   *
   * // Sets selection to the given range.
   * const range = writer.createRange( start, end );
   * selection.setTo( range );
   *
   * // Sets selection to given ranges.
   * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   * selection.setTo( ranges );
   *
   * // Sets selection to other selection.
   * // Note: It doesn't copy selection attributes.
   * const otherSelection = writer.createSelection();
   * selection.setTo( otherSelection );
   *
   * // Sets selection to the given document selection.
   * // Note: It doesn't copy selection attributes.
   * const documentSelection = new DocumentSelection( doc );
   * selection.setTo( documentSelection );
   *
   * // Sets collapsed selection at the given position.
   * const position = writer.createPositionFromPath( root, path );
   * selection.setTo( position );
   *
   * // Sets collapsed selection at the position of the given node and an offset.
   * selection.setTo( paragraph, offset );
   * ```
   *
   * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * ```ts
   * selection.setTo( paragraph, 'in' );
   * ```
   *
   * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.
   *
   * ```ts
   * selection.setTo( paragraph, 'on' );
   * ```
   *
   * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.
   *
   * ```ts
   * // Sets backward selection.
   * const selection = writer.createSelection( range, { backward: true } );
   * ```
   */
  setTo(...args) {
    let [selectable, placeOrOffset, options] = args;
    if (typeof placeOrOffset == "object") {
      options = placeOrOffset;
      placeOrOffset = void 0;
    }
    if (selectable === null) {
      this._setRanges([]);
    } else if (selectable instanceof _Selection) {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
    } else if (selectable && typeof selectable.getRanges == "function") {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
    } else if (selectable instanceof Range2) {
      this._setRanges([selectable], !!options && !!options.backward);
    } else if (selectable instanceof Position2) {
      this._setRanges([new Range2(selectable)]);
    } else if (selectable instanceof Node3) {
      const backward = !!options && !!options.backward;
      let range;
      if (placeOrOffset == "in") {
        range = Range2._createIn(selectable);
      } else if (placeOrOffset == "on") {
        range = Range2._createOn(selectable);
      } else if (placeOrOffset !== void 0) {
        range = new Range2(Position2._createAt(selectable, placeOrOffset));
      } else {
        throw new CKEditorError("model-selection-setto-required-second-parameter", [this, selectable]);
      }
      this._setRanges([range], backward);
    } else if (isIterable(selectable)) {
      this._setRanges(selectable, options && !!options.backward);
    } else {
      throw new CKEditorError("model-selection-setto-not-selectable", [this, selectable]);
    }
  }
  /**
   * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
   * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and
   * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.
   *
   * @fires change:range
   * @param newRanges Ranges to set.
   * @param isLastBackward Flag describing if last added range was selected forward - from start to end (`false`)
   * or backward - from end to start (`true`).
   */
  _setRanges(newRanges, isLastBackward = false) {
    const ranges = Array.from(newRanges);
    const anyNewRange = ranges.some((newRange) => {
      if (!(newRange instanceof Range2)) {
        throw new CKEditorError("model-selection-set-ranges-not-range", [this, newRanges]);
      }
      return this._ranges.every((oldRange) => {
        return !oldRange.isEqual(newRange);
      });
    });
    if (ranges.length === this._ranges.length && !anyNewRange) {
      return;
    }
    this._replaceAllRanges(ranges);
    this._lastRangeBackward = !!isLastBackward;
    this.fire("change:range", { directChange: true });
  }
  /**
   * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.
   *
   * The location can be specified in the same form as
   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
   *
   * @fires change:range
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  setFocus(itemOrPosition, offset) {
    if (this.anchor === null) {
      throw new CKEditorError("model-selection-setfocus-no-ranges", [this, itemOrPosition]);
    }
    const newFocus = Position2._createAt(itemOrPosition, offset);
    if (newFocus.compareWith(this.focus) == "same") {
      return;
    }
    const anchor = this.anchor;
    if (this._ranges.length) {
      this._popRange();
    }
    if (newFocus.compareWith(anchor) == "before") {
      this._pushRange(new Range2(newFocus, anchor));
      this._lastRangeBackward = true;
    } else {
      this._pushRange(new Range2(anchor, newFocus));
      this._lastRangeBackward = false;
    }
    this.fire("change:range", { directChange: true });
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(key) {
    return this._attrs.get(key);
  }
  /**
   * Returns iterable that iterates over this selection's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._attrs.entries();
  }
  /**
   * Returns iterable that iterates over this selection's attribute keys.
   */
  getAttributeKeys() {
    return this._attrs.keys();
  }
  /**
   * Checks if the selection has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on selection, `false` otherwise.
   */
  hasAttribute(key) {
    return this._attrs.has(key);
  }
  /**
   * Removes an attribute with given key from the selection.
   *
   * If given attribute was set on the selection, fires the {@link #event:change:range} event with
   * removed attribute key.
   *
   * @fires change:attribute
   * @param key Key of attribute to remove.
   */
  removeAttribute(key) {
    if (this.hasAttribute(key)) {
      this._attrs.delete(key);
      this.fire("change:attribute", { attributeKeys: [key], directChange: true });
    }
  }
  /**
   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
   *
   * If the attribute value has changed, fires the {@link #event:change:range} event with
   * the attribute key.
   *
   * @fires change:attribute
   * @param key Key of attribute to set.
   * @param value Attribute value.
   */
  setAttribute(key, value) {
    if (this.getAttribute(key) !== value) {
      this._attrs.set(key, value);
      this.fire("change:attribute", { attributeKeys: [key], directChange: true });
    }
  }
  /**
   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    if (this.rangeCount !== 1) {
      return null;
    }
    return this.getFirstRange().getContainedElement();
  }
  /**
   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
   *
   * This method's result can be used for example to apply block styling to all blocks covered by this selection.
   *
   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
   * but will not return blocks nested in other blocks.
   *
   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
   *
   * ```xml
   * <paragraph>[a</paragraph>
   * <blockQuote>
   * 	<paragraph>b</paragraph>
   * </blockQuote>
   * <paragraph>c]d</paragraph>
   * ```
   *
   * In this case the paragraph will also be returned, despite the collapsed selection:
   *
   * ```xml
   * <paragraph>[]a</paragraph>
   * ```
   *
   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
   *
   * ```xml
   * [<blockA></blockA>
   * <blockB>
   * 	<blockC></blockC>
   * 	<blockD></blockD>
   * </blockB>
   * <blockE></blockE>]
   * ```
   *
   * If the selection is inside a block all the inner blocks (A & B) are returned:
   *
   * ```xml
   * <block>
   * 	<blockA>[a</blockA>
   * 	<blockB>b]</blockB>
   * </block>
   * ```
   *
   * **Special case**: Selection ignores first and/or last blocks if nothing (from user perspective) is selected in them.
   *
   * ```xml
   * // Selection ends and the beginning of the last block.
   * <paragraph>[a</paragraph>
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // This block will not be returned
   *
   * // Selection begins at the end of the first block.
   * <paragraph>a[</paragraph> // This block will not be returned
   * <paragraph>b</paragraph>
   * <paragraph>c]</paragraph>
   *
   * // Selection begings at the end of the first block and ends at the beginning of the last block.
   * <paragraph>a[</paragraph> // This block will not be returned
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // This block will not be returned
   * ```
   */
  *getSelectedBlocks() {
    const visited = /* @__PURE__ */ new WeakSet();
    for (const range of this.getRanges()) {
      const startBlock = getParentBlock(range.start, visited);
      if (isStartBlockSelected(startBlock, range)) {
        yield startBlock;
      }
      for (const value of range.getWalker()) {
        const block = value.item;
        if (value.type == "elementEnd" && isUnvisitedTopBlock(block, visited, range)) {
          yield block;
        }
      }
      const endBlock = getParentBlock(range.end, visited);
      if (isEndBlockSelected(endBlock, range)) {
        yield endBlock;
      }
    }
  }
  /**
   * Checks whether the selection contains the entire content of the given element. This means that selection must start
   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
   * touching the element's end.
   *
   * By default, this method will check whether the entire content of the selection's current root is selected.
   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
   */
  containsEntireContent(element = this.anchor.root) {
    const limitStartPosition = Position2._createAt(element, 0);
    const limitEndPosition = Position2._createAt(element, "end");
    return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());
  }
  /**
   * Adds given range to internal {@link #_ranges ranges array}. Throws an error
   * if given range is intersecting with any range that is already stored in this selection.
   */
  _pushRange(range) {
    this._checkRange(range);
    this._ranges.push(new Range2(range.start, range.end));
  }
  /**
   * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
   */
  _checkRange(range) {
    for (let i = 0; i < this._ranges.length; i++) {
      if (range.isIntersecting(this._ranges[i])) {
        throw new CKEditorError("model-selection-range-intersects", [this, range], { addedRange: range, intersectingRange: this._ranges[i] });
      }
    }
  }
  /**
   * Replaces all the ranges by the given ones.
   * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.
   */
  _replaceAllRanges(ranges) {
    this._removeAllRanges();
    for (const range of ranges) {
      this._pushRange(range);
    }
  }
  /**
   * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
   * ensure proper ranges removal.
   */
  _removeAllRanges() {
    while (this._ranges.length > 0) {
      this._popRange();
    }
  }
  /**
   * Removes most recently added range from the selection.
   */
  _popRange() {
    this._ranges.pop();
  }
};
Selection2.prototype.is = function(type) {
  return type === "selection" || type === "model:selection";
};
function isUnvisitedBlock(element, visited) {
  if (visited.has(element)) {
    return false;
  }
  visited.add(element);
  return element.root.document.model.schema.isBlock(element) && !!element.parent;
}
function isUnvisitedTopBlock(element, visited, range) {
  return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range);
}
function getParentBlock(position, visited) {
  const element = position.parent;
  const schema = element.root.document.model.schema;
  const ancestors = position.parent.getAncestors({ parentFirst: true, includeSelf: true });
  let hasParentLimit = false;
  const block = ancestors.find((element2) => {
    if (hasParentLimit) {
      return false;
    }
    hasParentLimit = schema.isLimit(element2);
    return !hasParentLimit && isUnvisitedBlock(element2, visited);
  });
  ancestors.forEach((element2) => visited.add(element2));
  return block;
}
function isTopBlockInRange(block, range) {
  const parentBlock = findAncestorBlock(block);
  if (!parentBlock) {
    return true;
  }
  const isParentInRange = range.containsRange(Range2._createOn(parentBlock), true);
  return !isParentInRange;
}
function isStartBlockSelected(startBlock, range) {
  if (!startBlock) {
    return false;
  }
  if (range.isCollapsed || startBlock.isEmpty) {
    return true;
  }
  if (range.start.isTouching(Position2._createAt(startBlock, startBlock.maxOffset))) {
    return false;
  }
  return isTopBlockInRange(startBlock, range);
}
function isEndBlockSelected(endBlock, range) {
  if (!endBlock) {
    return false;
  }
  if (range.isCollapsed || endBlock.isEmpty) {
    return true;
  }
  if (range.end.isTouching(Position2._createAt(endBlock, 0))) {
    return false;
  }
  return isTopBlockInRange(endBlock, range);
}
function findAncestorBlock(node) {
  const schema = node.root.document.model.schema;
  let parent = node.parent;
  while (parent) {
    if (schema.isBlock(parent)) {
      return parent;
    }
    parent = parent.parent;
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/liverange.js
var LiveRange = class _LiveRange extends EmitterMixin(Range2) {
  /**
   * Creates a live range.
   *
   * @see module:engine/model/range~Range
   */
  constructor(start, end) {
    super(start, end);
    bindWithDocument.call(this);
  }
  /**
   * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
   * referring to it).
   */
  detach() {
    this.stopListening();
  }
  /**
   * Creates a {@link module:engine/model/range~Range range instance} that is equal to this live range.
   */
  toRange() {
    return new Range2(this.start, this.end);
  }
  /**
   * Creates a `LiveRange` instance that is equal to the given range.
   */
  static fromRange(range) {
    return new _LiveRange(range.start, range.end);
  }
};
LiveRange.prototype.is = function(type) {
  return type === "liveRange" || type === "model:liveRange" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type == "range" || type === "model:range";
};
function bindWithDocument() {
  this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
    const operation = args[0];
    if (!operation.isDocumentOperation) {
      return;
    }
    transform.call(this, operation);
  }, { priority: "low" });
}
function transform(operation) {
  const ranges = this.getTransformedByOperation(operation);
  const result = Range2._createFromRanges(ranges);
  const boundariesChanged = !result.isEqual(this);
  const contentChanged = doesOperationChangeRangeContent(this, operation);
  let deletionPosition = null;
  if (boundariesChanged) {
    if (result.root.rootName == "$graveyard") {
      if (operation.type == "remove") {
        deletionPosition = operation.sourcePosition;
      } else {
        deletionPosition = operation.deletionPosition;
      }
    }
    const oldRange = this.toRange();
    this.start = result.start;
    this.end = result.end;
    this.fire("change:range", oldRange, { deletionPosition });
  } else if (contentChanged) {
    this.fire("change:content", this.toRange(), { deletionPosition });
  }
}
function doesOperationChangeRangeContent(range, operation) {
  switch (operation.type) {
    case "insert":
      return range.containsPosition(operation.position);
    case "move":
    case "remove":
    case "reinsert":
    case "merge":
      return range.containsPosition(operation.sourcePosition) || range.start.isEqual(operation.sourcePosition) || range.containsPosition(operation.targetPosition);
    case "split":
      return range.containsPosition(operation.splitPosition) || range.containsPosition(operation.insertionPosition);
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/documentselection.js
var storePrefix = "selection:";
var DocumentSelection2 = class extends EmitterMixin(TypeCheckable2) {
  /**
   * Creates an empty live selection for given {@link module:engine/model/document~Document}.
   *
   * @param doc Document which owns this selection.
   */
  constructor(doc) {
    super();
    this._selection = new LiveSelection(doc);
    this._selection.delegate("change:range").to(this);
    this._selection.delegate("change:attribute").to(this);
    this._selection.delegate("change:marker").to(this);
  }
  /**
   * Describes whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   */
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  /**
   * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
   * Together with {@link #focus} they define the direction of selection, which is important
   * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or
   * {@link module:engine/model/range~Range#end end} position of the most recently added range.
   *
   * Is set to `null` if there are no ranges in selection.
   *
   * @see #focus
   */
  get anchor() {
    return this._selection.anchor;
  }
  /**
   * Selection focus. Focus is a position where the selection ends.
   *
   * Is set to `null` if there are no ranges in selection.
   *
   * @see #anchor
   */
  get focus() {
    return this._selection.focus;
  }
  /**
   * Number of ranges in selection.
   */
  get rangeCount() {
    return this._selection.rangeCount;
  }
  /**
   * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to
   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
   */
  get hasOwnRange() {
    return this._selection.hasOwnRange;
  }
  /**
   * Specifies whether the {@link #focus}
   * precedes {@link #anchor}.
   *
   * @readonly
   * @type {Boolean}
   */
  get isBackward() {
    return this._selection.isBackward;
  }
  /**
   * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.
   *
   * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.
   */
  get isGravityOverridden() {
    return this._selection.isGravityOverridden;
  }
  /**
   * A collection of selection {@link module:engine/model/markercollection~Marker markers}.
   * Marker is a selection marker when selection range is inside the marker range.
   *
   * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.
   */
  get markers() {
    return this._selection.markers;
  }
  /**
   * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.
   *
   * @internal
   */
  get _ranges() {
    return this._selection._ranges;
  }
  /**
   * Returns an iterable that iterates over copies of selection ranges.
   */
  getRanges() {
    return this._selection.getRanges();
  }
  /**
   * Returns the first position in the selection.
   * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  /**
   * Returns the last position in the selection.
   * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
   * any other position in the selection.
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  /**
   * Returns a copy of the first range in the selection.
   * First range is the one which {@link module:engine/model/range~Range#start start} position
   * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
   * (not to confuse with the first range added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  /**
   * Returns a copy of the last range in the selection.
   * Last range is the one which {@link module:engine/model/range~Range#end end} position
   * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
   * recently added to the selection).
   *
   * Returns `null` if there are no ranges in selection.
   */
  getLastRange() {
    return this._selection.getLastRange();
  }
  /**
   * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
   *
   * This method's result can be used for example to apply block styling to all blocks covered by this selection.
   *
   * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
   * but will not return blocks nested in other blocks.
   *
   * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
   *
   * ```
   * <paragraph>[a</paragraph>
   * <blockQuote>
   * 	<paragraph>b</paragraph>
   * </blockQuote>
   * <paragraph>c]d</paragraph>
   * ```
   *
   * In this case the paragraph will also be returned, despite the collapsed selection:
   *
   * ```
   * <paragraph>[]a</paragraph>
   * ```
   *
   * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
   *
   * ```
   * [<blockA></blockA>
   * <blockB>
   * 	<blockC></blockC>
   * 	<blockD></blockD>
   * </blockB>
   * <blockE></blockE>]
   * ```
   *
   * If the selection is inside a block all the inner blocks (A & B) are returned:
   *
   * ```
   * <block>
   * 	<blockA>[a</blockA>
   * 	<blockB>b]</blockB>
   * </block>
   * ```
   *
   * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
   * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
   *
   * ```
   * <paragraph>[a</paragraph>
   * <paragraph>b</paragraph>
   * <paragraph>]c</paragraph> // this block will not be returned
   * ```
   */
  getSelectedBlocks() {
    return this._selection.getSelectedBlocks();
  }
  /**
   * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
   * one range in the selection, and that range contains exactly one element.
   * Returns `null` if there is no selected element.
   */
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  /**
   * Checks whether the selection contains the entire content of the given element. This means that selection must start
   * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
   * touching the element's end.
   *
   * By default, this method will check whether the entire content of the selection's current root is selected.
   * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
   */
  containsEntireContent(element) {
    return this._selection.containsEntireContent(element);
  }
  /**
   * Unbinds all events previously bound by document selection.
   */
  destroy() {
    this._selection.destroy();
  }
  /**
   * Returns iterable that iterates over this selection's attribute keys.
   */
  getAttributeKeys() {
    return this._selection.getAttributeKeys();
  }
  /**
   * Returns iterable that iterates over this selection's attributes.
   *
   * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
   * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
   */
  getAttributes() {
    return this._selection.getAttributes();
  }
  /**
   * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
   *
   * @param key Key of attribute to look for.
   * @returns Attribute value or `undefined`.
   */
  getAttribute(key) {
    return this._selection.getAttribute(key);
  }
  /**
   * Checks if the selection has an attribute for given key.
   *
   * @param key Key of attribute to check.
   * @returns `true` if attribute with given key is set on selection, `false` otherwise.
   */
  hasAttribute(key) {
    return this._selection.hasAttribute(key);
  }
  /**
   * Refreshes selection attributes and markers according to the current position in the model.
   */
  refresh() {
    this._selection.updateMarkers();
    this._selection._updateAttributes(false);
  }
  /**
   * Registers a marker group prefix or a marker name to be collected in the
   * {@link ~DocumentSelection#markers selection markers collection}.
   *
   * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.
   *
   * @param prefixOrName The marker group prefix or marker name.
   */
  observeMarkers(prefixOrName) {
    this._selection.observeMarkers(prefixOrName);
  }
  /**
   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.
   *
   * The location can be specified in the same form as
   * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
   *
   * @see module:engine/model/writer~Writer#setSelectionFocus
   * @internal
   * @param offset Offset or one of the flags. Used only when
   * first parameter is a {@link module:engine/model/item~Item model item}.
   */
  _setFocus(itemOrPosition, offset) {
    this._selection.setFocus(itemOrPosition, offset);
  }
  /**
   * Sets this selection's ranges and direction to the specified location based on the given
   * {@link module:engine/model/selection~Selectable selectable}.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.
   *
   * @see module:engine/model/writer~Writer#setSelection
   * @internal
   */
  _setTo(...args) {
    this._selection.setTo(...args);
  }
  /**
   * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
   * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.
   *
   * @see module:engine/model/writer~Writer#setSelectionAttribute
   * @internal
   * @param key Key of the attribute to set.
   * @param value Attribute value.
   */
  _setAttribute(key, value) {
    this._selection.setAttribute(key, value);
  }
  /**
   * Removes an attribute with given key from the selection.
   * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}
   * event with removed attribute key.
   * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.
   *
   * @see module:engine/model/writer~Writer#removeSelectionAttribute
   * @internal
   * @param key Key of the attribute to remove.
   */
  _removeAttribute(key) {
    this._selection.removeAttribute(key);
  }
  /**
   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
   *
   * @internal
   */
  _getStoredAttributes() {
    return this._selection.getStoredAttributes();
  }
  /**
   * Temporarily changes the gravity of the selection from the left to the right.
   *
   * The gravity defines from which direction the selection inherits its attributes. If it's the default left
   * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.
   * This method allows to temporarily override this behavior by forcing the gravity to the right.
   *
   * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
   * of the process.
   *
   * @see module:engine/model/writer~Writer#overrideSelectionGravity
   * @internal
   * @returns The unique id which allows restoring the gravity.
   */
  _overrideGravity() {
    return this._selection.overrideGravity();
  }
  /**
   * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.
   *
   * Restoring the gravity is only possible using the unique identifier returned by
   * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored
   * the same number of times it was overridden.
   *
   * @see module:engine/model/writer~Writer#restoreSelectionGravity
   * @internal
   * @param uid The unique id returned by {@link #_overrideGravity}.
   */
  _restoreGravity(uid2) {
    this._selection.restoreGravity(uid2);
  }
  /**
   * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
   *
   * @internal
   * @param key Attribute key to convert.
   * @returns Converted attribute key, applicable for selection store.
   */
  static _getStoreAttributeKey(key) {
    return storePrefix + key;
  }
  /**
   * Checks whether the given attribute key is an attribute stored on an element.
   *
   * @internal
   */
  static _isStoreAttributeKey(key) {
    return key.startsWith(storePrefix);
  }
};
DocumentSelection2.prototype.is = function(type) {
  return type === "selection" || type == "model:selection" || type == "documentSelection" || type == "model:documentSelection";
};
var LiveSelection = class extends Selection2 {
  /**
   * Creates an empty live selection for given {@link module:engine/model/document~Document}.
   *
   * @param doc Document which owns this selection.
   */
  constructor(doc) {
    super();
    this.markers = new Collection({ idProperty: "name" });
    this._attributePriority = /* @__PURE__ */ new Map();
    this._selectionRestorePosition = null;
    this._hasChangedRange = false;
    this._overriddenGravityRegister = /* @__PURE__ */ new Set();
    this._observedMarkers = /* @__PURE__ */ new Set();
    this._model = doc.model;
    this._document = doc;
    this.listenTo(this._model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (!operation.isDocumentOperation || operation.type == "marker" || operation.type == "rename" || operation.type == "noop") {
        return;
      }
      if (this._ranges.length == 0 && this._selectionRestorePosition) {
        this._fixGraveyardSelection(this._selectionRestorePosition);
      }
      this._selectionRestorePosition = null;
      if (this._hasChangedRange) {
        this._hasChangedRange = false;
        this.fire("change:range", { directChange: false });
      }
    }, { priority: "lowest" });
    this.on("change:range", () => {
      this._validateSelectionRanges(this.getRanges());
    });
    this.listenTo(this._model.markers, "update", (evt, marker, oldRange, newRange) => {
      this._updateMarker(marker, newRange);
    });
    this.listenTo(this._document, "change", (evt, batch) => {
      clearAttributesStoredInElement(this._model, batch);
    });
  }
  get isCollapsed() {
    const length = this._ranges.length;
    return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
  }
  get anchor() {
    return super.anchor || this._document._getDefaultRange().start;
  }
  get focus() {
    return super.focus || this._document._getDefaultRange().end;
  }
  get rangeCount() {
    return this._ranges.length ? this._ranges.length : 1;
  }
  /**
   * Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to
   * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
   */
  get hasOwnRange() {
    return this._ranges.length > 0;
  }
  /**
   * When set to `true` then selection attributes on node before the caret won't be taken
   * into consideration while updating selection attributes.
   */
  get isGravityOverridden() {
    return !!this._overriddenGravityRegister.size;
  }
  /**
   * Unbinds all events previously bound by live selection.
   */
  destroy() {
    for (let i = 0; i < this._ranges.length; i++) {
      this._ranges[i].detach();
    }
    this.stopListening();
  }
  *getRanges() {
    if (this._ranges.length) {
      yield* super.getRanges();
    } else {
      yield this._document._getDefaultRange();
    }
  }
  getFirstRange() {
    return super.getFirstRange() || this._document._getDefaultRange();
  }
  getLastRange() {
    return super.getLastRange() || this._document._getDefaultRange();
  }
  setTo(...args) {
    super.setTo(...args);
    this._updateAttributes(true);
    this.updateMarkers();
  }
  setFocus(itemOrPosition, offset) {
    super.setFocus(itemOrPosition, offset);
    this._updateAttributes(true);
    this.updateMarkers();
  }
  setAttribute(key, value) {
    if (this._setAttribute(key, value)) {
      const attributeKeys = [key];
      this.fire("change:attribute", { attributeKeys, directChange: true });
    }
  }
  removeAttribute(key) {
    if (this._removeAttribute(key)) {
      const attributeKeys = [key];
      this.fire("change:attribute", { attributeKeys, directChange: true });
    }
  }
  overrideGravity() {
    const overrideUid = uid();
    this._overriddenGravityRegister.add(overrideUid);
    if (this._overriddenGravityRegister.size === 1) {
      this._updateAttributes(true);
    }
    return overrideUid;
  }
  restoreGravity(uid2) {
    if (!this._overriddenGravityRegister.has(uid2)) {
      throw new CKEditorError("document-selection-gravity-wrong-restore", this, { uid: uid2 });
    }
    this._overriddenGravityRegister.delete(uid2);
    if (!this.isGravityOverridden) {
      this._updateAttributes(true);
    }
  }
  observeMarkers(prefixOrName) {
    this._observedMarkers.add(prefixOrName);
    this.updateMarkers();
  }
  _replaceAllRanges(ranges) {
    this._validateSelectionRanges(ranges);
    super._replaceAllRanges(ranges);
  }
  _popRange() {
    this._ranges.pop().detach();
  }
  _pushRange(range) {
    const liveRange = this._prepareRange(range);
    if (liveRange) {
      this._ranges.push(liveRange);
    }
  }
  _validateSelectionRanges(ranges) {
    for (const range of ranges) {
      if (!this._document._validateSelectionRange(range)) {
        throw new CKEditorError("document-selection-wrong-position", this, { range });
      }
    }
  }
  /**
   * Prepares given range to be added to selection. Checks if it is correct,
   * converts it to {@link module:engine/model/liverange~LiveRange LiveRange}
   * and sets listeners listening to the range's change event.
   */
  _prepareRange(range) {
    this._checkRange(range);
    if (range.root == this._document.graveyard) {
      return;
    }
    const liveRange = LiveRange.fromRange(range);
    liveRange.on("change:range", (evt, oldRange, data) => {
      this._hasChangedRange = true;
      if (liveRange.root == this._document.graveyard) {
        this._selectionRestorePosition = data.deletionPosition;
        const index = this._ranges.indexOf(liveRange);
        this._ranges.splice(index, 1);
        liveRange.detach();
      }
    });
    return liveRange;
  }
  updateMarkers() {
    if (!this._observedMarkers.size) {
      return;
    }
    const markers = [];
    let changed = false;
    for (const marker of this._model.markers) {
      const markerGroup = marker.name.split(":", 1)[0];
      if (!this._observedMarkers.has(markerGroup)) {
        continue;
      }
      const markerRange = marker.getRange();
      for (const selectionRange of this.getRanges()) {
        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
          markers.push(marker);
        }
      }
    }
    const oldMarkers = Array.from(this.markers);
    for (const marker of markers) {
      if (!this.markers.has(marker)) {
        this.markers.add(marker);
        changed = true;
      }
    }
    for (const marker of Array.from(this.markers)) {
      if (!markers.includes(marker)) {
        this.markers.remove(marker);
        changed = true;
      }
    }
    if (changed) {
      this.fire("change:marker", { oldMarkers, directChange: false });
    }
  }
  _updateMarker(marker, markerRange) {
    const markerGroup = marker.name.split(":", 1)[0];
    if (!this._observedMarkers.has(markerGroup)) {
      return;
    }
    let changed = false;
    const oldMarkers = Array.from(this.markers);
    const hasMarker = this.markers.has(marker);
    if (!markerRange) {
      if (hasMarker) {
        this.markers.remove(marker);
        changed = true;
      }
    } else {
      let contained = false;
      for (const selectionRange of this.getRanges()) {
        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
          contained = true;
          break;
        }
      }
      if (contained && !hasMarker) {
        this.markers.add(marker);
        changed = true;
      } else if (!contained && hasMarker) {
        this.markers.remove(marker);
        changed = true;
      }
    }
    if (changed) {
      this.fire("change:marker", { oldMarkers, directChange: false });
    }
  }
  /**
   * Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.
   */
  _updateAttributes(clearAll) {
    const newAttributes = toMap(this._getSurroundingAttributes());
    const oldAttributes = toMap(this.getAttributes());
    if (clearAll) {
      this._attributePriority = /* @__PURE__ */ new Map();
      this._attrs = /* @__PURE__ */ new Map();
    } else {
      for (const [key, priority] of this._attributePriority) {
        if (priority == "low") {
          this._attrs.delete(key);
          this._attributePriority.delete(key);
        }
      }
    }
    this._setAttributesTo(newAttributes);
    const changed = [];
    for (const [newKey, newValue] of this.getAttributes()) {
      if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {
        changed.push(newKey);
      }
    }
    for (const [oldKey] of oldAttributes) {
      if (!this.hasAttribute(oldKey)) {
        changed.push(oldKey);
      }
    }
    if (changed.length > 0) {
      this.fire("change:attribute", { attributeKeys: changed, directChange: false });
    }
  }
  /**
   * Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
   * parameter).
   */
  _setAttribute(key, value, directChange = true) {
    const priority = directChange ? "normal" : "low";
    if (priority == "low" && this._attributePriority.get(key) == "normal") {
      return false;
    }
    const oldValue = super.getAttribute(key);
    if (oldValue === value) {
      return false;
    }
    this._attrs.set(key, value);
    this._attributePriority.set(key, priority);
    return true;
  }
  /**
   * Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
   * parameter).
   *
   * NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will
   * be changed according to `directChange` parameter.
   */
  _removeAttribute(key, directChange = true) {
    const priority = directChange ? "normal" : "low";
    if (priority == "low" && this._attributePriority.get(key) == "normal") {
      return false;
    }
    this._attributePriority.set(key, priority);
    if (!super.hasAttribute(key)) {
      return false;
    }
    this._attrs.delete(key);
    return true;
  }
  /**
   * Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
   * `directChange` parameter).
   */
  _setAttributesTo(attrs) {
    const changed = /* @__PURE__ */ new Set();
    for (const [oldKey, oldValue] of this.getAttributes()) {
      if (attrs.get(oldKey) === oldValue) {
        continue;
      }
      this._removeAttribute(oldKey, false);
    }
    for (const [key, value] of attrs) {
      const gotAdded = this._setAttribute(key, value, false);
      if (gotAdded) {
        changed.add(key);
      }
    }
    return changed;
  }
  /**
   * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
   */
  *getStoredAttributes() {
    const selectionParent = this.getFirstPosition().parent;
    if (this.isCollapsed && selectionParent.isEmpty) {
      for (const key of selectionParent.getAttributeKeys()) {
        if (key.startsWith(storePrefix)) {
          const realKey = key.substr(storePrefix.length);
          yield [realKey, selectionParent.getAttribute(key)];
        }
      }
    }
  }
  /**
   * Checks model text nodes that are closest to the selection's first position and returns attributes of first
   * found element. If there are no text nodes in selection's first position parent, it returns selection
   * attributes stored in that parent.
   */
  _getSurroundingAttributes() {
    const position = this.getFirstPosition();
    const schema = this._model.schema;
    if (position.root.rootName == "$graveyard") {
      return null;
    }
    let attrs = null;
    if (!this.isCollapsed) {
      const range = this.getFirstRange();
      for (const value of range) {
        if (value.item.is("element") && schema.isObject(value.item)) {
          attrs = getTextAttributes(value.item, schema);
          break;
        }
        if (value.type == "text") {
          attrs = value.item.getAttributes();
          break;
        }
      }
    } else {
      const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;
      const nodeAfter = position.textNode ? position.textNode : position.nodeAfter;
      if (!this.isGravityOverridden) {
        attrs = getTextAttributes(nodeBefore, schema);
      }
      if (!attrs) {
        attrs = getTextAttributes(nodeAfter, schema);
      }
      if (!this.isGravityOverridden && !attrs) {
        let node = nodeBefore;
        while (node && !attrs) {
          node = node.previousSibling;
          attrs = getTextAttributes(node, schema);
        }
      }
      if (!attrs) {
        let node = nodeAfter;
        while (node && !attrs) {
          node = node.nextSibling;
          attrs = getTextAttributes(node, schema);
        }
      }
      if (!attrs) {
        attrs = this.getStoredAttributes();
      }
    }
    return attrs;
  }
  /**
   * Fixes the selection after all its ranges got removed.
   * @param deletionPosition Position where the deletion happened.
   */
  _fixGraveyardSelection(deletionPosition) {
    const selectionRange = this._model.schema.getNearestSelectionRange(deletionPosition);
    if (selectionRange) {
      this._pushRange(selectionRange);
    }
  }
};
function getTextAttributes(node, schema) {
  if (!node) {
    return null;
  }
  if (node instanceof TextProxy2 || node instanceof Text2) {
    return node.getAttributes();
  }
  if (!schema.isInline(node)) {
    return null;
  }
  if (!schema.isObject(node)) {
    return [];
  }
  const attributes = [];
  for (const [key, value] of node.getAttributes()) {
    if (schema.checkAttribute("$text", key) && schema.getAttributeProperties(key).copyFromObject !== false) {
      attributes.push([key, value]);
    }
  }
  return attributes;
}
function clearAttributesStoredInElement(model, batch) {
  const differ = model.document.differ;
  for (const entry of differ.getChanges()) {
    if (entry.type != "insert") {
      continue;
    }
    const changeParent = entry.position.parent;
    const isNoLongerEmpty = entry.length === changeParent.maxOffset;
    if (isNoLongerEmpty) {
      model.enqueueChange(batch, (writer) => {
        const storedAttributes = Array.from(changeParent.getAttributeKeys()).filter((key) => key.startsWith(storePrefix));
        for (const key of storedAttributes) {
          writer.removeAttribute(key, changeParent);
        }
      });
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversionhelpers.js
var ConversionHelpers = class {
  /**
   * Creates a conversion helpers instance.
   */
  constructor(dispatchers) {
    this._dispatchers = dispatchers;
  }
  /**
   * Registers a conversion helper.
   *
   * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`
   * method description.
   *
   * @param conversionHelper The function to be called on event.
   */
  add(conversionHelper) {
    for (const dispatcher of this._dispatchers) {
      conversionHelper(dispatcher);
    }
    return this;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js
var DowncastHelpers = class extends ConversionHelpers {
  /**
   * Model element to view element conversion helper.
   *
   * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'p'
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'div',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'fancyParagraph',
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: 'heading',
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
   * 	}
   * } );
   * ```
   *
   * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or
   * the `children` props on a model description. You will find a couple examples below.
   *
   * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`
   * description. For example, this model:
   *
   * ```xml
   * <box>
   * 	<paragraph>Some text.</paragraph>
   * </box>
   * ```
   *
   * will be converted into this structure in the view:
   *
   * ```html
   * <div class="box" data-type="single">
   * 	<p>Some text.</p>
   * </div>
   * ```
   *
   * But if more items were inserted in the model:
   *
   * ```xml
   * <box>
   * 	<paragraph>Some text.</paragraph>
   * 	<paragraph>Other item.</paragraph>
   * </box>
   * ```
   *
   * it will be converted into this structure in the view (note the element `data-type` change):
   *
   * ```html
   * <div class="box" data-type="multiple">
   * 	<p>Some text.</p>
   * 	<p>Other item.</p>
   * </div>
   * ```
   *
   * Such a converter would look like this (note that the `paragraph` elements are converted separately):
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: {
   * 		name: 'box',
   * 		children: true
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'div', {
   * 			class: 'box',
   * 			'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'
   * 		} );
   * 	}
   * } );
   * ```
   *
   * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`
   * description. For example, this model:
   *
   * ```xml
   * <heading level="2">Some text.</heading>
   * ```
   *
   * will be converted into this structure in the view:
   *
   * ```html
   * <h2>Some text.</h2>
   * ```
   *
   * But if the `heading` element's `level` attribute has been updated to `3` for example, then
   * it will be converted into this structure in the view:
   *
   * ```html
   * <h3>Some text.</h3>
   * ```
   *
   * Such a converter would look as follows:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToElement( {
   * 	model: {
   * 		name: 'heading',
   * 		attributes: 'level'
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * You can read more about the element-to-element conversion in the
   * {@glink framework/deep-dive/conversion/downcast downcast conversion} guide.
   *
   * @param config Conversion configuration.
   * @param config.model The description or a name of the model element to convert.
   * @param config.model.attributes The list of attribute names that should be consumed while creating
   * the view element. Note that the view will be reconverted if any of the listed attributes changes.
   * @param config.model.children Specifies whether the view element requires reconversion if the list
   * of the model child nodes changed.
   * @param config.view A view element definition or a function that takes the model element and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as parameters and returns a view container element.
   */
  elementToElement(config) {
    return this.add(downcastElementToElement(config));
  }
  /**
   * The model element to view structure (several elements) conversion helper.
   *
   * This conversion results in creating a view structure with one or more slots defined for the child nodes.
   * For example, a model `<table>` may become this structure in the view:
   *
   * ```html
   * <figure class="table">
   * 	<table>
   * 		<tbody>${ slot for table rows }</tbody>
   * 	</table>
   * </figure>
   * ```
   *
   * The children of the model's `<table>` element will be inserted into the `<tbody>` element.
   * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.
   *
   * Imagine a table feature where for this model structure:
   *
   * ```xml
   * <table headingRows="1">
   * 	<tableRow> ... table cells 1 ... </tableRow>
   * 	<tableRow> ... table cells 2 ... </tableRow>
   * 	<tableRow> ... table cells 3 ... </tableRow>
   * 	<caption>Caption text</caption>
   * </table>
   * ```
   *
   * we want to generate this view structure:
   *
   * ```html
   * <figure class="table">
   * 	<table>
   * 		<thead>
   * 			<tr> ... table cells 1 ... </tr>
   * 		</thead>
   * 		<tbody>
   * 			<tr> ... table cells 2 ... </tr>
   * 			<tr> ... table cells 3 ... </tr>
   * 		</tbody>
   * 	</table>
   * 	<figcaption>Caption text</figcaption>
   * </figure>
   * ```
   *
   * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements
   * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.
   *
   * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.
   * In the example above, this will handle the table caption.
   *
   * Such a converter would look like this:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).elementToStructure( {
   * 	model: {
   * 		name: 'table',
   * 		attributes: [ 'headingRows' ]
   * 	},
   * 	view: ( modelElement, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		const figureElement = writer.createContainerElement( 'figure', { class: 'table' } );
   * 		const tableElement = writer.createContainerElement( 'table' );
   *
   * 		writer.insert( writer.createPositionAt( figureElement, 0 ), tableElement );
   *
   * 		const headingRows = modelElement.getAttribute( 'headingRows' ) || 0;
   *
   * 		if ( headingRows > 0 ) {
   * 			const tableHead = writer.createContainerElement( 'thead' );
   *
   * 			const headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );
   *
   * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );
   * 			writer.insert( writer.createPositionAt( tableHead, 0 ), headSlot );
   * 		}
   *
   * 		if ( headingRows < tableUtils.getRows( table ) ) {
   * 			const tableBody = writer.createContainerElement( 'tbody' );
   *
   * 			const bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );
   *
   * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );
   * 			writer.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );
   * 		}
   *
   * 		const restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );
   *
   * 		writer.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );
   *
   * 		return figureElement;
   * 	}
   * } );
   * ```
   *
   * Note: The children of a model element that's being converted must be allocated in the same order in the view
   * in which they are placed in the model.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The description or a name of the model element to convert.
   * @param config.model.name The name of the model element to convert.
   * @param config.model.attributes The list of attribute names that should be consumed while creating
   * the view structure. Note that the view will be reconverted if any of the listed attributes will change.
   * @param config.view A function that takes the model element and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters
   * and returns a view container element with slots for model child nodes to be converted into.
   */
  elementToStructure(config) {
    return this.add(downcastElementToStructure(config));
  }
  /**
   * Model attribute to view element conversion helper.
   *
   * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with
   * `"Foo"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: 'strong'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: 'b',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'invert',
   * 	view: {
   * 		name: 'span',
   * 		classes: [ 'font-light', 'bg-dark' ]
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: {
   * 		key: 'fontSize',
   * 		values: [ 'big', 'small' ]
   * 	},
   * 	view: {
   * 		big: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '1.2em'
   * 			}
   * 		},
   * 		small: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '0.8em'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: 'bold',
   * 	view: ( modelAttributeValue, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createAttributeElement( 'span', {
   * 			style: 'font-weight:' + modelAttributeValue
   * 		} );
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToElement( {
   * 	model: {
   * 		key: 'color',
   * 		name: '$text'
   * 	},
   * 	view: ( modelAttributeValue, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createAttributeElement( 'span', {
   * 			style: 'color:' + modelAttributeValue
   * 		} );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
   * of `String`s with possible values if the model attribute is an enumerable.
   * @param config.view A view element definition or a function
   * that takes the model attribute value and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view
   * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`
   * to view element definitions or functions.
   * @param config.converterPriority Converter priority.
   */
  attributeToElement(config) {
    return this.add(downcastAttributeToElement(config));
  }
  /**
   * Model attribute to view attribute conversion helper.
   *
   * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,
   * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'source',
   * 	view: 'src'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'source',
   * 	view: 'href',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'source'
   * 	},
   * 	view: 'src'
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: {
   * 		name: 'styled',
   * 		values: [ 'dark', 'light' ]
   * 	},
   * 	view: {
   * 		dark: {
   * 			key: 'class',
   * 			value: [ 'styled', 'styled-dark' ]
   * 		},
   * 		light: {
   * 			key: 'class',
   * 			value: [ 'styled', 'styled-light' ]
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'styled',
   * 	view: modelAttributeValue => ( {
   * 		key: 'class',
   * 		value: 'styled-' + modelAttributeValue
   * 	} )
   * } );
   * ```
   *
   * **Note**: Downcasting to a style property requires providing `value` as an object:
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).attributeToAttribute( {
   * 	model: 'lineHeight',
   * 	view: modelAttributeValue => ( {
   * 		key: 'style',
   * 		value: {
   * 			'line-height': modelAttributeValue,
   * 			'border-bottom': '1px dotted #ba2'
   * 		}
   * 	} )
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
   * the attribute key, possible values and, optionally, an element name to convert from.
   * @param config.view A view attribute key, or a `{ key, value }` object or a function that takes the model attribute value and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an
   * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.
   * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
   * `{ key, value }` objects or a functions.
   * @param config.converterPriority Converter priority.
   */
  attributeToAttribute(config) {
    return this.add(downcastAttributeToAttribute(config));
  }
  /**
   * Model marker to view element conversion helper.
   *
   * **Note**: This method should be used mainly for editing the downcast and it is recommended
   * to use the {@link #markerToData `#markerToData()`} helper instead.
   *
   * This helper may produce invalid HTML code (e.g. a span between table cells).
   * It should only be used when you are sure that the produced HTML will be semantically correct.
   *
   * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker
   * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`
   * becomes `<p>F<span data-marker="search"></span>oo b<span data-marker="search"></span>ar</p>` in the view.
   *
   * ```ts
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: 'marker-search'
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: 'search-result',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: {
   * 		name: 'span',
   * 		attributes: {
   * 			'data-marker': 'search'
   * 		}
   * 	}
   * } );
   *
   * editor.conversion.for( 'editingDowncast' ).markerToElement( {
   * 	model: 'search',
   * 	view: ( markerData, conversionApi ) => {
   * 		const { writer } = conversionApi;
   *
   * 		return writer.createUIElement( 'span', {
   * 			'data-marker': 'search',
   * 			'data-start': markerData.isOpening
   * 		} );
   * 	}
   * } );
   * ```
   *
   * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function
   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as a parameters and should return an instance of the
   * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from
   * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,
   * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for
   * the marker end boundary element.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or model marker group) to convert.
   * @param config.view A view element definition or a function that takes the model marker data and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
   * and returns a view UI element.
   * @param config.converterPriority Converter priority.
   */
  markerToElement(config) {
    return this.add(downcastMarkerToElement(config));
  }
  /**
   * Model marker to highlight conversion helper.
   *
   * This conversion results in creating a highlight on view nodes. For this kind of conversion,
   * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.
   *
   * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes
   * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes
   * `<p>F<span class="comment">oo b</span>ar</p>` in the view.
   *
   * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,
   * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).
   * For example, a model marker set like this:
   * `[<imageInline src="foo.jpg"></imageInline>]` becomes `<img src="foo.jpg" class="comment"></img>` in the view.
   *
   * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it
   * to a container element, it is the container element instance itself that applies values from the highlight descriptor.
   * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.
   *
   * ```ts
   * editor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );
   *
   * editor.conversion.for( 'downcast' ).markerToHighlight( {
   * 	model: 'comment',
   * 	view: { classes: 'comment' },
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'downcast' ).markerToHighlight( {
   * 	model: 'comment',
   * 	view: ( data, conversionApi ) => {
   * 		// Assuming that the marker name is in a form of comment:commentType:commentId.
   * 		const [ , commentType, commentId ] = data.markerName.split( ':' );
   *
   * 		return {
   * 			classes: [ 'comment', 'comment-' + commentType ],
   * 			attributes: { 'data-comment-id': commentId }
   * 		};
   * 	}
   * } );
   * ```
   *
   * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function
   * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
   * as the parameters and should return a
   * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.
   * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or model marker group) to convert.
   * @param config.view A highlight descriptor that will be used for highlighting or a function that takes the model marker data and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
   * and returns a highlight descriptor.
   * @param config.converterPriority Converter priority.
   */
  markerToHighlight(config) {
    return this.add(downcastMarkerToHighlight(config));
  }
  /**
   * Model marker converter for data downcast.
   *
   * This conversion creates a representation for model marker boundaries in the view:
   *
   * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.
   * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.
   *
   * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.
   * The default configuration for this conversion is that the first part is the `group` part and the rest of
   * the marker name becomes the `name` part.
   *
   * Tag and attribute names and values are generated from the marker name:
   *
   * * The templates for attributes are `data-[group]-start-before="[name]"`, `data-[group]-start-after="[name]"`,
   * `data-[group]-end-before="[name]"` and `data-[group]-end-after="[name]"`.
   * * The templates for view elements are `<[group]-start name="[name]">` and `<[group]-end name="[name]">`.
   *
   * Attributes mark whether the given marker's start or end boundary is before or after the given element.
   * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.
   * The other two are used when the former two cannot be used.
   *
   * The conversion configuration can take a function that will generate different group and name parts.
   * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two
   * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.
   *
   * Basic usage:
   *
   * ```ts
   * // Using the default conversion.
   * // In this case, all markers with names starting with 'comment:' will be converted.
   * // The `group` parameter will be set to `comment`.
   * // The `name` parameter will be the rest of the marker name (without the `:`).
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment'
   * } );
   * ```
   *
   * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked
   * by `[]`):
   *
   * ```
   * // Model:
   * <paragraph>Foo[bar</paragraph>
   * <imageBlock src="abc.jpg"></imageBlock>]
   *
   * // View:
   * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
   * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
   * ```
   *
   * In the example above, the comment starts before "bar" and ends after the image.
   *
   * If the `name` part is empty, the following view may be generated:
   *
   * ```html
   * <p>Foo <myMarker-start></myMarker-start>bar</p>
   * <figure data-myMarker-end-after="" class="image"><img src="abc.jpg" /></figure>
   * ```
   *
   * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.
   *
   * Examples where `data-group-start-after` and `data-group-end-before` are used:
   *
   * ```
   * // Model:
   * <blockQuote>[]<paragraph>Foo</paragraph></blockQuote>
   *
   * // View:
   * <blockquote><p data-group-end-before="name" data-group-start-before="name">Foo</p></blockquote>
   * ```
   *
   * Similarly, when a marker is collapsed after the last element:
   *
   * ```
   * // Model:
   * <blockQuote><paragraph>Foo</paragraph>[]</blockQuote>
   *
   * // View:
   * <blockquote><p data-group-end-after="name" data-group-start-after="name">Foo</p></blockquote>
   * ```
   *
   * When there are multiple markers from the same group stored in the same attribute of the same element, their
   * name parts are put together in the attribute value, for example: `data-group-start-before="name1,name2,name3"`.
   *
   * Other examples of usage:
   *
   * ```ts
   * // Using a custom function which is the same as the default conversion:
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment',
   * 	view: markerName => ( {
   * 		group: 'comment',
   * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
   * 	} )
   * } );
   *
   * // Using the converter priority:
   * editor.conversion.for( 'dataDowncast' ).markerToData( {
   * 	model: 'comment',
   * 	view: markerName => ( {
   * 		group: 'comment',
   * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
   * 	} ),
   * 	converterPriority: 'high'
   * } );
   * ```
   *
   * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.
   *
   * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to
   * add a converter to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.model The name of the model marker (or the model marker group) to convert.
   * @param config.view A function that takes the model marker name and
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters
   * and returns an object with the `group` and `name` properties.
   * @param config.converterPriority Converter priority.
   */
  markerToData(config) {
    return this.add(downcastMarkerToData(config));
  }
};
function insertText() {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    const viewText = viewWriter.createText(data.item.data);
    viewWriter.insert(viewPosition, viewText);
  };
}
function insertAttributesAndChildren() {
  return (evt, data, conversionApi) => {
    conversionApi.convertAttributes(data.item);
    if (!data.reconversion && data.item.is("element") && !data.item.isEmpty) {
      conversionApi.convertChildren(data.item);
    }
  };
}
function remove2() {
  return (evt, data, conversionApi) => {
    const viewStart = conversionApi.mapper.toViewPosition(data.position);
    const modelEnd = data.position.getShiftedBy(data.length);
    const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, { isPhantom: true });
    const viewRange = conversionApi.writer.createRange(viewStart, viewEnd);
    const removed = conversionApi.writer.remove(viewRange.getTrimmed());
    for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {
      conversionApi.mapper.unbindViewElement(child, { defer: true });
    }
  };
}
function createViewElementFromHighlightDescriptor(writer, descriptor) {
  const viewElement = writer.createAttributeElement("span", descriptor.attributes);
  if (descriptor.classes) {
    viewElement._addClass(descriptor.classes);
  }
  if (typeof descriptor.priority === "number") {
    viewElement._priority = descriptor.priority;
  }
  viewElement._id = descriptor.id;
  return viewElement;
}
function convertRangeSelection() {
  return (evt, data, conversionApi) => {
    const selection = data.selection;
    if (selection.isCollapsed) {
      return;
    }
    if (!conversionApi.consumable.consume(selection, "selection")) {
      return;
    }
    const viewRanges = [];
    for (const range of selection.getRanges()) {
      viewRanges.push(conversionApi.mapper.toViewRange(range));
    }
    conversionApi.writer.setSelection(viewRanges, { backward: selection.isBackward });
  };
}
function convertCollapsedSelection() {
  return (evt, data, conversionApi) => {
    const selection = data.selection;
    if (!selection.isCollapsed) {
      return;
    }
    if (!conversionApi.consumable.consume(selection, "selection")) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const modelPosition = selection.getFirstPosition();
    const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
    const brokenPosition = viewWriter.breakAttributes(viewPosition);
    viewWriter.setSelection(brokenPosition);
  };
}
function cleanSelection() {
  return (evt, data, conversionApi) => {
    const viewWriter = conversionApi.writer;
    const viewSelection = viewWriter.document.selection;
    for (const range of viewSelection.getRanges()) {
      if (range.isCollapsed) {
        if (range.end.parent.isAttached()) {
          conversionApi.writer.mergeAttributes(range.start);
        }
      }
    }
    viewWriter.setSelection(null);
  };
}
function wrap(elementCreator) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data);
    const newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);
    if (!oldViewElement && !newViewElement) {
      return;
    }
    conversionApi.consumable.consume(data.item, evt.name);
    const viewWriter = conversionApi.writer;
    const viewSelection = viewWriter.document.selection;
    if (data.item instanceof Selection2 || data.item instanceof DocumentSelection2) {
      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);
    } else {
      let viewRange = conversionApi.mapper.toViewRange(data.range);
      if (data.attributeOldValue !== null && oldViewElement) {
        viewRange = viewWriter.unwrap(viewRange, oldViewElement);
      }
      if (data.attributeNewValue !== null && newViewElement) {
        viewWriter.wrap(viewRange, newViewElement);
      }
    }
  };
}
function insertElement(elementCreator, consumer = defaultConsumer) {
  return (evt, data, conversionApi) => {
    if (!consumer(data.item, conversionApi.consumable, { preflight: true })) {
      return;
    }
    const viewElement = elementCreator(data.item, conversionApi, data);
    if (!viewElement) {
      return;
    }
    consumer(data.item, conversionApi.consumable);
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    conversionApi.mapper.bindElements(data.item, viewElement);
    conversionApi.writer.insert(viewPosition, viewElement);
    conversionApi.convertAttributes(data.item);
    reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, { reconversion: data.reconversion });
  };
}
function insertStructure(elementCreator, consumer) {
  return (evt, data, conversionApi) => {
    if (!consumer(data.item, conversionApi.consumable, { preflight: true })) {
      return;
    }
    const slotsMap = /* @__PURE__ */ new Map();
    conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi));
    const viewElement = elementCreator(data.item, conversionApi, data);
    conversionApi.writer._clearSlotFactory();
    if (!viewElement) {
      return;
    }
    validateSlotsChildren(data.item, slotsMap, conversionApi);
    consumer(data.item, conversionApi.consumable);
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    conversionApi.mapper.bindElements(data.item, viewElement);
    conversionApi.writer.insert(viewPosition, viewElement);
    conversionApi.convertAttributes(data.item);
    fillSlots(viewElement, slotsMap, conversionApi, { reconversion: data.reconversion });
  };
}
function insertUIElement(elementCreator) {
  return (evt, data, conversionApi) => {
    data.isOpening = true;
    const viewStartElement = elementCreator(data, conversionApi);
    data.isOpening = false;
    const viewEndElement = elementCreator(data, conversionApi);
    if (!viewStartElement || !viewEndElement) {
      return;
    }
    const markerRange = data.markerRange;
    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {
      return;
    }
    for (const value of markerRange) {
      if (!conversionApi.consumable.consume(value.item, evt.name)) {
        return;
      }
    }
    const mapper = conversionApi.mapper;
    const viewWriter = conversionApi.writer;
    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);
    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName);
    if (!markerRange.isCollapsed) {
      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);
      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);
    }
    evt.stop();
  };
}
function removeUIElement() {
  return (evt, data, conversionApi) => {
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
      conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
  };
}
function insertMarkerData(viewCreator) {
  return (evt, data, conversionApi) => {
    const viewMarkerData = viewCreator(data.markerName, conversionApi);
    if (!viewMarkerData) {
      return;
    }
    const markerRange = data.markerRange;
    if (!conversionApi.consumable.consume(markerRange, evt.name)) {
      return;
    }
    handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);
    handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);
    evt.stop();
  };
}
function handleMarkerBoundary(range, isStart, conversionApi, data, viewMarkerData) {
  const modelPosition = isStart ? range.start : range.end;
  const elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is("element") ? modelPosition.nodeAfter : null;
  const elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is("element") ? modelPosition.nodeBefore : null;
  if (elementAfter || elementBefore) {
    let modelElement;
    let isBefore;
    if (isStart && elementAfter || !isStart && !elementBefore) {
      modelElement = elementAfter;
      isBefore = true;
    } else {
      modelElement = elementBefore;
      isBefore = false;
    }
    const viewElement = conversionApi.mapper.toViewElement(modelElement);
    if (viewElement) {
      insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);
      return;
    }
  }
  const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
  insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);
}
function insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {
  const attributeName = `data-${viewMarkerData.group}-${isStart ? "start" : "end"}-${isBefore ? "before" : "after"}`;
  const markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(",") : [];
  markerNames.unshift(viewMarkerData.name);
  conversionApi.writer.setAttribute(attributeName, markerNames.join(","), viewElement);
  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
}
function insertMarkerAsElement(position, isStart, conversionApi, data, viewMarkerData) {
  const viewElementName = `${viewMarkerData.group}-${isStart ? "start" : "end"}`;
  const attrs = viewMarkerData.name ? { "name": viewMarkerData.name } : null;
  const viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);
  conversionApi.writer.insert(position, viewElement);
  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
}
function removeMarkerData(viewCreator) {
  return (evt, data, conversionApi) => {
    const viewData = viewCreator(data.markerName, conversionApi);
    if (!viewData) {
      return;
    }
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
      if (element.is("containerElement")) {
        removeMarkerFromAttribute(`data-${viewData.group}-start-before`, element);
        removeMarkerFromAttribute(`data-${viewData.group}-start-after`, element);
        removeMarkerFromAttribute(`data-${viewData.group}-end-before`, element);
        removeMarkerFromAttribute(`data-${viewData.group}-end-after`, element);
      } else {
        conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
      }
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
    function removeMarkerFromAttribute(attributeName, element) {
      if (element.hasAttribute(attributeName)) {
        const markerNames = new Set(element.getAttribute(attributeName).split(","));
        markerNames.delete(viewData.name);
        if (markerNames.size == 0) {
          conversionApi.writer.removeAttribute(attributeName, element);
        } else {
          conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(","), element);
        }
      }
    }
  };
}
function changeAttribute(attributeCreator) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);
    const newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);
    if (!oldAttribute && !newAttribute) {
      return;
    }
    conversionApi.consumable.consume(data.item, evt.name);
    const viewElement = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    if (!viewElement) {
      throw new CKEditorError("conversion-attribute-to-attribute-on-text", conversionApi.dispatcher, data);
    }
    if (data.attributeOldValue !== null && oldAttribute) {
      if (oldAttribute.key == "class") {
        const classes = typeof oldAttribute.value == "string" ? oldAttribute.value.split(/\s+/) : oldAttribute.value;
        for (const className of classes) {
          viewWriter.removeClass(className, viewElement);
        }
      } else if (oldAttribute.key == "style") {
        if (typeof oldAttribute.value == "string") {
          const styles = new StylesMap(viewWriter.document.stylesProcessor);
          styles.setTo(oldAttribute.value);
          for (const [key] of styles.getStylesEntries()) {
            viewWriter.removeStyle(key, viewElement);
          }
        } else {
          const keys = Object.keys(oldAttribute.value);
          for (const key of keys) {
            viewWriter.removeStyle(key, viewElement);
          }
        }
      } else {
        viewWriter.removeAttribute(oldAttribute.key, viewElement);
      }
    }
    if (data.attributeNewValue !== null && newAttribute) {
      if (newAttribute.key == "class") {
        const classes = typeof newAttribute.value == "string" ? newAttribute.value.split(/\s+/) : newAttribute.value;
        for (const className of classes) {
          viewWriter.addClass(className, viewElement);
        }
      } else if (newAttribute.key == "style") {
        if (typeof newAttribute.value == "string") {
          const styles = new StylesMap(viewWriter.document.stylesProcessor);
          styles.setTo(newAttribute.value);
          for (const [key, value] of styles.getStylesEntries()) {
            viewWriter.setStyle(key, value, viewElement);
          }
        } else {
          const keys = Object.keys(newAttribute.value);
          for (const key of keys) {
            viewWriter.setStyle(key, newAttribute.value[key], viewElement);
          }
        }
      } else {
        viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);
      }
    }
  };
}
function highlightText(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (!data.item) {
      return;
    }
    if (!(data.item instanceof Selection2 || data.item instanceof DocumentSelection2) && !data.item.is("$textProxy")) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);
    const viewSelection = viewWriter.document.selection;
    if (data.item instanceof Selection2 || data.item instanceof DocumentSelection2) {
      viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
    } else {
      const viewRange = conversionApi.mapper.toViewRange(data.range);
      const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);
      for (const element of rangeAfterWrap.getItems()) {
        if (element.is("attributeElement") && element.isSimilar(viewElement)) {
          conversionApi.mapper.bindElementToMarker(element, data.markerName);
          break;
        }
      }
    }
  };
}
function highlightElement(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (!data.item) {
      return;
    }
    if (!(data.item instanceof Element2)) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const viewElement = conversionApi.mapper.toViewElement(data.item);
    if (viewElement && viewElement.getCustomProperty("addHighlight")) {
      conversionApi.consumable.consume(data.item, evt.name);
      for (const value of Range2._createIn(data.item)) {
        conversionApi.consumable.consume(value.item, evt.name);
      }
      const addHighlightCallback = viewElement.getCustomProperty("addHighlight");
      addHighlightCallback(viewElement, descriptor, conversionApi.writer);
      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
    }
  };
}
function removeHighlight(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (data.markerRange.isCollapsed) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    const viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor);
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
      if (element.is("attributeElement")) {
        conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);
      } else {
        const removeHighlightCallback = element.getCustomProperty("removeHighlight");
        removeHighlightCallback(element, descriptor.id, conversionApi.writer);
      }
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
  };
}
function downcastElementToElement(config) {
  const model = normalizeModelElementConfig(config.model);
  const view = normalizeToElementConfig(config.view, "container");
  if (model.attributes.length) {
    model.children = true;
  }
  return (dispatcher) => {
    dispatcher.on(`insert:${model.name}`, insertElement(view, createConsumer(model)), { priority: config.converterPriority || "normal" });
    if (model.children || model.attributes.length) {
      dispatcher.on("reduceChanges", createChangeReducer(model), { priority: "low" });
    }
  };
}
function downcastElementToStructure(config) {
  const model = normalizeModelElementConfig(config.model);
  const view = normalizeToElementConfig(config.view, "container");
  model.children = true;
  return (dispatcher) => {
    if (dispatcher._conversionApi.schema.checkChild(model.name, "$text")) {
      throw new CKEditorError("conversion-element-to-structure-disallowed-text", dispatcher, { elementName: model.name });
    }
    dispatcher.on(`insert:${model.name}`, insertStructure(view, createConsumer(model)), { priority: config.converterPriority || "normal" });
    dispatcher.on("reduceChanges", createChangeReducer(model), { priority: "low" });
  };
}
function downcastAttributeToElement(config) {
  config = cloneDeep_default(config);
  let model = config.model;
  if (typeof model == "string") {
    model = { key: model };
  }
  let eventName = `attribute:${model.key}`;
  if (model.name) {
    eventName += ":" + model.name;
  }
  if (model.values) {
    for (const modelValue of model.values) {
      config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], "attribute");
    }
  } else {
    config.view = normalizeToElementConfig(config.view, "attribute");
  }
  const elementCreator = getFromAttributeCreator(config);
  return (dispatcher) => {
    dispatcher.on(eventName, wrap(elementCreator), { priority: config.converterPriority || "normal" });
  };
}
function downcastAttributeToAttribute(config) {
  config = cloneDeep_default(config);
  let model = config.model;
  if (typeof model == "string") {
    model = { key: model };
  }
  let eventName = `attribute:${model.key}`;
  if (model.name) {
    eventName += ":" + model.name;
  }
  if (model.values) {
    for (const modelValue of model.values) {
      config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);
    }
  } else {
    config.view = normalizeToAttributeConfig(config.view);
  }
  const elementCreator = getFromAttributeCreator(config);
  return (dispatcher) => {
    dispatcher.on(eventName, changeAttribute(elementCreator), { priority: config.converterPriority || "normal" });
  };
}
function downcastMarkerToElement(config) {
  const view = normalizeToElementConfig(config.view, "ui");
  return (dispatcher) => {
    dispatcher.on(`addMarker:${config.model}`, insertUIElement(view), { priority: config.converterPriority || "normal" });
    dispatcher.on(`removeMarker:${config.model}`, removeUIElement(), { priority: config.converterPriority || "normal" });
  };
}
function downcastMarkerToData(config) {
  config = cloneDeep_default(config);
  const group = config.model;
  let view = config.view;
  if (!view) {
    view = (markerName) => ({
      group,
      name: markerName.substr(config.model.length + 1)
    });
  }
  return (dispatcher) => {
    dispatcher.on(`addMarker:${group}`, insertMarkerData(view), { priority: config.converterPriority || "normal" });
    dispatcher.on(`removeMarker:${group}`, removeMarkerData(view), { priority: config.converterPriority || "normal" });
  };
}
function downcastMarkerToHighlight(config) {
  return (dispatcher) => {
    dispatcher.on(`addMarker:${config.model}`, highlightText(config.view), { priority: config.converterPriority || "normal" });
    dispatcher.on(`addMarker:${config.model}`, highlightElement(config.view), { priority: config.converterPriority || "normal" });
    dispatcher.on(`removeMarker:${config.model}`, removeHighlight(config.view), { priority: config.converterPriority || "normal" });
  };
}
function normalizeModelElementConfig(model) {
  if (typeof model == "string") {
    model = { name: model };
  }
  return {
    name: model.name,
    attributes: model.attributes ? toArray(model.attributes) : [],
    children: !!model.children
  };
}
function normalizeToElementConfig(view, viewElementType) {
  if (typeof view == "function") {
    return view;
  }
  return (modelData, conversionApi) => createViewElementFromDefinition(view, conversionApi, viewElementType);
}
function createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {
  if (typeof viewElementDefinition == "string") {
    viewElementDefinition = { name: viewElementDefinition };
  }
  let element;
  const viewWriter = conversionApi.writer;
  const attributes = Object.assign({}, viewElementDefinition.attributes);
  if (viewElementType == "container") {
    element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);
  } else if (viewElementType == "attribute") {
    const options = {
      priority: viewElementDefinition.priority || attributeelement_default.DEFAULT_PRIORITY
    };
    element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);
  } else {
    element = viewWriter.createUIElement(viewElementDefinition.name, attributes);
  }
  if (viewElementDefinition.styles) {
    const keys = Object.keys(viewElementDefinition.styles);
    for (const key of keys) {
      viewWriter.setStyle(key, viewElementDefinition.styles[key], element);
    }
  }
  if (viewElementDefinition.classes) {
    const classes = viewElementDefinition.classes;
    if (typeof classes == "string") {
      viewWriter.addClass(classes, element);
    } else {
      for (const className of classes) {
        viewWriter.addClass(className, element);
      }
    }
  }
  return element;
}
function getFromAttributeCreator(config) {
  if (config.model.values) {
    return (modelAttributeValue, conversionApi, data) => {
      const view = config.view[modelAttributeValue];
      if (view) {
        return view(modelAttributeValue, conversionApi, data);
      }
      return null;
    };
  } else {
    return config.view;
  }
}
function normalizeToAttributeConfig(view) {
  if (typeof view == "string") {
    return (modelAttributeValue) => ({ key: view, value: modelAttributeValue });
  } else if (typeof view == "object") {
    if (view.value) {
      return () => view;
    } else {
      return (modelAttributeValue) => ({ key: view.key, value: modelAttributeValue });
    }
  } else {
    return view;
  }
}
function prepareDescriptor(highlightDescriptor, data, conversionApi) {
  const descriptor = typeof highlightDescriptor == "function" ? highlightDescriptor(data, conversionApi) : highlightDescriptor;
  if (!descriptor) {
    return null;
  }
  if (!descriptor.priority) {
    descriptor.priority = 10;
  }
  if (!descriptor.id) {
    descriptor.id = data.markerName;
  }
  return descriptor;
}
function createChangeReducerCallback(model) {
  return (node, change) => {
    if (!node.is("element", model.name)) {
      return false;
    }
    if (change.type == "attribute") {
      if (model.attributes.includes(change.attributeKey)) {
        return true;
      }
    } else {
      if (model.children) {
        return true;
      }
    }
    return false;
  };
}
function createChangeReducer(model) {
  const shouldReplace = createChangeReducerCallback(model);
  return (evt, data) => {
    const reducedChanges = [];
    if (!data.reconvertedElements) {
      data.reconvertedElements = /* @__PURE__ */ new Set();
    }
    for (const change of data.changes) {
      const node = change.type == "attribute" ? change.range.start.nodeAfter : change.position.parent;
      if (!node || !shouldReplace(node, change)) {
        reducedChanges.push(change);
        continue;
      }
      if (!data.reconvertedElements.has(node)) {
        data.reconvertedElements.add(node);
        const position = Position2._createBefore(node);
        let changeIndex = reducedChanges.length;
        for (let i = reducedChanges.length - 1; i >= 0; i--) {
          const change2 = reducedChanges[i];
          const changePosition = change2.type == "attribute" ? change2.range.start : change2.position;
          const positionRelation = changePosition.compareWith(position);
          if (positionRelation == "before" || change2.type == "remove" && positionRelation == "same") {
            break;
          }
          changeIndex = i;
        }
        reducedChanges.splice(changeIndex, 0, {
          type: "remove",
          name: node.name,
          position,
          length: 1
        }, {
          type: "reinsert",
          name: node.name,
          position,
          length: 1
        });
      }
    }
    data.changes = reducedChanges;
  };
}
function createConsumer(model) {
  return (node, consumable, options = {}) => {
    const events = ["insert"];
    for (const attributeName of model.attributes) {
      if (node.hasAttribute(attributeName)) {
        events.push(`attribute:${attributeName}`);
      }
    }
    if (!events.every((event) => consumable.test(node, event))) {
      return false;
    }
    if (!options.preflight) {
      events.forEach((event) => consumable.consume(node, event));
    }
    return true;
  };
}
function createSlotFactory(element, slotsMap, conversionApi) {
  return (writer, modeOrFilter) => {
    const slot = writer.createContainerElement("$slot");
    let children = null;
    if (modeOrFilter === "children") {
      children = Array.from(element.getChildren());
    } else if (typeof modeOrFilter == "function") {
      children = Array.from(element.getChildren()).filter((element2) => modeOrFilter(element2));
    } else {
      throw new CKEditorError("conversion-slot-mode-unknown", conversionApi.dispatcher, { modeOrFilter });
    }
    slotsMap.set(slot, children);
    return slot;
  };
}
function validateSlotsChildren(element, slotsMap, conversionApi) {
  const childrenInSlots = Array.from(slotsMap.values()).flat();
  const uniqueChildrenInSlots = new Set(childrenInSlots);
  if (uniqueChildrenInSlots.size != childrenInSlots.length) {
    throw new CKEditorError("conversion-slot-filter-overlap", conversionApi.dispatcher, { element });
  }
  if (uniqueChildrenInSlots.size != element.childCount) {
    throw new CKEditorError("conversion-slot-filter-incomplete", conversionApi.dispatcher, { element });
  }
}
function fillSlots(viewElement, slotsMap, conversionApi, options) {
  conversionApi.mapper.on("modelToViewPosition", toViewPositionMapping, { priority: "highest" });
  let currentSlot = null;
  let currentSlotNodes = null;
  for ([currentSlot, currentSlotNodes] of slotsMap) {
    reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);
    conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));
    conversionApi.writer.remove(currentSlot);
  }
  conversionApi.mapper.off("modelToViewPosition", toViewPositionMapping);
  function toViewPositionMapping(evt, data) {
    const element = data.modelPosition.nodeAfter;
    const index = currentSlotNodes.indexOf(element);
    if (index < 0) {
      return;
    }
    data.viewPosition = data.mapper.findPositionIn(currentSlot, index);
  }
}
function reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {
  for (const modelChildNode of modelNodes) {
    if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {
      conversionApi.convertItem(modelChildNode);
    }
  }
}
function reinsertNode(viewRoot, modelNode, conversionApi, options) {
  const { writer, mapper } = conversionApi;
  if (!options.reconversion) {
    return false;
  }
  const viewChildNode = mapper.toViewElement(modelNode);
  if (!viewChildNode || viewChildNode.root == viewRoot) {
    return false;
  }
  if (!conversionApi.canReuseView(viewChildNode)) {
    return false;
  }
  writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(Position2._createBefore(modelNode)));
  return true;
}
function defaultConsumer(item, consumable, { preflight } = {}) {
  if (preflight) {
    return consumable.test(item, "insert");
  } else {
    return consumable.consume(item, "insert");
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/autoparagraphing.js
function autoParagraphEmptyRoots(writer) {
  const { schema, document: document2 } = writer.model;
  for (const root of document2.getRoots()) {
    if (root.isEmpty && !schema.checkChild(root, "$text")) {
      if (schema.checkChild(root, "paragraph")) {
        writer.insertElement("paragraph", root);
        return true;
      }
    }
  }
  return false;
}
function isParagraphable(position, nodeOrType, schema) {
  const context = schema.createContext(position);
  if (!schema.checkChild(context, "paragraph")) {
    return false;
  }
  if (!schema.checkChild(context.push("paragraph"), nodeOrType)) {
    return false;
  }
  return true;
}
function wrapInParagraph(position, writer) {
  const paragraph2 = writer.createElement("paragraph");
  writer.insert(paragraph2, position);
  return writer.createPositionAt(paragraph2, 0);
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js
var UpcastHelpers = class extends ConversionHelpers {
  /**
   * View element to model element conversion helper.
   *
   * This conversion results in creating a model element. For example,
   * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.
   *
   * Keep in mind that the element will be inserted only if it is allowed
   * by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: 'p',
   * 	model: 'paragraph'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: 'p',
   * 	model: 'paragraph',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	},
   * 	model: 'fancyParagraph'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToElement( {
   * 	view: {
   * 		name: 'p',
   * 		classes: 'heading'
   * 	},
   * 	model: ( viewElement, conversionApi ) => {
   * 		const modelWriter = conversionApi.writer;
   *
   * 		return modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted. If not set, the converter
   * will fire for every view element.
   * @param config.model Name of the model element, a model element instance or a function that takes a view element
   * and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}
   * and returns a model element. The model element will be inserted in the model.
   * @param config.converterPriority Converter priority.
   */
  elementToElement(config) {
    return this.add(upcastElementToElement(config));
  }
  /**
   * View element to model attribute conversion helper.
   *
   * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes
   * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.
   *
   * This helper is meant to set a model attribute on all the elements that are inside the converted element:
   *
   * ```
   * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
   * ```
   *
   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
   * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text. See
   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.
   *
   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: 'strong',
   * 	model: 'bold'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: 'strong',
   * 	model: 'bold',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		classes: 'bold'
   * 	},
   * 	model: 'bold'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		classes: [ 'styled', 'styled-dark' ]
   * 	},
   * 	model: {
   * 		key: 'styled',
   * 		value: 'dark'
   * 	}
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToAttribute( {
   * 	view: {
   * 		name: 'span',
   * 		styles: {
   * 			'font-size': /[\s\S]+/
   * 		}
   * 	},
   * 	model: {
   * 		key: 'fontSize',
   * 		value: ( viewElement, conversionApi ) => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   * 			const value = fontSize.substr( 0, fontSize.length - 2 );
   *
   * 			if ( value <= 10 ) {
   * 				return 'small';
   * 			} else if ( value > 12 ) {
   * 				return 'big';
   * 			}
   *
   * 			return null;
   * 		}
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted.
   * @param config.model Model attribute key or an object with `key` and `value` properties, describing
   * the model attribute. `value` property may be set as a function that takes a view element and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
   * If `String` is given, the model attribute value will be set to `true`.
   * @param config.converterPriority Converter priority. Defaults to `low`.
   */
  elementToAttribute(config) {
    return this.add(upcastElementToAttribute(config));
  }
  /**
   * View attribute to model attribute conversion helper.
   *
   * This conversion results in setting an attribute on a model node. For example, view `<img src="foo.jpg"></img>` becomes
   * `<imageBlock source="foo.jpg"></imageBlock>` in the model.
   *
   * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute
   * is set only on the corresponding model node:
   *
   * ```
   * <div class="dark"><div>foo</div></div>    -->    <div dark="true"><div>foo</div></div>
   * ```
   *
   * Above, `class="dark"` attribute is added only to the `<div>` elements that has it. This is in contrast to
   * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for
   * all the children in the model:
   *
   * ```
   * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
   * ```
   *
   * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
   * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text.
   *
   * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: 'src',
   * 	model: 'source'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: { key: 'src' },
   * 	model: 'source'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: { key: 'src' },
   * 	model: 'source',
   * 	converterPriority: 'normal'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		key: 'data-style',
   * 		value: /[\s\S]+/
   * 	},
   * 	model: 'styled'
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		name: 'img',
   * 		key: 'class',
   * 		value: 'styled-dark'
   * 	},
   * 	model: {
   * 		key: 'styled',
   * 		value: 'dark'
   * 	}
   * } );
   *
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		key: 'class',
   * 		value: /styled-[\S]+/
   * 	},
   * 	model: {
   * 		key: 'styled'
   * 		value: ( viewElement, conversionApi ) => {
   * 			const regexp = /styled-([\S]+)/;
   * 			const match = viewElement.getAttribute( 'class' ).match( regexp );
   *
   * 			return match[ 1 ];
   * 		}
   * 	}
   * } );
   * ```
   *
   * Converting styles works a bit differently as it requires `view.styles` to be an object and by default
   * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`
   * callback that returns the desired value.
   *
   * ```ts
   * // Default conversion of font-weight style will result in setting bold attribute to true.
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		styles: {
   * 			'font-weight': 'bold'
   * 		}
   * 	},
   * 	model: 'bold'
   * } );
   *
   * // This converter will pass any style value to the `lineHeight` model attribute.
   * editor.conversion.for( 'upcast' ).attributeToAttribute( {
   * 	view: {
   * 		styles: {
   * 			'line-height': /[\s\S]+/
   * 		}
   * 	},
   * 	model: {
   * 		key: 'lineHeight',
   * 		value: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )
   * 	}
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Specifies which view attribute will be converted. If a `String` is passed,
   * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
   * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
   * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
   * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
   * @param config.model Model attribute key or an object with `key` and `value` properties, describing
   * the model attribute. `value` property may be set as a function that takes a view element and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
   * If `String` is given, the model attribute value will be same as view attribute value.
   * @param config.converterPriority Converter priority. Defaults to `low`.
   */
  attributeToAttribute(config) {
    return this.add(upcastAttributeToAttribute(config));
  }
  /**
   * View element to model marker conversion helper.
   *
   * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:
   * `<p>Fo<span data-marker="comment" data-comment-id="7"></span>o</p><p>B<span data-marker="comment" data-comment-id="7"></span>ar</p>`,
   * after the conversion is done, the marker will be available in
   * {@link module:engine/model/model~Model#markers model document markers}.
   *
   * **Note**: When this helper is used in the data upcast in combination with
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,
   * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.
   *
   * In most of the cases, the {@link #dataToMarker} should be used instead.
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: 'search'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: 'search',
   * 	converterPriority: 'high'
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: 'marker-search',
   * 	model: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )
   * } );
   *
   * editor.conversion.for( 'upcast' ).elementToMarker( {
   * 	view: {
   * 		name: 'span',
   * 		attributes: {
   * 			'data-marker': 'search'
   * 		}
   * 	},
   * 	model: 'search'
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view Pattern matching all view elements which should be converted.
   * @param config.model Name of the model marker, or a function that takes a view element and returns
   * a model marker name.
   * @param config.converterPriority Converter priority.
   */
  elementToMarker(config) {
    return this.add(upcastElementToMarker(config));
  }
  /**
   * View-to-model marker conversion helper.
   *
   * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}
   * back to a model marker.
   *
   * This converter looks for specific view elements and view attributes that mark marker boundaries. See
   * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data
   * is expected by this converter.
   *
   * The `config.view` property is equal to the marker group name to convert.
   *
   * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).
   *
   * The conversion configuration can take a function that will generate a marker name.
   * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is
   * expected to return a string with the marker name.
   *
   * Basic usage:
   *
   * ```ts
   * // Using the default conversion.
   * // In this case, all markers from the `comment` group will be converted.
   * // The conversion will look for `<comment-start>` and `<comment-end>` tags and
   * // `data-comment-start-before`, `data-comment-start-after`,
   * // `data-comment-end-before` and `data-comment-end-after` attributes.
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment'
   * } );
   * ```
   *
   * An example of a model that may be generated by this conversion:
   *
   * ```
   * // View:
   * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
   * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
   *
   * // Model:
   * <paragraph>Foo[bar</paragraph>
   * <imageBlock src="abc.jpg"></imageBlock>]
   * ```
   *
   * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.
   *
   * Other examples of usage:
   *
   * ```ts
   * // Using a custom function which is the same as the default conversion:
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment',
   * 	model: ( name, conversionApi ) => 'comment:' + name,
   * } );
   *
   * // Using the converter priority:
   * editor.conversion.for( 'upcast' ).dataToMarker( {
   * 	view: 'comment',
   * 	model: ( name, conversionApi ) => 'comment:' + name,
   * 	converterPriority: 'high'
   * } );
   * ```
   *
   * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
   * to the conversion process.
   *
   * @param config Conversion configuration.
   * @param config.view The marker group name to convert.
   * @param config.model A function that takes the `name` part from the view element or attribute and
   * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.
   * @param config.converterPriority Converter priority.
   */
  dataToMarker(config) {
    return this.add(upcastDataToMarker(config));
  }
};
function convertToModelFragment() {
  return (evt, data, conversionApi) => {
    if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, { name: true })) {
      const { modelRange, modelCursor } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
      data.modelRange = modelRange;
      data.modelCursor = modelCursor;
    }
  };
}
function convertText() {
  return (evt, data, { schema, consumable, writer }) => {
    let position = data.modelCursor;
    if (!consumable.test(data.viewItem)) {
      return;
    }
    if (!schema.checkChild(position, "$text")) {
      if (!isParagraphable(position, "$text", schema)) {
        return;
      }
      if (data.viewItem.data.trim().length == 0) {
        return;
      }
      position = wrapInParagraph(position, writer);
    }
    consumable.consume(data.viewItem);
    const text2 = writer.createText(data.viewItem.data);
    writer.insert(text2, position);
    data.modelRange = writer.createRange(position, position.getShiftedBy(text2.offsetSize));
    data.modelCursor = data.modelRange.end;
  };
}
function convertSelectionChange(model, mapper) {
  return (evt, data) => {
    const viewSelection = data.newSelection;
    const ranges = [];
    for (const viewRange of viewSelection.getRanges()) {
      ranges.push(mapper.toModelRange(viewRange));
    }
    const modelSelection = model.createSelection(ranges, { backward: viewSelection.isBackward });
    if (!modelSelection.isEqual(model.document.selection)) {
      model.change((writer) => {
        writer.setSelection(modelSelection);
      });
    }
  };
}
function upcastElementToElement(config) {
  config = cloneDeep_default(config);
  const converter = prepareToElementConverter(config);
  const elementName = getViewElementNameFromConfig(config.view);
  const eventName = elementName ? `element:${elementName}` : "element";
  return (dispatcher) => {
    dispatcher.on(eventName, converter, { priority: config.converterPriority || "normal" });
  };
}
function upcastElementToAttribute(config) {
  config = cloneDeep_default(config);
  normalizeModelAttributeConfig(config);
  const converter = prepareToAttributeConverter(config, false);
  const elementName = getViewElementNameFromConfig(config.view);
  const eventName = elementName ? `element:${elementName}` : "element";
  return (dispatcher) => {
    dispatcher.on(eventName, converter, { priority: config.converterPriority || "low" });
  };
}
function upcastAttributeToAttribute(config) {
  config = cloneDeep_default(config);
  let viewKey = null;
  if (typeof config.view == "string" || config.view.key) {
    viewKey = normalizeViewAttributeKeyValueConfig(config);
  }
  normalizeModelAttributeConfig(config, viewKey);
  const converter = prepareToAttributeConverter(config, true);
  return (dispatcher) => {
    dispatcher.on("element", converter, { priority: config.converterPriority || "low" });
  };
}
function upcastElementToMarker(config) {
  const model = normalizeElementToMarkerModelConfig(config.model);
  return upcastElementToElement({ ...config, model });
}
function upcastDataToMarker(config) {
  config = cloneDeep_default(config);
  if (!config.model) {
    config.model = (name) => {
      return name ? config.view + ":" + name : config.view;
    };
  }
  const normalizedConfig = {
    view: config.view,
    model: config.model
  };
  const converterStart = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "start"));
  const converterEnd = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "end"));
  return (dispatcher) => {
    dispatcher.on(`element:${config.view}-start`, converterStart, { priority: config.converterPriority || "normal" });
    dispatcher.on(`element:${config.view}-end`, converterEnd, { priority: config.converterPriority || "normal" });
    const basePriority = priorities_default.low;
    const maxPriority = priorities_default.highest;
    const priorityFactor = priorities_default.get(config.converterPriority) / maxPriority;
    dispatcher.on("element", upcastAttributeToMarker(normalizedConfig), { priority: basePriority + priorityFactor });
  };
}
function upcastAttributeToMarker(config) {
  return (evt, data, conversionApi) => {
    const attrName = `data-${config.view}`;
    if (!conversionApi.consumable.test(data.viewItem, { attributes: attrName + "-end-after" }) && !conversionApi.consumable.test(data.viewItem, { attributes: attrName + "-start-after" }) && !conversionApi.consumable.test(data.viewItem, { attributes: attrName + "-end-before" }) && !conversionApi.consumable.test(data.viewItem, { attributes: attrName + "-start-before" })) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    if (conversionApi.consumable.consume(data.viewItem, { attributes: attrName + "-end-after" })) {
      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-end-after").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, { attributes: attrName + "-start-after" })) {
      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-start-after").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, { attributes: attrName + "-end-before" })) {
      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-end-before").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, { attributes: attrName + "-start-before" })) {
      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-start-before").split(","));
    }
    function addMarkerElements(position, markerViewNames) {
      for (const markerViewName of markerViewNames) {
        const markerName = config.model(markerViewName, conversionApi);
        const element = conversionApi.writer.createElement("$marker", { "data-name": markerName });
        conversionApi.writer.insert(element, position);
        if (data.modelCursor.isEqual(position)) {
          data.modelCursor = data.modelCursor.getShiftedBy(1);
        } else {
          data.modelCursor = data.modelCursor._getTransformedByInsertion(position, 1);
        }
        data.modelRange = data.modelRange._getTransformedByInsertion(position, 1)[0];
      }
    }
  };
}
function getViewElementNameFromConfig(viewConfig) {
  if (typeof viewConfig == "string") {
    return viewConfig;
  }
  if (typeof viewConfig == "object" && typeof viewConfig.name == "string") {
    return viewConfig.name;
  }
  return null;
}
function prepareToElementConverter(config) {
  const matcher = new Matcher(config.view);
  return (evt, data, conversionApi) => {
    const matcherResult = matcher.match(data.viewItem);
    if (!matcherResult) {
      return;
    }
    const match = matcherResult.match;
    match.name = true;
    if (!conversionApi.consumable.test(data.viewItem, match)) {
      return;
    }
    const modelElement = getModelElement(config.model, data.viewItem, conversionApi);
    if (!modelElement) {
      return;
    }
    if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
      return;
    }
    conversionApi.consumable.consume(data.viewItem, match);
    conversionApi.convertChildren(data.viewItem, modelElement);
    conversionApi.updateConversionResult(modelElement, data);
  };
}
function getModelElement(model, input, conversionApi) {
  if (model instanceof Function) {
    return model(input, conversionApi);
  } else {
    return conversionApi.writer.createElement(model);
  }
}
function normalizeViewAttributeKeyValueConfig(config) {
  if (typeof config.view == "string") {
    config.view = { key: config.view };
  }
  const key = config.view.key;
  const value = typeof config.view.value == "undefined" ? /[\s\S]*/ : config.view.value;
  let normalized;
  if (key == "class" || key == "style") {
    const keyName = key == "class" ? "classes" : "styles";
    normalized = {
      [keyName]: value
    };
  } else {
    normalized = {
      attributes: {
        [key]: value
      }
    };
  }
  if (config.view.name) {
    normalized.name = config.view.name;
  }
  config.view = normalized;
  return key;
}
function normalizeModelAttributeConfig(config, viewAttributeKeyToCopy = null) {
  const defaultModelValue = viewAttributeKeyToCopy === null ? true : (viewElement) => viewElement.getAttribute(viewAttributeKeyToCopy);
  const key = typeof config.model != "object" ? config.model : config.model.key;
  const value = typeof config.model != "object" || typeof config.model.value == "undefined" ? defaultModelValue : config.model.value;
  config.model = { key, value };
}
function prepareToAttributeConverter(config, shallow) {
  const matcher = new Matcher(config.view);
  return (evt, data, conversionApi) => {
    if (!data.modelRange && shallow) {
      return;
    }
    const match = matcher.match(data.viewItem);
    if (!match) {
      return;
    }
    if (onlyViewNameIsDefined(config.view, data.viewItem)) {
      match.match.name = true;
    } else {
      delete match.match.name;
    }
    if (!conversionApi.consumable.test(data.viewItem, match.match)) {
      return;
    }
    const modelKey = config.model.key;
    const modelValue = typeof config.model.value == "function" ? config.model.value(data.viewItem, conversionApi) : config.model.value;
    if (modelValue === null) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    const attributeWasSet = setAttributeOn(data.modelRange, { key: modelKey, value: modelValue }, shallow, conversionApi);
    if (attributeWasSet) {
      if (conversionApi.consumable.test(data.viewItem, { name: true })) {
        match.match.name = true;
      }
      conversionApi.consumable.consume(data.viewItem, match.match);
    }
  };
}
function onlyViewNameIsDefined(viewConfig, viewItem) {
  const configToTest = typeof viewConfig == "function" ? viewConfig(viewItem) : viewConfig;
  if (typeof configToTest == "object" && !getViewElementNameFromConfig(configToTest)) {
    return false;
  }
  return !configToTest.classes && !configToTest.attributes && !configToTest.styles;
}
function setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {
  let result = false;
  for (const node of Array.from(modelRange.getItems({ shallow }))) {
    if (!conversionApi.schema.checkAttribute(node, modelAttribute.key)) {
      continue;
    }
    result = true;
    if (node.hasAttribute(modelAttribute.key)) {
      continue;
    }
    conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);
  }
  return result;
}
function normalizeElementToMarkerModelConfig(model) {
  return (viewElement, conversionApi) => {
    const markerName = typeof model == "string" ? model : model(viewElement, conversionApi);
    return conversionApi.writer.createElement("$marker", { "data-name": markerName });
  };
}
function normalizeDataToMarkerConfig(config, type) {
  const elementCreatorFunction = (viewElement, conversionApi) => {
    const viewName = viewElement.getAttribute("name");
    const markerName = config.model(viewName, conversionApi);
    return conversionApi.writer.createElement("$marker", { "data-name": markerName });
  };
  return {
    // Upcast <markerGroup-start> and <markerGroup-end> elements.
    view: `${config.view}-${type}`,
    model: elementCreatorFunction
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js
function injectSelectionPostFixer(model) {
  model.document.registerPostFixer((writer) => selectionPostFixer(writer, model));
}
function selectionPostFixer(writer, model) {
  const selection = model.document.selection;
  const schema = model.schema;
  const ranges = [];
  let wasFixed = false;
  for (const modelRange of selection.getRanges()) {
    const correctedRange = tryFixingRange(modelRange, schema);
    if (correctedRange && !correctedRange.isEqual(modelRange)) {
      ranges.push(correctedRange);
      wasFixed = true;
    } else {
      ranges.push(modelRange);
    }
  }
  if (wasFixed) {
    writer.setSelection(mergeIntersectingRanges(ranges), { backward: selection.isBackward });
  }
  return false;
}
function tryFixingRange(range, schema) {
  if (range.isCollapsed) {
    return tryFixingCollapsedRange(range, schema);
  }
  return tryFixingNonCollapsedRage(range, schema);
}
function tryFixingCollapsedRange(range, schema) {
  const originalPosition = range.start;
  const nearestSelectionRange = schema.getNearestSelectionRange(originalPosition);
  if (!nearestSelectionRange) {
    const ancestorObject = originalPosition.getAncestors().reverse().find((item) => schema.isObject(item));
    if (ancestorObject) {
      return Range2._createOn(ancestorObject);
    }
    return null;
  }
  if (!nearestSelectionRange.isCollapsed) {
    return nearestSelectionRange;
  }
  const fixedPosition = nearestSelectionRange.start;
  if (originalPosition.isEqual(fixedPosition)) {
    return null;
  }
  return new Range2(fixedPosition);
}
function tryFixingNonCollapsedRage(range, schema) {
  const { start, end } = range;
  const isTextAllowedOnStart = schema.checkChild(start, "$text");
  const isTextAllowedOnEnd = schema.checkChild(end, "$text");
  const startLimitElement = schema.getLimitElement(start);
  const endLimitElement = schema.getLimitElement(end);
  if (startLimitElement === endLimitElement) {
    if (isTextAllowedOnStart && isTextAllowedOnEnd) {
      return null;
    }
    if (checkSelectionOnNonLimitElements(start, end, schema)) {
      const isStartBeforeSelectable = start.nodeAfter && schema.isSelectable(start.nodeAfter);
      const fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start, "forward");
      const isEndAfterSelectable = end.nodeBefore && schema.isSelectable(end.nodeBefore);
      const fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end, "backward");
      const rangeStart = fixedStart ? fixedStart.start : start;
      const rangeEnd = fixedEnd ? fixedEnd.end : end;
      return new Range2(rangeStart, rangeEnd);
    }
  }
  const isStartInLimit = startLimitElement && !startLimitElement.is("rootElement");
  const isEndInLimit = endLimitElement && !endLimitElement.is("rootElement");
  if (isStartInLimit || isEndInLimit) {
    const bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;
    const expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start.nodeAfter, schema));
    const expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end.nodeBefore, schema));
    let fixedStart = start;
    let fixedEnd = end;
    if (expandStart) {
      fixedStart = Position2._createBefore(findOutermostLimitAncestor(startLimitElement, schema));
    }
    if (expandEnd) {
      fixedEnd = Position2._createAfter(findOutermostLimitAncestor(endLimitElement, schema));
    }
    return new Range2(fixedStart, fixedEnd);
  }
  return null;
}
function findOutermostLimitAncestor(startingNode, schema) {
  let isLimitNode = startingNode;
  let parent = isLimitNode;
  while (schema.isLimit(parent) && parent.parent) {
    isLimitNode = parent;
    parent = parent.parent;
  }
  return isLimitNode;
}
function checkSelectionOnNonLimitElements(start, end, schema) {
  const startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, "$text");
  const endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, "$text");
  return startIsOnBlock || endIsOnBlock;
}
function mergeIntersectingRanges(ranges) {
  const rangesToMerge = [...ranges];
  const rangeIndexesToRemove = /* @__PURE__ */ new Set();
  let currentRangeIndex = 1;
  while (currentRangeIndex < rangesToMerge.length) {
    const currentRange = rangesToMerge[currentRangeIndex];
    const previousRanges = rangesToMerge.slice(0, currentRangeIndex);
    for (const [previousRangeIndex, previousRange] of previousRanges.entries()) {
      if (rangeIndexesToRemove.has(previousRangeIndex)) {
        continue;
      }
      if (currentRange.isEqual(previousRange)) {
        rangeIndexesToRemove.add(previousRangeIndex);
      } else if (currentRange.isIntersecting(previousRange)) {
        rangeIndexesToRemove.add(previousRangeIndex);
        rangeIndexesToRemove.add(currentRangeIndex);
        const mergedRange = currentRange.getJoined(previousRange);
        rangesToMerge.push(mergedRange);
      }
    }
    currentRangeIndex++;
  }
  const nonIntersectingRanges = rangesToMerge.filter((_, index) => !rangeIndexesToRemove.has(index));
  return nonIntersectingRanges;
}
function isSelectable(node, schema) {
  return node && schema.isSelectable(node);
}

// node_modules/@ckeditor/ckeditor5-engine/src/controller/editingcontroller.js
var EditingController = class extends ObservableMixin() {
  /**
   * Creates an editing controller instance.
   *
   * @param model Editing model.
   * @param stylesProcessor The styles processor instance.
   */
  constructor(model, stylesProcessor) {
    super();
    this.model = model;
    this.view = new View2(stylesProcessor);
    this.mapper = new Mapper();
    this.downcastDispatcher = new DowncastDispatcher({
      mapper: this.mapper,
      schema: model.schema
    });
    const doc = this.model.document;
    const selection = doc.selection;
    const markers = this.model.markers;
    this.listenTo(this.model, "_beforeChanges", () => {
      this.view._disableRendering(true);
    }, { priority: "highest" });
    this.listenTo(this.model, "_afterChanges", () => {
      this.view._disableRendering(false);
    }, { priority: "lowest" });
    this.listenTo(doc, "change", () => {
      this.view.change((writer) => {
        this.downcastDispatcher.convertChanges(doc.differ, markers, writer);
        this.downcastDispatcher.convertSelection(selection, markers, writer);
      });
    }, { priority: "low" });
    this.listenTo(this.view.document, "selectionChange", convertSelectionChange(this.model, this.mapper));
    this.listenTo(this.view.document, "beforeinput", fixTargetRanges(this.mapper, this.model.schema, this.view), { priority: "high" });
    this.downcastDispatcher.on("insert:$text", insertText(), { priority: "lowest" });
    this.downcastDispatcher.on("insert", insertAttributesAndChildren(), { priority: "lowest" });
    this.downcastDispatcher.on("remove", remove2(), { priority: "low" });
    this.downcastDispatcher.on("cleanSelection", cleanSelection());
    this.downcastDispatcher.on("selection", convertRangeSelection(), { priority: "low" });
    this.downcastDispatcher.on("selection", convertCollapsedSelection(), { priority: "low" });
    this.view.document.roots.bindTo(this.model.document.roots).using((root) => {
      if (root.rootName == "$graveyard") {
        return null;
      }
      const viewRoot = new RootEditableElement(this.view.document, root.name);
      viewRoot.rootName = root.rootName;
      this.mapper.bindElements(root, viewRoot);
      return viewRoot;
    });
  }
  /**
   * Removes all event listeners attached to the `EditingController`. Destroys all objects created
   * by `EditingController` that need to be destroyed.
   */
  destroy() {
    this.view.destroy();
    this.stopListening();
  }
  /**
   * Calling this method will refresh the marker by triggering the downcast conversion for it.
   *
   * Reconverting the marker is useful when you want to change its {@link module:engine/view/element~Element view element}
   * without changing any marker data. For instance:
   *
   * ```ts
   * let isCommentActive = false;
   *
   * model.conversion.markerToHighlight( {
   * 	model: 'comment',
   * 	view: data => {
   * 		const classes = [ 'comment-marker' ];
   *
   * 		if ( isCommentActive ) {
   * 			classes.push( 'comment-marker--active' );
   * 		}
   *
   * 		return { classes };
   * 	}
   * } );
   *
   * // ...
   *
   * // Change the property that indicates if marker is displayed as active or not.
   * isCommentActive = true;
   *
   * // Reconverting will downcast and synchronize the marker with the new isCommentActive state value.
   * editor.editing.reconvertMarker( 'comment' );
   * ```
   *
   * **Note**: If you want to reconvert a model item, use {@link #reconvertItem} instead.
   *
   * @param markerOrName Name of a marker to update, or a marker instance.
   */
  reconvertMarker(markerOrName) {
    const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    const currentMarker = this.model.markers.get(markerName);
    if (!currentMarker) {
      throw new CKEditorError("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName });
    }
    this.model.change(() => {
      this.model.markers._refresh(currentMarker);
    });
  }
  /**
   * Calling this method will downcast a model item on demand (by requesting a refresh in the {@link module:engine/model/differ~Differ}).
   *
   * You can use it if you want the view representation of a specific item updated as a response to external modifications. For instance,
   * when the view structure depends not only on the associated model data but also on some external state.
   *
   * **Note**: If you want to reconvert a model marker, use {@link #reconvertMarker} instead.
   *
   * @param item Item to refresh.
   */
  reconvertItem(item) {
    this.model.change(() => {
      this.model.document.differ._refreshItem(item);
    });
  }
};
function fixTargetRanges(mapper, schema, view) {
  return (evt, data) => {
    if (view.document.isComposing && !env_default.isAndroid) {
      return;
    }
    for (let i = 0; i < data.targetRanges.length; i++) {
      const viewRange = data.targetRanges[i];
      const modelRange = mapper.toModelRange(viewRange);
      const correctedRange = tryFixingRange(modelRange, schema);
      if (!correctedRange || correctedRange.isEqual(modelRange)) {
        continue;
      }
      data.targetRanges[i] = mapper.toViewRange(correctedRange);
    }
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js
var ViewConsumable = class _ViewConsumable {
  constructor() {
    this._consumables = /* @__PURE__ */ new Map();
  }
  add(element, consumables) {
    let elementConsumables;
    if (element.is("$text") || element.is("documentFragment")) {
      this._consumables.set(element, true);
      return;
    }
    if (!this._consumables.has(element)) {
      elementConsumables = new ViewElementConsumables(element);
      this._consumables.set(element, elementConsumables);
    } else {
      elementConsumables = this._consumables.get(element);
    }
    elementConsumables.add(consumables);
  }
  /**
   * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.
   * It returns `true` when all items included in method's call can be consumed. Returns `false` when
   * first already consumed item is found and `null` when first non-consumable item is found.
   *
   * ```ts
   * viewConsumable.test( p, { name: true } ); // Tests element's name.
   * viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
   * viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
   * viewConsumable.test( p, { styles: 'color' } ); // Tests style.
   * viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
   * viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
   * viewConsumable.test( textNode ); // Tests text node.
   * viewConsumable.test( docFragment ); // Tests document fragment.
   * ```
   *
   * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
   *
   * ```ts
   * viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
   * viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   * @returns Returns `true` when all items included in method's call can be consumed. Returns `false`
   * when first already consumed item is found and `null` when first non-consumable item is found.
   */
  test(element, consumables) {
    const elementConsumables = this._consumables.get(element);
    if (elementConsumables === void 0) {
      return null;
    }
    if (element.is("$text") || element.is("documentFragment")) {
      return elementConsumables;
    }
    return elementConsumables.test(consumables);
  }
  /**
   * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
   *
   * ```ts
   * viewConsumable.consume( p, { name: true } ); // Consumes element's name.
   * viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
   * viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
   * viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
   * viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
   * viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
   * viewConsumable.consume( textNode ); // Consumes text node.
   * viewConsumable.consume( docFragment ); // Consumes document fragment.
   * ```
   *
   * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
   *
   * ```ts
   * viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
   * viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   * @returns Returns `true` when all items included in method's call can be consumed,
   * otherwise returns `false`.
   */
  consume(element, consumables) {
    if (this.test(element, consumables)) {
      if (element.is("$text") || element.is("documentFragment")) {
        this._consumables.set(element, false);
      } else {
        this._consumables.get(element).consume(consumables);
      }
      return true;
    }
    return false;
  }
  /**
   * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.
   * Method does not revert items that were never previously added for consumption, even if they are included in
   * method's call.
   *
   * ```ts
   * viewConsumable.revert( p, { name: true } ); // Reverts element's name.
   * viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
   * viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
   * viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
   * viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
   * viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
   * viewConsumable.revert( textNode ); // Reverts text node.
   * viewConsumable.revert( docFragment ); // Reverts document fragment.
   * ```
   *
   * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
   * consumption.
   *
   * ```ts
   * viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
   * viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
   * ```
   *
   * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param consumables.name If set to true element's name will be included.
   * @param consumables.attributes Attribute name or array of attribute names.
   * @param consumables.classes Class name or array of class names.
   * @param consumables.styles Style name or array of style names.
   */
  revert(element, consumables) {
    const elementConsumables = this._consumables.get(element);
    if (elementConsumables !== void 0) {
      if (element.is("$text") || element.is("documentFragment")) {
        this._consumables.set(element, true);
      } else {
        elementConsumables.revert(consumables);
      }
    }
  }
  /**
   * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include
   * element's name and all its attributes, classes and styles.
   */
  static consumablesFromElement(element) {
    const consumables = {
      element,
      name: true,
      attributes: [],
      classes: [],
      styles: []
    };
    const attributes = element.getAttributeKeys();
    for (const attribute of attributes) {
      if (attribute == "style" || attribute == "class") {
        continue;
      }
      consumables.attributes.push(attribute);
    }
    const classes = element.getClassNames();
    for (const className of classes) {
      consumables.classes.push(className);
    }
    const styles = element.getStyleNames();
    for (const style of styles) {
      consumables.styles.push(style);
    }
    return consumables;
  }
  /**
   * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
   * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
   * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
   *
   * @param from View node or document fragment from which `ViewConsumable` will be created.
   * @param instance If provided, given `ViewConsumable` instance will be used
   * to add all consumables. It will be returned instead of a new instance.
   */
  static createFrom(from, instance) {
    if (!instance) {
      instance = new _ViewConsumable();
    }
    if (from.is("$text")) {
      instance.add(from);
      return instance;
    }
    if (from.is("element")) {
      instance.add(from, _ViewConsumable.consumablesFromElement(from));
    }
    if (from.is("documentFragment")) {
      instance.add(from);
    }
    for (const child of from.getChildren()) {
      instance = _ViewConsumable.createFrom(child, instance);
    }
    return instance;
  }
};
var CONSUMABLE_TYPES = ["attributes", "classes", "styles"];
var ViewElementConsumables = class {
  /**
   * Creates ViewElementConsumables instance.
   *
   * @param from View node or document fragment from which `ViewElementConsumables` is being created.
   */
  constructor(from) {
    this.element = from;
    this._canConsumeName = null;
    this._consumables = {
      attributes: /* @__PURE__ */ new Map(),
      styles: /* @__PURE__ */ new Map(),
      classes: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Adds consumable parts of the {@link module:engine/view/element~Element view element}.
   * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
   * styles still could be consumed):
   *
   * ```ts
   * consumables.add( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
   *
   * @param consumables Object describing which parts of the element can be consumed.
   * @param consumables.name If set to `true` element's name will be added as consumable.
   * @param consumables.attributes Attribute name or array of attribute names to add as consumable.
   * @param consumables.classes Class name or array of class names to add as consumable.
   * @param consumables.styles Style name or array of style names to add as consumable.
   */
  add(consumables) {
    if (consumables.name) {
      this._canConsumeName = true;
    }
    for (const type of CONSUMABLE_TYPES) {
      if (type in consumables) {
        this._add(type, consumables[type]);
      }
    }
  }
  /**
   * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.
   *
   * Element's name can be tested:
   *
   * ```ts
   * consumables.test( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be tested.
   * @param consumables.name If set to `true` element's name will be tested.
   * @param consumables.attributes Attribute name or array of attribute names to test.
   * @param consumables.classes Class name or array of class names to test.
   * @param consumables.styles Style name or array of style names to test.
   * @returns `true` when all tested items can be consumed, `null` when even one of the items
   * was never marked for consumption and `false` when even one of the items was already consumed.
   */
  test(consumables) {
    if (consumables.name && !this._canConsumeName) {
      return this._canConsumeName;
    }
    for (const type of CONSUMABLE_TYPES) {
      if (type in consumables) {
        const value = this._test(type, consumables[type]);
        if (value !== true) {
          return value;
        }
      }
    }
    return true;
  }
  /**
   * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item
   * is already consumed - it consumes all consumable items provided.
   * Element's name can be consumed:
   *
   * ```ts
   * consumables.consume( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be consumed.
   * @param consumables.name If set to `true` element's name will be consumed.
   * @param consumables.attributes Attribute name or array of attribute names to consume.
   * @param consumables.classes Class name or array of class names to consume.
   * @param consumables.styles Style name or array of style names to consume.
   */
  consume(consumables) {
    if (consumables.name) {
      this._canConsumeName = false;
    }
    for (const type of CONSUMABLE_TYPES) {
      if (type in consumables) {
        this._consume(type, consumables[type]);
      }
    }
  }
  /**
   * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.
   * Element's name can be reverted:
   *
   * ```ts
   * consumables.revert( { name: true } );
   * ```
   *
   * Attributes classes and styles:
   *
   * ```ts
   * consumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );
   * consumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   * ```
   *
   * @param consumables Object describing which parts of the element should be reverted.
   * @param consumables.name If set to `true` element's name will be reverted.
   * @param consumables.attributes Attribute name or array of attribute names to revert.
   * @param consumables.classes Class name or array of class names to revert.
   * @param consumables.styles Style name or array of style names to revert.
   */
  revert(consumables) {
    if (consumables.name) {
      this._canConsumeName = true;
    }
    for (const type of CONSUMABLE_TYPES) {
      if (type in consumables) {
        this._revert(type, consumables[type]);
      }
    }
  }
  /**
   * Helper method that adds consumables of a given type: attribute, class or style.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * type is provided - it should be handled separately by providing actual style/class type.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   */
  _add(type, item) {
    const items = toArray(item);
    const consumables = this._consumables[type];
    for (const name of items) {
      if (type === "attributes" && (name === "class" || name === "style")) {
        throw new CKEditorError("viewconsumable-invalid-attribute", this);
      }
      consumables.set(name, true);
      if (type === "styles") {
        for (const alsoName of this.element.document.stylesProcessor.getRelatedStyles(name)) {
          consumables.set(alsoName, true);
        }
      }
    }
  }
  /**
   * Helper method that tests consumables of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   * @returns Returns `true` if all items can be consumed, `null` when one of the items cannot be
   * consumed and `false` when one of the items is already consumed.
   */
  _test(type, item) {
    const items = toArray(item);
    const consumables = this._consumables[type];
    for (const name of items) {
      if (type === "attributes" && (name === "class" || name === "style")) {
        const consumableName = name == "class" ? "classes" : "styles";
        const value = this._test(consumableName, [...this._consumables[consumableName].keys()]);
        if (value !== true) {
          return value;
        }
      } else {
        const value = consumables.get(name);
        if (value === void 0) {
          return null;
        }
        if (!value) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Helper method that consumes items of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
   * @param item Consumable item or array of items.
   */
  _consume(type, item) {
    const items = toArray(item);
    const consumables = this._consumables[type];
    for (const name of items) {
      if (type === "attributes" && (name === "class" || name === "style")) {
        const consumableName = name == "class" ? "classes" : "styles";
        this._consume(consumableName, [...this._consumables[consumableName].keys()]);
      } else {
        consumables.set(name, false);
        if (type == "styles") {
          for (const toConsume of this.element.document.stylesProcessor.getRelatedStyles(name)) {
            consumables.set(toConsume, false);
          }
        }
      }
    }
  }
  /**
   * Helper method that reverts items of a given type: attribute, class or style.
   *
   * @param type Type of the consumable item: `attributes`, `classes` or , `styles`.
   * @param item Consumable item or array of items.
   */
  _revert(type, item) {
    const items = toArray(item);
    const consumables = this._consumables[type];
    for (const name of items) {
      if (type === "attributes" && (name === "class" || name === "style")) {
        const consumableName = name == "class" ? "classes" : "styles";
        this._revert(consumableName, [...this._consumables[consumableName].keys()]);
      } else {
        const value = consumables.get(name);
        if (value === false) {
          consumables.set(name, true);
        }
      }
    }
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js
var Schema = class extends ObservableMixin() {
  /**
   * Creates a schema instance.
   */
  constructor() {
    super();
    this._sourceDefinitions = {};
    this._attributeProperties = /* @__PURE__ */ Object.create(null);
    this._customChildChecks = /* @__PURE__ */ new Map();
    this._customAttributeChecks = /* @__PURE__ */ new Map();
    this._genericCheckSymbol = Symbol("$generic");
    this.decorate("checkChild");
    this.decorate("checkAttribute");
    this.on("checkAttribute", (evt, args) => {
      args[0] = new SchemaContext(args[0]);
    }, { priority: "highest" });
    this.on("checkChild", (evt, args) => {
      args[0] = new SchemaContext(args[0]);
      args[1] = this.getDefinition(args[1]);
    }, { priority: "highest" });
  }
  /**
   * Registers a schema item. Can only be called once for every item name.
   *
   * ```ts
   * schema.register( 'paragraph', {
   * 	inheritAllFrom: '$block'
   * } );
   * ```
   */
  register(itemName, definition) {
    if (this._sourceDefinitions[itemName]) {
      throw new CKEditorError("schema-cannot-register-item-twice", this, {
        itemName
      });
    }
    this._sourceDefinitions[itemName] = [
      Object.assign({}, definition)
    ];
    this._clearCache();
  }
  /**
   * Extends a {@link #register registered} item's definition.
   *
   * Extending properties such as `allowIn` will add more items to the existing properties,
   * while redefining properties such as `isBlock` will override the previously defined ones.
   *
   * ```ts
   * schema.register( 'foo', {
   * 	allowIn: '$root',
   * 	isBlock: true;
   * } );
   * schema.extend( 'foo', {
   * 	allowIn: 'blockQuote',
   * 	isBlock: false
   * } );
   *
   * schema.getDefinition( 'foo' );
   * //	{
   * //		allowIn: [ '$root', 'blockQuote' ],
   * // 		isBlock: false
   * //	}
   * ```
   */
  extend(itemName, definition) {
    if (!this._sourceDefinitions[itemName]) {
      throw new CKEditorError("schema-cannot-extend-missing-item", this, {
        itemName
      });
    }
    this._sourceDefinitions[itemName].push(Object.assign({}, definition));
    this._clearCache();
  }
  /**
   * Returns data of all registered items.
   *
   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
   * checking a list of all block elements, etc).
   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
   * in other cases.
   */
  getDefinitions() {
    if (!this._compiledDefinitions) {
      this._compile();
    }
    return this._compiledDefinitions;
  }
  /**
   * Returns a definition of the given item or `undefined` if an item is not registered.
   *
   * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
   * checking a list of all block elements, etc).
   * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
   * in other cases.
   */
  getDefinition(item) {
    let itemName;
    if (typeof item == "string") {
      itemName = item;
    } else if ("is" in item && (item.is("$text") || item.is("$textProxy"))) {
      itemName = "$text";
    } else {
      itemName = item.name;
    }
    return this.getDefinitions()[itemName];
  }
  /**
   * Returns `true` if the given item is registered in the schema.
   *
   * ```ts
   * schema.isRegistered( 'paragraph' ); // -> true
   * schema.isRegistered( editor.model.document.getRoot() ); // -> true
   * schema.isRegistered( 'foo' ); // -> false
   * ```
   */
  isRegistered(item) {
    return !!this.getDefinition(item);
  }
  /**
   * Returns `true` if the given item is defined to be
   * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.
   *
   * ```ts
   * schema.isBlock( 'paragraph' ); // -> true
   * schema.isBlock( '$root' ); // -> false
   *
   * const paragraphElement = writer.createElement( 'paragraph' );
   * schema.isBlock( paragraphElement ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#block-elements Block elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isBlock(item) {
    const def = this.getDefinition(item);
    return !!(def && def.isBlock);
  }
  /**
   * Returns `true` if the given item should be treated as a limit element.
   *
   * It considers an item to be a limit element if its
   * {@link module:engine/model/schema~SchemaItemDefinition}'s
   * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or
   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
   * was set to `true`.
   *
   * ```ts
   * schema.isLimit( 'paragraph' ); // -> false
   * schema.isLimit( '$root' ); // -> true
   * schema.isLimit( editor.model.document.getRoot() ); // -> true
   * schema.isLimit( 'imageBlock' ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#limit-elements Limit elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isLimit(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isLimit || def.isObject);
  }
  /**
   * Returns `true` if the given item should be treated as an object element.
   *
   * It considers an item to be an object element if its
   * {@link module:engine/model/schema~SchemaItemDefinition}'s
   * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
   * was set to `true`.
   *
   * ```ts
   * schema.isObject( 'paragraph' ); // -> false
   * schema.isObject( 'imageBlock' ); // -> true
   *
   * const imageElement = writer.createElement( 'imageBlock' );
   * schema.isObject( imageElement ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#object-elements Object elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isObject(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);
  }
  /**
   * Returns `true` if the given item is defined to be
   * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.
   *
   * ```ts
   * schema.isInline( 'paragraph' ); // -> false
   * schema.isInline( 'softBreak' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isInline( text ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#inline-elements Inline elements} section of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isInline(item) {
    const def = this.getDefinition(item);
    return !!(def && def.isInline);
  }
  /**
   * Returns `true` if the given item is defined to be
   * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.
   *
   * ```ts
   * schema.isSelectable( 'paragraph' ); // -> false
   * schema.isSelectable( 'heading1' ); // -> false
   * schema.isSelectable( 'imageBlock' ); // -> true
   * schema.isSelectable( 'tableCell' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isSelectable( text ); // -> false
   * ```
   *
   * See the {@glink framework/deep-dive/schema#selectable-elements Selectable elements section} of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isSelectable(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isSelectable || def.isObject);
  }
  /**
   * Returns `true` if the given item is defined to be
   * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.
   *
   * ```ts
   * schema.isContent( 'paragraph' ); // -> false
   * schema.isContent( 'heading1' ); // -> false
   * schema.isContent( 'imageBlock' ); // -> true
   * schema.isContent( 'horizontalLine' ); // -> true
   *
   * const text = writer.createText( 'foo' );
   * schema.isContent( text ); // -> true
   * ```
   *
   * See the {@glink framework/deep-dive/schema#content-elements Content elements section} of
   * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
   */
  isContent(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isContent || def.isObject);
  }
  /**
   * Checks whether the given node can be a child of the given context.
   *
   * ```ts
   * schema.checkChild( model.document.getRoot(), paragraph ); // -> false
   *
   * schema.register( 'paragraph', {
   * 	allowIn: '$root'
   * } );
   *
   * schema.checkChild( model.document.getRoot(), paragraph ); // -> true
   * ```
   *
   * Both {@link module:engine/model/schema~Schema#addChildCheck callback checks} and declarative rules (added when
   * {@link module:engine/model/schema~Schema#register registering} and {@link module:engine/model/schema~Schema#extend extending} items)
   * are evaluated when this method is called.
   *
   * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
   *
   * Note that when verifying whether the given node can be a child of the given context, the schema also verifies the entire
   * context &ndash; from its root to its last element. Therefore, it is possible for `checkChild()` to return `false` even though
   * the `context` last element can contain the checked child. It happens if one of the `context` elements does not allow its child.
   * When `context` is verified, {@link module:engine/model/schema~Schema#addChildCheck custom checks} are considered as well.
   *
   * @fires checkChild
   * @param context The context in which the child will be checked.
   * @param def The child to check.
   */
  checkChild(context, def) {
    if (!def) {
      return false;
    }
    return this._checkContextMatch(context, def);
  }
  /**
   * Checks whether the given attribute can be applied in the given context (on the last item of the context).
   *
   * ```ts
   * schema.checkAttribute( textNode, 'bold' ); // -> false
   *
   * schema.extend( '$text', {
   * 	allowAttributes: 'bold'
   * } );
   *
   * schema.checkAttribute( textNode, 'bold' ); // -> true
   * ```
   *
   * Both {@link module:engine/model/schema~Schema#addAttributeCheck callback checks} and declarative rules (added when
   * {@link module:engine/model/schema~Schema#register registering} and {@link module:engine/model/schema~Schema#extend extending} items)
   * are evaluated when this method is called.
   *
   * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
   *
   * @fires checkAttribute
   * @param context The context in which the attribute will be checked.
   * @param attributeName Name of attribute to check in the given context.
   */
  checkAttribute(context, attributeName) {
    const def = this.getDefinition(context.last);
    if (!def) {
      return false;
    }
    const isAllowed = this._evaluateAttributeChecks(context, attributeName);
    return isAllowed !== void 0 ? isAllowed : def.allowAttributes.includes(attributeName);
  }
  /**
   * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).
   *
   * In other words &ndash; both elements are not a limit elements and whether `elementToMerge`'s children
   * {@link #checkChild are allowed} in the `positionOrBaseElement`.
   *
   * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}
   * will be valid.
   *
   * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the
   * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.
   *
   * @param positionOrBaseElement The position or base element to which the `elementToMerge` will be merged.
   * @param elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.
   */
  checkMerge(positionOrBaseElement, elementToMerge) {
    if (positionOrBaseElement instanceof Position2) {
      const nodeBefore = positionOrBaseElement.nodeBefore;
      const nodeAfter = positionOrBaseElement.nodeAfter;
      if (!(nodeBefore instanceof Element2)) {
        throw new CKEditorError("schema-check-merge-no-element-before", this);
      }
      if (!(nodeAfter instanceof Element2)) {
        throw new CKEditorError("schema-check-merge-no-element-after", this);
      }
      return this.checkMerge(nodeBefore, nodeAfter);
    }
    if (this.isLimit(positionOrBaseElement) || this.isLimit(elementToMerge)) {
      return false;
    }
    for (const child of elementToMerge.getChildren()) {
      if (!this.checkChild(positionOrBaseElement, child)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Allows registering a callback to the {@link #checkChild} method calls.
   *
   * Callbacks allow you to implement rules which are not otherwise possible to achieve
   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
   *
   * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
   *
   * For example, by using this method you can disallow elements in specific contexts:
   *
   * ```ts
   * // Disallow `heading1` inside a `blockQuote` that is inside a table.
   * schema.addChildCheck( ( context, childDefinition ) => {
   * 	if ( context.endsWith( 'tableCell blockQuote' ) ) {
   * 		return false;
   * 	}
   * }, 'heading1' );
   * ```
   *
   * You can skip the optional `itemName` parameter to evaluate the callback for every `checkChild()` call.
   *
   * ```ts
   * // Inside specific custom element, allow only children, which allows for a specific attribute.
   * schema.addChildCheck( ( context, childDefinition ) => {
   * 	if ( context.endsWith( 'myElement' ) ) {
   * 		return childDefinition.allowAttributes.includes( 'myAttribute' );
   * 	}
   * } );
   * ```
   *
   * Please note that the generic callbacks may affect the editor performance and should be avoided if possible.
   *
   * When one of the callbacks makes a decision (returns `true` or `false`) the processing is finished and other callbacks are not fired.
   * Callbacks are fired in the order they were added, however generic callbacks are fired before callbacks added for a specified item.
   *
   * You can also use `checkChild` event, if you need even better control. The result from the example above could also be
   * achieved with following event callback:
   *
   * ```ts
   * schema.on( 'checkChild', ( evt, args ) => {
   * 	const context = args[ 0 ];
   * 	const childDefinition = args[ 1 ];
   *
   * 	if ( context.endsWith( 'myElement' ) ) {
   * 		// Prevent next listeners from being called.
   * 		evt.stop();
   * 		// Set the `checkChild()` return value.
   * 		evt.return = childDefinition.allowAttributes.includes( 'myAttribute' );
   * 	}
   * }, { priority: 'high' } );
   * ```
   *
   * Note that the callback checks and declarative rules checks are processed on `normal` priority.
   *
   * Adding callbacks this way can also negatively impact editor performance.
   *
   * @param callback The callback to be called. It is called with two parameters:
   * {@link module:engine/model/schema~SchemaContext} (context) instance and
   * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (definition). The callback may return `true/false` to override
   * `checkChild()`'s return value. If it does not return a boolean value, the default algorithm (or other callbacks) will define
   * `checkChild()`'s return value.
   * @param itemName Name of the schema item for which the callback is registered. If specified, the callback will be run only for
   * `checkChild()` calls which `def` parameter matches the `itemName`. Otherwise, the callback will run for every `checkChild` call.
   */
  addChildCheck(callback, itemName) {
    const key = itemName !== void 0 ? itemName : this._genericCheckSymbol;
    const checks = this._customChildChecks.get(key) || [];
    checks.push(callback);
    this._customChildChecks.set(key, checks);
  }
  /**
   * Allows registering a callback to the {@link #checkAttribute} method calls.
   *
   * Callbacks allow you to implement rules which are not otherwise possible to achieve
   * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
   *
   * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
   *
   * For example, by using this method you can disallow setting attributes on nodes in specific contexts:
   *
   * ```ts
   * // Disallow setting `bold` on text inside `heading1` element:
   * schema.addAttributeCheck( context => {
   * 	if ( context.endsWith( 'heading1 $text' ) ) {
   * 		return false;
   * 	}
   * }, 'bold' );
   * ```
   *
   * You can skip the optional `attributeName` parameter to evaluate the callback for every `checkAttribute()` call.
   *
   * ```ts
   * // Disallow formatting attributes on text inside custom `myTitle` element:
   * schema.addAttributeCheck( ( context, attributeName ) => {
   * 	if ( context.endsWith( 'myTitle $text' ) && schema.getAttributeProperties( attributeName ).isFormatting ) {
   * 		return false;
   * 	}
   * } );
   * ```
   *
   * Please note that the generic callbacks may affect the editor performance and should be avoided if possible.
   *
   * When one of the callbacks makes a decision (returns `true` or `false`) the processing is finished and other callbacks are not fired.
   * Callbacks are fired in the order they were added, however generic callbacks are fired before callbacks added for a specified item.
   *
   * You can also use {@link #event:checkAttribute} event, if you need even better control. The result from the example above could also
   * be achieved with following event callback:
   *
   * ```ts
   * schema.on( 'checkAttribute', ( evt, args ) => {
   * 	const context = args[ 0 ];
   * 	const attributeName = args[ 1 ];
   *
   * 	if ( context.endsWith( 'myTitle $text' ) && schema.getAttributeProperties( attributeName ).isFormatting ) {
   * 		// Prevent next listeners from being called.
   * 		evt.stop();
   * 		// Set the `checkAttribute()` return value.
   * 		evt.return = false;
   * 	}
   * }, { priority: 'high' } );
   * ```
   *
   * Note that the callback checks and declarative rules checks are processed on `normal` priority.
   *
   * Adding callbacks this way can also negatively impact editor performance.
   *
   * @param callback The callback to be called. It is called with two parameters:
   * {@link module:engine/model/schema~SchemaContext `context`} and attribute name. The callback may return `true` or `false`, to
   * override `checkAttribute()`'s return value. If it does not return a boolean value, the default algorithm (or other callbacks)
   * will define `checkAttribute()`'s return value.
   * @param attributeName Name of the attribute for which the callback is registered. If specified, the callback will be run only for
   * `checkAttribute()` calls with matching `attributeName`. Otherwise, the callback will run for every `checkAttribute()` call.
   */
  addAttributeCheck(callback, attributeName) {
    const key = attributeName !== void 0 ? attributeName : this._genericCheckSymbol;
    const checks = this._customAttributeChecks.get(key) || [];
    checks.push(callback);
    this._customAttributeChecks.set(key, checks);
  }
  /**
   * This method allows assigning additional metadata to the model attributes. For example,
   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is
   * used to mark formatting attributes (like `bold` or `italic`).
   *
   * ```ts
   * // Mark bold as a formatting attribute.
   * schema.setAttributeProperties( 'bold', {
   * 	isFormatting: true
   * } );
   *
   * // Override code not to be considered a formatting markup.
   * schema.setAttributeProperties( 'code', {
   * 	isFormatting: false
   * } );
   * ```
   *
   * Properties are not limited to members defined in the
   * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:
   *
   * ```ts
   * schema.setAttributeProperties( 'blockQuote', {
   * 	customProperty: 'value'
   * } );
   * ```
   *
   * Subsequent calls with the same attribute will extend its custom properties:
   *
   * ```ts
   * schema.setAttributeProperties( 'blockQuote', {
   * 	one: 1
   * } );
   *
   * schema.setAttributeProperties( 'blockQuote', {
   * 	two: 2
   * } );
   *
   * console.log( schema.getAttributeProperties( 'blockQuote' ) );
   * // Logs: { one: 1, two: 2 }
   * ```
   *
   * @param attributeName A name of the attribute to receive the properties.
   * @param properties A dictionary of properties.
   */
  setAttributeProperties(attributeName, properties) {
    this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);
  }
  /**
   * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.
   *
   * @param attributeName A name of the attribute.
   */
  getAttributeProperties(attributeName) {
    return this._attributeProperties[attributeName] || /* @__PURE__ */ Object.create(null);
  }
  /**
   * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire
   * selection/range/position or the root otherwise.
   *
   * @param selectionOrRangeOrPosition The selection/range/position to check.
   * @returns The lowest limit element containing the entire `selectionOrRangeOrPosition`.
   */
  getLimitElement(selectionOrRangeOrPosition) {
    let element;
    if (selectionOrRangeOrPosition instanceof Position2) {
      element = selectionOrRangeOrPosition.parent;
    } else {
      const ranges = selectionOrRangeOrPosition instanceof Range2 ? [selectionOrRangeOrPosition] : Array.from(selectionOrRangeOrPosition.getRanges());
      element = ranges.reduce((element2, range) => {
        const rangeCommonAncestor = range.getCommonAncestor();
        if (!element2) {
          return rangeCommonAncestor;
        }
        return element2.getCommonAncestor(rangeCommonAncestor, { includeSelf: true });
      }, null);
    }
    while (!this.isLimit(element)) {
      if (element.parent) {
        element = element.parent;
      } else {
        break;
      }
    }
    return element;
  }
  /**
   * Checks whether the attribute is allowed in selection:
   *
   * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
   * * if the selection is collapsed, then checks if on the selection position there's a text with the
   * specified attribute allowed.
   *
   * @param selection Selection which will be checked.
   * @param attribute The name of the attribute to check.
   */
  checkAttributeInSelection(selection, attribute) {
    if (selection.isCollapsed) {
      const firstPosition = selection.getFirstPosition();
      const context = [
        ...firstPosition.getAncestors(),
        new Text2("", selection.getAttributes())
      ];
      return this.checkAttribute(context, attribute);
    } else {
      const ranges = selection.getRanges();
      for (const range of ranges) {
        for (const value of range) {
          if (this.checkAttribute(value.item, attribute)) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).
   *
   * @param ranges Ranges to be validated.
   * @param attribute The name of the attribute to check.
   * @returns Ranges in which the attribute is allowed.
   */
  *getValidRanges(ranges, attribute) {
    ranges = convertToMinimalFlatRanges(ranges);
    for (const range of ranges) {
      yield* this._getValidRangesForRange(range, attribute);
    }
  }
  /**
   * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is
   * nearest to that `position` and is a correct range for selection.
   *
   * The correct selection range might be collapsed when it is located in a position where the text node can be placed.
   * Non-collapsed range is returned when selection can be placed around element marked as an "object" in
   * the {@link module:engine/model/schema~Schema schema}.
   *
   * Direction of searching for the nearest correct selection range can be specified as:
   *
   * * `both` - searching will be performed in both ways,
   * * `forward` - searching will be performed only forward,
   * * `backward` - searching will be performed only backward.
   *
   * When valid selection range cannot be found, `null` is returned.
   *
   * @param position Reference position where new selection range should be looked for.
   * @param direction Search direction.
   * @returns Nearest selection range or `null` if one cannot be found.
   */
  getNearestSelectionRange(position, direction = "both") {
    if (position.root.rootName == "$graveyard") {
      return null;
    }
    if (this.checkChild(position, "$text")) {
      return new Range2(position);
    }
    let backwardWalker, forwardWalker;
    const limitElement = position.getAncestors().reverse().find((item) => this.isLimit(item)) || position.root;
    if (direction == "both" || direction == "backward") {
      backwardWalker = new TreeWalker2({
        boundaries: Range2._createIn(limitElement),
        startPosition: position,
        direction: "backward"
      });
    }
    if (direction == "both" || direction == "forward") {
      forwardWalker = new TreeWalker2({
        boundaries: Range2._createIn(limitElement),
        startPosition: position
      });
    }
    for (const data of combineWalkers(backwardWalker, forwardWalker)) {
      const type = data.walker == backwardWalker ? "elementEnd" : "elementStart";
      const value = data.value;
      if (value.type == type && this.isObject(value.item)) {
        return Range2._createOn(value.item);
      }
      if (this.checkChild(value.nextPosition, "$text")) {
        return new Range2(value.nextPosition);
      }
    }
    return null;
  }
  /**
   * Tries to find position ancestors that allow to insert a given node.
   * It starts searching from the given position and goes node by node to the top of the model tree
   * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an
   * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.
   *
   * @param position The position that the search will start from.
   * @param node The node for which an allowed parent should be found or its name.
   * @returns Allowed parent or null if nothing was found.
   */
  findAllowedParent(position, node) {
    let parent = position.parent;
    while (parent) {
      if (this.checkChild(parent, node)) {
        return parent;
      }
      if (this.isLimit(parent)) {
        return null;
      }
      parent = parent.parent;
    }
    return null;
  }
  /**
   * Sets attributes allowed by the schema on a given node.
   *
   * @param node A node to set attributes on.
   * @param attributes Attributes keys and values.
   * @param writer An instance of the model writer.
   */
  setAllowedAttributes(node, attributes, writer) {
    const model = writer.model;
    for (const [attributeName, attributeValue] of Object.entries(attributes)) {
      if (model.schema.checkAttribute(node, attributeName)) {
        writer.setAttribute(attributeName, attributeValue, node);
      }
    }
  }
  /**
   * Removes attributes disallowed by the schema.
   *
   * @param nodes Nodes that will be filtered.
   */
  removeDisallowedAttributes(nodes, writer) {
    for (const node of nodes) {
      if (node.is("$text")) {
        removeDisallowedAttributeFromNode(this, node, writer);
      } else {
        const rangeInNode = Range2._createIn(node);
        const positionsInRange = rangeInNode.getPositions();
        for (const position of positionsInRange) {
          const item = position.nodeBefore || position.parent;
          removeDisallowedAttributeFromNode(this, item, writer);
        }
      }
    }
  }
  /**
   * Gets attributes of a node that have a given property.
   *
   * @param node Node to get attributes from.
   * @param propertyName Name of the property that attribute must have to return it.
   * @param propertyValue Desired value of the property that we want to check.
   * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will
   * return attributes which given property's value is equal to this parameter.
   * @returns Object with attributes' names as key and attributes' values as value.
   */
  getAttributesWithProperty(node, propertyName, propertyValue) {
    const attributes = {};
    for (const [attributeName, attributeValue] of node.getAttributes()) {
      const attributeProperties = this.getAttributeProperties(attributeName);
      if (attributeProperties[propertyName] === void 0) {
        continue;
      }
      if (propertyValue === void 0 || propertyValue === attributeProperties[propertyName]) {
        attributes[attributeName] = attributeValue;
      }
    }
    return attributes;
  }
  /**
   * Creates an instance of the schema context.
   */
  createContext(context) {
    return new SchemaContext(context);
  }
  _clearCache() {
    this._compiledDefinitions = null;
  }
  _compile() {
    const definitions = {};
    const sourceRules = this._sourceDefinitions;
    const itemNames = Object.keys(sourceRules);
    for (const itemName of itemNames) {
      definitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);
    }
    const items = Object.values(definitions);
    for (const item of items) {
      propagateAllowIn(definitions, item);
      propagateAllowChildren(definitions, item);
      propagateDisallowIn(definitions, item);
      propagateDisallowChildren(definitions, item);
    }
    for (const item of items) {
      resolveDisallows(definitions, item);
    }
    for (const item of items) {
      compileAllowContentOf(definitions, item);
    }
    for (const item of items) {
      compileAllowWhere(definitions, item);
    }
    for (const item of items) {
      compileAllowAttributesOf(definitions, item);
    }
    for (const item of items) {
      compileInheritPropertiesFrom(definitions, item);
    }
    this._compiledDefinitions = compileDefinitions(definitions);
  }
  _checkContextMatch(context, def) {
    const parentItem = context.last;
    let isAllowed = this._evaluateChildChecks(context, def);
    isAllowed = isAllowed !== void 0 ? isAllowed : def.allowIn.includes(parentItem.name);
    if (!isAllowed) {
      return false;
    }
    const parentItemDefinition = this.getDefinition(parentItem);
    const parentContext = context.trimLast();
    if (!parentItemDefinition) {
      return false;
    }
    if (parentContext.length == 0) {
      return true;
    }
    return this._checkContextMatch(parentContext, parentItemDefinition);
  }
  /**
   * Calls child check callbacks to decide whether `def` is allowed in `context`. It uses both generic and specific (defined for `def`
   * item) callbacks. If neither callback makes a decision, `undefined` is returned.
   *
   * Note that the first callback that makes a decision "wins", i.e., if any callback returns `true` or `false`, then the processing
   * is over and that result is returned.
   */
  _evaluateChildChecks(context, def) {
    const genericChecks = this._customChildChecks.get(this._genericCheckSymbol) || [];
    const childChecks = this._customChildChecks.get(def.name) || [];
    for (const check2 of [...genericChecks, ...childChecks]) {
      const result = check2(context, def);
      if (result !== void 0) {
        return result;
      }
    }
  }
  /**
   * Calls attribute check callbacks to decide whether `attributeName` can be set on the last element of `context`. It uses both
   * generic and specific (defined for `attributeName`) callbacks. If neither callback makes a decision, `undefined` is returned.
   *
   * Note that the first callback that makes a decision "wins", i.e., if any callback returns `true` or `false`, then the processing
   * is over and that result is returned.
   */
  _evaluateAttributeChecks(context, attributeName) {
    const genericChecks = this._customAttributeChecks.get(this._genericCheckSymbol) || [];
    const childChecks = this._customAttributeChecks.get(attributeName) || [];
    for (const check2 of [...genericChecks, ...childChecks]) {
      const result = check2(context, attributeName);
      if (result !== void 0) {
        return result;
      }
    }
  }
  /**
   * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges
   * inside the given range on which the attribute can be applied.
   *
   * This is a helper function for {@link ~Schema#getValidRanges}.
   *
   * @param range The range to process.
   * @param attribute The name of the attribute to check.
   * @returns Ranges in which the attribute is allowed.
   */
  *_getValidRangesForRange(range, attribute) {
    let start = range.start;
    let end = range.start;
    for (const item of range.getItems({ shallow: true })) {
      if (item.is("element")) {
        yield* this._getValidRangesForRange(Range2._createIn(item), attribute);
      }
      if (!this.checkAttribute(item, attribute)) {
        if (!start.isEqual(end)) {
          yield new Range2(start, end);
        }
        start = Position2._createAfter(item);
      }
      end = Position2._createAfter(item);
    }
    if (!start.isEqual(end)) {
      yield new Range2(start, end);
    }
  }
  /**
   * Returns a model range which is optimal (in terms of UX) for inserting a widget block.
   *
   * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph
   * will be returned so that it is not split. If the selection is at the end of a paragraph,
   * the collapsed range after this paragraph will be returned.
   *
   * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range
   * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced
   * by the inserted widget block.
   *
   * @internal
   * @param selection The selection based on which the insertion position should be calculated.
   * @param place The place where to look for optimal insertion range.
   * The `auto` value will determine itself the best position for insertion.
   * The `before` value will try to find a position before selection.
   * The `after` value will try to find a position after selection.
   * @returns The optimal range.
   */
  findOptimalInsertionRange(selection, place) {
    const selectedElement = selection.getSelectedElement();
    if (selectedElement && this.isObject(selectedElement) && !this.isInline(selectedElement)) {
      if (place == "before" || place == "after") {
        return new Range2(Position2._createAt(selectedElement, place));
      }
      return Range2._createOn(selectedElement);
    }
    const firstBlock = first(selection.getSelectedBlocks());
    if (!firstBlock) {
      return new Range2(selection.focus);
    }
    if (firstBlock.isEmpty) {
      return new Range2(Position2._createAt(firstBlock, 0));
    }
    const positionAfter = Position2._createAfter(firstBlock);
    if (selection.focus.isTouching(positionAfter)) {
      return new Range2(positionAfter);
    }
    return new Range2(Position2._createBefore(firstBlock));
  }
};
var SchemaContext = class _SchemaContext {
  /**
   * Creates an instance of the context.
   */
  constructor(context) {
    if (context instanceof _SchemaContext) {
      return context;
    }
    let items;
    if (typeof context == "string") {
      items = [context];
    } else if (!Array.isArray(context)) {
      items = context.getAncestors({ includeSelf: true });
    } else {
      items = context;
    }
    this._items = items.map(mapContextItem);
  }
  /**
   * The number of items.
   */
  get length() {
    return this._items.length;
  }
  /**
   * The last item (the lowest node).
   */
  get last() {
    return this._items[this._items.length - 1];
  }
  /**
   * Iterable interface.
   *
   * Iterates over all context items.
   */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
  /**
   * Returns a new schema context instance with an additional item.
   *
   * Item can be added as:
   *
   * ```ts
   * const context = new SchemaContext( [ '$root' ] );
   *
   * // An element.
   * const fooElement = writer.createElement( 'fooElement' );
   * const newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]
   *
   * // A text node.
   * const text = writer.createText( 'foobar' );
   * const newContext = context.push( text ); // [ '$root', '$text' ]
   *
   * // A string (element name).
   * const newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]
   * ```
   *
   * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item
   * (without ancestors).
   *
   * @param item An item that will be added to the current context.
   * @returns A new schema context instance with an additional item.
   */
  push(item) {
    const ctx = new _SchemaContext([item]);
    ctx._items = [...this._items, ...ctx._items];
    return ctx;
  }
  /**
   * Returns a new schema context that is based on this context but has the last item removed.
   *
   * ```ts
   * const ctxParagraph = new SchemaContext( [ '$root', 'blockQuote', 'paragraph' ] );
   * const ctxBlockQuote = ctxParagraph.trimLast(); // Items in `ctxBlockQuote` are: `$root` an `blockQuote`.
   * const ctxRoot = ctxBlockQuote.trimLast(); // Items in `ctxRoot` are: `$root`.
   * ```
   *
   * @returns A new reduced schema context instance.
   */
  trimLast() {
    const ctx = new _SchemaContext([]);
    ctx._items = this._items.slice(0, -1);
    return ctx;
  }
  /**
   * Gets an item on the given index.
   */
  getItem(index) {
    return this._items[index];
  }
  /**
   * Returns the names of items.
   */
  *getNames() {
    yield* this._items.map((item) => item.name);
  }
  /**
   * Checks whether the context ends with the given nodes.
   *
   * ```ts
   * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
   *
   * ctx.endsWith( '$text' ); // -> true
   * ctx.endsWith( 'paragraph $text' ); // -> true
   * ctx.endsWith( '$root' ); // -> false
   * ctx.endsWith( 'paragraph' ); // -> false
   * ```
   */
  endsWith(query) {
    return Array.from(this.getNames()).join(" ").endsWith(query);
  }
  /**
   * Checks whether the context starts with the given nodes.
   *
   * ```ts
   * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
   *
   * ctx.endsWith( '$root' ); // -> true
   * ctx.endsWith( '$root paragraph' ); // -> true
   * ctx.endsWith( '$text' ); // -> false
   * ctx.endsWith( 'paragraph' ); // -> false
   * ```
   */
  startsWith(query) {
    return Array.from(this.getNames()).join(" ").startsWith(query);
  }
};
function compileBaseItemRule(sourceItemRules, itemName) {
  const itemRule = {
    name: itemName,
    allowIn: /* @__PURE__ */ new Set(),
    allowChildren: /* @__PURE__ */ new Set(),
    disallowIn: /* @__PURE__ */ new Set(),
    disallowChildren: /* @__PURE__ */ new Set(),
    allowContentOf: /* @__PURE__ */ new Set(),
    allowWhere: /* @__PURE__ */ new Set(),
    allowAttributes: /* @__PURE__ */ new Set(),
    disallowAttributes: /* @__PURE__ */ new Set(),
    allowAttributesOf: /* @__PURE__ */ new Set(),
    inheritTypesFrom: /* @__PURE__ */ new Set()
  };
  copyTypes(sourceItemRules, itemRule);
  copyProperty(sourceItemRules, itemRule, "allowIn");
  copyProperty(sourceItemRules, itemRule, "allowChildren");
  copyProperty(sourceItemRules, itemRule, "disallowIn");
  copyProperty(sourceItemRules, itemRule, "disallowChildren");
  copyProperty(sourceItemRules, itemRule, "allowContentOf");
  copyProperty(sourceItemRules, itemRule, "allowWhere");
  copyProperty(sourceItemRules, itemRule, "allowAttributes");
  copyProperty(sourceItemRules, itemRule, "disallowAttributes");
  copyProperty(sourceItemRules, itemRule, "allowAttributesOf");
  copyProperty(sourceItemRules, itemRule, "inheritTypesFrom");
  resolveInheritAll(sourceItemRules, itemRule);
  return itemRule;
}
function propagateAllowIn(definitions, item) {
  for (const parentName of item.allowIn) {
    const parentItem = definitions[parentName];
    if (parentItem) {
      parentItem.allowChildren.add(item.name);
    } else {
      item.allowIn.delete(parentName);
    }
  }
}
function propagateAllowChildren(definitions, item) {
  for (const childName of item.allowChildren) {
    const childItem = definitions[childName];
    if (childItem) {
      childItem.allowIn.add(item.name);
    } else {
      item.allowChildren.delete(childName);
    }
  }
}
function propagateDisallowIn(definitions, item) {
  for (const parentName of item.disallowIn) {
    const parentItem = definitions[parentName];
    if (parentItem) {
      parentItem.disallowChildren.add(item.name);
    } else {
      item.disallowIn.delete(parentName);
    }
  }
}
function propagateDisallowChildren(definitions, item) {
  for (const childName of item.disallowChildren) {
    const childItem = definitions[childName];
    if (childItem) {
      childItem.disallowIn.add(item.name);
    } else {
      item.disallowChildren.delete(childName);
    }
  }
}
function resolveDisallows(definitions, item) {
  for (const childName of item.disallowChildren) {
    item.allowChildren.delete(childName);
  }
  for (const parentName of item.disallowIn) {
    item.allowIn.delete(parentName);
  }
  for (const attributeName of item.disallowAttributes) {
    item.allowAttributes.delete(attributeName);
  }
}
function compileAllowContentOf(definitions, item) {
  for (const allowContentOfItemName of item.allowContentOf) {
    const baseItem = definitions[allowContentOfItemName];
    if (!baseItem) {
      continue;
    }
    baseItem.disallowChildren.forEach((childName) => {
      if (item.allowChildren.has(childName)) {
        return;
      }
      item.disallowChildren.add(childName);
      definitions[childName].disallowIn.add(item.name);
    });
    baseItem.allowChildren.forEach((childName) => {
      if (item.disallowChildren.has(childName)) {
        return;
      }
      item.allowChildren.add(childName);
      definitions[childName].allowIn.add(item.name);
    });
  }
}
function compileAllowWhere(definitions, item) {
  for (const allowWhereItemName of item.allowWhere) {
    const baseItem = definitions[allowWhereItemName];
    if (!baseItem) {
      continue;
    }
    baseItem.disallowIn.forEach((parentName) => {
      if (item.allowIn.has(parentName)) {
        return;
      }
      item.disallowIn.add(parentName);
      definitions[parentName].disallowChildren.add(item.name);
    });
    baseItem.allowIn.forEach((parentName) => {
      if (item.disallowIn.has(parentName)) {
        return;
      }
      item.allowIn.add(parentName);
      definitions[parentName].allowChildren.add(item.name);
    });
  }
}
function compileDefinitions(definitions) {
  const finalDefinitions = {};
  for (const item of Object.values(definitions)) {
    finalDefinitions[item.name] = {
      name: item.name,
      // `is*` properties may not be set - convert `undefined` to `false`.
      isBlock: !!item.isBlock,
      isContent: !!item.isContent,
      isInline: !!item.isInline,
      isLimit: !!item.isLimit,
      isObject: !!item.isObject,
      isSelectable: !!item.isSelectable,
      // Filter out non-existing items.
      allowIn: Array.from(item.allowIn).filter((name) => !!definitions[name]),
      allowChildren: Array.from(item.allowChildren).filter((name) => !!definitions[name]),
      allowAttributes: Array.from(item.allowAttributes)
    };
  }
  return finalDefinitions;
}
function compileAllowAttributesOf(definitions, item) {
  for (const allowAttributeOfItemName of item.allowAttributesOf) {
    const baseItem = definitions[allowAttributeOfItemName];
    if (!baseItem) {
      return;
    }
    baseItem.allowAttributes.forEach((attributeName) => {
      if (item.disallowAttributes.has(attributeName)) {
        return;
      }
      item.allowAttributes.add(attributeName);
    });
  }
}
function compileInheritPropertiesFrom(definitions, item) {
  for (const inheritPropertiesOfItemName of item.inheritTypesFrom) {
    const inheritFrom = definitions[inheritPropertiesOfItemName];
    if (inheritFrom) {
      const typeNames = Object.keys(inheritFrom).filter((name) => name.startsWith("is"));
      for (const name of typeNames) {
        if (!(name in item)) {
          item[name] = inheritFrom[name];
        }
      }
    }
  }
}
function copyTypes(sourceItemRules, itemRule) {
  for (const sourceItemRule of sourceItemRules) {
    const typeNames = Object.keys(sourceItemRule).filter((name) => name.startsWith("is"));
    for (const name of typeNames) {
      itemRule[name] = !!sourceItemRule[name];
    }
  }
}
function copyProperty(sourceItemRules, itemRule, propertyName) {
  for (const sourceItemRule of sourceItemRules) {
    let value = sourceItemRule[propertyName];
    if (typeof value == "string") {
      value = [value];
    }
    if (Array.isArray(value)) {
      value.forEach((singleValue) => itemRule[propertyName].add(singleValue));
    }
  }
}
function resolveInheritAll(sourceItemRules, itemRule) {
  for (const sourceItemRule of sourceItemRules) {
    const inheritFrom = sourceItemRule.inheritAllFrom;
    if (inheritFrom) {
      itemRule.allowContentOf.add(inheritFrom);
      itemRule.allowWhere.add(inheritFrom);
      itemRule.allowAttributesOf.add(inheritFrom);
      itemRule.inheritTypesFrom.add(inheritFrom);
    }
  }
}
function mapContextItem(ctxItem) {
  if (typeof ctxItem == "string" || ctxItem.is("documentFragment")) {
    return {
      name: typeof ctxItem == "string" ? ctxItem : "$documentFragment",
      *getAttributeKeys() {
      },
      getAttribute() {
      }
    };
  } else {
    return {
      // '$text' means text nodes and text proxies.
      name: ctxItem.is("element") ? ctxItem.name : "$text",
      *getAttributeKeys() {
        yield* ctxItem.getAttributeKeys();
      },
      getAttribute(key) {
        return ctxItem.getAttribute(key);
      }
    };
  }
}
function* combineWalkers(backward, forward) {
  let done = false;
  while (!done) {
    done = true;
    if (backward) {
      const step = backward.next();
      if (!step.done) {
        done = false;
        yield {
          walker: backward,
          value: step.value
        };
      }
    }
    if (forward) {
      const step = forward.next();
      if (!step.done) {
        done = false;
        yield {
          walker: forward,
          value: step.value
        };
      }
    }
  }
}
function* convertToMinimalFlatRanges(ranges) {
  for (const range of ranges) {
    yield* range.getMinimalFlatRanges();
  }
}
function removeDisallowedAttributeFromNode(schema, node, writer) {
  for (const attribute of node.getAttributeKeys()) {
    if (!schema.checkAttribute(node, attribute)) {
      writer.removeAttribute(attribute, node);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js
var UpcastDispatcher = class extends EmitterMixin() {
  /**
   * Creates an upcast dispatcher that operates using the passed API.
   *
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi
   * @param conversionApi Additional properties for an interface that will be passed to events fired
   * by the upcast dispatcher.
   */
  constructor(conversionApi) {
    super();
    this._splitParts = /* @__PURE__ */ new Map();
    this._cursorParents = /* @__PURE__ */ new Map();
    this._modelCursor = null;
    this._emptyElementsToKeep = /* @__PURE__ */ new Set();
    this.conversionApi = {
      ...conversionApi,
      consumable: null,
      writer: null,
      store: null,
      convertItem: (viewItem, modelCursor) => this._convertItem(viewItem, modelCursor),
      convertChildren: (viewElement, positionOrElement) => this._convertChildren(viewElement, positionOrElement),
      safeInsert: (modelNode, position) => this._safeInsert(modelNode, position),
      updateConversionResult: (modelElement, data) => this._updateConversionResult(modelElement, data),
      // Advanced API - use only if custom position handling is needed.
      splitToAllowedParent: (modelNode, modelCursor) => this._splitToAllowedParent(modelNode, modelCursor),
      getSplitParts: (modelElement) => this._getSplitParts(modelElement),
      keepEmptyElement: (modelElement) => this._keepEmptyElement(modelElement)
    };
  }
  /**
   * Starts the conversion process. The entry point for the conversion.
   *
   * @fires element
   * @fires text
   * @fires documentFragment
   * @param viewElement The part of the view to be converted.
   * @param writer An instance of the model writer.
   * @param context Elements will be converted according to this context.
   * @returns Model data that is the result of the conversion process
   * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's
   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
   */
  convert(viewElement, writer, context = ["$root"]) {
    this.fire("viewCleanup", viewElement);
    this._modelCursor = createContextTree(context, writer);
    this.conversionApi.writer = writer;
    this.conversionApi.consumable = ViewConsumable.createFrom(viewElement);
    this.conversionApi.store = {};
    const { modelRange } = this._convertItem(viewElement, this._modelCursor);
    const documentFragment = writer.createDocumentFragment();
    if (modelRange) {
      this._removeEmptyElements();
      for (const item of Array.from(this._modelCursor.parent.getChildren())) {
        writer.append(item, documentFragment);
      }
      documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);
    }
    this._modelCursor = null;
    this._splitParts.clear();
    this._cursorParents.clear();
    this._emptyElementsToKeep.clear();
    this.conversionApi.writer = null;
    this.conversionApi.store = null;
    return documentFragment;
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem
   */
  _convertItem(viewItem, modelCursor) {
    const data = { viewItem, modelCursor, modelRange: null };
    if (viewItem.is("element")) {
      this.fire(`element:${viewItem.name}`, data, this.conversionApi);
    } else if (viewItem.is("$text")) {
      this.fire("text", data, this.conversionApi);
    } else {
      this.fire("documentFragment", data, this.conversionApi);
    }
    if (data.modelRange && !(data.modelRange instanceof Range2)) {
      throw new CKEditorError("view-conversion-dispatcher-incorrect-result", this);
    }
    return { modelRange: data.modelRange, modelCursor: data.modelCursor };
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren
   */
  _convertChildren(viewItem, elementOrModelCursor) {
    let nextModelCursor = elementOrModelCursor.is("position") ? elementOrModelCursor : Position2._createAt(elementOrModelCursor, 0);
    const modelRange = new Range2(nextModelCursor);
    for (const viewChild of Array.from(viewItem.getChildren())) {
      const result = this._convertItem(viewChild, nextModelCursor);
      if (result.modelRange instanceof Range2) {
        modelRange.end = result.modelRange.end;
        nextModelCursor = result.modelCursor;
      }
    }
    return { modelRange, modelCursor: nextModelCursor };
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert
   */
  _safeInsert(modelNode, position) {
    const splitResult = this._splitToAllowedParent(modelNode, position);
    if (!splitResult) {
      return false;
    }
    this.conversionApi.writer.insert(modelNode, splitResult.position);
    return true;
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult
   */
  _updateConversionResult(modelElement, data) {
    const parts = this._getSplitParts(modelElement);
    const writer = this.conversionApi.writer;
    if (!data.modelRange) {
      data.modelRange = writer.createRange(writer.createPositionBefore(modelElement), writer.createPositionAfter(parts[parts.length - 1]));
    }
    const savedCursorParent = this._cursorParents.get(modelElement);
    if (savedCursorParent) {
      data.modelCursor = writer.createPositionAt(savedCursorParent, 0);
    } else {
      data.modelCursor = data.modelRange.end;
    }
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent
   */
  _splitToAllowedParent(node, modelCursor) {
    const { schema, writer } = this.conversionApi;
    let allowedParent = schema.findAllowedParent(modelCursor, node);
    if (allowedParent) {
      if (allowedParent === modelCursor.parent) {
        return { position: modelCursor };
      }
      if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {
        allowedParent = null;
      }
    }
    if (!allowedParent) {
      if (!isParagraphable(modelCursor, node, schema)) {
        return null;
      }
      return {
        position: wrapInParagraph(modelCursor, writer)
      };
    }
    const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent);
    const stack = [];
    for (const treeWalkerValue of splitResult.range.getWalker()) {
      if (treeWalkerValue.type == "elementEnd") {
        stack.push(treeWalkerValue.item);
      } else {
        const originalPart = stack.pop();
        const splitPart = treeWalkerValue.item;
        this._registerSplitPair(originalPart, splitPart);
      }
    }
    const cursorParent = splitResult.range.end.parent;
    this._cursorParents.set(node, cursorParent);
    return {
      position: splitResult.position,
      cursorParent
    };
  }
  /**
   * Registers that a `splitPart` element is a split part of the `originalPart` element.
   *
   * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.
   */
  _registerSplitPair(originalPart, splitPart) {
    if (!this._splitParts.has(originalPart)) {
      this._splitParts.set(originalPart, [originalPart]);
    }
    const list = this._splitParts.get(originalPart);
    this._splitParts.set(splitPart, list);
    list.push(splitPart);
  }
  /**
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts
   */
  _getSplitParts(element) {
    let parts;
    if (!this._splitParts.has(element)) {
      parts = [element];
    } else {
      parts = this._splitParts.get(element);
    }
    return parts;
  }
  /**
   * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.
   */
  _keepEmptyElement(element) {
    this._emptyElementsToKeep.add(element);
  }
  /**
   * Checks if there are any empty elements created while splitting and removes them.
   *
   * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,
   * as some elements might have become empty after other empty elements were removed from them.
   */
  _removeEmptyElements() {
    let anyRemoved = false;
    for (const element of this._splitParts.keys()) {
      if (element.isEmpty && !this._emptyElementsToKeep.has(element)) {
        this.conversionApi.writer.remove(element);
        this._splitParts.delete(element);
        anyRemoved = true;
      }
    }
    if (anyRemoved) {
      this._removeEmptyElements();
    }
  }
};
function extractMarkersFromModelFragment(modelItem, writer) {
  const markerElements = /* @__PURE__ */ new Set();
  const markers = /* @__PURE__ */ new Map();
  const range = Range2._createIn(modelItem).getItems();
  for (const item of range) {
    if (item.is("element", "$marker")) {
      markerElements.add(item);
    }
  }
  for (const markerElement of markerElements) {
    const markerName = markerElement.getAttribute("data-name");
    const currentPosition = writer.createPositionBefore(markerElement);
    if (!markers.has(markerName)) {
      markers.set(markerName, new Range2(currentPosition.clone()));
    } else {
      markers.get(markerName).end = currentPosition.clone();
    }
    writer.remove(markerElement);
  }
  return markers;
}
function createContextTree(contextDefinition, writer) {
  let position;
  for (const item of new SchemaContext(contextDefinition)) {
    const attributes = {};
    for (const key of item.getAttributeKeys()) {
      attributes[key] = item.getAttribute(key);
    }
    const current = writer.createElement(item.name, attributes);
    if (position) {
      writer.insert(current, position);
    }
    position = Position2._createAt(current, 0);
  }
  return position;
}

// node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/basichtmlwriter.js
var BasicHtmlWriter = class {
  /**
   * Returns an HTML string created from the document fragment.
   */
  getHtml(fragment) {
    const doc = global_default.document.implementation.createHTMLDocument("");
    const container = doc.createElement("div");
    container.appendChild(fragment);
    return container.innerHTML;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor.js
var HtmlDataProcessor = class {
  /**
   * Creates a new instance of the HTML data processor class.
   *
   * @param document The view document instance.
   */
  constructor(document2) {
    this.skipComments = true;
    this.domParser = new DOMParser();
    this.domConverter = new DomConverter(document2, { renderingMode: "data" });
    this.htmlWriter = new BasicHtmlWriter();
  }
  /**
   * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
   * to data format &ndash; in this case to an HTML string.
   *
   * @returns HTML string.
   */
  toData(viewFragment) {
    const domFragment = this.domConverter.viewToDom(viewFragment);
    return this.htmlWriter.getHtml(domFragment);
  }
  /**
   * Converts the provided HTML string to a view tree.
   *
   * @param data An HTML string.
   * @returns A converted view element.
   */
  toView(data) {
    const domFragment = this._toDom(data);
    return this.domConverter.domToView(domFragment, { skipComments: this.skipComments });
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from the DOM to the view elements.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as raw data.
   */
  registerRawContentMatcher(pattern) {
    this.domConverter.registerRawContentMatcher(pattern);
  }
  /**
   * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
   * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
   *
   * This mode allows for a more precise handling of the block fillers (so they do not leak into the editor content) but
   * bloats the editor data with additional markup.
   *
   * This mode may be required by some features and will be turned on by them automatically.
   *
   * @param type Whether to use the default or the marked `&nbsp;` block fillers.
   */
  useFillerType(type) {
    this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
  }
  /**
   * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
   * the provided data.
   */
  _toDom(data) {
    if (!/<(?:html|body|head|meta)(?:\s[^>]*)?>/i.test(data.trim().slice(0, 1e4))) {
      data = `<body>${data}</body>`;
    }
    const document2 = this.domParser.parseFromString(data, "text/html");
    const fragment = document2.createDocumentFragment();
    const bodyChildNodes = document2.body.childNodes;
    while (bodyChildNodes.length > 0) {
      fragment.appendChild(bodyChildNodes[0]);
    }
    return fragment;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js
var DataController = class extends EmitterMixin() {
  /**
   * Creates a data controller instance.
   *
   * @param model Data model.
   * @param stylesProcessor The styles processor instance.
   */
  constructor(model, stylesProcessor) {
    super();
    this.model = model;
    this.mapper = new Mapper();
    this.downcastDispatcher = new DowncastDispatcher({
      mapper: this.mapper,
      schema: model.schema
    });
    this.downcastDispatcher.on("insert:$text", insertText(), { priority: "lowest" });
    this.downcastDispatcher.on("insert", insertAttributesAndChildren(), { priority: "lowest" });
    this.upcastDispatcher = new UpcastDispatcher({
      schema: model.schema
    });
    this.viewDocument = new Document(stylesProcessor);
    this.stylesProcessor = stylesProcessor;
    this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);
    this.processor = this.htmlProcessor;
    this._viewWriter = new DowncastWriter(this.viewDocument);
    this.upcastDispatcher.on("text", convertText(), { priority: "lowest" });
    this.upcastDispatcher.on("element", convertToModelFragment(), { priority: "lowest" });
    this.upcastDispatcher.on("documentFragment", convertToModelFragment(), { priority: "lowest" });
    ObservableMixin().prototype.decorate.call(this, "init");
    ObservableMixin().prototype.decorate.call(this, "set");
    ObservableMixin().prototype.decorate.call(this, "get");
    ObservableMixin().prototype.decorate.call(this, "toView");
    ObservableMixin().prototype.decorate.call(this, "toModel");
    this.on("init", () => {
      this.fire("ready");
    }, { priority: "lowest" });
    this.on("ready", () => {
      this.model.enqueueChange({ isUndoable: false }, autoParagraphEmptyRoots);
    }, { priority: "lowest" });
  }
  /**
   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and
   * formatted by the {@link #processor data processor}.
   *
   * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
   * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
   *
   * @fires get
   * @param options Additional configuration for the retrieved data. `DataController` provides two optional
   * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.
   * @param options.rootName Root name. Default 'main'.
   * @param options.trim Whether returned data should be trimmed. This option is set to `empty` by default,
   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely
   * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).
   * @returns Output data.
   */
  get(options = {}) {
    const { rootName = "main", trim = "empty" } = options;
    if (!this._checkIfRootsExists([rootName])) {
      throw new CKEditorError("datacontroller-get-non-existent-root", this);
    }
    const root = this.model.document.getRoot(rootName);
    if (!root.isAttached()) {
      logWarning("datacontroller-get-detached-root", this);
    }
    if (trim === "empty" && !this.model.hasContent(root, { ignoreWhitespaces: true })) {
      return "";
    }
    return this.stringify(root, options);
  }
  /**
   * Returns the content of the given {@link module:engine/model/element~Element model's element} or
   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters
   * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.
   *
   * @param modelElementOrFragment The element whose content will be stringified.
   * @param options Additional configuration passed to the conversion process.
   * @returns Output data.
   */
  stringify(modelElementOrFragment, options = {}) {
    const viewDocumentFragment = this.toView(modelElementOrFragment, options);
    return this.processor.toData(viewDocumentFragment);
  }
  /**
   * Returns the content of the given {@link module:engine/model/element~Element model element} or
   * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast
   * converters attached to {@link #downcastDispatcher} into a
   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
   *
   * @fires toView
   * @param modelElementOrFragment Element or document fragment whose content will be converted.
   * @param options Additional configuration that will be available through the
   * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.
   * @returns Output view DocumentFragment.
   */
  toView(modelElementOrFragment, options = {}) {
    const viewDocument = this.viewDocument;
    const viewWriter = this._viewWriter;
    this.mapper.clearBindings();
    const modelRange = Range2._createIn(modelElementOrFragment);
    const viewDocumentFragment = new DocumentFragment(viewDocument);
    this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment);
    const markers = modelElementOrFragment.is("documentFragment") ? modelElementOrFragment.markers : _getMarkersRelativeToElement(modelElementOrFragment);
    this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);
    return viewDocumentFragment;
  }
  /**
   * Sets the initial input data parsed by the {@link #processor data processor} and
   * converted by the {@link #upcastDispatcher view-to-model converters}.
   * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.
   *
   * **Note** This method is {@link module:utils/observablemixin~Observable#decorate decorated} which is
   * used by e.g. collaborative editing plugin that syncs remote data on init.
   *
   * When data is passed as a string, it is initialized on the default `main` root:
   *
   * ```ts
   * dataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.
   * ```
   *
   * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
   *
   * ```ts
   * dataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.
   * ```
   *
   * @fires init
   * @param data Input data as a string or an object containing the `rootName` - `data`
   * pairs to initialize data on multiple roots at once.
   * @returns Promise that is resolved after the data is set on the editor.
   */
  init(data) {
    if (this.model.document.version) {
      throw new CKEditorError("datacontroller-init-document-not-empty", this);
    }
    let initialData = {};
    if (typeof data === "string") {
      initialData.main = data;
    } else {
      initialData = data;
    }
    if (!this._checkIfRootsExists(Object.keys(initialData))) {
      throw new CKEditorError("datacontroller-init-non-existent-root", this);
    }
    this.model.enqueueChange({ isUndoable: false }, (writer) => {
      for (const rootName of Object.keys(initialData)) {
        const modelRoot = this.model.document.getRoot(rootName);
        writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);
      }
    });
    return Promise.resolve();
  }
  /**
   * Sets the input data parsed by the {@link #processor data processor} and
   * converted by the {@link #upcastDispatcher view-to-model converters}.
   * This method can be used any time to replace existing editor data with the new one without clearing the
   * {@link module:engine/model/document~Document#history document history}.
   *
   * This method also creates a batch with all the changes applied. If all you need is to parse data, use
   * the {@link #parse} method.
   *
   * When data is passed as a string it is set on the default `main` root:
   *
   * ```ts
   * dataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.
   * ```
   *
   * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
   *
   * ```ts
   * dataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.
   * ```
   *
   * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.
   *
   * ```ts
   * dataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );
   * ```
   *
   * @fires set
   * @param data Input data as a string or an object containing the `rootName` - `data`
   * pairs to set data on multiple roots at once.
   * @param options Options for setting data.
   * @param options.batchType The batch type that will be used to create a batch for the changes applied by this method.
   * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be
   * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,
   * the undo stack will be preserved instead and not cleared when new data is applied.
   */
  set(data, options = {}) {
    let newData = {};
    if (typeof data === "string") {
      newData.main = data;
    } else {
      newData = data;
    }
    if (!this._checkIfRootsExists(Object.keys(newData))) {
      throw new CKEditorError("datacontroller-set-non-existent-root", this);
    }
    this.model.enqueueChange(options.batchType || {}, (writer) => {
      writer.setSelection(null);
      writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
      for (const rootName of Object.keys(newData)) {
        const modelRoot = this.model.document.getRoot(rootName);
        writer.remove(writer.createRangeIn(modelRoot));
        writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);
      }
    });
  }
  /**
   * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters
   * attached to the {@link #upcastDispatcher}.
   *
   * @see #set
   * @param data Data to parse.
   * @param context Base context in which the view will be converted to the model.
   * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
   * @returns Parsed data.
   */
  parse(data, context = "$root") {
    const viewDocumentFragment = this.processor.toView(data);
    return this.toModel(viewDocumentFragment, context);
  }
  /**
   * Returns the result of the given {@link module:engine/view/element~Element view element} or
   * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the
   * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.
   *
   * When marker elements were converted during the conversion process, it will be set as a document fragment's
   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
   *
   * @fires toModel
   * @param viewElementOrFragment The element or document fragment whose content will be converted.
   * @param context Base context in which the view will be converted to the model.
   * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
   * @returns Output document fragment.
   */
  toModel(viewElementOrFragment, context = "$root") {
    return this.model.change((writer) => {
      return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);
    });
  }
  /**
   * Adds the style processor normalization rules.
   *
   * You can implement your own rules as well as use one of the available processor rules:
   *
   * * background: {@link module:engine/view/styles/background~addBackgroundRules}
   * * border: {@link module:engine/view/styles/border~addBorderRules}
   * * margin: {@link module:engine/view/styles/margin~addMarginRules}
   * * padding: {@link module:engine/view/styles/padding~addPaddingRules}
   */
  addStyleProcessorRules(callback) {
    callback(this.stylesProcessor);
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}
   * and a {@link #processor processor} for view elements whose content should be treated as raw data
   * and not processed during the conversion from DOM to view elements.
   *
   * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}
   * `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as a raw data.
   */
  registerRawContentMatcher(pattern) {
    if (this.processor && this.processor !== this.htmlProcessor) {
      this.processor.registerRawContentMatcher(pattern);
    }
    this.htmlProcessor.registerRawContentMatcher(pattern);
  }
  /**
   * Removes all event listeners set by the DataController.
   */
  destroy() {
    this.stopListening();
  }
  /**
   * Checks whether all provided root names are actually existing editor roots.
   *
   * @param rootNames Root names to check.
   * @returns Whether all provided root names are existing editor roots.
   */
  _checkIfRootsExists(rootNames) {
    for (const rootName of rootNames) {
      if (!this.model.document.getRoot(rootName)) {
        return false;
      }
    }
    return true;
  }
};
function _getMarkersRelativeToElement(element) {
  const result = [];
  const doc = element.root.document;
  if (!doc) {
    return /* @__PURE__ */ new Map();
  }
  const elementRange = Range2._createIn(element);
  for (const marker of doc.model.markers) {
    const markerRange = marker.getRange();
    const isMarkerCollapsed = markerRange.isCollapsed;
    const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);
    if (isMarkerCollapsed && isMarkerAtElementBoundary) {
      result.push([marker.name, markerRange]);
    } else {
      const updatedMarkerRange = elementRange.getIntersection(markerRange);
      if (updatedMarkerRange) {
        result.push([marker.name, updatedMarkerRange]);
      }
    }
  }
  result.sort(([n1, r1], [n2, r2]) => {
    if (r1.end.compareWith(r2.start) !== "after") {
      return 1;
    } else if (r1.start.compareWith(r2.end) !== "before") {
      return -1;
    } else {
      switch (r1.start.compareWith(r2.start)) {
        case "before":
          return 1;
        case "after":
          return -1;
        default:
          switch (r1.end.compareWith(r2.end)) {
            case "before":
              return 1;
            case "after":
              return -1;
            default:
              return n2.localeCompare(n1);
          }
      }
    }
  });
  return new Map(result);
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js
var Conversion = class {
  /**
   * Creates a new conversion instance.
   */
  constructor(downcastDispatchers, upcastDispatchers) {
    this._helpers = /* @__PURE__ */ new Map();
    this._downcast = toArray(downcastDispatchers);
    this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: true });
    this._upcast = toArray(upcastDispatchers);
    this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: false });
  }
  /**
   * Define an alias for registered dispatcher.
   *
   * ```ts
   * const conversion = new Conversion(
   * 	[ dataDowncastDispatcher, editingDowncastDispatcher ],
   * 	upcastDispatcher
   * );
   *
   * conversion.addAlias( 'dataDowncast', dataDowncastDispatcher );
   * ```
   *
   * @param alias An alias of a dispatcher.
   * @param dispatcher Dispatcher which should have an alias.
   */
  addAlias(alias, dispatcher) {
    const isDowncast = this._downcast.includes(dispatcher);
    const isUpcast = this._upcast.includes(dispatcher);
    if (!isUpcast && !isDowncast) {
      throw new CKEditorError("conversion-add-alias-dispatcher-not-registered", this);
    }
    this._createConversionHelpers({ name: alias, dispatchers: [dispatcher], isDowncast });
  }
  /**
   * Provides a chainable API to assign converters to a conversion dispatchers group.
   *
   * If the given group name has not been registered, the
   * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.
   *
   * You can use conversion helpers available directly in the `for()` chain or your custom ones via
   * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.
   *
   * # Using built-in conversion helpers
   *
   * The `for()` chain comes with a set of conversion helpers which you can use like this:
   *
   * ```ts
   * editor.conversion.for( 'downcast' )
   * 	.elementToElement( config1 )        // Adds an element-to-element downcast converter.
   * 	.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.
   *
   * editor.conversion.for( 'upcast' )
   * 	.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.
   * ```
   *
   * Refer to the documentation of built-in conversion helpers to learn about their configuration options.
   *
   * * downcast (model-to-view) conversion helpers:
   *
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.
   *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.
   *
   * * upcast (view-to-model) conversion helpers:
   *
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.
   *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.
   *
   * # Using custom conversion helpers
   *
   * If you need to implement an atypical converter, you can do so by calling:
   *
   * ```ts
   * editor.conversion.for( direction ).add( customHelper );
   * ```
   *
   * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that
   * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.
   *
   * Example:
   *
   * ```ts
   * editor.conversion.for( 'upcast' ).add( dispatcher => {
   * 	dispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {
   * 		// Do something with a view <a> element.
   * 	} );
   * } );
   * ```
   *
   * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
   * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write
   * custom converters.
   *
   * @param groupName The name of dispatchers group to add the converters to.
   */
  for(groupName) {
    if (!this._helpers.has(groupName)) {
      throw new CKEditorError("conversion-for-unknown-group", this);
    }
    return this._helpers.get(groupName);
  }
  /**
   * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).
   * For example, the model `<paragraph>Foo</paragraph>` is turned into `<p>Foo</p>` in the view.
   *
   * ```ts
   * // A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).
   * editor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );
   *
   * // Override other converters by specifying a converter definition with a higher priority.
   * editor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );
   *
   * // View specified as an object instead of a string.
   * editor.conversion.elementToElement( {
   * 	model: 'fancyParagraph',
   * 	view: {
   * 		name: 'p',
   * 		classes: 'fancy'
   * 	}
   * } );
   *
   * // Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.
   * editor.conversion.elementToElement( {
   * 	model: 'paragraph',
   * 	view: 'p',
   * 	upcastAlso: [
   * 		'div',
   * 		{
   * 			// Any element with the `display: block` style.
   * 			styles: {
   * 				display: 'block'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
   * editor.conversion.elementToElement( {
   * 	model: 'heading',
   * 	view: 'h2',
   * 	// Convert "heading-like" paragraphs to headings.
   * 	upcastAlso: viewElement => {
   * 		const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 		if ( !fontSize ) {
   * 			return null;
   * 		}
   *
   * 		const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 		if ( !match ) {
   * 			return null;
   * 		}
   *
   * 		const size = Number( match[ 1 ] );
   *
   * 		if ( size > 26 ) {
   * 			// Returned value can be an object with the matched properties.
   * 			// These properties will be "consumed" during the conversion.
   * 			// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 			return { name: true, styles: [ 'font-size' ] };
   * 		}
   *
   * 		return null;
   * 	}
   * } );
   * ```
   *
   * `definition.model` is a `String` with a model element name to convert from or to.
   *
   * @param definition The converter definition.
   */
  elementToElement(definition) {
    this.for("downcast").elementToElement(definition);
    for (const { model, view } of _getAllUpcastDefinitions(definition)) {
      this.for("upcast").elementToElement({
        model,
        view,
        converterPriority: definition.converterPriority
      });
    }
  }
  /**
   * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).
   * For example, a model text node with `"Foo"` as data and the `bold` attribute will be turned to `<strong>Foo</strong>` in the view.
   *
   * ```ts
   * // A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).
   * editor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );
   *
   * // Override other converters by specifying a converter definition with a higher priority.
   * editor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );
   *
   * // View specified as an object instead of a string.
   * editor.conversion.attributeToElement( {
   * 	model: 'bold',
   * 	view: {
   * 		name: 'span',
   * 		classes: 'bold'
   * 	}
   * } );
   *
   * // Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.
   * // The same attribute on different elements may then be handled by a different converter.
   * editor.conversion.attributeToElement( {
   * 	model: {
   * 		key: 'textDecoration',
   * 		values: [ 'underline', 'lineThrough' ],
   * 		name: '$text'
   * 	},
   * 	view: {
   * 		underline: {
   * 			name: 'span',
   * 			styles: {
   * 				'text-decoration': 'underline'
   * 			}
   * 		},
   * 		lineThrough: {
   * 			name: 'span',
   * 			styles: {
   * 				'text-decoration': 'line-through'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * // Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.
   * editor.conversion.attributeToElement( {
   * 	model: 'bold',
   * 	view: 'strong',
   * 	upcastAlso: [
   * 		'b',
   * 		{
   * 			name: 'span',
   * 			classes: 'bold'
   * 		},
   * 		{
   * 			name: 'span',
   * 			styles: {
   * 				'font-weight': 'bold'
   * 			}
   * 		},
   * 		viewElement => {
   * 			const fontWeight = viewElement.getStyle( 'font-weight' );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && fontWeight && /\d+/.test() && Number( fontWeight ) > 500 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return {
   * 					name: true,
   * 					styles: [ 'font-weight' ]
   * 				};
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).
   * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
   * editor.conversion.attributeToElement( {
   * 	model: {
   * 		key: 'fontSize',
   * 		values: [ 'big', 'small' ]
   * 	},
   * 	view: {
   * 		big: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '1.2em'
   * 			}
   * 		},
   * 		small: {
   * 			name: 'span',
   * 			styles: {
   * 				'font-size': '0.8em'
   * 			}
   * 		}
   * 	},
   * 	upcastAlso: {
   * 		big: viewElement => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 			if ( !fontSize ) {
   * 				return null;
   * 			}
   *
   * 			const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 			if ( !match ) {
   * 				return null;
   * 			}
   *
   * 			const size = Number( match[ 1 ] );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && size > 10 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return { name: true, styles: [ 'font-size' ] };
   * 			}
   *
   * 			return null;
   * 		},
   * 		small: viewElement => {
   * 			const fontSize = viewElement.getStyle( 'font-size' );
   *
   * 			if ( !fontSize ) {
   * 				return null;
   * 			}
   *
   * 			const match = fontSize.match( /(\d+)\s*px/ );
   *
   * 			if ( !match ) {
   * 				return null;
   * 			}
   *
   * 			const size = Number( match[ 1 ] );
   *
   * 			if ( viewElement.is( 'element', 'span' ) && size < 10 ) {
   * 				// Returned value can be an object with the matched properties.
   * 				// These properties will be "consumed" during the conversion.
   * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
   *
   * 				return { name: true, styles: [ 'font-size' ] };
   * 			}
   *
   * 			return null;
   * 		}
   * 	}
   * } );
   * ```
   *
   * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object
   * describing the attribute key and value to convert or a `String` specifying just the attribute key (in such a case
   * `value` is set to `true`).
   *
   * @param definition The converter definition.
   */
  attributeToElement(definition) {
    this.for("downcast").attributeToElement(definition);
    for (const { model, view } of _getAllUpcastDefinitions(definition)) {
      this.for("upcast").elementToAttribute({
        view,
        model,
        converterPriority: definition.converterPriority
      });
    }
  }
  /**
   * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa). For example,
   * `<imageBlock src='foo.jpg'></imageBlock>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).
   * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.
   * To convert the text attributes,
   * the {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}should be set up.
   *
   * ```ts
   * // A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).
   * editor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );
   *
   * // Attribute values are strictly specified.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'aside',
   * 		values: [ 'aside' ]
   * 	},
   * 	view: {
   * 		aside: {
   * 			name: 'img',
   * 			key: 'class',
   * 			value: [ 'aside', 'half-size' ]
   * 		}
   * 	}
   * } );
   *
   * // Set the style attribute.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		name: 'imageInline',
   * 		key: 'aside',
   * 		values: [ 'aside' ]
   * 	},
   * 	view: {
   * 		aside: {
   * 			name: 'img',
   * 			key: 'style',
   * 			value: {
   * 				float: 'right',
   * 				width: '50%',
   * 				margin: '5px'
   * 			}
   * 		}
   * 	}
   * } );
   *
   * // Conversion from and to a model attribute key whose value is an enum (`align=right|center`).
   * // Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.
   * editor.conversion.attributeToAttribute( {
   * 	model: {
   * 		key: 'align',
   * 		values: [ 'right', 'center' ]
   * 	},
   * 	view: {
   * 		right: {
   * 			key: 'class',
   * 			value: 'align-right'
   * 		},
   * 		center: {
   * 			key: 'class',
   * 			value: 'align-center'
   * 		}
   * 	},
   * 	upcastAlso: {
   * 		right: {
   * 			styles: {
   * 				'text-align': 'right'
   * 			}
   * 		},
   * 		center: {
   * 			styles: {
   * 				'text-align': 'center'
   * 			}
   * 		}
   * 	}
   * } );
   * ```
   *
   * The `definition.model` parameter specifies which model attribute should be converted from and to.
   * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.
   * The `key` property is the model attribute key to convert from and to.
   * The `values` are the possible model attribute values. If the `values` parameter is not set, the model attribute value
   * will be the same as the view attribute value.
   * If `name` is set, the conversion will be set up only for model elements with the given name.
   *
   * The `definition.view` parameter specifies which view attribute should be converted from and to.
   * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.
   * The `key` property is the view attribute key to convert from and to.
   * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be
   * the same as the model attribute value.
   * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.
   * If `key` is `'style'`, `value` is an object with key-value pairs.
   * In other cases, `value` is a `String`.
   * If `name` is set, the conversion will be set up only for model elements with the given name.
   * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`
   * to `{ key, value, [ name ] }` objects.
   *
   * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.
   * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`
   * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.
   *
   * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should
   * be given in both parameters.
   *
   * @param definition The converter definition.
   * @param definition.model The model attribute to convert from and to.
   * @param definition.view The view attribute to convert from and to.
   * @param definition.upcastAlso Any view element matching `definition.upcastAlso` will also be converted to the given model attribute.
   * `definition.upcastAlso` is used only if `config.model.values` is specified.
   */
  attributeToAttribute(definition) {
    this.for("downcast").attributeToAttribute(definition);
    for (const { model, view } of _getAllUpcastDefinitions(definition)) {
      this.for("upcast").attributeToAttribute({
        view,
        model
      });
    }
  }
  /**
   * Creates and caches conversion helpers for given dispatchers group.
   *
   * @param options.name Group name.
   */
  _createConversionHelpers({ name, dispatchers, isDowncast }) {
    if (this._helpers.has(name)) {
      throw new CKEditorError("conversion-group-exists", this);
    }
    const helpers = isDowncast ? new DowncastHelpers(dispatchers) : new UpcastHelpers(dispatchers);
    this._helpers.set(name, helpers);
  }
};
function* _getAllUpcastDefinitions(definition) {
  if (definition.model.values) {
    for (const value of definition.model.values) {
      const model = { key: definition.model.key, value };
      const view = definition.view[value];
      const upcastAlso = definition.upcastAlso ? definition.upcastAlso[value] : void 0;
      yield* _getUpcastDefinition(model, view, upcastAlso);
    }
  } else {
    yield* _getUpcastDefinition(definition.model, definition.view, definition.upcastAlso);
  }
}
function* _getUpcastDefinition(model, view, upcastAlso) {
  yield { model, view };
  if (upcastAlso) {
    for (const upcastAlsoItem of toArray(upcastAlso)) {
      yield { model, view: upcastAlsoItem };
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/xmldataprocessor.js
var XmlDataProcessor = class {
  /**
   * Creates a new instance of the XML data processor class.
   *
   * @param document The view document instance.
   * @param options Configuration options.
   * @param options.namespaces A list of namespaces allowed to use in the XML input.
   */
  constructor(document2, options = {}) {
    this.skipComments = true;
    this.namespaces = options.namespaces || [];
    this.domParser = new DOMParser();
    this.domConverter = new DomConverter(document2, { renderingMode: "data" });
    this.htmlWriter = new BasicHtmlWriter();
  }
  /**
   * Converts the provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
   * to data format &ndash; in this case an XML string.
   *
   * @returns An XML string.
   */
  toData(viewFragment) {
    const domFragment = this.domConverter.viewToDom(viewFragment);
    return this.htmlWriter.getHtml(domFragment);
  }
  /**
   * Converts the provided XML string to a view tree.
   *
   * @param data An XML string.
   * @returns A converted view element.
   */
  toView(data) {
    const domFragment = this._toDom(data);
    return this.domConverter.domToView(domFragment, {
      keepOriginalCase: true,
      skipComments: this.skipComments
    });
  }
  /**
   * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
   * and not processed during the conversion from XML to view elements.
   *
   * The raw data can be later accessed by a
   * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
   *
   * @param pattern Pattern matching all view elements whose content should be treated as raw data.
   */
  registerRawContentMatcher(pattern) {
    this.domConverter.registerRawContentMatcher(pattern);
  }
  /**
   * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
   * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
   *
   * This mode allows for a more precise handling of block fillers (so they do not leak into editor content) but
   * bloats the editor data with additional markup.
   *
   * This mode may be required by some features and will be turned on by them automatically.
   *
   * @param type Whether to use the default or the marked `&nbsp;` block fillers.
   */
  useFillerType(type) {
    this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
  }
  /**
   * Converts an XML string to its DOM representation. Returns a document fragment containing nodes parsed from
   * the provided data.
   */
  _toDom(data) {
    const namespaces = this.namespaces.map((nsp) => `xmlns:${nsp}="nsp"`).join(" ");
    data = `<xml ${namespaces}>${data}</xml>`;
    const parsedDocument = this.domParser.parseFromString(data, "text/xml");
    const parserError = parsedDocument.querySelector("parsererror");
    if (parserError) {
      throw new Error("Parse error - " + parserError.textContent);
    }
    const fragment = parsedDocument.createDocumentFragment();
    const nodes = parsedDocument.documentElement.childNodes;
    while (nodes.length > 0) {
      fragment.appendChild(nodes[0]);
    }
    return fragment;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/operation.js
var Operation = class {
  /**
   * Base operation constructor.
   *
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(baseVersion) {
    this.baseVersion = baseVersion;
    this.isDocumentOperation = this.baseVersion !== null;
    this.batch = null;
  }
  /**
   * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws
   * an error if operation is not valid.
   *
   * @internal
   */
  _validate() {
  }
  /**
   * Custom toJSON method to solve child-parent circular dependencies.
   *
   * @returns Clone of this object with the operation property replaced with string.
   */
  toJSON() {
    const json = Object.assign({}, this);
    json.__className = this.constructor.className;
    delete json.batch;
    delete json.isDocumentOperation;
    return json;
  }
  /**
   * Name of the operation class used for serialization.
   */
  static get className() {
    return "Operation";
  }
  /**
   * Creates `Operation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param doc Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    return new this(json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js
function _insert(position, nodes) {
  const normalizedNodes = _normalizeNodes(nodes);
  const offset = normalizedNodes.reduce((sum, node) => sum + node.offsetSize, 0);
  const parent = position.parent;
  _splitNodeAtPosition(position);
  const index = position.index;
  parent._insertChild(index, normalizedNodes);
  _mergeNodesAtIndex(parent, index + normalizedNodes.length);
  _mergeNodesAtIndex(parent, index);
  return new Range2(position, position.getShiftedBy(offset));
}
function _remove(range) {
  if (!range.isFlat) {
    throw new CKEditorError("operation-utils-remove-range-not-flat", this);
  }
  const parent = range.start.parent;
  _splitNodeAtPosition(range.start);
  _splitNodeAtPosition(range.end);
  const removed = parent._removeChildren(range.start.index, range.end.index - range.start.index);
  _mergeNodesAtIndex(parent, range.start.index);
  return removed;
}
function _move(sourceRange, targetPosition) {
  if (!sourceRange.isFlat) {
    throw new CKEditorError("operation-utils-move-range-not-flat", this);
  }
  const nodes = _remove(sourceRange);
  targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);
  return _insert(targetPosition, nodes);
}
function _setAttribute(range, key, value) {
  _splitNodeAtPosition(range.start);
  _splitNodeAtPosition(range.end);
  for (const item of range.getItems({ shallow: true })) {
    const node = item.is("$textProxy") ? item.textNode : item;
    if (value !== null) {
      node._setAttribute(key, value);
    } else {
      node._removeAttribute(key);
    }
    _mergeNodesAtIndex(node.parent, node.index);
  }
  _mergeNodesAtIndex(range.end.parent, range.end.index);
}
function _normalizeNodes(nodes) {
  const normalized = [];
  function convert2(nodes2) {
    if (typeof nodes2 == "string") {
      normalized.push(new Text2(nodes2));
    } else if (nodes2 instanceof TextProxy2) {
      normalized.push(new Text2(nodes2.data, nodes2.getAttributes()));
    } else if (nodes2 instanceof Node3) {
      normalized.push(nodes2);
    } else if (isIterable(nodes2)) {
      for (const node of nodes2) {
        convert2(node);
      }
    } else {
      const unreachable = nodes2;
    }
  }
  convert2(nodes);
  for (let i = 1; i < normalized.length; i++) {
    const node = normalized[i];
    const prev = normalized[i - 1];
    if (node instanceof Text2 && prev instanceof Text2 && _haveSameAttributes(node, prev)) {
      normalized.splice(i - 1, 2, new Text2(prev.data + node.data, prev.getAttributes()));
      i--;
    }
  }
  return normalized;
}
function _mergeNodesAtIndex(element, index) {
  const nodeBefore = element.getChild(index - 1);
  const nodeAfter = element.getChild(index);
  if (nodeBefore && nodeAfter && nodeBefore.is("$text") && nodeAfter.is("$text") && _haveSameAttributes(nodeBefore, nodeAfter)) {
    const mergedNode = new Text2(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes());
    element._removeChildren(index - 1, 2);
    element._insertChild(index - 1, mergedNode);
  }
}
function _splitNodeAtPosition(position) {
  const textNode = position.textNode;
  const element = position.parent;
  if (textNode) {
    const offsetDiff = position.offset - textNode.startOffset;
    const index = textNode.index;
    element._removeChildren(index, 1);
    const firstPart = new Text2(textNode.data.substr(0, offsetDiff), textNode.getAttributes());
    const secondPart = new Text2(textNode.data.substr(offsetDiff), textNode.getAttributes());
    element._insertChild(index, [firstPart, secondPart]);
  }
}
function _haveSameAttributes(nodeA, nodeB) {
  const iteratorA = nodeA.getAttributes();
  const iteratorB = nodeB.getAttributes();
  for (const attr of iteratorA) {
    if (attr[1] !== nodeB.getAttribute(attr[0])) {
      return false;
    }
    iteratorB.next();
  }
  return iteratorB.next().done;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/moveoperation.js
var MoveOperation = class _MoveOperation extends Operation {
  /**
   * Creates a move operation.
   *
   * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
   * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
   * `sourcePosition` with offset shifted by `howMany`.
   * @param targetPosition Position at which moved nodes will be inserted.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(sourcePosition, howMany, targetPosition, baseVersion) {
    super(baseVersion);
    this.sourcePosition = sourcePosition.clone();
    this.sourcePosition.stickiness = "toNext";
    this.howMany = howMany;
    this.targetPosition = targetPosition.clone();
    this.targetPosition.stickiness = "toNone";
  }
  /**
   * @inheritDoc
   */
  get type() {
    if (this.targetPosition.root.rootName == "$graveyard") {
      return "remove";
    } else if (this.sourcePosition.root.rootName == "$graveyard") {
      return "reinsert";
    }
    return "move";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return [
      Range2._createFromPositionAndShift(this.sourcePosition, this.howMany),
      Range2._createFromPositionAndShift(this.targetPosition, 0)
    ];
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new _MoveOperation(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
  }
  /**
   * Returns the start position of the moved range after it got moved. This may be different than
   * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
   * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
   * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
   *
   * ```
   *  vv              vv
   * abcdefg ===> adefbcg
   *      ^          ^
   *      targetPos  movedRangeStart
   *      offset 6   offset 4
   *```
   */
  getMovedRangeStart() {
    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const newTargetPosition = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
    return new _MoveOperation(this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const sourceElement = this.sourcePosition.parent;
    const targetElement = this.targetPosition.parent;
    const sourceOffset = this.sourcePosition.offset;
    const targetOffset = this.targetPosition.offset;
    if (sourceOffset + this.howMany > sourceElement.maxOffset) {
      throw new CKEditorError("move-operation-nodes-do-not-exist", this);
    } else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {
      throw new CKEditorError("move-operation-range-into-itself", this);
    } else if (this.sourcePosition.root == this.targetPosition.root) {
      if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
        const i = this.sourcePosition.path.length - 1;
        if (this.targetPosition.path[i] >= sourceOffset && this.targetPosition.path[i] < sourceOffset + this.howMany) {
          throw new CKEditorError("move-operation-node-into-itself", this);
        }
      }
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    _move(Range2._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = this.sourcePosition.toJSON();
    json.targetPosition = this.targetPosition.toJSON();
    return json;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MoveOperation";
  }
  /**
   * Creates `MoveOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    const sourcePosition = Position2.fromJSON(json.sourcePosition, document2);
    const targetPosition = Position2.fromJSON(json.targetPosition, document2);
    return new this(sourcePosition, json.howMany, targetPosition, json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/insertoperation.js
var InsertOperation = class _InsertOperation extends Operation {
  /**
   * Creates an insert operation.
   *
   * @param position Position of insertion.
   * @param nodes The list of nodes to be inserted.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(position, nodes, baseVersion) {
    super(baseVersion);
    this.position = position.clone();
    this.position.stickiness = "toNone";
    this.nodes = new NodeList(_normalizeNodes(nodes));
    this.shouldReceiveAttributes = false;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "insert";
  }
  /**
   * Total offset size of inserted nodes.
   */
  get howMany() {
    return this.nodes.maxOffset;
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this.position.clone();
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    const nodes = new NodeList([...this.nodes].map((node) => node._clone(true)));
    const insert = new _InsertOperation(this.position, nodes, this.baseVersion);
    insert.shouldReceiveAttributes = this.shouldReceiveAttributes;
    return insert;
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const graveyard = this.position.root.document.graveyard;
    const gyPosition = new Position2(graveyard, [0]);
    return new MoveOperation(this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const targetElement = this.position.parent;
    if (!targetElement || targetElement.maxOffset < this.position.offset) {
      throw new CKEditorError("insert-operation-position-invalid", this);
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const originalNodes = this.nodes;
    this.nodes = new NodeList([...originalNodes].map((node) => node._clone(true)));
    _insert(this.position, originalNodes);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    json.position = this.position.toJSON();
    json.nodes = this.nodes.toJSON();
    return json;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "InsertOperation";
  }
  /**
   * Creates `InsertOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    const children = [];
    for (const child of json.nodes) {
      if (child.name) {
        children.push(Element2.fromJSON(child));
      } else {
        children.push(Text2.fromJSON(child));
      }
    }
    const insert = new _InsertOperation(Position2.fromJSON(json.position, document2), children, json.baseVersion);
    insert.shouldReceiveAttributes = json.shouldReceiveAttributes;
    return insert;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/splitoperation.js
var SplitOperation = class _SplitOperation extends Operation {
  /**
   * Creates a split operation.
   *
   * @param splitPosition Position at which an element should be split.
   * @param howMany Total offset size of elements that are in the split element after `position`.
   * @param insertionPosition Position at which the clone of split element (or element from graveyard) will be inserted.
   * @param graveyardPosition Position in the graveyard root before the element which
   * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {
    super(baseVersion);
    this.splitPosition = splitPosition.clone();
    this.splitPosition.stickiness = "toNext";
    this.howMany = howMany;
    this.insertionPosition = insertionPosition;
    this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;
    if (this.graveyardPosition) {
      this.graveyardPosition.stickiness = "toNext";
    }
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "split";
  }
  /**
   * Position inside the new clone of a split element.
   *
   * This is a position where nodes that are after the split position will be moved to.
   */
  get moveTargetPosition() {
    const path = this.insertionPosition.path.slice();
    path.push(0);
    return new Position2(this.insertionPosition.root, path);
  }
  /**
   * Artificial range that contains all the nodes from the split element that will be moved to the new element.
   * The range starts at {@link #splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
   */
  get movedRange() {
    const end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new Range2(this.splitPosition, end);
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    const ranges = [
      Range2._createFromPositionAndShift(this.splitPosition, 0),
      Range2._createFromPositionAndShift(this.insertionPosition, 0)
    ];
    if (this.graveyardPosition) {
      ranges.push(Range2._createFromPositionAndShift(this.graveyardPosition, 0));
    }
    return ranges;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new _SplitOperation(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const graveyard = this.splitPosition.root.document.graveyard;
    const graveyardPosition = new Position2(graveyard, [0]);
    return new MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const element = this.splitPosition.parent;
    const offset = this.splitPosition.offset;
    if (!element || element.maxOffset < offset) {
      throw new CKEditorError("split-operation-position-invalid", this);
    } else if (!element.parent) {
      throw new CKEditorError("split-operation-split-in-root", this);
    } else if (this.howMany != element.maxOffset - this.splitPosition.offset) {
      throw new CKEditorError("split-operation-how-many-invalid", this);
    } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
      throw new CKEditorError("split-operation-graveyard-position-invalid", this);
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const splitElement = this.splitPosition.parent;
    if (this.graveyardPosition) {
      _move(Range2._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
    } else {
      const newElement = splitElement._clone();
      _insert(this.insertionPosition, newElement);
    }
    const sourceRange = new Range2(Position2._createAt(splitElement, this.splitPosition.offset), Position2._createAt(splitElement, splitElement.maxOffset));
    _move(sourceRange, this.moveTargetPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    json.splitPosition = this.splitPosition.toJSON();
    json.insertionPosition = this.insertionPosition.toJSON();
    if (this.graveyardPosition) {
      json.graveyardPosition = this.graveyardPosition.toJSON();
    }
    return json;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "SplitOperation";
  }
  /**
   * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion
   * position is after the split element.
   */
  static getInsertionPosition(splitPosition) {
    const path = splitPosition.path.slice(0, -1);
    path[path.length - 1]++;
    return new Position2(splitPosition.root, path, "toPrevious");
  }
  /**
   * Creates `SplitOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    const splitPosition = Position2.fromJSON(json.splitPosition, document2);
    const insertionPosition = Position2.fromJSON(json.insertionPosition, document2);
    const graveyardPosition = json.graveyardPosition ? Position2.fromJSON(json.graveyardPosition, document2) : null;
    return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/mergeoperation.js
var MergeOperation = class _MergeOperation extends Operation {
  /**
   * Creates a merge operation.
   *
   * @param sourcePosition Position inside the merged element. All nodes from that
   * element after that position will be moved to {@link #targetPosition}.
   * @param howMany Summary offset size of nodes which will be moved from the merged element to the new parent.
   * @param targetPosition Position which the nodes from the merged elements will be moved to.
   * @param graveyardPosition Position in graveyard to which the merged element will be moved.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {
    super(baseVersion);
    this.sourcePosition = sourcePosition.clone();
    this.sourcePosition.stickiness = "toPrevious";
    this.howMany = howMany;
    this.targetPosition = targetPosition.clone();
    this.targetPosition.stickiness = "toNext";
    this.graveyardPosition = graveyardPosition.clone();
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "merge";
  }
  /**
   * Position before the merged element (which will be deleted).
   */
  get deletionPosition() {
    return new Position2(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
  }
  /**
   * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.
   * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
   */
  get movedRange() {
    const end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new Range2(this.sourcePosition, end);
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    const mergedElement = this.sourcePosition.parent;
    return [
      Range2._createOn(mergedElement),
      // These could be positions but `Selectable` type only supports `Iterable<Range>`.
      Range2._createFromPositionAndShift(this.targetPosition, 0),
      Range2._createFromPositionAndShift(this.graveyardPosition, 0)
    ];
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new _MergeOperation(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    const targetPosition = this.targetPosition._getTransformedByMergeOperation(this);
    const path = this.sourcePosition.path.slice(0, -1);
    const insertionPosition = new Position2(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);
    return new SplitOperation(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const sourceElement = this.sourcePosition.parent;
    const targetElement = this.targetPosition.parent;
    if (!sourceElement.parent) {
      throw new CKEditorError("merge-operation-source-position-invalid", this);
    } else if (!targetElement.parent) {
      throw new CKEditorError("merge-operation-target-position-invalid", this);
    } else if (this.howMany != sourceElement.maxOffset) {
      throw new CKEditorError("merge-operation-how-many-invalid", this);
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const mergedElement = this.sourcePosition.parent;
    const sourceRange = Range2._createIn(mergedElement);
    _move(sourceRange, this.targetPosition);
    _move(Range2._createOn(mergedElement), this.graveyardPosition);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = json.sourcePosition.toJSON();
    json.targetPosition = json.targetPosition.toJSON();
    json.graveyardPosition = json.graveyardPosition.toJSON();
    return json;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MergeOperation";
  }
  /**
   * Creates `MergeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    const sourcePosition = Position2.fromJSON(json.sourcePosition, document2);
    const targetPosition = Position2.fromJSON(json.targetPosition, document2);
    const graveyardPosition = Position2.fromJSON(json.graveyardPosition, document2);
    return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/markeroperation.js
var MarkerOperation = class _MarkerOperation extends Operation {
  /**
   * @param name Marker name.
   * @param oldRange Marker range before the change.
   * @param newRange Marker range after the change.
   * @param markers Marker collection on which change should be executed.
   * @param affectsData Specifies whether the marker operation affects the data produced by the data pipeline
   * (is persisted in the editor's data).
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(name, oldRange, newRange, markers, affectsData, baseVersion) {
    super(baseVersion);
    this.name = name;
    this.oldRange = oldRange ? oldRange.clone() : null;
    this.newRange = newRange ? newRange.clone() : null;
    this.affectsData = affectsData;
    this._markers = markers;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "marker";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    const ranges = [];
    if (this.oldRange) {
      ranges.push(this.oldRange.clone());
    }
    if (this.newRange) {
      if (this.oldRange) {
        ranges.push(...this.newRange.getDifference(this.oldRange));
      } else {
        ranges.push(this.newRange.clone());
      }
    }
    return ranges;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new _MarkerOperation(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new _MarkerOperation(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    if (this.newRange) {
      this._markers._set(this.name, this.newRange, true, this.affectsData);
    } else {
      this._markers._remove(this.name);
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  toJSON() {
    const json = super.toJSON();
    if (this.oldRange) {
      json.oldRange = this.oldRange.toJSON();
    }
    if (this.newRange) {
      json.newRange = this.newRange.toJSON();
    }
    delete json._markers;
    return json;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "MarkerOperation";
  }
  /**
   * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    return new _MarkerOperation(json.name, json.oldRange ? Range2.fromJSON(json.oldRange, document2) : null, json.newRange ? Range2.fromJSON(json.newRange, document2) : null, document2.model.markers, json.affectsData, json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/attributeoperation.js
var AttributeOperation = class _AttributeOperation extends Operation {
  /**
   * Creates an operation that changes, removes or adds attributes.
   *
   * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
   * have an attribute with the same key as the added attribute.
   *
   * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
   * must have an attribute with that key added.
   *
   * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
   * operation's ranges must already have an attribute with given key and `oldValue` as value
   *
   * @param range Range on which the operation should be applied. Must be a flat range.
   * @param key Key of an attribute to change or remove.
   * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
   * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(range, key, oldValue, newValue, baseVersion) {
    super(baseVersion);
    this.range = range.clone();
    this.key = key;
    this.oldValue = oldValue === void 0 ? null : oldValue;
    this.newValue = newValue === void 0 ? null : newValue;
  }
  /**
   * @inheritDoc
   */
  get type() {
    if (this.oldValue === null) {
      return "addAttribute";
    } else if (this.newValue === null) {
      return "removeAttribute";
    } else {
      return "changeAttribute";
    }
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this.range.clone();
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new _AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new _AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    json.range = this.range.toJSON();
    return json;
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (!this.range.isFlat) {
      throw new CKEditorError("attribute-operation-range-not-flat", this);
    }
    for (const item of this.range.getItems({ shallow: true })) {
      if (this.oldValue !== null && !isEqual_default(item.getAttribute(this.key), this.oldValue)) {
        throw new CKEditorError("attribute-operation-wrong-old-value", this, { item, key: this.key, value: this.oldValue });
      }
      if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {
        throw new CKEditorError("attribute-operation-attribute-exists", this, { node: item, key: this.key });
      }
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    if (!isEqual_default(this.oldValue, this.newValue)) {
      _setAttribute(this.range, this.key, this.newValue);
    }
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "AttributeOperation";
  }
  /**
   * Creates `AttributeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    return new _AttributeOperation(Range2.fromJSON(json.range, document2), json.key, json.oldValue, json.newValue, json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/nooperation.js
var NoOperation = class _NoOperation extends Operation {
  get type() {
    return "noop";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return null;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   */
  clone() {
    return new _NoOperation(this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new _NoOperation(this.baseVersion + 1);
  }
  /** @internal */
  _execute() {
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "NoOperation";
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/renameoperation.js
var RenameOperation = class _RenameOperation extends Operation {
  /**
   * Creates an operation that changes element's name.
   *
   * @param position Position before an element to change.
   * @param oldName Current name of the element.
   * @param newName New name for the element.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(position, oldName, newName, baseVersion) {
    super(baseVersion);
    this.position = position;
    this.position.stickiness = "toNext";
    this.oldName = oldName;
    this.newName = newName;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "rename";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this.position.nodeAfter;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new _RenameOperation(this.position.clone(), this.oldName, this.newName, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new _RenameOperation(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    const element = this.position.nodeAfter;
    if (!(element instanceof Element2)) {
      throw new CKEditorError("rename-operation-wrong-position", this);
    } else if (element.name !== this.oldName) {
      throw new CKEditorError("rename-operation-wrong-name", this);
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    const element = this.position.nodeAfter;
    element.name = this.newName;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    json.position = this.position.toJSON();
    return json;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RenameOperation";
  }
  /**
   * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    return new _RenameOperation(Position2.fromJSON(json.position, document2), json.oldName, json.newName, json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/rootattributeoperation.js
var RootAttributeOperation = class _RootAttributeOperation extends Operation {
  /**
   * Creates an operation that changes, removes or adds attributes on root element.
   *
   * @see module:engine/model/operation/attributeoperation~AttributeOperation
   * @param root Root element to change.
   * @param key Key of an attribute to change or remove.
   * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
   * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  constructor(root, key, oldValue, newValue, baseVersion) {
    super(baseVersion);
    this.root = root;
    this.key = key;
    this.oldValue = oldValue === void 0 ? null : oldValue;
    this.newValue = newValue === void 0 ? null : newValue;
  }
  /**
   * @inheritDoc
   */
  get type() {
    if (this.oldValue === null) {
      return "addRootAttribute";
    } else if (this.newValue === null) {
      return "removeRootAttribute";
    } else {
      return "changeRootAttribute";
    }
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this.root;
  }
  /**
   * Creates and returns an operation that has the same parameters as this operation.
   *
   * @returns Clone of this operation.
   */
  clone() {
    return new _RootAttributeOperation(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  /**
   * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
   */
  getReversed() {
    return new _RootAttributeOperation(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (this.root != this.root.root || this.root.is("documentFragment")) {
      throw new CKEditorError("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
    }
    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
      throw new CKEditorError("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
    }
    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
      throw new CKEditorError("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    if (this.newValue !== null) {
      this.root._setAttribute(this.key, this.newValue);
    } else {
      this.root._removeAttribute(this.key);
    }
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    json.root = this.root.toJSON();
    return json;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RootAttributeOperation";
  }
  /**
   * Creates `RootAttributeOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    if (!document2.getRoot(json.root)) {
      throw new CKEditorError("rootattribute-operation-fromjson-no-root", this, { rootName: json.root });
    }
    return new _RootAttributeOperation(document2.getRoot(json.root), json.key, json.oldValue, json.newValue, json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/rootoperation.js
var RootOperation = class _RootOperation extends Operation {
  /**
   * Creates an operation that creates or removes a root element.
   *
   * @param rootName Root name to create or detach.
   * @param elementName Root element name.
   * @param isAdd Specifies whether the operation adds (`true`) or detaches the root (`false`).
   * @param document Document which owns the root.
   * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation can be applied.
   */
  constructor(rootName, elementName, isAdd, document2, baseVersion) {
    super(baseVersion);
    this.rootName = rootName;
    this.elementName = elementName;
    this.isAdd = isAdd;
    this._document = document2;
    if (!this._document.getRoot(this.rootName)) {
      const root = this._document.createRoot(this.elementName, this.rootName);
      root._isAttached = false;
    }
  }
  /**
   * @inheritDoc
   */
  get type() {
    return this.isAdd ? "addRoot" : "detachRoot";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return this._document.getRoot(this.rootName);
  }
  /**
   * @inheritDoc
   */
  clone() {
    return new _RootOperation(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
  }
  /**
   * @inheritDoc
   */
  getReversed() {
    return new _RootOperation(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
  }
  /**
   * @inheritDoc
   */
  _execute() {
    this._document.getRoot(this.rootName)._isAttached = this.isAdd;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    delete json._document;
    return json;
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "RootOperation";
  }
  /**
   * Creates `RootOperation` object from deserialized object, i.e. from parsed JSON string.
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    return new _RootOperation(json.rootName, json.elementName, json.isAdd, document2, json.baseVersion);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/operationfactory.js
var operations = {};
operations[AttributeOperation.className] = AttributeOperation;
operations[InsertOperation.className] = InsertOperation;
operations[MarkerOperation.className] = MarkerOperation;
operations[MoveOperation.className] = MoveOperation;
operations[NoOperation.className] = NoOperation;
operations[Operation.className] = Operation;
operations[RenameOperation.className] = RenameOperation;
operations[RootAttributeOperation.className] = RootAttributeOperation;
operations[RootOperation.className] = RootOperation;
operations[SplitOperation.className] = SplitOperation;
operations[MergeOperation.className] = MergeOperation;
var OperationFactory = class {
  /**
   * Creates an operation instance from a JSON object (parsed JSON string).
   *
   * @param json Deserialized JSON object.
   * @param document Document on which this operation will be applied.
   */
  static fromJSON(json, document2) {
    return operations[json.__className].fromJSON(json, document2);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js
var transformations = /* @__PURE__ */ new Map();
function setTransformation(OperationA, OperationB, transformationFunction) {
  let aGroup = transformations.get(OperationA);
  if (!aGroup) {
    aGroup = /* @__PURE__ */ new Map();
    transformations.set(OperationA, aGroup);
  }
  aGroup.set(OperationB, transformationFunction);
}
function getTransformation(OperationA, OperationB) {
  const aGroup = transformations.get(OperationA);
  if (aGroup && aGroup.has(OperationB)) {
    return aGroup.get(OperationB);
  }
  return noUpdateTransformation;
}
function noUpdateTransformation(a) {
  return [a];
}
function transform2(a, b, context = {}) {
  const transformationFunction = getTransformation(a.constructor, b.constructor);
  try {
    a = a.clone();
    return transformationFunction(a, b, context);
  } catch (e) {
    throw e;
  }
}
function transformSets(operationsA, operationsB, options) {
  operationsA = operationsA.slice();
  operationsB = operationsB.slice();
  const contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);
  contextFactory.setOriginalOperations(operationsA);
  contextFactory.setOriginalOperations(operationsB);
  const originalOperations = contextFactory.originalOperations;
  if (operationsA.length == 0 || operationsB.length == 0) {
    return { operationsA, operationsB, originalOperations };
  }
  const nextTransformIndex = /* @__PURE__ */ new WeakMap();
  for (const op of operationsA) {
    nextTransformIndex.set(op, 0);
  }
  const data = {
    nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,
    nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,
    originalOperationsACount: operationsA.length,
    originalOperationsBCount: operationsB.length
  };
  let i = 0;
  while (i < operationsA.length) {
    const opA = operationsA[i];
    const indexB = nextTransformIndex.get(opA);
    if (indexB == operationsB.length) {
      i++;
      continue;
    }
    const opB = operationsB[indexB];
    const newOpsA = transform2(opA, opB, contextFactory.getContext(opA, opB, true));
    const newOpsB = transform2(opB, opA, contextFactory.getContext(opB, opA, false));
    contextFactory.updateRelation(opA, opB);
    contextFactory.setOriginalOperations(newOpsA, opA);
    contextFactory.setOriginalOperations(newOpsB, opB);
    for (const newOpA of newOpsA) {
      nextTransformIndex.set(newOpA, indexB + newOpsB.length);
    }
    operationsA.splice(i, 1, ...newOpsA);
    operationsB.splice(indexB, 1, ...newOpsB);
  }
  handlePartialMarkerOperations(operationsA);
  handlePartialMarkerOperations(operationsB);
  if (options.padWithNoOps) {
    const brokenOperationsACount = operationsA.length - data.originalOperationsACount;
    const brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;
    padWithNoOps(operationsA, brokenOperationsBCount - brokenOperationsACount);
    padWithNoOps(operationsB, brokenOperationsACount - brokenOperationsBCount);
  }
  updateBaseVersions(operationsA, data.nextBaseVersionB);
  updateBaseVersions(operationsB, data.nextBaseVersionA);
  return { operationsA, operationsB, originalOperations };
}
var ContextFactory = class {
  /**
   * Creates `ContextFactory` instance.
   *
   * @param document Document which the operations change.
   * @param useRelations Whether during transformation relations should be used (used during undo for
   * better conflict resolution).
   * @param forceWeakRemove If set to `false`, remove operation will be always stronger than move operation,
   * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.
   */
  constructor(document2, useRelations, forceWeakRemove = false) {
    this.originalOperations = /* @__PURE__ */ new Map();
    this._history = document2.history;
    this._useRelations = useRelations;
    this._forceWeakRemove = !!forceWeakRemove;
    this._relations = /* @__PURE__ */ new Map();
  }
  /**
   * Sets "original operation" for given operations.
   *
   * During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two
   * or multiple operations. When gathering additional data it is important that all operations can be somehow linked
   * so a cloned and transformed "version" still kept track of the data assigned earlier to it.
   *
   * The original operation object will be used as such an universal linking id. Throughout the transformation process
   * all cloned operations will refer to "the original operation" when storing and reading additional data.
   *
   * If `takeFrom` is not set, each operation from `operations` array will be assigned itself as "the original operation".
   * This should be used as an initialization step.
   *
   * If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned
   * for `takeFrom` operation. This should be used to update original operations. It should be used in a way that
   * `operations` are the result of `takeFrom` transformation to ensure proper "original operation propagation".
   */
  setOriginalOperations(operations2, takeFrom = null) {
    const originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;
    for (const operation of operations2) {
      this.originalOperations.set(operation, originalOperation || operation);
    }
  }
  /**
   * Saves a relation between operations `opA` and `opB`.
   *
   * Relations are then later used to help solve conflicts when operations are transformed.
   */
  updateRelation(opA, opB) {
    if (opA instanceof MoveOperation) {
      if (opB instanceof MergeOperation) {
        if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {
          this._setRelation(opA, opB, "insertAtSource");
        } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {
          this._setRelation(opA, opB, "insertBetween");
        } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {
          this._setRelation(opA, opB, "moveTargetAfter");
        }
      } else if (opB instanceof MoveOperation) {
        if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "insertBefore");
        } else {
          this._setRelation(opA, opB, "insertAfter");
        }
      }
    } else if (opA instanceof SplitOperation) {
      if (opB instanceof MergeOperation) {
        if (opA.splitPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "splitBefore");
        }
      } else if (opB instanceof MoveOperation) {
        if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "splitBefore");
        } else {
          const range = Range2._createFromPositionAndShift(opB.sourcePosition, opB.howMany);
          if (opA.splitPosition.hasSameParentAs(opB.sourcePosition) && range.containsPosition(opA.splitPosition)) {
            const howMany = range.end.offset - opA.splitPosition.offset;
            const offset = opA.splitPosition.offset - range.start.offset;
            this._setRelation(opA, opB, { howMany, offset });
          }
        }
      }
    } else if (opA instanceof MergeOperation) {
      if (opB instanceof MergeOperation) {
        if (!opA.targetPosition.isEqual(opB.sourcePosition)) {
          this._setRelation(opA, opB, "mergeTargetNotMoved");
        }
        if (opA.sourcePosition.isEqual(opB.targetPosition)) {
          this._setRelation(opA, opB, "mergeSourceNotMoved");
        }
        if (opA.sourcePosition.isEqual(opB.sourcePosition)) {
          this._setRelation(opA, opB, "mergeSameElement");
        }
      } else if (opB instanceof SplitOperation) {
        if (opA.sourcePosition.isEqual(opB.splitPosition)) {
          this._setRelation(opA, opB, "splitAtSource");
        }
      } else if (opB instanceof MoveOperation && opB.howMany > 0) {
        if (opA.sourcePosition.isEqual(opB.sourcePosition.getShiftedBy(opB.howMany))) {
          this._setRelation(opA, opB, "mergeSourceAffected");
        }
        if (opA.targetPosition.isEqual(opB.sourcePosition)) {
          this._setRelation(opA, opB, "mergeTargetWasBefore");
        }
      }
    } else if (opA instanceof MarkerOperation) {
      const markerRange = opA.newRange;
      if (!markerRange) {
        return;
      }
      if (opB instanceof MergeOperation) {
        const wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);
        const wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);
        const wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);
        const wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);
        if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {
          this._setRelation(opA, opB, {
            wasInLeftElement,
            wasStartBeforeMergedElement,
            wasEndBeforeMergedElement,
            wasInRightElement
          });
        }
      }
    }
  }
  /**
   * Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.
   */
  getContext(opA, opB, aIsStrong) {
    return {
      aIsStrong,
      aWasUndone: this._wasUndone(opA),
      bWasUndone: this._wasUndone(opB),
      abRelation: this._useRelations ? this._getRelation(opA, opB) : null,
      baRelation: this._useRelations ? this._getRelation(opB, opA) : null,
      forceWeakRemove: this._forceWeakRemove
    };
  }
  /**
   * Returns whether given operation `op` has already been undone.
   *
   * Information whether an operation was undone gives more context when making a decision when two operations are in conflict.
   */
  _wasUndone(op) {
    const originalOp = this.originalOperations.get(op);
    return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);
  }
  /**
   * Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation
   * was set earlier or `null` if there was no relation between those operations.
   *
   * This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.
   *
   * When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the
   * undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,
   * we look forward in the future and ask if in that future `opB` was undone.
   *
   * Relations is a backward process to `wasUndone()`.
   *
   * Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing
   * operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is
   * a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation
   * between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make
   * a better decision when resolving a conflict between two operations, because we know more about the context of
   * those two operations.
   *
   * This is why this function does not return a relation directly between `opA` and `opB` because we need to look
   * back to search for a meaningful contextual information.
   */
  _getRelation(opA, opB) {
    const origB = this.originalOperations.get(opB);
    const undoneB = this._history.getUndoneOperation(origB);
    if (!undoneB) {
      return null;
    }
    const origA = this.originalOperations.get(opA);
    const relationsA = this._relations.get(origA);
    if (relationsA) {
      return relationsA.get(undoneB) || null;
    }
    return null;
  }
  /**
   * Helper function for `ContextFactory#updateRelations`.
   */
  _setRelation(opA, opB, relation) {
    const origA = this.originalOperations.get(opA);
    const origB = this.originalOperations.get(opB);
    let relationsA = this._relations.get(origA);
    if (!relationsA) {
      relationsA = /* @__PURE__ */ new Map();
      this._relations.set(origA, relationsA);
    }
    relationsA.set(origB, relation);
  }
};
function updateBaseVersions(operations2, baseVersion) {
  for (const operation of operations2) {
    operation.baseVersion = baseVersion++;
  }
}
function padWithNoOps(operations2, howMany) {
  for (let i = 0; i < howMany; i++) {
    operations2.push(new NoOperation(0));
  }
}
function handlePartialMarkerOperations(operations2) {
  const markerOps = /* @__PURE__ */ new Map();
  for (let i = 0; i < operations2.length; i++) {
    const op = operations2[i];
    if (!(op instanceof MarkerOperation)) {
      continue;
    }
    if (op.baseVersion !== -1) {
      markerOps.set(op.name, {
        op,
        ranges: op.newRange ? [op.newRange] : []
      });
    } else {
      if (op.newRange) {
        markerOps.get(op.name).ranges.push(op.newRange);
      }
      operations2.splice(i, 1);
      i--;
    }
  }
  for (const { op, ranges } of markerOps.values()) {
    if (ranges.length) {
      op.newRange = Range2._createFromRanges(ranges);
    } else {
      op.newRange = null;
    }
  }
}
setTransformation(AttributeOperation, AttributeOperation, (a, b, context) => {
  if (a.key === b.key && a.range.start.hasSameParentAs(b.range.start)) {
    const operations2 = a.range.getDifference(b.range).map((range) => {
      return new AttributeOperation(range, a.key, a.oldValue, a.newValue, 0);
    });
    const common = a.range.getIntersection(b.range);
    if (common) {
      if (context.aIsStrong) {
        operations2.push(new AttributeOperation(common, b.key, b.newValue, a.newValue, 0));
      }
    }
    if (operations2.length == 0) {
      return [new NoOperation(0)];
    }
    return operations2;
  } else {
    return [a];
  }
});
setTransformation(AttributeOperation, InsertOperation, (a, b) => {
  if (a.range.start.hasSameParentAs(b.position) && a.range.containsPosition(b.position)) {
    const range = a.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);
    const result = range.map((r) => {
      return new AttributeOperation(r, a.key, a.oldValue, a.newValue, a.baseVersion);
    });
    if (b.shouldReceiveAttributes) {
      const op = _getComplementaryAttributeOperations(b, a.key, a.oldValue);
      if (op) {
        result.unshift(op);
      }
    }
    return result;
  }
  a.range = a.range._getTransformedByInsertion(b.position, b.howMany, false)[0];
  return [a];
});
function _getComplementaryAttributeOperations(insertOperation, key, newValue) {
  const nodes = insertOperation.nodes;
  const insertValue = nodes.getNode(0).getAttribute(key);
  if (insertValue == newValue) {
    return null;
  }
  const range = new Range2(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));
  return new AttributeOperation(range, key, insertValue, newValue, 0);
}
setTransformation(AttributeOperation, MergeOperation, (a, b) => {
  const ranges = [];
  if (a.range.start.hasSameParentAs(b.deletionPosition)) {
    if (a.range.containsPosition(b.deletionPosition) || a.range.start.isEqual(b.deletionPosition)) {
      ranges.push(Range2._createFromPositionAndShift(b.graveyardPosition, 1));
    }
  }
  const range = a.range._getTransformedByMergeOperation(b);
  if (!range.isCollapsed) {
    ranges.push(range);
  }
  return ranges.map((range2) => {
    return new AttributeOperation(range2, a.key, a.oldValue, a.newValue, a.baseVersion);
  });
});
setTransformation(AttributeOperation, MoveOperation, (a, b) => {
  const ranges = _breakRangeByMoveOperation(a.range, b);
  return ranges.map((range) => new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion));
});
function _breakRangeByMoveOperation(range, moveOp) {
  const moveRange = Range2._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany);
  let common = null;
  let difference = [];
  if (moveRange.containsRange(range, true)) {
    common = range;
  } else if (range.start.hasSameParentAs(moveRange.start)) {
    difference = range.getDifference(moveRange);
    common = range.getIntersection(moveRange);
  } else {
    difference = [range];
  }
  const result = [];
  for (let diff2 of difference) {
    diff2 = diff2._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany);
    const targetPosition = moveOp.getMovedRangeStart();
    const spread = diff2.start.hasSameParentAs(targetPosition);
    const diffs = diff2._getTransformedByInsertion(targetPosition, moveOp.howMany, spread);
    result.push(...diffs);
  }
  if (common) {
    result.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);
  }
  return result;
}
setTransformation(AttributeOperation, SplitOperation, (a, b) => {
  if (a.range.end.isEqual(b.insertionPosition)) {
    if (!b.graveyardPosition) {
      a.range.end.offset++;
    }
    return [a];
  }
  if (a.range.start.hasSameParentAs(b.splitPosition) && a.range.containsPosition(b.splitPosition)) {
    const secondPart = a.clone();
    secondPart.range = new Range2(b.moveTargetPosition.clone(), a.range.end._getCombined(b.splitPosition, b.moveTargetPosition));
    a.range.end = b.splitPosition.clone();
    a.range.end.stickiness = "toPrevious";
    return [a, secondPart];
  }
  a.range = a.range._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(InsertOperation, AttributeOperation, (a, b) => {
  const result = [a];
  if (a.shouldReceiveAttributes && a.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a.position)) {
    const op = _getComplementaryAttributeOperations(a, b.key, b.newValue);
    if (op) {
      result.push(op);
    }
  }
  return result;
});
setTransformation(InsertOperation, InsertOperation, (a, b, context) => {
  if (a.position.isEqual(b.position) && context.aIsStrong) {
    return [a];
  }
  a.position = a.position._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(InsertOperation, MoveOperation, (a, b) => {
  a.position = a.position._getTransformedByMoveOperation(b);
  return [a];
});
setTransformation(InsertOperation, SplitOperation, (a, b) => {
  a.position = a.position._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(InsertOperation, MergeOperation, (a, b) => {
  a.position = a.position._getTransformedByMergeOperation(b);
  return [a];
});
setTransformation(MarkerOperation, InsertOperation, (a, b) => {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedByInsertOperation(b)[0];
  }
  if (a.newRange) {
    a.newRange = a.newRange._getTransformedByInsertOperation(b)[0];
  }
  return [a];
});
setTransformation(MarkerOperation, MarkerOperation, (a, b, context) => {
  if (a.name == b.name) {
    if (context.aIsStrong) {
      a.oldRange = b.newRange ? b.newRange.clone() : null;
    } else {
      return [new NoOperation(0)];
    }
  }
  return [a];
});
setTransformation(MarkerOperation, MergeOperation, (a, b) => {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedByMergeOperation(b);
  }
  if (a.newRange) {
    a.newRange = a.newRange._getTransformedByMergeOperation(b);
  }
  return [a];
});
setTransformation(MarkerOperation, MoveOperation, (a, b) => {
  const result = [a];
  if (a.oldRange) {
    a.oldRange = Range2._createFromRanges(a.oldRange._getTransformedByMoveOperation(b));
  }
  if (a.newRange) {
    const ranges = a.newRange._getTransformedByMoveOperation(b);
    a.newRange = ranges[0];
    for (let i = 1; i < ranges.length; i++) {
      const op = a.clone();
      op.oldRange = null;
      op.newRange = ranges[i];
      op.baseVersion = -1;
      result.push(op);
    }
  }
  return result;
});
setTransformation(MarkerOperation, SplitOperation, (a, b, context) => {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedBySplitOperation(b);
  }
  if (a.newRange) {
    if (context.abRelation) {
      const aNewRange = a.newRange._getTransformedBySplitOperation(b);
      if (a.newRange.start.isEqual(b.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {
        a.newRange.start = Position2._createAt(b.insertionPosition);
      } else if (a.newRange.start.isEqual(b.splitPosition) && !context.abRelation.wasInLeftElement) {
        a.newRange.start = Position2._createAt(b.moveTargetPosition);
      } else {
        a.newRange.start = aNewRange.start;
      }
      if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasInRightElement) {
        a.newRange.end = Position2._createAt(b.moveTargetPosition);
      } else if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {
        a.newRange.end = Position2._createAt(b.insertionPosition);
      } else {
        a.newRange.end = aNewRange.end;
      }
      return [a];
    }
    a.newRange = a.newRange._getTransformedBySplitOperation(b);
  }
  return [a];
});
setTransformation(MergeOperation, InsertOperation, (a, b) => {
  if (a.sourcePosition.hasSameParentAs(b.position)) {
    a.howMany += b.howMany;
  }
  a.sourcePosition = a.sourcePosition._getTransformedByInsertOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(MergeOperation, MergeOperation, (a, b, context) => {
  if (a.sourcePosition.isEqual(b.sourcePosition) && a.targetPosition.isEqual(b.targetPosition)) {
    if (!context.bWasUndone) {
      return [new NoOperation(0)];
    } else {
      const path = b.graveyardPosition.path.slice();
      path.push(0);
      a.sourcePosition = new Position2(b.graveyardPosition.root, path);
      a.howMany = 0;
      return [a];
    }
  }
  if (a.sourcePosition.isEqual(b.sourcePosition) && !a.targetPosition.isEqual(b.targetPosition) && !context.bWasUndone && context.abRelation != "splitAtSource") {
    const aToGraveyard = a.targetPosition.root.rootName == "$graveyard";
    const bToGraveyard = b.targetPosition.root.rootName == "$graveyard";
    const aIsWeak = aToGraveyard && !bToGraveyard;
    const bIsWeak = bToGraveyard && !aToGraveyard;
    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
    if (forceMove) {
      const sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);
      const targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
      return [new MoveOperation(sourcePosition, a.howMany, targetPosition, 0)];
    } else {
      return [new NoOperation(0)];
    }
  }
  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {
    a.howMany += b.howMany;
  }
  a.sourcePosition = a.sourcePosition._getTransformedByMergeOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
  if (!a.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);
  }
  return [a];
});
setTransformation(MergeOperation, MoveOperation, (a, b, context) => {
  const removedRange = Range2._createFromPositionAndShift(b.sourcePosition, b.howMany);
  if (b.type == "remove" && !context.bWasUndone) {
    if (a.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a.sourcePosition)) {
      return [new NoOperation(0)];
    }
  }
  if (b.sourcePosition.getShiftedBy(b.howMany).isEqual(a.sourcePosition)) {
    a.sourcePosition.stickiness = "toNone";
  } else if (b.targetPosition.isEqual(a.sourcePosition) && context.abRelation == "mergeSourceAffected") {
    a.sourcePosition.stickiness = "toNext";
  } else if (b.sourcePosition.isEqual(a.targetPosition)) {
    a.targetPosition.stickiness = "toNone";
    a.howMany -= b.howMany;
  } else if (b.targetPosition.isEqual(a.targetPosition) && context.abRelation == "mergeTargetWasBefore") {
    a.targetPosition.stickiness = "toPrevious";
    a.howMany += b.howMany;
  } else {
    if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {
      a.howMany += b.howMany;
    }
    if (a.sourcePosition.hasSameParentAs(b.sourcePosition)) {
      a.howMany -= b.howMany;
    }
  }
  a.sourcePosition = a.sourcePosition._getTransformedByMoveOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByMoveOperation(b);
  a.sourcePosition.stickiness = "toPrevious";
  a.targetPosition.stickiness = "toNext";
  if (!a.graveyardPosition.isEqual(b.targetPosition)) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
  }
  return [a];
});
setTransformation(MergeOperation, SplitOperation, (a, b, context) => {
  if (b.graveyardPosition) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1);
    if (a.deletionPosition.isEqual(b.graveyardPosition)) {
      a.howMany = b.howMany;
    }
  }
  if (a.targetPosition.isEqual(b.splitPosition)) {
    const mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual(b.graveyardPosition);
    if (mergeSplittingElement || context.abRelation == "mergeTargetNotMoved") {
      a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);
      return [a];
    }
  }
  if (a.sourcePosition.isEqual(b.splitPosition)) {
    if (context.abRelation == "mergeSourceNotMoved") {
      a.howMany = 0;
      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
      return [a];
    }
    if (context.abRelation == "mergeSameElement" || a.sourcePosition.offset > 0) {
      a.sourcePosition = b.moveTargetPosition.clone();
      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
      return [a];
    }
  }
  if (a.sourcePosition.hasSameParentAs(b.splitPosition)) {
    a.howMany = b.splitPosition.offset;
  }
  a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);
  a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(MoveOperation, InsertOperation, (a, b) => {
  const moveRange = Range2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  const transformed = moveRange._getTransformedByInsertOperation(b, false)[0];
  a.sourcePosition = transformed.start;
  a.howMany = transformed.end.offset - transformed.start.offset;
  if (!a.targetPosition.isEqual(b.position)) {
    a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);
  }
  return [a];
});
setTransformation(MoveOperation, MoveOperation, (a, b, context) => {
  const rangeA = Range2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  const rangeB = Range2._createFromPositionAndShift(b.sourcePosition, b.howMany);
  let aIsStrong = context.aIsStrong;
  let insertBefore = !context.aIsStrong;
  if (context.abRelation == "insertBefore" || context.baRelation == "insertAfter") {
    insertBefore = true;
  } else if (context.abRelation == "insertAfter" || context.baRelation == "insertBefore") {
    insertBefore = false;
  }
  let newTargetPosition;
  if (a.targetPosition.isEqual(b.targetPosition) && insertBefore) {
    newTargetPosition = a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
  } else {
    newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
  }
  if (_moveTargetIntoMovedRange(a, b) && _moveTargetIntoMovedRange(b, a)) {
    return [b.getReversed()];
  }
  const bTargetsToA = rangeA.containsPosition(b.targetPosition);
  if (bTargetsToA && rangeA.containsRange(rangeB, true)) {
    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  }
  const aTargetsToB = rangeB.containsPosition(a.targetPosition);
  if (aTargetsToB && rangeB.containsRange(rangeA, true)) {
    rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
    rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  }
  const aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());
  if (aCompB == "prefix" || aCompB == "extension") {
    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  }
  if (a.type == "remove" && b.type != "remove" && !context.aWasUndone && !context.forceWeakRemove) {
    aIsStrong = true;
  } else if (a.type != "remove" && b.type == "remove" && !context.bWasUndone && !context.forceWeakRemove) {
    aIsStrong = false;
  }
  const ranges = [];
  const difference = rangeA.getDifference(rangeB);
  for (const range of difference) {
    range.start = range.start._getTransformedByDeletion(b.sourcePosition, b.howMany);
    range.end = range.end._getTransformedByDeletion(b.sourcePosition, b.howMany);
    const shouldSpread = compareArrays(range.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == "same";
    const newRanges = range._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);
    ranges.push(...newRanges);
  }
  const common = rangeA.getIntersection(rangeB);
  if (common !== null && aIsStrong) {
    common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
    common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
    if (ranges.length === 0) {
      ranges.push(common);
    } else if (ranges.length == 1) {
      if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {
        ranges.unshift(common);
      } else {
        ranges.push(common);
      }
    } else {
      ranges.splice(1, 0, common);
    }
  }
  if (ranges.length === 0) {
    return [new NoOperation(a.baseVersion)];
  }
  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
});
setTransformation(MoveOperation, SplitOperation, (a, b, context) => {
  let newTargetPosition = a.targetPosition.clone();
  if (!a.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == "moveTargetAfter") {
    newTargetPosition = a.targetPosition._getTransformedBySplitOperation(b);
  }
  const moveRange = Range2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  if (moveRange.end.isEqual(b.insertionPosition)) {
    if (!b.graveyardPosition) {
      a.howMany++;
    }
    a.targetPosition = newTargetPosition;
    return [a];
  }
  if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {
    let rightRange = new Range2(b.splitPosition, moveRange.end);
    rightRange = rightRange._getTransformedBySplitOperation(b);
    const ranges2 = [
      new Range2(moveRange.start, b.splitPosition),
      rightRange
    ];
    return _makeMoveOperationsFromRanges(ranges2, newTargetPosition);
  }
  if (a.targetPosition.isEqual(b.splitPosition) && context.abRelation == "insertAtSource") {
    newTargetPosition = b.moveTargetPosition;
  }
  if (a.targetPosition.isEqual(b.insertionPosition) && context.abRelation == "insertBetween") {
    newTargetPosition = a.targetPosition;
  }
  const transformed = moveRange._getTransformedBySplitOperation(b);
  const ranges = [transformed];
  if (b.graveyardPosition) {
    const movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);
    if (a.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {
      ranges.push(Range2._createFromPositionAndShift(b.insertionPosition, 1));
    }
  }
  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
});
setTransformation(MoveOperation, MergeOperation, (a, b, context) => {
  const movedRange = Range2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  if (b.deletionPosition.hasSameParentAs(a.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {
    if (a.type == "remove" && !context.forceWeakRemove) {
      if (!context.aWasUndone) {
        const results = [];
        let gyMoveSource = b.graveyardPosition.clone();
        let splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);
        const aTarget = a.targetPosition.getTransformedByOperation(b);
        if (a.howMany > 1) {
          results.push(new MoveOperation(a.sourcePosition, a.howMany - 1, aTarget, 0));
          gyMoveSource = gyMoveSource._getTransformedByMove(a.sourcePosition, aTarget, a.howMany - 1);
          splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a.sourcePosition, aTarget, a.howMany - 1);
        }
        const gyMoveTarget = b.deletionPosition._getCombined(a.sourcePosition, aTarget);
        const gyMove = new MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);
        const splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();
        splitNodesMoveTargetPath.push(0);
        const splitNodesMoveTarget = new Position2(gyMove.targetPosition.root, splitNodesMoveTargetPath);
        splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);
        const splitNodesMove = new MoveOperation(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);
        results.push(gyMove);
        results.push(splitNodesMove);
        return results;
      }
    } else {
      if (a.howMany == 1) {
        if (!context.bWasUndone) {
          return [new NoOperation(0)];
        } else {
          a.sourcePosition = b.graveyardPosition.clone();
          a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
          return [a];
        }
      }
    }
  }
  const moveRange = Range2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  const transformed = moveRange._getTransformedByMergeOperation(b);
  a.sourcePosition = transformed.start;
  a.howMany = transformed.end.offset - transformed.start.offset;
  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
  return [a];
});
setTransformation(RenameOperation, InsertOperation, (a, b) => {
  a.position = a.position._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(RenameOperation, MergeOperation, (a, b) => {
  if (a.position.isEqual(b.deletionPosition)) {
    a.position = b.graveyardPosition.clone();
    a.position.stickiness = "toNext";
    return [a];
  }
  a.position = a.position._getTransformedByMergeOperation(b);
  return [a];
});
setTransformation(RenameOperation, MoveOperation, (a, b) => {
  a.position = a.position._getTransformedByMoveOperation(b);
  return [a];
});
setTransformation(RenameOperation, RenameOperation, (a, b, context) => {
  if (a.position.isEqual(b.position)) {
    if (context.aIsStrong) {
      a.oldName = b.newName;
    } else {
      return [new NoOperation(0)];
    }
  }
  return [a];
});
setTransformation(RenameOperation, SplitOperation, (a, b) => {
  const renamePath = a.position.path;
  const splitPath = b.splitPosition.getParentPath();
  if (compareArrays(renamePath, splitPath) == "same" && !b.graveyardPosition) {
    const extraRename = new RenameOperation(a.position.getShiftedBy(1), a.oldName, a.newName, 0);
    return [a, extraRename];
  }
  a.position = a.position._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(RootAttributeOperation, RootAttributeOperation, (a, b, context) => {
  if (a.root === b.root && a.key === b.key) {
    if (!context.aIsStrong || a.newValue === b.newValue) {
      return [new NoOperation(0)];
    } else {
      a.oldValue = b.newValue;
    }
  }
  return [a];
});
setTransformation(RootOperation, RootOperation, (a, b) => {
  if (a.rootName === b.rootName && a.isAdd === b.isAdd) {
    return [new NoOperation(0)];
  }
  return [a];
});
setTransformation(SplitOperation, InsertOperation, (a, b) => {
  if (a.splitPosition.hasSameParentAs(b.position) && a.splitPosition.offset < b.position.offset) {
    a.howMany += b.howMany;
  }
  a.splitPosition = a.splitPosition._getTransformedByInsertOperation(b);
  a.insertionPosition = a.insertionPosition._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(SplitOperation, MergeOperation, (a, b, context) => {
  if (!a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs(b.sourcePosition)) {
    const splitPath = b.graveyardPosition.path.slice();
    splitPath.push(0);
    const splitPosition = new Position2(b.graveyardPosition.root, splitPath);
    const insertionPosition = SplitOperation.getInsertionPosition(new Position2(b.graveyardPosition.root, splitPath));
    const additionalSplit = new SplitOperation(splitPosition, 0, insertionPosition, null, 0);
    a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);
    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
    a.graveyardPosition = additionalSplit.insertionPosition.clone();
    a.graveyardPosition.stickiness = "toNext";
    return [additionalSplit, a];
  }
  if (a.splitPosition.hasSameParentAs(b.deletionPosition) && !a.splitPosition.isAfter(b.deletionPosition)) {
    a.howMany--;
  }
  if (a.splitPosition.hasSameParentAs(b.targetPosition)) {
    a.howMany += b.howMany;
  }
  a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);
  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
  if (a.graveyardPosition) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);
  }
  return [a];
});
setTransformation(SplitOperation, MoveOperation, (a, b, context) => {
  const rangeToMove = Range2._createFromPositionAndShift(b.sourcePosition, b.howMany);
  if (a.graveyardPosition) {
    const gyElementMoved = rangeToMove.start.isEqual(a.graveyardPosition) || rangeToMove.containsPosition(a.graveyardPosition);
    if (!context.bWasUndone && gyElementMoved) {
      const sourcePosition = a.splitPosition._getTransformedByMoveOperation(b);
      const newParentPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
      const newTargetPath = newParentPosition.path.slice();
      newTargetPath.push(0);
      const newTargetPosition = new Position2(newParentPosition.root, newTargetPath);
      const moveOp = new MoveOperation(sourcePosition, a.howMany, newTargetPosition, 0);
      return [moveOp];
    }
    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
  }
  const splitAtTarget = a.splitPosition.isEqual(b.targetPosition);
  if (splitAtTarget && (context.baRelation == "insertAtSource" || context.abRelation == "splitBefore")) {
    a.howMany += b.howMany;
    a.splitPosition = a.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
    return [a];
  }
  if (splitAtTarget && context.abRelation && context.abRelation.howMany) {
    const { howMany, offset } = context.abRelation;
    a.howMany += howMany;
    a.splitPosition = a.splitPosition.getShiftedBy(offset);
    return [a];
  }
  if (a.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a.splitPosition)) {
    const howManyRemoved = b.howMany - (a.splitPosition.offset - b.sourcePosition.offset);
    a.howMany -= howManyRemoved;
    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {
      a.howMany += b.howMany;
    }
    a.splitPosition = b.sourcePosition.clone();
    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
    return [a];
  }
  if (!b.sourcePosition.isEqual(b.targetPosition)) {
    if (a.splitPosition.hasSameParentAs(b.sourcePosition) && a.splitPosition.offset <= b.sourcePosition.offset) {
      a.howMany -= b.howMany;
    }
    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {
      a.howMany += b.howMany;
    }
  }
  a.splitPosition.stickiness = "toNone";
  a.splitPosition = a.splitPosition._getTransformedByMoveOperation(b);
  a.splitPosition.stickiness = "toNext";
  if (a.graveyardPosition) {
    a.insertionPosition = a.insertionPosition._getTransformedByMoveOperation(b);
  } else {
    a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
  }
  return [a];
});
setTransformation(SplitOperation, SplitOperation, (a, b, context) => {
  if (a.splitPosition.isEqual(b.splitPosition)) {
    if (!a.graveyardPosition && !b.graveyardPosition) {
      return [new NoOperation(0)];
    }
    if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {
      return [new NoOperation(0)];
    }
    if (context.abRelation == "splitBefore") {
      a.howMany = 0;
      a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);
      return [a];
    }
  }
  if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {
    const aInGraveyard = a.splitPosition.root.rootName == "$graveyard";
    const bInGraveyard = b.splitPosition.root.rootName == "$graveyard";
    const aIsWeak = aInGraveyard && !bInGraveyard;
    const bIsWeak = bInGraveyard && !aInGraveyard;
    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
    if (forceMove) {
      const result = [];
      if (b.howMany) {
        result.push(new MoveOperation(b.moveTargetPosition, b.howMany, b.splitPosition, 0));
      }
      if (a.howMany) {
        result.push(new MoveOperation(a.splitPosition, a.howMany, a.moveTargetPosition, 0));
      }
      return result;
    } else {
      return [new NoOperation(0)];
    }
  }
  if (a.graveyardPosition) {
    a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);
  }
  if (a.splitPosition.isEqual(b.insertionPosition) && context.abRelation == "splitBefore") {
    a.howMany++;
    return [a];
  }
  if (b.splitPosition.isEqual(a.insertionPosition) && context.baRelation == "splitBefore") {
    const newPositionPath = b.insertionPosition.path.slice();
    newPositionPath.push(0);
    const newPosition = new Position2(b.insertionPosition.root, newPositionPath);
    const moveOp = new MoveOperation(a.insertionPosition, 1, newPosition, 0);
    return [a, moveOp];
  }
  if (a.splitPosition.hasSameParentAs(b.splitPosition) && a.splitPosition.offset < b.splitPosition.offset) {
    a.howMany -= b.howMany;
  }
  a.splitPosition = a.splitPosition._getTransformedBySplitOperation(b);
  a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
  return [a];
});
function _moveTargetIntoMovedRange(a, b) {
  return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;
}
function _makeMoveOperationsFromRanges(ranges, targetPosition) {
  const operations2 = [];
  for (let i = 0; i < ranges.length; i++) {
    const range = ranges[i];
    const op = new MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, 0);
    operations2.push(op);
    for (let j = i + 1; j < ranges.length; j++) {
      ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];
    }
    targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);
  }
  return operations2;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/liveposition.js
var LivePosition = class extends EmitterMixin(Position2) {
  /**
   * Creates a live position.
   *
   * @see module:engine/model/position~Position
   */
  constructor(root, path, stickiness = "toNone") {
    super(root, path, stickiness);
    if (!this.root.is("rootElement")) {
      throw new CKEditorError("model-liveposition-root-not-rootelement", root);
    }
    bindWithDocument2.call(this);
  }
  /**
   * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
   * referring to it).
   */
  detach() {
    this.stopListening();
  }
  /**
   * Creates a {@link module:engine/model/position~Position position instance}, which is equal to this live position.
   */
  toPosition() {
    return new Position2(this.root, this.path.slice(), this.stickiness);
  }
  /**
   * Creates a `LivePosition` instance that is equal to position.
   */
  static fromPosition(position, stickiness) {
    return new this(position.root, position.path.slice(), stickiness ? stickiness : position.stickiness);
  }
};
LivePosition.prototype.is = function(type) {
  return type === "livePosition" || type === "model:livePosition" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type == "position" || type === "model:position";
};
function bindWithDocument2() {
  this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
    const operation = args[0];
    if (!operation.isDocumentOperation) {
      return;
    }
    transform3.call(this, operation);
  }, { priority: "low" });
}
function transform3(operation) {
  const result = this.getTransformedByOperation(operation);
  if (!this.isEqual(result)) {
    const oldPosition = this.toPosition();
    this.path = result.path;
    this.root = result.root;
    this.fire("change", oldPosition);
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/batch.js
var Batch = class {
  /**
   * Creates a batch instance.
   *
   * @see module:engine/model/model~Model#enqueueChange
   * @see module:engine/model/model~Model#change
   * @param type A set of flags that specify the type of the batch. Batch type can alter how some of the features work
   * when encountering a given `Batch` instance (for example, when a feature listens to applied operations).
   */
  constructor(type = {}) {
    if (typeof type === "string") {
      type = type === "transparent" ? { isUndoable: false } : {};
      logWarning("batch-constructor-deprecated-string-type");
    }
    const { isUndoable = true, isLocal = true, isUndo = false, isTyping = false } = type;
    this.operations = [];
    this.isUndoable = isUndoable;
    this.isLocal = isLocal;
    this.isUndo = isUndo;
    this.isTyping = isTyping;
  }
  /**
   * The type of the batch.
   *
   * **This property has been deprecated and is always set to the `'default'` value.**
   *
   * It can be one of the following values:
   * * `'default'` &ndash; All "normal" batches. This is the most commonly used type.
   * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing
   * changes.
   *
   * @deprecated
   */
  get type() {
    logWarning("batch-type-deprecated");
    return "default";
  }
  /**
   * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.
   * If there are no operations in the batch or neither operation has the base version set, it returns `null`.
   */
  get baseVersion() {
    for (const op of this.operations) {
      if (op.baseVersion !== null) {
        return op.baseVersion;
      }
    }
    return null;
  }
  /**
   * Adds an operation to the batch instance.
   *
   * @param operation An operation to add.
   * @returns The added operation.
   */
  addOperation(operation) {
    operation.batch = this;
    this.operations.push(operation);
    return operation;
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js
var Differ = class _Differ {
  /**
   * Creates a `Differ` instance.
   *
   * @param markerCollection Model's marker collection.
   */
  constructor(markerCollection) {
    this._changesInElement = /* @__PURE__ */ new Map();
    this._elementsSnapshots = /* @__PURE__ */ new Map();
    this._elementChildrenSnapshots = /* @__PURE__ */ new Map();
    this._elementState = /* @__PURE__ */ new Map();
    this._changedMarkers = /* @__PURE__ */ new Map();
    this._changedRoots = /* @__PURE__ */ new Map();
    this._changeCount = 0;
    this._cachedChanges = null;
    this._cachedChangesWithGraveyard = null;
    this._refreshedItems = /* @__PURE__ */ new Set();
    this._markerCollection = markerCollection;
  }
  /**
   * Informs whether there are any changes buffered in `Differ`.
   */
  get isEmpty() {
    return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
  }
  /**
   * Buffers the given operation. **An operation has to be buffered before it is executed.**
   *
   * @param operationToBuffer An operation to buffer.
   */
  bufferOperation(operationToBuffer) {
    const operation = operationToBuffer;
    switch (operation.type) {
      case "insert": {
        if (this._isInInsertedElement(operation.position.parent)) {
          return;
        }
        this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);
        break;
      }
      case "addAttribute":
      case "removeAttribute":
      case "changeAttribute": {
        for (const item of operation.range.getItems({ shallow: true })) {
          if (this._isInInsertedElement(item.parent)) {
            continue;
          }
          this._markAttribute(item);
        }
        break;
      }
      case "remove":
      case "move":
      case "reinsert": {
        if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {
          return;
        }
        const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);
        const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);
        if (!sourceParentInserted) {
          this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);
        }
        if (!targetParentInserted) {
          this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);
        }
        const range = Range2._createFromPositionAndShift(operation.sourcePosition, operation.howMany);
        for (const node of range.getItems({ shallow: true })) {
          this._setElementState(node, "move");
        }
        break;
      }
      case "rename": {
        if (this._isInInsertedElement(operation.position.parent)) {
          return;
        }
        this._markRemove(operation.position.parent, operation.position.offset, 1);
        this._markInsert(operation.position.parent, operation.position.offset, 1);
        const range = Range2._createFromPositionAndShift(operation.position, 1);
        for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {
          const markerData = marker.getData();
          this.bufferMarkerChange(marker.name, markerData, markerData);
        }
        this._setElementState(operation.position.nodeAfter, "rename");
        break;
      }
      case "split": {
        const splitElement = operation.splitPosition.parent;
        if (!this._isInInsertedElement(splitElement)) {
          this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);
          const range = Range2._createFromPositionAndShift(operation.splitPosition, operation.howMany);
          for (const node of range.getItems({ shallow: true })) {
            this._setElementState(node, "move");
          }
        }
        if (!this._isInInsertedElement(operation.insertionPosition.parent)) {
          this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);
        }
        if (operation.graveyardPosition) {
          this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);
          this._setElementState(operation.graveyardPosition.nodeAfter, "move");
        }
        break;
      }
      case "merge": {
        const mergedElement = operation.sourcePosition.parent;
        if (!this._isInInsertedElement(mergedElement.parent)) {
          this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);
        }
        const graveyardParent = operation.graveyardPosition.parent;
        this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1);
        this._setElementState(mergedElement, "move");
        const mergedIntoElement = operation.targetPosition.parent;
        if (!this._isInInsertedElement(mergedIntoElement)) {
          this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);
          const range = Range2._createFromPositionAndShift(operation.sourcePosition, operation.howMany);
          for (const node of range.getItems({ shallow: true })) {
            this._setElementState(node, "move");
          }
        }
        break;
      }
      case "detachRoot":
      case "addRoot": {
        const root = operation.affectedSelectable;
        if (!root._isLoaded) {
          return;
        }
        if (root.isAttached() == operation.isAdd) {
          return;
        }
        this._bufferRootStateChange(operation.rootName, operation.isAdd);
        break;
      }
      case "addRootAttribute":
      case "removeRootAttribute":
      case "changeRootAttribute": {
        if (!operation.root._isLoaded) {
          return;
        }
        const rootName = operation.root.rootName;
        this._bufferRootAttributeChange(rootName, operation.key, operation.oldValue, operation.newValue);
        break;
      }
    }
    this._cachedChanges = null;
  }
  /**
   * Buffers a marker change.
   *
   * @param markerName The name of the marker that changed.
   * @param oldMarkerData Marker data before the change.
   * @param newMarkerData Marker data after the change.
   */
  bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {
    if (oldMarkerData.range && oldMarkerData.range.root.is("rootElement") && !oldMarkerData.range.root._isLoaded) {
      oldMarkerData.range = null;
    }
    if (newMarkerData.range && newMarkerData.range.root.is("rootElement") && !newMarkerData.range.root._isLoaded) {
      newMarkerData.range = null;
    }
    let buffered = this._changedMarkers.get(markerName);
    if (!buffered) {
      buffered = { newMarkerData, oldMarkerData };
      this._changedMarkers.set(markerName, buffered);
    } else {
      buffered.newMarkerData = newMarkerData;
    }
    if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {
      this._changedMarkers.delete(markerName);
    }
  }
  /**
   * Returns all markers that should be removed as a result of buffered changes.
   *
   * @returns Markers to remove. Each array item is an object containing the `name` and `range` properties.
   */
  getMarkersToRemove() {
    const result = [];
    for (const [name, change] of this._changedMarkers) {
      if (change.oldMarkerData.range != null) {
        result.push({ name, range: change.oldMarkerData.range });
      }
    }
    return result;
  }
  /**
   * Returns all markers which should be added as a result of buffered changes.
   *
   * @returns Markers to add. Each array item is an object containing the `name` and `range` properties.
   */
  getMarkersToAdd() {
    const result = [];
    for (const [name, change] of this._changedMarkers) {
      if (change.newMarkerData.range != null) {
        result.push({ name, range: change.newMarkerData.range });
      }
    }
    return result;
  }
  /**
   * Returns all markers which changed.
   */
  getChangedMarkers() {
    return Array.from(this._changedMarkers).map(([name, change]) => ({
      name,
      data: {
        oldRange: change.oldMarkerData.range,
        newRange: change.newMarkerData.range
      }
    }));
  }
  /**
   * Checks whether some of the buffered changes affect the editor data.
   *
   * Types of changes which affect the editor data:
   *
   * * model structure changes,
   * * attribute changes,
   * * a root is added or detached,
   * * changes of markers which were defined as `affectsData`,
   * * changes of markers' `affectsData` property.
   */
  hasDataChanges() {
    if (this.getChanges().length) {
      return true;
    }
    if (this._changedRoots.size > 0) {
      return true;
    }
    for (const { newMarkerData, oldMarkerData } of this._changedMarkers.values()) {
      if (newMarkerData.affectsData !== oldMarkerData.affectsData) {
        return true;
      }
      if (newMarkerData.affectsData) {
        const markerAdded = newMarkerData.range && !oldMarkerData.range;
        const markerRemoved = !newMarkerData.range && oldMarkerData.range;
        const markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);
        if (markerAdded || markerRemoved || markerChanged) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}
   * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.
   *
   * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done
   * on the model. The items are sorted by the position on which the change happened. If a position
   * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.
   *
   * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.
   *
   * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the
   * previous {@link #getChanges} call, the next call will return the cached value.
   *
   * @param options Additional options.
   * @param options.includeChangesInGraveyard If set to `true`, also changes that happened
   * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.
   * @returns Diff between the old and the new model tree state.
   */
  getChanges(options = {}) {
    if (this._cachedChanges) {
      if (options.includeChangesInGraveyard) {
        return this._cachedChangesWithGraveyard.slice();
      } else {
        return this._cachedChanges.slice();
      }
    }
    let diffSet = [];
    for (const element of this._changesInElement.keys()) {
      const changes = this._changesInElement.get(element).sort((a, b) => {
        if (a.offset === b.offset) {
          if (a.type != b.type) {
            return a.type == "remove" ? -1 : 1;
          }
          return 0;
        }
        return a.offset < b.offset ? -1 : 1;
      });
      const childrenBefore = this._elementChildrenSnapshots.get(element);
      const childrenAfter = _getChildrenSnapshots(element.getChildren());
      const diffInstructions = _generateDiffInstructionsFromChanges(childrenBefore.length, changes);
      let i = 0;
      let j = 0;
      for (const instruction of diffInstructions) {
        if (instruction === "i") {
          const action = this._getDiffActionForNode(childrenAfter[i].node, "insert");
          const childSnapshotBefore = this._elementsSnapshots.get(childrenAfter[i].node);
          const diffItem = this._getInsertDiff(element, i, action, childrenAfter[i], childSnapshotBefore);
          diffSet.push(diffItem);
          i++;
        } else if (instruction === "r") {
          const action = this._getDiffActionForNode(childrenBefore[j].node, "remove");
          const diffItem = this._getRemoveDiff(element, i, action, childrenBefore[j]);
          diffSet.push(diffItem);
          j++;
        } else if (instruction === "a") {
          const beforeAttributes = childrenBefore[j].attributes;
          const afterAttributes = childrenAfter[i].attributes;
          let range;
          if (childrenAfter[i].name == "$text") {
            range = new Range2(Position2._createAt(element, i), Position2._createAt(element, i + 1));
          } else {
            const index = element.offsetToIndex(i);
            range = new Range2(Position2._createAt(element, i), Position2._createAt(element.getChild(index), 0));
          }
          const diffItems = this._getAttributesDiff(range, beforeAttributes, afterAttributes);
          diffSet.push(...diffItems);
          i++;
          j++;
        } else {
          i++;
          j++;
        }
      }
    }
    diffSet.sort((a, b) => {
      if (a.position.root != b.position.root) {
        return a.position.root.rootName < b.position.root.rootName ? -1 : 1;
      }
      if (a.position.isEqual(b.position)) {
        return a.changeCount - b.changeCount;
      }
      return a.position.isBefore(b.position) ? -1 : 1;
    });
    for (let i = 1, prevIndex = 0; i < diffSet.length; i++) {
      const prevDiff = diffSet[prevIndex];
      const thisDiff = diffSet[i];
      const isConsecutiveTextRemove = prevDiff.type == "remove" && thisDiff.type == "remove" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.isEqual(thisDiff.position);
      const isConsecutiveTextAdd = prevDiff.type == "insert" && thisDiff.type == "insert" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset;
      const isConsecutiveAttributeChange = prevDiff.type == "attribute" && thisDiff.type == "attribute" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;
      if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {
        prevDiff.length++;
        if (isConsecutiveAttributeChange) {
          prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);
        }
        diffSet[i] = null;
      } else {
        prevIndex = i;
      }
    }
    diffSet = diffSet.filter((v) => v);
    for (const item of diffSet) {
      delete item.changeCount;
      if (item.type == "attribute") {
        delete item.position;
        delete item.length;
      }
    }
    this._changeCount = 0;
    this._cachedChangesWithGraveyard = diffSet;
    this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);
    if (options.includeChangesInGraveyard) {
      return this._cachedChangesWithGraveyard.slice();
    } else {
      return this._cachedChanges.slice();
    }
  }
  /**
   * Returns all roots that have changed (either were attached, or detached, or their attributes changed).
   *
   * @returns Diff between the old and the new roots state.
   */
  getChangedRoots() {
    return Array.from(this._changedRoots.values()).map((diffItem) => {
      const entry = { ...diffItem };
      if (entry.state !== void 0) {
        delete entry.attributes;
      }
      return entry;
    });
  }
  /**
   * Returns a set of model items that were marked to get refreshed.
   */
  getRefreshedItems() {
    return new Set(this._refreshedItems);
  }
  /**
   * Resets `Differ`. Removes all buffered changes.
   */
  reset() {
    this._changesInElement.clear();
    this._elementChildrenSnapshots.clear();
    this._elementsSnapshots.clear();
    this._elementState.clear();
    this._changedMarkers.clear();
    this._changedRoots.clear();
    this._refreshedItems.clear();
    this._cachedChanges = null;
  }
  /**
   * Marks the given `item` in differ to be "refreshed". It means that the item will be marked as removed and inserted
   * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.
   *
   * @internal
   * @param item Item to refresh.
   */
  _refreshItem(item) {
    if (this._isInInsertedElement(item.parent)) {
      return;
    }
    this._markRemove(item.parent, item.startOffset, item.offsetSize);
    this._markInsert(item.parent, item.startOffset, item.offsetSize);
    this._refreshedItems.add(item);
    this._setElementState(item, "refresh");
    const range = Range2._createOn(item);
    for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {
      const markerData = marker.getData();
      this.bufferMarkerChange(marker.name, markerData, markerData);
    }
    this._cachedChanges = null;
  }
  /**
   * Buffers all the data related to given root like it was all just added to the editor.
   *
   * Following changes are buffered:
   *
   * * root is attached,
   * * all root content is inserted,
   * * all root attributes are added,
   * * all markers inside the root are added.
   *
   * @internal
   */
  _bufferRootLoad(root) {
    if (!root.isAttached()) {
      return;
    }
    this._bufferRootStateChange(root.rootName, true);
    this._markInsert(root, 0, root.maxOffset);
    for (const key of root.getAttributeKeys()) {
      this._bufferRootAttributeChange(root.rootName, key, null, root.getAttribute(key));
    }
    for (const marker of this._markerCollection) {
      if (marker.getRange().root == root) {
        const markerData = marker.getData();
        this.bufferMarkerChange(marker.name, { ...markerData, range: null }, markerData);
      }
    }
  }
  /**
   * Buffers the root state change after the root was attached or detached
   */
  _bufferRootStateChange(rootName, isAttached) {
    if (!this._changedRoots.has(rootName)) {
      this._changedRoots.set(rootName, { name: rootName, state: isAttached ? "attached" : "detached" });
      return;
    }
    const diffItem = this._changedRoots.get(rootName);
    if (diffItem.state !== void 0) {
      delete diffItem.state;
      if (diffItem.attributes === void 0) {
        this._changedRoots.delete(rootName);
      }
    } else {
      diffItem.state = isAttached ? "attached" : "detached";
    }
  }
  /**
   * Buffers a root attribute change.
   */
  _bufferRootAttributeChange(rootName, key, oldValue, newValue) {
    const diffItem = this._changedRoots.get(rootName) || { name: rootName };
    const attrs = diffItem.attributes || {};
    if (attrs[key]) {
      const attrEntry = attrs[key];
      if (newValue === attrEntry.oldValue) {
        delete attrs[key];
      } else {
        attrEntry.newValue = newValue;
      }
    } else {
      attrs[key] = { oldValue, newValue };
    }
    if (Object.entries(attrs).length === 0) {
      delete diffItem.attributes;
      if (diffItem.state === void 0) {
        this._changedRoots.delete(rootName);
      }
    } else {
      diffItem.attributes = attrs;
      this._changedRoots.set(rootName, diffItem);
    }
  }
  /**
   * Saves and handles an insert change.
   */
  _markInsert(parent, offset, howMany) {
    if (parent.root.is("rootElement") && !parent.root._isLoaded) {
      return;
    }
    const changeItem = { type: "insert", offset, howMany, count: this._changeCount++ };
    this._markChange(parent, changeItem);
  }
  /**
   * Saves and handles a remove change.
   */
  _markRemove(parent, offset, howMany) {
    if (parent.root.is("rootElement") && !parent.root._isLoaded) {
      return;
    }
    const changeItem = { type: "remove", offset, howMany, count: this._changeCount++ };
    this._markChange(parent, changeItem);
    this._removeAllNestedChanges(parent, offset, howMany);
  }
  /**
   * Saves and handles an attribute change.
   */
  _markAttribute(item) {
    if (item.root.is("rootElement") && !item.root._isLoaded) {
      return;
    }
    const changeItem = { type: "attribute", offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++ };
    this._markChange(item.parent, changeItem);
  }
  /**
   * Saves and handles a model change.
   */
  _markChange(parent, changeItem) {
    this._makeSnapshots(parent);
    const changes = this._getChangesForElement(parent);
    this._handleChange(changeItem, changes);
    changes.push(changeItem);
    for (let i = 0; i < changes.length; i++) {
      if (changes[i].howMany < 1) {
        changes.splice(i, 1);
        i--;
      }
    }
  }
  /**
   * Tries to set given state for given item.
   *
   * This method does simple validation (it sets the state only for model elements, not for text proxy nodes). It also follows state
   * setting rules, that is, `'refresh'` cannot overwrite `'rename'`, and `'rename'` cannot overwrite `'move'`.
   */
  _setElementState(node, state) {
    if (!node.is("element")) {
      return;
    }
    const currentStatePriority = _Differ._statesPriority.indexOf(this._elementState.get(node));
    const newStatePriority = _Differ._statesPriority.indexOf(state);
    if (newStatePriority > currentStatePriority) {
      this._elementState.set(node, state);
    }
  }
  /**
   * Returns a value for {@link ~DifferItemAction `action`} property for diff items returned by {@link ~Differ#getChanges}.
   * This method aims to return `'rename'` or `'refresh'` when it should, and `diffItemType` ("default action") in all other cases.
   *
   * It bases on a few factors:
   *
   * * for text nodes, the method always returns `diffItemType`,
   * * for newly inserted element, the method returns `diffItemType`,
   * * if {@link ~Differ#_elementState element state} was not recorded, the method returns `diffItemType`,
   * * if state was recorded, and it was `'move'` (default action), the method returns `diffItemType`,
   * * finally, if state was `'refresh'` or `'rename'`, the method returns the state value.
   */
  _getDiffActionForNode(node, diffItemType) {
    if (!node.is("element")) {
      return diffItemType;
    }
    if (!this._elementsSnapshots.has(node)) {
      return diffItemType;
    }
    const state = this._elementState.get(node);
    if (!state || state == "move") {
      return diffItemType;
    }
    return state;
  }
  /**
   * Gets an array of changes that have already been saved for a given element.
   */
  _getChangesForElement(element) {
    let changes;
    if (this._changesInElement.has(element)) {
      changes = this._changesInElement.get(element);
    } else {
      changes = [];
      this._changesInElement.set(element, changes);
    }
    return changes;
  }
  /**
   * Creates and saves a snapshot for all children of the given element.
   */
  _makeSnapshots(element) {
    if (this._elementChildrenSnapshots.has(element)) {
      return;
    }
    const childrenSnapshots = _getChildrenSnapshots(element.getChildren());
    this._elementChildrenSnapshots.set(element, childrenSnapshots);
    for (const snapshot of childrenSnapshots) {
      this._elementsSnapshots.set(snapshot.node, snapshot);
    }
  }
  /**
   * For a given newly saved change, compares it with a change already done on the element and modifies the incoming
   * change and/or the old change.
   *
   * @param inc Incoming (new) change.
   * @param changes An array containing all the changes done on that element.
   */
  _handleChange(inc, changes) {
    inc.nodesToHandle = inc.howMany;
    for (const old of changes) {
      const incEnd = inc.offset + inc.howMany;
      const oldEnd = old.offset + old.howMany;
      if (inc.type == "insert") {
        if (old.type == "insert") {
          if (inc.offset <= old.offset) {
            old.offset += inc.howMany;
          } else if (inc.offset < oldEnd) {
            old.howMany += inc.nodesToHandle;
            inc.nodesToHandle = 0;
          }
        }
        if (old.type == "remove") {
          if (inc.offset < old.offset) {
            old.offset += inc.howMany;
          }
        }
        if (old.type == "attribute") {
          if (inc.offset <= old.offset) {
            old.offset += inc.howMany;
          } else if (inc.offset < oldEnd) {
            const howMany = old.howMany;
            old.howMany = inc.offset - old.offset;
            changes.unshift({
              type: "attribute",
              offset: incEnd,
              howMany: howMany - old.howMany,
              count: this._changeCount++
            });
          }
        }
      }
      if (inc.type == "remove") {
        if (old.type == "insert") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (incEnd <= oldEnd) {
            if (inc.offset < old.offset) {
              const intersectionLength = incEnd - old.offset;
              old.offset = inc.offset;
              old.howMany -= intersectionLength;
              inc.nodesToHandle -= intersectionLength;
            } else {
              old.howMany -= inc.nodesToHandle;
              inc.nodesToHandle = 0;
            }
          } else {
            if (inc.offset <= old.offset) {
              inc.nodesToHandle -= old.howMany;
              old.howMany = 0;
            } else if (inc.offset < oldEnd) {
              const intersectionLength = oldEnd - inc.offset;
              old.howMany -= intersectionLength;
              inc.nodesToHandle -= intersectionLength;
            }
          }
        }
        if (old.type == "remove") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (inc.offset < old.offset) {
            inc.nodesToHandle += old.howMany;
            old.howMany = 0;
          }
        }
        if (old.type == "attribute") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (inc.offset < old.offset) {
            const intersectionLength = incEnd - old.offset;
            old.offset = inc.offset;
            old.howMany -= intersectionLength;
          } else if (inc.offset < oldEnd) {
            if (incEnd <= oldEnd) {
              const howMany = old.howMany;
              old.howMany = inc.offset - old.offset;
              const howManyAfter = howMany - old.howMany - inc.nodesToHandle;
              changes.unshift({
                type: "attribute",
                offset: inc.offset,
                howMany: howManyAfter,
                count: this._changeCount++
              });
            } else {
              old.howMany -= oldEnd - inc.offset;
            }
          }
        }
      }
      if (inc.type == "attribute") {
        if (old.type == "insert") {
          if (inc.offset < old.offset && incEnd > old.offset) {
            if (incEnd > oldEnd) {
              const attributePart = {
                type: "attribute",
                offset: oldEnd,
                howMany: incEnd - oldEnd,
                count: this._changeCount++
              };
              this._handleChange(attributePart, changes);
              changes.push(attributePart);
            }
            inc.nodesToHandle = old.offset - inc.offset;
            inc.howMany = inc.nodesToHandle;
          } else if (inc.offset >= old.offset && inc.offset < oldEnd) {
            if (incEnd > oldEnd) {
              inc.nodesToHandle = incEnd - oldEnd;
              inc.offset = oldEnd;
            } else {
              inc.nodesToHandle = 0;
            }
          }
        }
        if (old.type == "remove") {
          if (inc.offset < old.offset && incEnd > old.offset) {
            const attributePart = {
              type: "attribute",
              offset: old.offset,
              howMany: incEnd - old.offset,
              count: this._changeCount++
            };
            this._handleChange(attributePart, changes);
            changes.push(attributePart);
            inc.nodesToHandle = old.offset - inc.offset;
            inc.howMany = inc.nodesToHandle;
          }
        }
        if (old.type == "attribute") {
          if (inc.offset >= old.offset && incEnd <= oldEnd) {
            inc.nodesToHandle = 0;
            inc.howMany = 0;
            inc.offset = 0;
          } else if (inc.offset <= old.offset && incEnd >= oldEnd) {
            old.howMany = 0;
          }
        }
      }
    }
    inc.howMany = inc.nodesToHandle;
    delete inc.nodesToHandle;
  }
  /**
   * Returns an object with a single insert change description.
   *
   * @param parent The element in which the change happened.
   * @param offset The offset at which change happened.
   * @param action Further specifies what kind of action led to generating this change.
   * @param elementSnapshot Snapshot of the inserted node after changes.
   * @param elementSnapshotBefore Snapshot of the inserted node before changes.
   * @returns The diff item.
   */
  _getInsertDiff(parent, offset, action, elementSnapshot, elementSnapshotBefore) {
    const diffItem = {
      type: "insert",
      position: Position2._createAt(parent, offset),
      name: elementSnapshot.name,
      attributes: new Map(elementSnapshot.attributes),
      length: 1,
      changeCount: this._changeCount++,
      action
    };
    if (action != "insert" && elementSnapshotBefore) {
      diffItem.before = {
        name: elementSnapshotBefore.name,
        attributes: new Map(elementSnapshotBefore.attributes)
      };
    }
    return diffItem;
  }
  /**
   * Returns an object with a single remove change description.
   *
   * @param parent The element in which change happened.
   * @param offset The offset at which change happened.
   * @param action Further specifies what kind of action led to generating this change.
   * @param elementSnapshot The snapshot of the removed node before changes.
   * @returns The diff item.
   */
  _getRemoveDiff(parent, offset, action, elementSnapshot) {
    return {
      type: "remove",
      action,
      position: Position2._createAt(parent, offset),
      name: elementSnapshot.name,
      attributes: new Map(elementSnapshot.attributes),
      length: 1,
      changeCount: this._changeCount++
    };
  }
  /**
   * Returns an array of objects where each one is a single attribute change description.
   *
   * @param range The range where the change happened.
   * @param oldAttributes A map, map iterator or compatible object that contains attributes before the change.
   * @param newAttributes A map, map iterator or compatible object that contains attributes after the change.
   * @returns An array containing one or more diff items.
   */
  _getAttributesDiff(range, oldAttributes, newAttributes) {
    const diffs = [];
    newAttributes = new Map(newAttributes);
    for (const [key, oldValue] of oldAttributes) {
      const newValue = newAttributes.has(key) ? newAttributes.get(key) : null;
      if (newValue !== oldValue) {
        diffs.push({
          type: "attribute",
          position: range.start,
          range: range.clone(),
          length: 1,
          attributeKey: key,
          attributeOldValue: oldValue,
          attributeNewValue: newValue,
          changeCount: this._changeCount++
        });
      }
      newAttributes.delete(key);
    }
    for (const [key, newValue] of newAttributes) {
      diffs.push({
        type: "attribute",
        position: range.start,
        range: range.clone(),
        length: 1,
        attributeKey: key,
        attributeOldValue: null,
        attributeNewValue: newValue,
        changeCount: this._changeCount++
      });
    }
    return diffs;
  }
  /**
   * Checks whether given element or any of its parents is an element that is buffered as an inserted element.
   */
  _isInInsertedElement(element) {
    const parent = element.parent;
    if (!parent) {
      return false;
    }
    const changes = this._changesInElement.get(parent);
    const offset = element.startOffset;
    if (changes) {
      for (const change of changes) {
        if (change.type == "insert" && offset >= change.offset && offset < change.offset + change.howMany) {
          return true;
        }
      }
    }
    return this._isInInsertedElement(parent);
  }
  /**
   * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`
   * and `howMany`.
   */
  _removeAllNestedChanges(parent, offset, howMany) {
    const range = new Range2(Position2._createAt(parent, offset), Position2._createAt(parent, offset + howMany));
    for (const item of range.getItems({ shallow: true })) {
      if (item.is("element")) {
        this._changesInElement.delete(item);
        this._removeAllNestedChanges(item, 0, item.maxOffset);
      }
    }
  }
};
Differ._statesPriority = [void 0, "refresh", "rename", "move"];
var differ_default = Differ;
function _getSingleNodeSnapshot(node) {
  return {
    node,
    name: node.is("$text") ? "$text" : node.name,
    attributes: new Map(node.getAttributes())
  };
}
function _getChildrenSnapshots(children) {
  const snapshots = [];
  for (const child of children) {
    if (child.is("$text")) {
      for (let i = 0; i < child.data.length; ++i) {
        snapshots.push(_getSingleNodeSnapshot(child));
      }
    } else {
      snapshots.push(_getSingleNodeSnapshot(child));
    }
  }
  return snapshots;
}
function _generateDiffInstructionsFromChanges(oldChildrenLength, changes) {
  const diff2 = [];
  let offset = 0;
  let oldChildrenHandled = 0;
  for (const change of changes) {
    if (change.offset > offset) {
      for (let i = 0; i < change.offset - offset; i++) {
        diff2.push("e");
      }
      oldChildrenHandled += change.offset - offset;
    }
    if (change.type == "insert") {
      for (let i = 0; i < change.howMany; i++) {
        diff2.push("i");
      }
      offset = change.offset + change.howMany;
    } else if (change.type == "remove") {
      for (let i = 0; i < change.howMany; i++) {
        diff2.push("r");
      }
      offset = change.offset;
      oldChildrenHandled += change.howMany;
    } else {
      if (change.howMany > 1500) {
        for (let i = 0; i < change.howMany; i++) {
          diff2.push("a");
        }
      } else {
        diff2.push(..."a".repeat(change.howMany).split(""));
      }
      offset = change.offset + change.howMany;
      oldChildrenHandled += change.howMany;
    }
  }
  if (oldChildrenHandled < oldChildrenLength) {
    for (let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {
      diff2.push("e");
    }
  }
  return diff2;
}
function _changesInGraveyardFilter(entry) {
  const posInGy = "position" in entry && entry.position.root.rootName == "$graveyard";
  const rangeInGy = "range" in entry && entry.range.root.rootName == "$graveyard";
  return !posInGy && !rangeInGy;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/history.js
var History = class {
  constructor() {
    this._operations = [];
    this._undoPairs = /* @__PURE__ */ new Map();
    this._undoneOperations = /* @__PURE__ */ new Set();
    this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
    this._version = 0;
    this._gaps = /* @__PURE__ */ new Map();
  }
  /**
   * The version of the last operation in the history.
   *
   * The history version is incremented automatically when a new operation is added to the history.
   * Setting the version manually should be done only in rare circumstances when a gap is planned
   * between history versions. When doing so, a gap will be created and the history will accept adding
   * an operation with base version equal to the new history version.
   */
  get version() {
    return this._version;
  }
  set version(version) {
    if (this._operations.length && version > this._version + 1) {
      this._gaps.set(this._version, version);
    }
    this._version = version;
  }
  /**
   * The last history operation.
   */
  get lastOperation() {
    return this._operations[this._operations.length - 1];
  }
  /**
   * Adds an operation to the history and increments the history version.
   *
   * The operation's base version should be equal to the history version. Otherwise an error is thrown.
   */
  addOperation(operation) {
    if (operation.baseVersion !== this.version) {
      throw new CKEditorError("model-document-history-addoperation-incorrect-version", this, {
        operation,
        historyVersion: this.version
      });
    }
    this._operations.push(operation);
    this._version++;
    this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);
  }
  /**
   * Returns operations from the given range of operation base versions that were added to the history.
   *
   * Note that there may be gaps in operations base versions.
   *
   * @param fromBaseVersion Base version from which operations should be returned (inclusive).
   * @param toBaseVersion Base version up to which operations should be returned (exclusive).
   * @returns History operations for the given range, in chronological order.
   */
  getOperations(fromBaseVersion, toBaseVersion = this.version) {
    if (!this._operations.length) {
      return [];
    }
    const firstOperation = this._operations[0];
    if (fromBaseVersion === void 0) {
      fromBaseVersion = firstOperation.baseVersion;
    }
    let inclusiveTo = toBaseVersion - 1;
    for (const [gapFrom, gapTo] of this._gaps) {
      if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {
        fromBaseVersion = gapTo;
      }
      if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {
        inclusiveTo = gapFrom - 1;
      }
    }
    if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {
      return [];
    }
    let fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion);
    if (fromIndex === void 0) {
      fromIndex = 0;
    }
    let toIndex = this._baseVersionToOperationIndex.get(inclusiveTo);
    if (toIndex === void 0) {
      toIndex = this._operations.length - 1;
    }
    return this._operations.slice(
      fromIndex,
      // The `toIndex` should be included in the returned operations, so add `1`.
      toIndex + 1
    );
  }
  /**
   * Returns operation from the history that bases on given `baseVersion`.
   *
   * @param baseVersion Base version of the operation to get.
   * @returns Operation with given base version or `undefined` if there is no such operation in history.
   */
  getOperation(baseVersion) {
    const operationIndex = this._baseVersionToOperationIndex.get(baseVersion);
    if (operationIndex === void 0) {
      return;
    }
    return this._operations[operationIndex];
  }
  /**
   * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,
   * history is keeping more context information about operations, which helps in operational transformation.
   *
   * @param undoneOperation Operation which is undone by `undoingOperation`.
   * @param undoingOperation Operation which undoes `undoneOperation`.
   */
  setOperationAsUndone(undoneOperation, undoingOperation) {
    this._undoPairs.set(undoingOperation, undoneOperation);
    this._undoneOperations.add(undoneOperation);
  }
  /**
   * Checks whether given `operation` is undoing any other operation.
   *
   * @param operation Operation to check.
   * @returns `true` if given `operation` is undoing any other operation, `false` otherwise.
   */
  isUndoingOperation(operation) {
    return this._undoPairs.has(operation);
  }
  /**
   * Checks whether given `operation` has been undone by any other operation.
   *
   * @param operation Operation to check.
   * @returns `true` if given `operation` has been undone any other operation, `false` otherwise.
   */
  isUndoneOperation(operation) {
    return this._undoneOperations.has(operation);
  }
  /**
   * For given `undoingOperation`, returns the operation which has been undone by it.
   *
   * @returns Operation that has been undone by given `undoingOperation` or `undefined`
   * if given `undoingOperation` is not undoing any other operation.
   */
  getUndoneOperation(undoingOperation) {
    return this._undoPairs.get(undoingOperation);
  }
  /**
   * Resets the history of operations.
   */
  reset() {
    this._version = 0;
    this._undoPairs = /* @__PURE__ */ new Map();
    this._operations = [];
    this._undoneOperations = /* @__PURE__ */ new Set();
    this._gaps = /* @__PURE__ */ new Map();
    this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/rootelement.js
var RootElement = class extends Element2 {
  /**
   * Creates root element.
   *
   * @param document Document that is an owner of this root.
   * @param name Node name.
   * @param rootName Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
   */
  constructor(document2, name, rootName = "main") {
    super(name);
    this._isAttached = true;
    this._isLoaded = true;
    this._document = document2;
    this.rootName = rootName;
  }
  /**
   * {@link module:engine/model/document~Document Document} that owns this root element.
   */
  get document() {
    return this._document;
  }
  /**
   * Informs if the root element is currently attached to the document, or not.
   *
   * A detached root is equivalent to being removed and cannot contain any children or markers.
   *
   * By default, a newly added root is attached. It can be detached using
   * {@link module:engine/model/writer~Writer#detachRoot `Writer#detachRoot`}. A detached root can be re-attached again using
   * {@link module:engine/model/writer~Writer#addRoot `Writer#addRoot`}.
   */
  isAttached() {
    return this._isAttached;
  }
  /**
   * Converts `RootElement` instance to `string` containing its name.
   *
   * @returns `RootElement` instance converted to `string`.
   */
  toJSON() {
    return this.rootName;
  }
};
RootElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rootElement" || type === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
    type === "element" || type === "model:element" || type === "node" || type === "model:node";
  }
  return name === this.name && (type === "rootElement" || type === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
  type === "element" || type === "model:element");
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/document.js
var graveyardName = "$graveyard";
var Document2 = class extends EmitterMixin() {
  /**
   * Creates an empty document instance with no {@link #roots} (other than
   * the {@link #graveyard graveyard root}).
   */
  constructor(model) {
    super();
    this.model = model;
    this.history = new History();
    this.selection = new DocumentSelection2(this);
    this.roots = new Collection({ idProperty: "rootName" });
    this.differ = new differ_default(model.markers);
    this.isReadOnly = false;
    this._postFixers = /* @__PURE__ */ new Set();
    this._hasSelectionChangedFromTheLastChangeBlock = false;
    this.createRoot("$root", graveyardName);
    this.listenTo(model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (operation.isDocumentOperation) {
        this.differ.bufferOperation(operation);
      }
    }, { priority: "high" });
    this.listenTo(model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (operation.isDocumentOperation) {
        this.history.addOperation(operation);
      }
    }, { priority: "low" });
    this.listenTo(this.selection, "change", () => {
      this._hasSelectionChangedFromTheLastChangeBlock = true;
    });
    this.listenTo(model.markers, "update", (evt, marker, oldRange, newRange, oldMarkerData) => {
      const newMarkerData = { ...marker.getData(), range: newRange };
      this.differ.bufferMarkerChange(marker.name, oldMarkerData, newMarkerData);
      if (oldRange === null) {
        marker.on("change", (evt2, oldRange2) => {
          const markerData = marker.getData();
          this.differ.bufferMarkerChange(marker.name, { ...markerData, range: oldRange2 }, markerData);
        });
      }
    });
    this.registerPostFixer((writer) => {
      let result = false;
      for (const root of this.roots) {
        if (!root.isAttached() && !root.isEmpty) {
          writer.remove(writer.createRangeIn(root));
          result = true;
        }
      }
      for (const marker of this.model.markers) {
        if (!marker.getRange().root.isAttached()) {
          writer.removeMarker(marker);
          result = true;
        }
      }
      return result;
    });
  }
  /**
   * The document version. Every applied operation increases the version number. It is used to
   * ensure that operations are applied on a proper document version.
   *
   * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.
   *
   * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,
   * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.
   */
  get version() {
    return this.history.version;
  }
  set version(version) {
    this.history.version = version;
  }
  /**
   * The graveyard tree root. A document always has a graveyard root that stores removed nodes.
   */
  get graveyard() {
    return this.getRoot(graveyardName);
  }
  /**
   * Creates a new root.
   *
   * **Note:** do not use this method after the editor has been initialized! If you want to dynamically add a root, use
   * {@link module:engine/model/writer~Writer#addRoot `model.Writer#addRoot`} instead.
   *
   * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
   * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
   * @param rootName A unique root name.
   * @returns The created root.
   */
  createRoot(elementName = "$root", rootName = "main") {
    if (this.roots.get(rootName)) {
      throw new CKEditorError("model-document-createroot-name-exists", this, { name: rootName });
    }
    const root = new RootElement(this, elementName, rootName);
    this.roots.add(root);
    return root;
  }
  /**
   * Removes all event listeners set by the document instance.
   */
  destroy() {
    this.selection.destroy();
    this.stopListening();
  }
  /**
   * Returns a root by its name.
   *
   * Detached roots are returned by this method. This is to be able to operate on the detached root (for example, to be able to create
   * a position inside such a root for undo feature purposes).
   *
   * @param name The root name of the root to return.
   * @returns The root registered under a given name or `null` when there is no root with the given name.
   */
  getRoot(name = "main") {
    return this.roots.get(name);
  }
  /**
   * Returns an array with names of all roots added to the document (except the {@link #graveyard graveyard root}).
   *
   * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
   * on the document data know which roots are still a part of the document and should be processed.
   *
   * @param includeDetached Specified whether detached roots should be returned as well.
   */
  getRootNames(includeDetached = false) {
    return this.getRoots(includeDetached).map((root) => root.rootName);
  }
  /**
   * Returns an array with all roots added to the document (except the {@link #graveyard graveyard root}).
   *
   * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
   * on the document data know which roots are still a part of the document and should be processed.
   *
   * @param includeDetached Specified whether detached roots should be returned as well.
   */
  getRoots(includeDetached = false) {
    return this.roots.filter((root) => root != this.graveyard && (includeDetached || root.isAttached()) && root._isLoaded);
  }
  /**
   * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features
   * will operate on a correct model state.
   *
   * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after
   * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but
   * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made
   * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
   * not be fixed in the new document tree state.
   *
   * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the
   * executed changes block. Thanks to that, all changes done by the callback will be added to the same
   * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent
   * for the user.
   *
   * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the
   * callback should add an empty paragraph so that the editor is never empty:
   *
   * ```ts
   * document.registerPostFixer( writer => {
   * 	const changes = document.differ.getChanges();
   *
   * 	// Check if the changes lead to an empty root in the editor.
   * 	for ( const entry of changes ) {
   * 		if ( entry.type == 'remove' && entry.position.root.isEmpty ) {
   * 			writer.insertElement( 'paragraph', entry.position.root, 0 );
   *
   * 			// It is fine to return early, even if multiple roots would need to be fixed.
   * 			// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.
   * 			return true;
   * 		}
   * 	}
   *
   * 	return false;
   * } );
   * ```
   */
  registerPostFixer(postFixer) {
    this._postFixers.add(postFixer);
  }
  /**
   * A custom `toJSON()` method to solve child-parent circular dependencies.
   *
   * @returns A clone of this object with the document property changed to a string.
   */
  toJSON() {
    const json = clone_default(this);
    json.selection = "[engine.model.DocumentSelection]";
    json.model = "[engine.model.Model]";
    return json;
  }
  /**
   * Check if there were any changes done on document, and if so, call post-fixers,
   * fire `change` event for features and conversion and then reset the differ.
   * Fire `change:data` event when at least one operation or buffered marker changes the data.
   *
   * @internal
   * @fires change
   * @fires change:data
   * @param writer The writer on which post-fixers will be called.
   */
  _handleChangeBlock(writer) {
    if (this._hasDocumentChangedFromTheLastChangeBlock()) {
      this._callPostFixers(writer);
      this.selection.refresh();
      if (this.differ.hasDataChanges()) {
        this.fire("change:data", writer.batch);
      } else {
        this.fire("change", writer.batch);
      }
      this.selection.refresh();
      this.differ.reset();
    }
    this._hasSelectionChangedFromTheLastChangeBlock = false;
  }
  /**
   * Returns whether there is a buffered change or if the selection has changed from the last
   * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}
   * or {@link module:engine/model/model~Model#change `change()` block}.
   *
   * @returns Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.
   */
  _hasDocumentChangedFromTheLastChangeBlock() {
    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
  }
  /**
   * Returns the default root for this document which is either the first root that was added to the document using
   * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
   *
   * @returns The default root for this document.
   */
  _getDefaultRoot() {
    const roots = this.getRoots();
    return roots.length ? roots[0] : this.graveyard;
  }
  /**
   * Returns the default range for this selection. The default range is a collapsed range that starts and ends
   * at the beginning of this selection's document {@link #_getDefaultRoot default root}.
   *
   * @internal
   */
  _getDefaultRange() {
    const defaultRoot = this._getDefaultRoot();
    const model = this.model;
    const schema = model.schema;
    const position = model.createPositionFromPath(defaultRoot, [0]);
    const nearestRange = schema.getNearestSelectionRange(position);
    return nearestRange || model.createRange(position);
  }
  /**
   * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for
   * the {@link #selection document's selection}.
   *
   * @internal
   * @param range A range to check.
   * @returns `true` if `range` is valid, `false` otherwise.
   */
  _validateSelectionRange(range) {
    return range.start.isValid() && range.end.isValid() && validateTextNodePosition(range.start) && validateTextNodePosition(range.end);
  }
  /**
   * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
   *
   * @param writer The writer on which post-fixer callbacks will be called.
   */
  _callPostFixers(writer) {
    let wasFixed = false;
    do {
      for (const callback of this._postFixers) {
        this.selection.refresh();
        wasFixed = callback(writer);
        if (wasFixed) {
          break;
        }
      }
    } while (wasFixed);
  }
};
function validateTextNodePosition(rangeBoundary) {
  const textNode = rangeBoundary.textNode;
  if (textNode) {
    const data = textNode.data;
    const offset = rangeBoundary.offset - textNode.startOffset;
    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/markercollection.js
var MarkerCollection = class extends EmitterMixin() {
  constructor() {
    super(...arguments);
    this._markers = /* @__PURE__ */ new Map();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link ~Marker markers} added to the collection.
   */
  [Symbol.iterator]() {
    return this._markers.values();
  }
  /**
   * Checks if given {@link ~Marker marker} or marker name is in the collection.
   *
   * @param markerOrName Name of marker or marker instance to check.
   * @returns `true` if marker is in the collection, `false` otherwise.
   */
  has(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    return this._markers.has(markerName);
  }
  /**
   * Returns {@link ~Marker marker} with given `markerName`.
   *
   * @param markerName Name of marker to get.
   * @returns Marker with given name or `null` if such marker was
   * not added to the collection.
   */
  get(markerName) {
    return this._markers.get(markerName) || null;
  }
  /**
   * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
   * {@link module:engine/model/range~Range range}.
   *
   * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in
   * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired
   * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}
   * flag has changed.
   *
   * @internal
   * @fires update
   * @param markerOrName Name of marker to set or marker instance to update.
   * @param range Marker range.
   * @param managedUsingOperations Specifies whether the marker is managed using operations.
   * @param affectsData Specifies whether the marker affects the data produced by the data pipeline
   * (is persisted in the editor's data).
   * @returns `Marker` instance which was added or updated.
   */
  _set(markerOrName, range, managedUsingOperations = false, affectsData = false) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    if (markerName.includes(",")) {
      throw new CKEditorError("markercollection-incorrect-marker-name", this);
    }
    const oldMarker = this._markers.get(markerName);
    if (oldMarker) {
      const oldMarkerData = oldMarker.getData();
      const oldRange = oldMarker.getRange();
      let hasChanged = false;
      if (!oldRange.isEqual(range)) {
        oldMarker._attachLiveRange(LiveRange.fromRange(range));
        hasChanged = true;
      }
      if (managedUsingOperations != oldMarker.managedUsingOperations) {
        oldMarker._managedUsingOperations = managedUsingOperations;
        hasChanged = true;
      }
      if (typeof affectsData === "boolean" && affectsData != oldMarker.affectsData) {
        oldMarker._affectsData = affectsData;
        hasChanged = true;
      }
      if (hasChanged) {
        this.fire(`update:${markerName}`, oldMarker, oldRange, range, oldMarkerData);
      }
      return oldMarker;
    }
    const liveRange = LiveRange.fromRange(range);
    const marker = new Marker(markerName, liveRange, managedUsingOperations, affectsData);
    this._markers.set(markerName, marker);
    this.fire(`update:${markerName}`, marker, null, range, { ...marker.getData(), range: null });
    return marker;
  }
  /**
   * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
   *
   * @internal
   * @fires update
   * @param markerOrName Marker or name of a marker to remove.
   * @returns `true` if marker was found and removed, `false` otherwise.
   */
  _remove(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    const oldMarker = this._markers.get(markerName);
    if (oldMarker) {
      this._markers.delete(markerName);
      this.fire(`update:${markerName}`, oldMarker, oldMarker.getRange(), null, oldMarker.getData());
      this._destroyMarker(oldMarker);
      return true;
    }
    return false;
  }
  /**
   * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}
   * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast
   * conversion} for the marker.
   *
   * @internal
   * @fires update
   * @param markerOrName Marker or name of a marker to refresh.
   */
  _refresh(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    const marker = this._markers.get(markerName);
    if (!marker) {
      throw new CKEditorError("markercollection-refresh-marker-not-exists", this);
    }
    const range = marker.getRange();
    this.fire(`update:${markerName}`, marker, range, range, marker.getData());
  }
  /**
   * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.
   */
  *getMarkersAtPosition(position) {
    for (const marker of this) {
      if (marker.getRange().containsPosition(position)) {
        yield marker;
      }
    }
  }
  /**
   * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.
   */
  *getMarkersIntersectingRange(range) {
    for (const marker of this) {
      if (marker.getRange().getIntersection(range) !== null) {
        yield marker;
      }
    }
  }
  /**
   * Destroys marker collection and all markers inside it.
   */
  destroy() {
    for (const marker of this._markers.values()) {
      this._destroyMarker(marker);
    }
    this._markers = null;
    this.stopListening();
  }
  /**
   * Iterates over all markers that starts with given `prefix`.
   *
   * ```ts
   * const markerFooA = markersCollection._set( 'foo:a', rangeFooA );
   * const markerFooB = markersCollection._set( 'foo:b', rangeFooB );
   * const markerBarA = markersCollection._set( 'bar:a', rangeBarA );
   * const markerFooBarA = markersCollection._set( 'foobar:a', rangeFooBarA );
   * Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
   * Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
   * ```
   */
  *getMarkersGroup(prefix) {
    for (const marker of this._markers.values()) {
      if (marker.name.startsWith(prefix + ":")) {
        yield marker;
      }
    }
  }
  /**
   * Destroys the marker.
   */
  _destroyMarker(marker) {
    marker.stopListening();
    marker._detachLiveRange();
  }
};
var Marker = class extends EmitterMixin(TypeCheckable2) {
  /**
   * Creates a marker instance.
   *
   * @param name Marker name.
   * @param liveRange Range marked by the marker.
   * @param managedUsingOperations Specifies whether the marker is managed using operations.
   * @param affectsData Specifies whether the marker affects the data produced by the data pipeline (is persisted in the editor's data).
   */
  constructor(name, liveRange, managedUsingOperations, affectsData) {
    super();
    this.name = name;
    this._liveRange = this._attachLiveRange(liveRange);
    this._managedUsingOperations = managedUsingOperations;
    this._affectsData = affectsData;
  }
  /**
   * A value indicating if the marker is managed using operations.
   * See {@link ~Marker marker class description} to learn more about marker types.
   * See {@link module:engine/model/writer~Writer#addMarker}.
   */
  get managedUsingOperations() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._managedUsingOperations;
  }
  /**
   * A value indicating if the marker changes the data.
   */
  get affectsData() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._affectsData;
  }
  /**
   * Returns the marker data (properties defining the marker).
   */
  getData() {
    return {
      range: this.getRange(),
      affectsData: this.affectsData,
      managedUsingOperations: this.managedUsingOperations
    };
  }
  /**
   * Returns current marker start position.
   */
  getStart() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._liveRange.start.clone();
  }
  /**
   * Returns current marker end position.
   */
  getEnd() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._liveRange.end.clone();
  }
  /**
   * Returns a range that represents the current state of the marker.
   *
   * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a
   * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only
   * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
   * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
   * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
   * that it's data is up-to-date.
   */
  getRange() {
    if (!this._liveRange) {
      throw new CKEditorError("marker-destroyed", this);
    }
    return this._liveRange.toRange();
  }
  /**
   * Binds new live range to the marker and detach the old one if is attached.
   *
   * @internal
   * @param liveRange Live range to attach
   * @returns Attached live range.
   */
  _attachLiveRange(liveRange) {
    if (this._liveRange) {
      this._detachLiveRange();
    }
    liveRange.delegate("change:range").to(this);
    liveRange.delegate("change:content").to(this);
    this._liveRange = liveRange;
    return liveRange;
  }
  /**
   * Unbinds and destroys currently attached live range.
   *
   * @internal
   */
  _detachLiveRange() {
    this._liveRange.stopDelegating("change:range", this);
    this._liveRange.stopDelegating("change:content", this);
    this._liveRange.detach();
    this._liveRange = null;
  }
};
Marker.prototype.is = function(type) {
  return type === "marker" || type === "model:marker";
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/detachoperation.js
var DetachOperation = class extends Operation {
  /**
   * Creates an insert operation.
   *
   * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
   * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
   * `sourcePosition` with offset shifted by `howMany`.
   */
  constructor(sourcePosition, howMany) {
    super(null);
    this.sourcePosition = sourcePosition.clone();
    this.howMany = howMany;
  }
  /**
   * @inheritDoc
   */
  get type() {
    return "detach";
  }
  /**
   * @inheritDoc
   */
  get affectedSelectable() {
    return null;
  }
  /**
   * @inheritDoc
   */
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = this.sourcePosition.toJSON();
    return json;
  }
  /**
   * @inheritDoc
   * @internal
   */
  _validate() {
    if (this.sourcePosition.root.document) {
      throw new CKEditorError("detach-operation-on-document-node", this);
    }
  }
  /**
   * @inheritDoc
   * @internal
   */
  _execute() {
    _remove(Range2._createFromPositionAndShift(this.sourcePosition, this.howMany));
  }
  /**
   * @inheritDoc
   */
  static get className() {
    return "DetachOperation";
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js
var DocumentFragment2 = class _DocumentFragment extends TypeCheckable2 {
  /**
   * Creates an empty `DocumentFragment`.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.
   *
   * @internal
   * @param children Nodes to be contained inside the `DocumentFragment`.
   */
  constructor(children) {
    super();
    this.markers = /* @__PURE__ */ new Map();
    this._children = new NodeList();
    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
   * Returns an iterator that iterates over all nodes contained inside this document fragment.
   */
  [Symbol.iterator]() {
    return this.getChildren();
  }
  /**
   * Number of this document fragment's children.
   */
  get childCount() {
    return this._children.length;
  }
  /**
   * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.
   */
  get maxOffset() {
    return this._children.maxOffset;
  }
  /**
   * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
   */
  get isEmpty() {
    return this.childCount === 0;
  }
  /**
   * Artificial next sibling. Returns `null`. Added for compatibility reasons.
   */
  get nextSibling() {
    return null;
  }
  /**
   * Artificial previous sibling. Returns `null`. Added for compatibility reasons.
   */
  get previousSibling() {
    return null;
  }
  /**
   * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
   */
  get root() {
    return this;
  }
  /**
   * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get parent() {
    return null;
  }
  /**
   * Artificial owner of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
   */
  get document() {
    return null;
  }
  /**
   * Returns `false` as `DocumentFragment` by definition is not attached to a document. Added for compatibility reasons.
   */
  isAttached() {
    return false;
  }
  /**
   * Returns empty array. Added for compatibility reasons.
   */
  getAncestors() {
    return [];
  }
  /**
   * Gets the child at the given index. Returns `null` if incorrect index was passed.
   *
   * @param index Index in this document fragment.
   * @returns Child node.
   */
  getChild(index) {
    return this._children.getNode(index);
  }
  /**
   * Gets the child at the given offset. Returns `null` if incorrect index was passed.
   *
   * @param offset Offset in this document fragment.
   * @returns Child node.
   */
  getChildAtOffset(offset) {
    return this._children.getNodeAtOffset(offset);
  }
  /**
   * Returns an iterator that iterates over all of this document fragment's children.
   */
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  /**
   * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
   *
   * @param node Child node to look for.
   * @returns Child node's index.
   */
  getChildIndex(node) {
    return this._children.getNodeIndex(node);
  }
  /**
   * Returns the starting offset of given child. Starting offset is equal to the sum of
   * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
   * given node is not a child of this document fragment.
   *
   * @param node Child node to look for.
   * @returns Child node's starting offset.
   */
  getChildStartOffset(node) {
    return this._children.getNodeStartOffset(node);
  }
  /**
   * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
   */
  getPath() {
    return [];
  }
  /**
   * Returns a descendant node by its path relative to this element.
   *
   * ```ts
   * // <this>a<b>c</b></this>
   * this.getNodeByPath( [ 0 ] );     // -> "a"
   * this.getNodeByPath( [ 1 ] );     // -> <b>
   * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
   * ```
   *
   * @param relativePath Path of the node to find, relative to this element.
   */
  getNodeByPath(relativePath) {
    let node = this;
    for (const offset of relativePath) {
      node = node.getChildAtOffset(offset);
    }
    return node;
  }
  /**
   * Converts offset "position" to index "position".
   *
   * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
   * too high, returns index after last child.
   *
   * ```ts
   * const textNode = new Text( 'foo' );
   * const pElement = new Element( 'p' );
   * const docFrag = new DocumentFragment( [ textNode, pElement ] );
   * docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
   * docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
   * docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
   * docFrag.offsetToIndex( 2 ); // Returns 0.
   * docFrag.offsetToIndex( 3 ); // Returns 1.
   * docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
   * ```
   *
   * @param offset Offset to look for.
   * @returns Index of a node that occupies given offset.
   */
  offsetToIndex(offset) {
    return this._children.offsetToIndex(offset);
  }
  /**
   * Converts `DocumentFragment` instance to plain object and returns it.
   * Takes care of converting all of this document fragment's children.
   *
   * @returns `DocumentFragment` instance converted to plain object.
   */
  toJSON() {
    const json = [];
    for (const node of this._children) {
      json.push(node.toJSON());
    }
    return json;
  }
  /**
   * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
   * Converts `DocumentFragment` children to proper nodes.
   *
   * @param json Plain object to be converted to `DocumentFragment`.
   * @returns `DocumentFragment` instance created using given plain object.
   */
  static fromJSON(json) {
    const children = [];
    for (const child of json) {
      if (child.name) {
        children.push(Element2.fromJSON(child));
      } else {
        children.push(Text2.fromJSON(child));
      }
    }
    return new _DocumentFragment(children);
  }
  /**
   * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.
   *
   * @internal
   * @param items Items to be inserted.
   */
  _appendChild(items) {
    this._insertChild(this.childCount, items);
  }
  /**
   * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
   * to this document fragment.
   *
   * @internal
   * @param index Index at which nodes should be inserted.
   * @param items Items to be inserted.
   */
  _insertChild(index, items) {
    const nodes = normalize4(items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
    }
    this._children._insertNodes(index, nodes);
  }
  /**
   * Removes one or more nodes starting at the given index
   * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
   *
   * @internal
   * @param index Index of the first node to remove.
   * @param howMany Number of nodes to remove.
   * @returns Array containing removed nodes.
   */
  _removeChildren(index, howMany = 1) {
    const nodes = this._children._removeNodes(index, howMany);
    for (const node of nodes) {
      node.parent = null;
    }
    return nodes;
  }
};
DocumentFragment2.prototype.is = function(type) {
  return type === "documentFragment" || type === "model:documentFragment";
};
function normalize4(nodes) {
  if (typeof nodes == "string") {
    return [new Text2(nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new Text2(node);
    }
    if (node instanceof TextProxy2) {
      return new Text2(node.data, node.getAttributes());
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js
var Writer = class {
  /**
   * Creates a writer instance.
   *
   * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or
   * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.
   *
   * @internal
   */
  constructor(model, batch) {
    this.model = model;
    this.batch = batch;
  }
  /**
   * Creates a new {@link module:engine/model/text~Text text node}.
   *
   * ```ts
   * writer.createText( 'foo' );
   * writer.createText( 'foo', { bold: true } );
   * ```
   *
   * @param data Text data.
   * @param attributes Text attributes.
   * @returns {module:engine/model/text~Text} Created text node.
   */
  createText(data, attributes) {
    return new Text2(data, attributes);
  }
  /**
   * Creates a new {@link module:engine/model/element~Element element}.
   *
   * ```ts
   * writer.createElement( 'paragraph' );
   * writer.createElement( 'paragraph', { alignment: 'center' } );
   * ```
   *
   * @param name Name of the element.
   * @param attributes Elements attributes.
   * @returns Created element.
   */
  createElement(name, attributes) {
    return new Element2(name, attributes);
  }
  /**
   * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
   *
   * @returns Created document fragment.
   */
  createDocumentFragment() {
    return new DocumentFragment2();
  }
  /**
   * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.
   * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
   *
   * @param element The element to clone.
   * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
   * element will be cloned without any child.
   */
  cloneElement(element, deep = true) {
    return element._clone(deep);
  }
  /**
   * Inserts item on given position.
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.insert( paragraph, position );
   * ```
   *
   * Instead of using position you can use parent and offset:
   *
   * ```ts
   * const text = writer.createText( 'foo' );
   * writer.insert( text, paragraph, 5 );
   * ```
   *
   * You can also use `end` instead of the offset to insert at the end:
   *
   * ```ts
   * const text = writer.createText( 'foo' );
   * writer.insert( text, paragraph, 'end' );
   * ```
   *
   * Or insert before or after another element:
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.insert( paragraph, anotherParagraph, 'after' );
   * ```
   *
   * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
   *
   * Note that if the item already has parent it will be removed from the previous parent.
   *
   * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,
   * `model-writer-insert-forbidden-move` is thrown.
   *
   * If you want to move {@link module:engine/model/range~Range range} instead of an
   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
   *
   * **Note:** For a paste-like content insertion mechanism see
   * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.
   *
   * @param item Item or document fragment to insert.
   * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
   */
  insert(item, itemOrPosition, offset = 0) {
    this._assertWriterUsedCorrectly();
    if (item instanceof Text2 && item.data == "") {
      return;
    }
    const position = Position2._createAt(itemOrPosition, offset);
    if (item.parent) {
      if (isSameTree(item.root, position.root)) {
        this.move(Range2._createOn(item), position);
        return;
      } else {
        if (item.root.document) {
          throw new CKEditorError("model-writer-insert-forbidden-move", this);
        } else {
          this.remove(item);
        }
      }
    }
    const version = position.root.document ? position.root.document.version : null;
    const insert = new InsertOperation(position, item, version);
    if (item instanceof Text2) {
      insert.shouldReceiveAttributes = true;
    }
    this.batch.addOperation(insert);
    this.model.applyOperation(insert);
    if (item instanceof DocumentFragment2) {
      for (const [markerName, markerRange] of item.markers) {
        const rangeRootPosition = Position2._createAt(markerRange.root, 0);
        const range = new Range2(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));
        const options = { range, usingOperation: true, affectsData: true };
        if (this.model.markers.has(markerName)) {
          this.updateMarker(markerName, options);
        } else {
          this.addMarker(markerName, options);
        }
      }
    }
  }
  insertText(text2, attributes, itemOrPosition, offset) {
    if (attributes instanceof DocumentFragment2 || attributes instanceof Element2 || attributes instanceof Position2) {
      this.insert(this.createText(text2), attributes, itemOrPosition);
    } else {
      this.insert(this.createText(text2, attributes), itemOrPosition, offset);
    }
  }
  insertElement(name, attributes, itemOrPositionOrOffset, offset) {
    if (attributes instanceof DocumentFragment2 || attributes instanceof Element2 || attributes instanceof Position2) {
      this.insert(this.createElement(name), attributes, itemOrPositionOrOffset);
    } else {
      this.insert(this.createElement(name, attributes), itemOrPositionOrOffset, offset);
    }
  }
  /**
   * Inserts item at the end of the given parent.
   *
   * ```ts
   * const paragraph = writer.createElement( 'paragraph' );
   * writer.append( paragraph, root );
   * ```
   *
   * Note that if the item already has parent it will be removed from the previous parent.
   *
   * If you want to move {@link module:engine/model/range~Range range} instead of an
   * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
   *
   * @param item Item or document fragment to insert.
   */
  append(item, parent) {
    this.insert(item, parent, "end");
  }
  appendText(text2, attributes, parent) {
    if (attributes instanceof DocumentFragment2 || attributes instanceof Element2) {
      this.insert(this.createText(text2), attributes, "end");
    } else {
      this.insert(this.createText(text2, attributes), parent, "end");
    }
  }
  appendElement(name, attributes, parent) {
    if (attributes instanceof DocumentFragment2 || attributes instanceof Element2) {
      this.insert(this.createElement(name), attributes, "end");
    } else {
      this.insert(this.createElement(name, attributes), parent, "end");
    }
  }
  /**
   * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}
   * or on a {@link module:engine/model/range~Range range}.
   *
   * @param key Attribute key.
   * @param value Attribute new value.
   * @param itemOrRange Model item or range on which the attribute will be set.
   */
  setAttribute(key, value, itemOrRange) {
    this._assertWriterUsedCorrectly();
    if (itemOrRange instanceof Range2) {
      const ranges = itemOrRange.getMinimalFlatRanges();
      for (const range of ranges) {
        setAttributeOnRange(this, key, value, range);
      }
    } else {
      setAttributeOnItem(this, key, value, itemOrRange);
    }
  }
  /**
   * Sets values of attributes on a {@link module:engine/model/item~Item model item}
   * or on a {@link module:engine/model/range~Range range}.
   *
   * ```ts
   * writer.setAttributes( {
   * 	bold: true,
   * 	italic: true
   * }, range );
   * ```
   *
   * @param attributes Attributes keys and values.
   * @param itemOrRange Model item or range on which the attributes will be set.
   */
  setAttributes(attributes, itemOrRange) {
    for (const [key, val] of toMap(attributes)) {
      this.setAttribute(key, val, itemOrRange);
    }
  }
  /**
   * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}
   * or from a {@link module:engine/model/range~Range range}.
   *
   * @param key Attribute key.
   * @param itemOrRange Model item or range from which the attribute will be removed.
   */
  removeAttribute(key, itemOrRange) {
    this._assertWriterUsedCorrectly();
    if (itemOrRange instanceof Range2) {
      const ranges = itemOrRange.getMinimalFlatRanges();
      for (const range of ranges) {
        setAttributeOnRange(this, key, null, range);
      }
    } else {
      setAttributeOnItem(this, key, null, itemOrRange);
    }
  }
  /**
   * Removes all attributes from all elements in the range or from the given item.
   *
   * @param itemOrRange Model item or range from which all attributes will be removed.
   */
  clearAttributes(itemOrRange) {
    this._assertWriterUsedCorrectly();
    const removeAttributesFromItem = (item) => {
      for (const attribute of item.getAttributeKeys()) {
        this.removeAttribute(attribute, item);
      }
    };
    if (!(itemOrRange instanceof Range2)) {
      removeAttributesFromItem(itemOrRange);
    } else {
      for (const item of itemOrRange.getItems()) {
        removeAttributesFromItem(item);
      }
    }
  }
  /**
   * Moves all items in the source range to the target position.
   *
   * ```ts
   * writer.move( sourceRange, targetPosition );
   * ```
   *
   * Instead of the target position you can use parent and offset or define that range should be moved to the end
   * or before or after chosen item:
   *
   * ```ts
   * // Moves all items in the range to the paragraph at offset 5:
   * writer.move( sourceRange, paragraph, 5 );
   * // Moves all items in the range to the end of a blockquote:
   * writer.move( sourceRange, blockquote, 'end' );
   * // Moves all items in the range to a position after an image:
   * writer.move( sourceRange, image, 'after' );
   * ```
   *
   * These parameters work the same way as {@link #createPositionAt `writer.createPositionAt()`}.
   *
   * Note that items can be moved only within the same tree. It means that you can move items within the same root
   * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},
   * but you can not move items from document fragment to the document or from one detached element to another. Use
   * {@link module:engine/model/writer~Writer#insert} in such cases.
   *
   * @param range Source range.
   * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
   */
  move(range, itemOrPosition, offset) {
    this._assertWriterUsedCorrectly();
    if (!(range instanceof Range2)) {
      throw new CKEditorError("writer-move-invalid-range", this);
    }
    if (!range.isFlat) {
      throw new CKEditorError("writer-move-range-not-flat", this);
    }
    const position = Position2._createAt(itemOrPosition, offset);
    if (position.isEqual(range.start)) {
      return;
    }
    this._addOperationForAffectedMarkers("move", range);
    if (!isSameTree(range.root, position.root)) {
      throw new CKEditorError("writer-move-different-document", this);
    }
    const version = range.root.document ? range.root.document.version : null;
    const operation = new MoveOperation(range.start, range.end.offset - range.start.offset, position, version);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
  }
  /**
   * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.
   *
   * @param itemOrRange Model item or range to remove.
   */
  remove(itemOrRange) {
    this._assertWriterUsedCorrectly();
    const rangeToRemove = itemOrRange instanceof Range2 ? itemOrRange : Range2._createOn(itemOrRange);
    const ranges = rangeToRemove.getMinimalFlatRanges().reverse();
    for (const flat of ranges) {
      this._addOperationForAffectedMarkers("move", flat);
      applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);
    }
  }
  /**
   * Merges two siblings at the given position.
   *
   * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or
   * `writer-merge-no-element-after` error will be thrown.
   *
   * @param position Position between merged elements.
   */
  merge(position) {
    this._assertWriterUsedCorrectly();
    const nodeBefore = position.nodeBefore;
    const nodeAfter = position.nodeAfter;
    this._addOperationForAffectedMarkers("merge", position);
    if (!(nodeBefore instanceof Element2)) {
      throw new CKEditorError("writer-merge-no-element-before", this);
    }
    if (!(nodeAfter instanceof Element2)) {
      throw new CKEditorError("writer-merge-no-element-after", this);
    }
    if (!position.root.document) {
      this._mergeDetached(position);
    } else {
      this._merge(position);
    }
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  createPositionFromPath(root, path, stickiness) {
    return this.model.createPositionFromPath(root, path, stickiness);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.
   *
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  createPositionAt(itemOrPosition, offset) {
    return this.model.createPositionAt(itemOrPosition, offset);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionAfter(item) {
    return this.model.createPositionAfter(item);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionBefore(item) {
    return this.model.createPositionBefore(item);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.
   *
   * @param start Start position.
   * @param end End position. If not set, range will be collapsed at `start` position.
   */
  createRange(start, end) {
    return this.model.createRange(start, end);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(element) {
    return this.model.createRangeIn(element);
  }
  /**
   * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.
   *
   * @param element Element which is a parent for the range.
   */
  createRangeOn(element) {
    return this.model.createRangeOn(element);
  }
  createSelection(...args) {
    return this.model.createSelection(...args);
  }
  /**
   * Performs merge action in a detached tree.
   *
   * @param position Position between merged elements.
   */
  _mergeDetached(position) {
    const nodeBefore = position.nodeBefore;
    const nodeAfter = position.nodeAfter;
    this.move(Range2._createIn(nodeAfter), Position2._createAt(nodeBefore, "end"));
    this.remove(nodeAfter);
  }
  /**
   * Performs merge action in a non-detached tree.
   *
   * @param position Position between merged elements.
   */
  _merge(position) {
    const targetPosition = Position2._createAt(position.nodeBefore, "end");
    const sourcePosition = Position2._createAt(position.nodeAfter, 0);
    const graveyard = position.root.document.graveyard;
    const graveyardPosition = new Position2(graveyard, [0]);
    const version = position.root.document.version;
    const merge = new MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version);
    this.batch.addOperation(merge);
    this.model.applyOperation(merge);
  }
  /**
   * Renames the given element.
   *
   * @param element The element to rename.
   * @param newName New element name.
   */
  rename(element, newName) {
    this._assertWriterUsedCorrectly();
    if (!(element instanceof Element2)) {
      throw new CKEditorError("writer-rename-not-element-instance", this);
    }
    const version = element.root.document ? element.root.document.version : null;
    const renameOperation = new RenameOperation(Position2._createBefore(element), element.name, newName, version);
    this.batch.addOperation(renameOperation);
    this.model.applyOperation(renameOperation);
  }
  /**
   * Splits elements starting from the given position and going to the top of the model tree as long as given
   * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.
   *
   * The element needs to have a parent. It cannot be a root element nor a document fragment.
   * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.
   *
   * @param position Position of split.
   * @param limitElement Stop splitting when this element will be reached.
   * @returns Split result with properties:
   * * `position` - Position between split elements.
   * * `range` - Range that stars from the end of the first split element and ends at the beginning of the first copy element.
   */
  split(position, limitElement) {
    this._assertWriterUsedCorrectly();
    let splitElement = position.parent;
    if (!splitElement.parent) {
      throw new CKEditorError("writer-split-element-no-parent", this);
    }
    if (!limitElement) {
      limitElement = splitElement.parent;
    }
    if (!position.parent.getAncestors({ includeSelf: true }).includes(limitElement)) {
      throw new CKEditorError("writer-split-invalid-limit-element", this);
    }
    let firstSplitElement;
    let firstCopyElement;
    do {
      const version = splitElement.root.document ? splitElement.root.document.version : null;
      const howMany = splitElement.maxOffset - position.offset;
      const insertionPosition = SplitOperation.getInsertionPosition(position);
      const split = new SplitOperation(position, howMany, insertionPosition, null, version);
      this.batch.addOperation(split);
      this.model.applyOperation(split);
      if (!firstSplitElement && !firstCopyElement) {
        firstSplitElement = splitElement;
        firstCopyElement = position.parent.nextSibling;
      }
      position = this.createPositionAfter(position.parent);
      splitElement = position.parent;
    } while (splitElement !== limitElement);
    return {
      position,
      range: new Range2(Position2._createAt(firstSplitElement, "end"), Position2._createAt(firstCopyElement, 0))
    };
  }
  /**
   * Wraps the given range with the given element or with a new element (if a string was passed).
   *
   * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).
   * If not, an error will be thrown.
   *
   * @param range Range to wrap.
   * @param elementOrString Element or name of element to wrap the range with.
   */
  wrap(range, elementOrString) {
    this._assertWriterUsedCorrectly();
    if (!range.isFlat) {
      throw new CKEditorError("writer-wrap-range-not-flat", this);
    }
    const element = elementOrString instanceof Element2 ? elementOrString : new Element2(elementOrString);
    if (element.childCount > 0) {
      throw new CKEditorError("writer-wrap-element-not-empty", this);
    }
    if (element.parent !== null) {
      throw new CKEditorError("writer-wrap-element-attached", this);
    }
    this.insert(element, range.start);
    const shiftedRange = new Range2(range.start.getShiftedBy(1), range.end.getShiftedBy(1));
    this.move(shiftedRange, Position2._createAt(element, 0));
  }
  /**
   * Unwraps children of the given element  all its children are moved before it and then the element is removed.
   * Throws error if you try to unwrap an element which does not have a parent.
   *
   * @param element Element to unwrap.
   */
  unwrap(element) {
    this._assertWriterUsedCorrectly();
    if (element.parent === null) {
      throw new CKEditorError("writer-unwrap-element-no-parent", this);
    }
    this.move(Range2._createIn(element), this.createPositionAfter(element));
    this.remove(element);
  }
  /**
   * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
   * changes in the document and updates its range automatically, when model tree changes.
   *
   * As the first parameter you can set marker name.
   *
   * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See
   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
   * markers managed by operations and not-managed by operations.
   *
   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
   * `true` when the marker change changes the data returned by the
   * {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
   *
   * Create marker directly base on marker's name:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: false } );
   * ```
   *
   * Create marker using operation:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: true } );
   * ```
   *
   * Create marker that affects the editor data:
   *
   * ```ts
   * addMarker( markerName, { range, usingOperation: false, affectsData: true } );
   * ```
   *
   * Note: For efficiency reasons, it's best to create and keep as little markers as possible.
   *
   * @see module:engine/model/markercollection~Marker
   * @param name Name of a marker to create - must be unique.
   * @param options.usingOperation Flag indicating that the marker should be added by MarkerOperation.
   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
   * @param options.range Marker range.
   * @param options.affectsData Flag indicating that the marker changes the editor data.
   * @returns Marker that was set.
   */
  addMarker(name, options) {
    this._assertWriterUsedCorrectly();
    if (!options || typeof options.usingOperation != "boolean") {
      throw new CKEditorError("writer-addmarker-no-usingoperation", this);
    }
    const usingOperation = options.usingOperation;
    const range = options.range;
    const affectsData = options.affectsData === void 0 ? false : options.affectsData;
    if (this.model.markers.has(name)) {
      throw new CKEditorError("writer-addmarker-marker-exists", this);
    }
    if (!range) {
      throw new CKEditorError("writer-addmarker-no-range", this);
    }
    if (!usingOperation) {
      return this.model.markers._set(name, range, usingOperation, affectsData);
    }
    applyMarkerOperation(this, name, null, range, affectsData);
    return this.model.markers.get(name);
  }
  /**
   * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
   * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the
   * marker's range directly using this method.
   *
   * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique
   * name is created and returned.
   *
   * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model
   * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.
   *
   * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See
   * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
   * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.
   *
   * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
   * `true` when the marker change changes the data returned by
   * the {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
   * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
   * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
   *
   * Update marker directly base on marker's name:
   *
   * ```ts
   * updateMarker( markerName, { range } );
   * ```
   *
   * Update marker using operation:
   *
   * ```ts
   * updateMarker( marker, { range, usingOperation: true } );
   * updateMarker( markerName, { range, usingOperation: true } );
   * ```
   *
   * Change marker's option (start using operations to manage it):
   *
   * ```ts
   * updateMarker( marker, { usingOperation: true } );
   * ```
   *
   * Change marker's option (inform the engine, that the marker does not affect the data anymore):
   *
   * ```ts
   * updateMarker( markerName, { affectsData: false } );
   * ```
   *
   * @see module:engine/model/markercollection~Marker
   * @param markerOrName Name of a marker to update, or a marker instance.
   * @param options If options object is not defined then marker will be refreshed by triggering
   * downcast conversion for this marker with the same data.
   * @param options.range Marker range to update.
   * @param options.usingOperation Flag indicated whether the marker should be added by MarkerOperation.
   * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
   * @param options.affectsData Flag indicating that the marker changes the editor data.
   */
  updateMarker(markerOrName, options) {
    this._assertWriterUsedCorrectly();
    const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    const currentMarker = this.model.markers.get(markerName);
    if (!currentMarker) {
      throw new CKEditorError("writer-updatemarker-marker-not-exists", this);
    }
    if (!options) {
      logWarning("writer-updatemarker-reconvert-using-editingcontroller", { markerName });
      this.model.markers._refresh(currentMarker);
      return;
    }
    const hasUsingOperationDefined = typeof options.usingOperation == "boolean";
    const affectsDataDefined = typeof options.affectsData == "boolean";
    const affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;
    if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {
      throw new CKEditorError("writer-updatemarker-wrong-options", this);
    }
    const currentRange = currentMarker.getRange();
    const updatedRange = options.range ? options.range : currentRange;
    if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {
      if (options.usingOperation) {
        applyMarkerOperation(this, markerName, null, updatedRange, affectsData);
      } else {
        applyMarkerOperation(this, markerName, currentRange, null, affectsData);
        this.model.markers._set(markerName, updatedRange, void 0, affectsData);
      }
      return;
    }
    if (currentMarker.managedUsingOperations) {
      applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);
    } else {
      this.model.markers._set(markerName, updatedRange, void 0, affectsData);
    }
  }
  /**
   * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
   * The marker is removed accordingly to how it has been created, so if the marker was created using operation,
   * it will be destroyed using operation.
   *
   * @param markerOrName Marker or marker name to remove.
   */
  removeMarker(markerOrName) {
    this._assertWriterUsedCorrectly();
    const name = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    if (!this.model.markers.has(name)) {
      throw new CKEditorError("writer-removemarker-no-marker", this);
    }
    const marker = this.model.markers.get(name);
    if (!marker.managedUsingOperations) {
      this.model.markers._remove(name);
      return;
    }
    const oldRange = marker.getRange();
    applyMarkerOperation(this, name, oldRange, null, marker.affectsData);
  }
  /**
   * Adds a new root to the document (or re-attaches a {@link #detachRoot detached root}).
   *
   * Throws an error, if trying to add a root that is already added and attached.
   *
   * @param rootName Name of the added root.
   * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
   * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
   * @returns The added root element.
   */
  addRoot(rootName, elementName = "$root") {
    this._assertWriterUsedCorrectly();
    const root = this.model.document.getRoot(rootName);
    if (root && root.isAttached()) {
      throw new CKEditorError("writer-addroot-root-exists", this);
    }
    const document2 = this.model.document;
    const operation = new RootOperation(rootName, elementName, true, document2, document2.version);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
    return this.model.document.getRoot(rootName);
  }
  /**
   * Detaches the root from the document.
   *
   * All content and markers are removed from the root upon detaching. New content and new markers cannot be added to the root, as long
   * as it is detached.
   *
   * A root cannot be fully removed from the document, it can be only detached. A root is permanently removed only after you
   * re-initialize the editor and do not specify the root in the initial data.
   *
   * A detached root can be re-attached using {@link #addRoot}.
   *
   * Throws an error if the root does not exist or the root is already detached.
   *
   * @param rootOrName Name of the detached root.
   */
  detachRoot(rootOrName) {
    this._assertWriterUsedCorrectly();
    const root = typeof rootOrName == "string" ? this.model.document.getRoot(rootOrName) : rootOrName;
    if (!root || !root.isAttached()) {
      throw new CKEditorError("writer-detachroot-no-root", this);
    }
    for (const marker of this.model.markers) {
      if (marker.getRange().root === root) {
        this.removeMarker(marker);
      }
    }
    for (const key of root.getAttributeKeys()) {
      this.removeAttribute(key, root);
    }
    this.remove(this.createRangeIn(root));
    const document2 = this.model.document;
    const operation = new RootOperation(root.rootName, root.name, false, document2, document2.version);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
  }
  setSelection(...args) {
    this._assertWriterUsedCorrectly();
    this.model.document.selection._setTo(...args);
  }
  /**
   * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
   *
   * The location can be specified in the same form as
   * {@link #createPositionAt `writer.createPositionAt()`} parameters.
   *
   * @param itemOrPosition
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  setSelectionFocus(itemOrPosition, offset) {
    this._assertWriterUsedCorrectly();
    this.model.document.selection._setFocus(itemOrPosition, offset);
  }
  setSelectionAttribute(keyOrObjectOrIterable, value) {
    this._assertWriterUsedCorrectly();
    if (typeof keyOrObjectOrIterable === "string") {
      this._setSelectionAttribute(keyOrObjectOrIterable, value);
    } else {
      for (const [key, value2] of toMap(keyOrObjectOrIterable)) {
        this._setSelectionAttribute(key, value2);
      }
    }
  }
  /**
   * Removes attribute(s) with given key(s) from the selection.
   *
   * Remove one attribute:
   *
   * ```ts
   * writer.removeSelectionAttribute( 'italic' );
   * ```
   *
   * Remove multiple attributes:
   *
   * ```ts
   * writer.removeSelectionAttribute( [ 'italic', 'bold' ] );
   * ```
   *
   * @param keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.
   */
  removeSelectionAttribute(keyOrIterableOfKeys) {
    this._assertWriterUsedCorrectly();
    if (typeof keyOrIterableOfKeys === "string") {
      this._removeSelectionAttribute(keyOrIterableOfKeys);
    } else {
      for (const key of keyOrIterableOfKeys) {
        this._removeSelectionAttribute(key);
      }
    }
  }
  /**
   * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}
   * of the selection from left to right.
   *
   * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,
   * then the selection (after being moved by the user) inherits attributes from its left-hand side.
   * This method allows to temporarily override this behavior by forcing the gravity to the right.
   *
   * For the following model fragment:
   *
   * ```xml
   * <$text bold="true" linkHref="url">bar[]</$text><$text bold="true">biz</$text>
   * ```
   *
   * * Default gravity: selection will have the `bold` and `linkHref` attributes.
   * * Overridden gravity: selection will have `bold` attribute.
   *
   * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
   * of the process.
   *
   * @returns The unique id which allows restoring the gravity.
   */
  overrideSelectionGravity() {
    return this.model.document.selection._overrideGravity();
  }
  /**
   * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.
   *
   * Restoring the gravity is only possible using the unique identifier returned by
   * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored
   * the same number of times it was overridden.
   *
   * @param uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.
   */
  restoreSelectionGravity(uid2) {
    this.model.document.selection._restoreGravity(uid2);
  }
  /**
   * @param key Key of the attribute to remove.
   * @param value Attribute value.
   */
  _setSelectionAttribute(key, value) {
    const selection = this.model.document.selection;
    if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
      const storeKey = DocumentSelection2._getStoreAttributeKey(key);
      this.setAttribute(storeKey, value, selection.anchor.parent);
    }
    selection._setAttribute(key, value);
  }
  /**
   * @param key Key of the attribute to remove.
   */
  _removeSelectionAttribute(key) {
    const selection = this.model.document.selection;
    if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
      const storeKey = DocumentSelection2._getStoreAttributeKey(key);
      this.removeAttribute(storeKey, selection.anchor.parent);
    }
    selection._removeAttribute(key);
  }
  /**
   * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.
   */
  _assertWriterUsedCorrectly() {
    if (this.model._currentWriter !== this) {
      throw new CKEditorError("writer-incorrect-use", this);
    }
  }
  /**
   * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers
   * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range
   * can be later correctly processed during undo.
   *
   * @param type Writer action type.
   * @param positionOrRange Position or range where the writer action happens.
   */
  _addOperationForAffectedMarkers(type, positionOrRange) {
    for (const marker of this.model.markers) {
      if (!marker.managedUsingOperations) {
        continue;
      }
      const markerRange = marker.getRange();
      let isAffected = false;
      if (type === "move") {
        const range = positionOrRange;
        isAffected = range.containsPosition(markerRange.start) || range.start.isEqual(markerRange.start) || range.containsPosition(markerRange.end) || range.end.isEqual(markerRange.end);
      } else {
        const position = positionOrRange;
        const elementBefore = position.nodeBefore;
        const elementAfter = position.nodeAfter;
        const affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;
        const affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;
        const affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;
        const affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;
        isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;
      }
      if (isAffected) {
        this.updateMarker(marker.name, { range: markerRange });
      }
    }
  }
};
function setAttributeOnRange(writer, key, value, range) {
  const model = writer.model;
  const doc = model.document;
  let lastSplitPosition = range.start;
  let position;
  let valueBefore;
  let valueAfter;
  for (const val of range.getWalker({ shallow: true })) {
    valueAfter = val.item.getAttribute(key);
    if (position && valueBefore != valueAfter) {
      if (valueBefore != value) {
        addOperation();
      }
      lastSplitPosition = position;
    }
    position = val.nextPosition;
    valueBefore = valueAfter;
  }
  if (position instanceof Position2 && position != lastSplitPosition && valueBefore != value) {
    addOperation();
  }
  function addOperation() {
    const range2 = new Range2(lastSplitPosition, position);
    const version = range2.root.document ? doc.version : null;
    const operation = new AttributeOperation(range2, key, valueBefore, value, version);
    writer.batch.addOperation(operation);
    model.applyOperation(operation);
  }
}
function setAttributeOnItem(writer, key, value, item) {
  const model = writer.model;
  const doc = model.document;
  const previousValue = item.getAttribute(key);
  let range, operation;
  if (previousValue != value) {
    const isRootChanged = item.root === item;
    if (isRootChanged) {
      const version = item.document ? doc.version : null;
      operation = new RootAttributeOperation(item, key, previousValue, value, version);
    } else {
      range = new Range2(Position2._createBefore(item), writer.createPositionAfter(item));
      const version = range.root.document ? doc.version : null;
      operation = new AttributeOperation(range, key, previousValue, value, version);
    }
    writer.batch.addOperation(operation);
    model.applyOperation(operation);
  }
}
function applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {
  const model = writer.model;
  const doc = model.document;
  const operation = new MarkerOperation(name, oldRange, newRange, model.markers, !!affectsData, doc.version);
  writer.batch.addOperation(operation);
  model.applyOperation(operation);
}
function applyRemoveOperation(position, howMany, batch, model) {
  let operation;
  if (position.root.document) {
    const doc = model.document;
    const graveyardPosition = new Position2(doc.graveyard, [0]);
    operation = new MoveOperation(position, howMany, graveyardPosition, doc.version);
  } else {
    operation = new DetachOperation(position, howMany);
  }
  batch.addOperation(operation);
  model.applyOperation(operation);
}
function isSameTree(rootA, rootB) {
  if (rootA === rootB) {
    return true;
  }
  if (rootA instanceof RootElement && rootB instanceof RootElement) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js
function deleteContent(model, selection, options = {}) {
  if (selection.isCollapsed) {
    return;
  }
  const selRange = selection.getFirstRange();
  if (selRange.root.rootName == "$graveyard") {
    return;
  }
  const schema = model.schema;
  model.change((writer) => {
    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {
      replaceEntireContentWithParagraph(writer, selection);
      return;
    }
    const attributesForAutoparagraph = {};
    if (!options.doNotAutoparagraph) {
      const selectedElement = selection.getSelectedElement();
      if (selectedElement) {
        Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, "copyOnReplace", true));
      }
    }
    const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange);
    if (!startPosition.isTouching(endPosition)) {
      writer.remove(writer.createRange(startPosition, endPosition));
    }
    if (!options.leaveUnmerged) {
      mergeBranches(writer, startPosition, endPosition);
      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);
    }
    collapseSelectionAt(writer, selection, startPosition);
    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {
      insertParagraph(writer, startPosition, selection, attributesForAutoparagraph);
    }
    startPosition.detach();
    endPosition.detach();
  });
}
function getLivePositionsForSelectedBlocks(range) {
  const model = range.root.document.model;
  const startPosition = range.start;
  let endPosition = range.end;
  if (model.hasContent(range, { ignoreMarkers: true })) {
    const endBlock = getParentBlock2(endPosition);
    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {
      const selection = model.createSelection(range);
      model.modifySelection(selection, { direction: "backward" });
      const newEndPosition = selection.getLastPosition();
      const skippedRange = model.createRange(newEndPosition, endPosition);
      if (!model.hasContent(skippedRange, { ignoreMarkers: true })) {
        endPosition = newEndPosition;
      }
    }
  }
  return [
    LivePosition.fromPosition(startPosition, "toPrevious"),
    LivePosition.fromPosition(endPosition, "toNext")
  ];
}
function getParentBlock2(position) {
  const element = position.parent;
  const schema = element.root.document.model.schema;
  const ancestors = element.getAncestors({ parentFirst: true, includeSelf: true });
  for (const element2 of ancestors) {
    if (schema.isLimit(element2)) {
      return null;
    }
    if (schema.isBlock(element2)) {
      return element2;
    }
  }
}
function mergeBranches(writer, startPosition, endPosition) {
  const model = writer.model;
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition);
  if (!startAncestor || !endAncestor) {
    return;
  }
  if (!model.hasContent(startAncestor, { ignoreMarkers: true }) && model.hasContent(endAncestor, { ignoreMarkers: true })) {
    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);
  } else {
    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);
  }
}
function mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == commonAncestor || endElement == commonAncestor) {
    return;
  }
  startPosition = writer.createPositionAfter(startElement);
  endPosition = writer.createPositionBefore(endElement);
  if (!endPosition.isEqual(startPosition)) {
    writer.insert(endElement, startPosition);
  }
  writer.merge(startPosition);
  while (endPosition.parent.isEmpty) {
    const parentToRemove = endPosition.parent;
    endPosition = writer.createPositionBefore(parentToRemove);
    writer.remove(parentToRemove);
  }
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);
}
function mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == commonAncestor || endElement == commonAncestor) {
    return;
  }
  startPosition = writer.createPositionAfter(startElement);
  endPosition = writer.createPositionBefore(endElement);
  if (!endPosition.isEqual(startPosition)) {
    writer.insert(startElement, endPosition);
  }
  while (startPosition.parent.isEmpty) {
    const parentToRemove = startPosition.parent;
    startPosition = writer.createPositionBefore(parentToRemove);
    writer.remove(parentToRemove);
  }
  endPosition = writer.createPositionBefore(endElement);
  mergeRight(writer, endPosition);
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);
}
function mergeRight(writer, position) {
  const startElement = position.nodeBefore;
  const endElement = position.nodeAfter;
  if (startElement.name != endElement.name) {
    writer.rename(startElement, endElement.name);
  }
  writer.clearAttributes(startElement);
  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);
  writer.merge(position);
}
function checkShouldMerge(schema, startPosition, endPosition) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == endElement) {
    return false;
  }
  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
    return false;
  }
  return isCrossingLimitElement(startPosition, endPosition, schema);
}
function getAncestorsJustBelowCommonAncestor(positionA, positionB) {
  const ancestorsA = positionA.getAncestors();
  const ancestorsB = positionB.getAncestors();
  let i = 0;
  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {
    i++;
  }
  return [ancestorsA[i], ancestorsB[i]];
}
function shouldAutoparagraph(schema, position) {
  const isTextAllowed = schema.checkChild(position, "$text");
  const isParagraphAllowed = schema.checkChild(position, "paragraph");
  return !isTextAllowed && isParagraphAllowed;
}
function isCrossingLimitElement(leftPos, rightPos, schema) {
  const rangeToCheck = new Range2(leftPos, rightPos);
  for (const value of rangeToCheck.getWalker()) {
    if (schema.isLimit(value.item)) {
      return false;
    }
  }
  return true;
}
function insertParagraph(writer, position, selection, attributes = {}) {
  const paragraph2 = writer.createElement("paragraph");
  writer.model.schema.setAllowedAttributes(paragraph2, attributes, writer);
  writer.insert(paragraph2, position);
  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph2, 0));
}
function replaceEntireContentWithParagraph(writer, selection) {
  const limitElement = writer.model.schema.getLimitElement(selection);
  writer.remove(writer.createRangeIn(limitElement));
  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);
}
function shouldEntireContentBeReplacedWithParagraph(schema, selection) {
  const limitElement = schema.getLimitElement(selection);
  if (!selection.containsEntireContent(limitElement)) {
    return false;
  }
  const range = selection.getFirstRange();
  if (range.start.parent == range.end.parent) {
    return false;
  }
  return schema.checkChild(limitElement, "paragraph");
}
function collapseSelectionAt(writer, selection, positionOrRange) {
  if (selection instanceof DocumentSelection2) {
    writer.setSelection(positionOrRange);
  } else {
    selection.setTo(positionOrRange);
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/getselectedcontent.js
function getSelectedContent(model, selection) {
  return model.change((writer) => {
    const frag = writer.createDocumentFragment();
    const range = selection.getFirstRange();
    if (!range || range.isCollapsed) {
      return frag;
    }
    const root = range.start.root;
    const commonPath = range.start.getCommonPath(range.end);
    const commonParent = root.getNodeByPath(commonPath);
    let flatSubtreeRange;
    if (range.start.parent == range.end.parent) {
      flatSubtreeRange = range;
    } else {
      flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range.start.path[commonPath.length]), writer.createPositionAt(commonParent, range.end.path[commonPath.length] + 1));
    }
    const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;
    for (const item of flatSubtreeRange.getItems({ shallow: true })) {
      if (item.is("$textProxy")) {
        writer.appendText(item.data, item.getAttributes(), frag);
      } else {
        writer.append(writer.cloneElement(item, true), frag);
      }
    }
    if (flatSubtreeRange != range) {
      const newRange = range._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];
      const leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);
      const rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, "end"));
      removeRangeContent(rightExcessRange, writer);
      removeRangeContent(leftExcessRange, writer);
    }
    return frag;
  });
}
function removeRangeContent(range, writer) {
  const parentsToCheck = [];
  Array.from(range.getItems({ direction: "backward" })).map((item) => writer.createRangeOn(item)).filter((itemRange) => {
    const contained = (itemRange.start.isAfter(range.start) || itemRange.start.isEqual(range.start)) && (itemRange.end.isBefore(range.end) || itemRange.end.isEqual(range.end));
    return contained;
  }).forEach((itemRange) => {
    parentsToCheck.push(itemRange.start.parent);
    writer.remove(itemRange);
  });
  parentsToCheck.forEach((parentToCheck) => {
    let parent = parentToCheck;
    while (parent.parent && parent.isEmpty) {
      const removeRange = writer.createRangeOn(parent);
      parent = parent.parent;
      writer.remove(removeRange);
    }
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js
function insertContent(model, content, selectable) {
  return model.change((writer) => {
    const selection = selectable ? selectable : model.document.selection;
    if (!selection.isCollapsed) {
      model.deleteContent(selection, { doNotAutoparagraph: true });
    }
    const insertion = new Insertion(model, writer, selection.anchor);
    const fakeMarkerElements = [];
    let nodesToInsert;
    if (content.is("documentFragment")) {
      if (content.markers.size) {
        const markersPosition = [];
        for (const [name, range] of content.markers) {
          const { start, end } = range;
          const isCollapsed = start.isEqual(end);
          markersPosition.push({ position: start, name, isCollapsed }, { position: end, name, isCollapsed });
        }
        markersPosition.sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
        for (const { position, name, isCollapsed } of markersPosition) {
          let fakeElement = null;
          let collapsed = null;
          const isAtBeginning = position.parent === content && position.isAtStart;
          const isAtEnd = position.parent === content && position.isAtEnd;
          if (!isAtBeginning && !isAtEnd) {
            fakeElement = writer.createElement("$marker");
            writer.insert(fakeElement, position);
          } else if (isCollapsed) {
            collapsed = isAtBeginning ? "start" : "end";
          }
          fakeMarkerElements.push({
            name,
            element: fakeElement,
            collapsed
          });
        }
      }
      nodesToInsert = content.getChildren();
    } else {
      nodesToInsert = [content];
    }
    insertion.handleNodes(nodesToInsert);
    let newRange = insertion.getSelectionRange();
    if (content.is("documentFragment") && fakeMarkerElements.length) {
      const selectionLiveRange = newRange ? LiveRange.fromRange(newRange) : null;
      const markersData = {};
      for (let i = fakeMarkerElements.length - 1; i >= 0; i--) {
        const { name, element, collapsed } = fakeMarkerElements[i];
        const isStartBoundary = !markersData[name];
        if (isStartBoundary) {
          markersData[name] = [];
        }
        if (element) {
          const elementPosition = writer.createPositionAt(element, "before");
          markersData[name].push(elementPosition);
          writer.remove(element);
        } else {
          const rangeOnInsertion = insertion.getAffectedRange();
          if (!rangeOnInsertion) {
            if (collapsed) {
              markersData[name].push(insertion.position);
            }
            continue;
          }
          if (collapsed) {
            markersData[name].push(rangeOnInsertion[collapsed]);
          } else {
            markersData[name].push(isStartBoundary ? rangeOnInsertion.start : rangeOnInsertion.end);
          }
        }
      }
      for (const [name, [start, end]] of Object.entries(markersData)) {
        if (start && end && start.root === end.root && start.root.document && !writer.model.markers.has(name)) {
          writer.addMarker(name, {
            usingOperation: true,
            affectsData: true,
            range: new Range2(start, end)
          });
        }
      }
      if (selectionLiveRange) {
        newRange = selectionLiveRange.toRange();
        selectionLiveRange.detach();
      }
    }
    if (newRange) {
      if (selection instanceof DocumentSelection2) {
        writer.setSelection(newRange);
      } else {
        selection.setTo(newRange);
      }
    } else {
    }
    const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);
    insertion.destroy();
    return affectedRange;
  });
}
var Insertion = class {
  constructor(model, writer, position) {
    this._firstNode = null;
    this._lastNode = null;
    this._lastAutoParagraph = null;
    this._filterAttributesOf = [];
    this._affectedStart = null;
    this._affectedEnd = null;
    this._nodeToSelect = null;
    this.model = model;
    this.writer = writer;
    this.position = position;
    this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]);
    this.schema = model.schema;
    this._documentFragment = writer.createDocumentFragment();
    this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);
  }
  /**
   * Handles insertion of a set of nodes.
   *
   * @param nodes Nodes to insert.
   */
  handleNodes(nodes) {
    for (const node of Array.from(nodes)) {
      this._handleNode(node);
    }
    this._insertPartialFragment();
    if (this._lastAutoParagraph) {
      this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);
    }
    this._mergeOnRight();
    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
    this._filterAttributesOf = [];
  }
  /**
   * Updates the last node after the auto paragraphing.
   *
   * @param node The last auto paragraphing node.
   */
  _updateLastNodeFromAutoParagraph(node) {
    const positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);
    const positionAfterNode = this.writer.createPositionAfter(node);
    if (positionAfterNode.isAfter(positionAfterLastNode)) {
      this._lastNode = node;
      if (this.position.parent != node || !this.position.isAtEnd) {
        throw new CKEditorError("insertcontent-invalid-insertion-position", this);
      }
      this.position = positionAfterNode;
      this._setAffectedBoundaries(this.position);
    }
  }
  /**
   * Returns range to be selected after insertion.
   * Returns `null` if there is no valid range to select after insertion.
   */
  getSelectionRange() {
    if (this._nodeToSelect) {
      return Range2._createOn(this._nodeToSelect);
    }
    return this.model.schema.getNearestSelectionRange(this.position);
  }
  /**
   * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state
   * before the insertion. Returns `null` if no changes were done.
   */
  getAffectedRange() {
    if (!this._affectedStart) {
      return null;
    }
    return new Range2(this._affectedStart, this._affectedEnd);
  }
  /**
   * Destroys `Insertion` instance.
   */
  destroy() {
    if (this._affectedStart) {
      this._affectedStart.detach();
    }
    if (this._affectedEnd) {
      this._affectedEnd.detach();
    }
  }
  /**
   * Handles insertion of a single node.
   */
  _handleNode(node) {
    if (!this._checkAndSplitToAllowedPosition(node)) {
      if (!this.schema.isObject(node)) {
        this._handleDisallowedNode(node);
      }
      return;
    }
    this._appendToFragment(node);
    if (!this._firstNode) {
      this._firstNode = node;
    }
    this._lastNode = node;
  }
  /**
   * Inserts the temporary DocumentFragment into the model.
   */
  _insertPartialFragment() {
    if (this._documentFragment.isEmpty) {
      return;
    }
    const livePosition = LivePosition.fromPosition(this.position, "toNext");
    this._setAffectedBoundaries(this.position);
    if (this._documentFragment.getChild(0) == this._firstNode) {
      this.writer.insert(this._firstNode, this.position);
      this._mergeOnLeft();
      this.position = livePosition.toPosition();
    }
    if (!this._documentFragment.isEmpty) {
      this.writer.insert(this._documentFragment, this.position);
    }
    this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);
    this.position = livePosition.toPosition();
    livePosition.detach();
  }
  /**
   * @param node The disallowed node which needs to be handled.
   */
  _handleDisallowedNode(node) {
    if (node.is("element")) {
      this.handleNodes(node.getChildren());
    }
  }
  /**
   * Append a node to the temporary DocumentFragment.
   *
   * @param node The node to insert.
   */
  _appendToFragment(node) {
    if (!this.schema.checkChild(this.position, node)) {
      throw new CKEditorError("insertcontent-wrong-position", this, { node, position: this.position });
    }
    this.writer.insert(node, this._documentFragmentPosition);
    this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize);
    if (this.schema.isObject(node) && !this.schema.checkChild(this.position, "$text")) {
      this._nodeToSelect = node;
    } else {
      this._nodeToSelect = null;
    }
    this._filterAttributesOf.push(node);
  }
  /**
   * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to
   * mark the affected range.
   *
   * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed
   * during merging, but the logic there is more complicated so it is left out of this function.
   */
  _setAffectedBoundaries(position) {
    if (!this._affectedStart) {
      this._affectedStart = LivePosition.fromPosition(position, "toPrevious");
    }
    if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {
      if (this._affectedEnd) {
        this._affectedEnd.detach();
      }
      this._affectedEnd = LivePosition.fromPosition(position, "toNext");
    }
  }
  /**
   * Merges the previous sibling of the first node if it should be merged.
   *
   * After the content was inserted we may try to merge it with its siblings.
   * This should happen only if the selection was in those elements initially.
   */
  _mergeOnLeft() {
    const node = this._firstNode;
    if (!(node instanceof Element2)) {
      return;
    }
    if (!this._canMergeLeft(node)) {
      return;
    }
    const mergePosLeft = LivePosition._createBefore(node);
    mergePosLeft.stickiness = "toNext";
    const livePosition = LivePosition.fromPosition(this.position, "toNext");
    if (this._affectedStart.isEqual(mergePosLeft)) {
      this._affectedStart.detach();
      this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, "end", "toPrevious");
    }
    if (this._firstNode === this._lastNode) {
      this._firstNode = mergePosLeft.nodeBefore;
      this._lastNode = mergePosLeft.nodeBefore;
    }
    this.writer.merge(mergePosLeft);
    if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
      this._affectedEnd.detach();
      this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, "end", "toNext");
    }
    this.position = livePosition.toPosition();
    livePosition.detach();
    this._filterAttributesOf.push(this.position.parent);
    mergePosLeft.detach();
  }
  /**
   * Merges the next sibling of the last node if it should be merged.
   *
   * After the content was inserted we may try to merge it with its siblings.
   * This should happen only if the selection was in those elements initially.
   */
  _mergeOnRight() {
    const node = this._lastNode;
    if (!(node instanceof Element2)) {
      return;
    }
    if (!this._canMergeRight(node)) {
      return;
    }
    const mergePosRight = LivePosition._createAfter(node);
    mergePosRight.stickiness = "toNext";
    if (!this.position.isEqual(mergePosRight)) {
      throw new CKEditorError("insertcontent-invalid-insertion-position", this);
    }
    this.position = Position2._createAt(mergePosRight.nodeBefore, "end");
    const livePosition = LivePosition.fromPosition(this.position, "toPrevious");
    if (this._affectedEnd.isEqual(mergePosRight)) {
      this._affectedEnd.detach();
      this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, "end", "toNext");
    }
    if (this._firstNode === this._lastNode) {
      this._firstNode = mergePosRight.nodeBefore;
      this._lastNode = mergePosRight.nodeBefore;
    }
    this.writer.merge(mergePosRight);
    if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {
      this._affectedStart.detach();
      this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, "toPrevious");
    }
    this.position = livePosition.toPosition();
    livePosition.detach();
    this._filterAttributesOf.push(this.position.parent);
    mergePosRight.detach();
  }
  /**
   * Checks whether specified node can be merged with previous sibling element.
   *
   * @param node The node which could potentially be merged.
   */
  _canMergeLeft(node) {
    const previousSibling = node.previousSibling;
    return previousSibling instanceof Element2 && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);
  }
  /**
   * Checks whether specified node can be merged with next sibling element.
   *
   * @param node The node which could potentially be merged.
   */
  _canMergeRight(node) {
    const nextSibling = node.nextSibling;
    return nextSibling instanceof Element2 && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);
  }
  /**
   * Inserts a paragraph and moves the insertion position into it.
   */
  _insertAutoParagraph() {
    this._insertPartialFragment();
    const paragraph2 = this.writer.createElement("paragraph");
    this.writer.insert(paragraph2, this.position);
    this._setAffectedBoundaries(this.position);
    this._lastAutoParagraph = paragraph2;
    this.position = this.writer.createPositionAt(paragraph2, 0);
  }
  /**
   * @returns Whether an allowed position was found.
   * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
   */
  _checkAndSplitToAllowedPosition(node) {
    const allowedIn = this._getAllowedIn(this.position.parent, node);
    if (!allowedIn) {
      return false;
    }
    if (allowedIn != this.position.parent) {
      this._insertPartialFragment();
    }
    while (allowedIn != this.position.parent) {
      if (this.position.isAtStart) {
        const parent = this.position.parent;
        this.position = this.writer.createPositionBefore(parent);
        if (parent.isEmpty && parent.parent === allowedIn) {
          this.writer.remove(parent);
        }
      } else if (this.position.isAtEnd) {
        this.position = this.writer.createPositionAfter(this.position.parent);
      } else {
        const tempPos = this.writer.createPositionAfter(this.position.parent);
        this._setAffectedBoundaries(this.position);
        this.writer.split(this.position);
        this.position = tempPos;
        this.canMergeWith.add(this.position.nodeAfter);
      }
    }
    if (!this.schema.checkChild(this.position.parent, node)) {
      this._insertAutoParagraph();
    }
    return true;
  }
  /**
   * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
   *
   * It also verifies if auto-paragraphing could help.
   *
   * @param contextElement The element in which context the node should be checked.
   * @param childNode The node to check.
   */
  _getAllowedIn(contextElement, childNode) {
    if (this.schema.checkChild(contextElement, childNode)) {
      return contextElement;
    }
    if (this.schema.checkChild(contextElement, "paragraph") && this.schema.checkChild("paragraph", childNode)) {
      return contextElement;
    }
    if (this.schema.isLimit(contextElement)) {
      return null;
    }
    return this._getAllowedIn(contextElement.parent, childNode);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertobject.js
function insertObject(model, object, selectable, options = {}) {
  if (!model.schema.isObject(object)) {
    throw new CKEditorError("insertobject-element-not-an-object", model, { object });
  }
  const originalSelection = selectable ? selectable : model.document.selection;
  let insertionSelection = originalSelection;
  if (options.findOptimalPosition && model.schema.isBlock(object)) {
    insertionSelection = model.createSelection(model.schema.findOptimalInsertionRange(originalSelection, options.findOptimalPosition));
  }
  const firstSelectedBlock = first(originalSelection.getSelectedBlocks());
  const attributesToCopy = {};
  if (firstSelectedBlock) {
    Object.assign(attributesToCopy, model.schema.getAttributesWithProperty(firstSelectedBlock, "copyOnReplace", true));
  }
  return model.change((writer) => {
    if (!insertionSelection.isCollapsed) {
      model.deleteContent(insertionSelection, { doNotAutoparagraph: true });
    }
    let elementToInsert = object;
    const insertionPositionParent = insertionSelection.anchor.parent;
    if (!model.schema.checkChild(insertionPositionParent, object) && model.schema.checkChild(insertionPositionParent, "paragraph") && model.schema.checkChild("paragraph", object)) {
      elementToInsert = writer.createElement("paragraph");
      writer.insert(object, elementToInsert);
    }
    model.schema.setAllowedAttributes(elementToInsert, attributesToCopy, writer);
    const affectedRange = model.insertContent(elementToInsert, insertionSelection);
    if (affectedRange.isCollapsed) {
      return affectedRange;
    }
    if (options.setSelection) {
      updateSelection(writer, object, options.setSelection, attributesToCopy);
    }
    return affectedRange;
  });
}
function updateSelection(writer, contextElement, place, paragraphAttributes) {
  const model = writer.model;
  if (place == "on") {
    writer.setSelection(contextElement, "on");
    return;
  }
  if (place != "after") {
    throw new CKEditorError("insertobject-invalid-place-parameter-value", model);
  }
  let nextElement = contextElement.nextSibling;
  if (model.schema.isInline(contextElement)) {
    writer.setSelection(contextElement, "after");
    return;
  }
  const canSetSelection = nextElement && model.schema.checkChild(nextElement, "$text");
  if (!canSetSelection && model.schema.checkChild(contextElement.parent, "paragraph")) {
    nextElement = writer.createElement("paragraph");
    model.schema.setAllowedAttributes(nextElement, paragraphAttributes, writer);
    model.insertContent(nextElement, writer.createPositionAfter(contextElement));
  }
  if (nextElement) {
    writer.setSelection(nextElement, 0);
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/modifyselection.js
var wordBoundaryCharacters = ' ,.?!:;"-()';
function modifySelection(model, selection, options = {}) {
  const schema = model.schema;
  const isForward = options.direction != "backward";
  const unit = options.unit ? options.unit : "character";
  const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;
  const focus = selection.focus;
  const walker = new TreeWalker2({
    boundaries: getSearchRange(focus, isForward),
    singleCharacters: true,
    direction: isForward ? "forward" : "backward"
  });
  const data = { walker, schema, isForward, unit, treatEmojiAsSingleUnit };
  let next;
  while (next = walker.next()) {
    if (next.done) {
      return;
    }
    const position = tryExtendingTo(data, next.value);
    if (position) {
      if (selection instanceof DocumentSelection2) {
        model.change((writer) => {
          writer.setSelectionFocus(position);
        });
      } else {
        selection.setFocus(position);
      }
      return;
    }
  }
}
function tryExtendingTo(data, value) {
  const { isForward, walker, unit, schema, treatEmojiAsSingleUnit } = data;
  const { type, item, nextPosition } = value;
  if (type == "text") {
    if (data.unit === "word") {
      return getCorrectWordBreakPosition(walker, isForward);
    }
    return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);
  }
  if (type == (isForward ? "elementStart" : "elementEnd")) {
    if (schema.isSelectable(item)) {
      return Position2._createAt(item, isForward ? "after" : "before");
    }
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  } else {
    if (schema.isLimit(item)) {
      walker.skip(() => true);
      return;
    }
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  }
}
function getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {
  const textNode = walker.position.textNode;
  if (textNode) {
    const data = textNode.data;
    let offset = walker.position.offset - textNode.startOffset;
    while (isInsideSurrogatePair(data, offset) || unit == "character" && isInsideCombinedSymbol(data, offset) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset)) {
      walker.next();
      offset = walker.position.offset - textNode.startOffset;
    }
  }
  return walker.position;
}
function getCorrectWordBreakPosition(walker, isForward) {
  let textNode = walker.position.textNode;
  if (!textNode) {
    textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
  }
  while (textNode && textNode.is("$text")) {
    const offset = walker.position.offset - textNode.startOffset;
    if (isAtNodeBoundary(textNode, offset, isForward)) {
      textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
    } else if (isAtWordBoundary(textNode.data, offset, isForward)) {
      break;
    } else {
      walker.next();
    }
  }
  return walker.position;
}
function getSearchRange(start, isForward) {
  const root = start.root;
  const searchEnd = Position2._createAt(root, isForward ? "end" : 0);
  if (isForward) {
    return new Range2(start, searchEnd);
  } else {
    return new Range2(searchEnd, start);
  }
}
function isAtWordBoundary(data, offset, isForward) {
  const offsetToCheck = offset + (isForward ? 0 : -1);
  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));
}
function isAtNodeBoundary(textNode, offset, isForward) {
  return offset === (isForward ? textNode.offsetSize : 0);
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/model.js
var Model = class extends ObservableMixin() {
  // @if CK_DEBUG_ENGINE // private _operationLogs: Array<string>;
  // @if CK_DEBUG_ENGINE // private _appliedOperations: Array<Operation>;
  constructor() {
    super();
    this.markers = new MarkerCollection();
    this.document = new Document2(this);
    this.schema = new Schema();
    this._pendingChanges = [];
    this._currentWriter = null;
    ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((methodName) => this.decorate(methodName));
    this.on("applyOperation", (evt, args) => {
      const operation = args[0];
      operation._validate();
    }, { priority: "highest" });
    this.schema.register("$root", {
      isLimit: true
    });
    this.schema.register("$container", {
      allowIn: ["$root", "$container"]
    });
    this.schema.register("$block", {
      allowIn: ["$root", "$container"],
      isBlock: true
    });
    this.schema.register("$blockObject", {
      allowWhere: "$block",
      isBlock: true,
      isObject: true
    });
    this.schema.register("$inlineObject", {
      allowWhere: "$text",
      allowAttributesOf: "$text",
      isInline: true,
      isObject: true
    });
    this.schema.register("$text", {
      allowIn: "$block",
      isInline: true,
      isContent: true
    });
    this.schema.register("$clipboardHolder", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: true
    });
    this.schema.register("$documentFragment", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: true
    });
    this.schema.register("$marker");
    this.schema.addChildCheck(() => true, "$marker");
    injectSelectionPostFixer(this);
    this.document.registerPostFixer(autoParagraphEmptyRoots);
    this.on("insertContent", (evt, [content, selectable]) => {
      evt.return = insertContent(this, content, selectable);
    });
    this.on("insertObject", (evt, [element, selection, options]) => {
      evt.return = insertObject(this, element, selection, options);
    });
    this.on("canEditAt", (evt) => {
      const canEditAt = !this.document.isReadOnly;
      evt.return = canEditAt;
      if (!canEditAt) {
        evt.stop();
      }
    });
  }
  /**
   * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes
   * (including detached nodes  i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),
   * the {@link module:engine/model/document~Document#selection document's selection}, and
   * {@link module:engine/model/model~Model#markers model markers}.
   *
   * ```ts
   * model.change( writer => {
   * 	writer.insertText( 'foo', paragraph, 'end' );
   * } );
   * ```
   *
   * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined
   * into a single undo step.
   *
   * ```ts
   * model.change( writer => {
   * 	writer.insertText( 'foo', paragraph, 'end' ); // foo.
   *
   * 	model.change( writer => {
   * 		writer.insertText( 'bar', paragraph, 'end' ); // foobar.
   * 	} );
   *
   * 	writer.insertText( 'bom', paragraph, 'end' ); // foobarbom.
   * } );
   * ```
   *
   * The callback of the `change()` block is executed synchronously.
   *
   * You can also return a value from the change block.
   *
   * ```ts
   * const img = model.change( writer => {
   * 	return writer.createElement( 'img' );
   * } );
   * ```
   *
   * @see #enqueueChange
   * @typeParam TReturn The return type of the provided callback.
   * @param callback Callback function which may modify the model.
   */
  change(callback) {
    try {
      if (this._pendingChanges.length === 0) {
        this._pendingChanges.push({ batch: new Batch(), callback });
        return this._runPendingChanges()[0];
      } else {
        return callback(this._currentWriter);
      }
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  enqueueChange(batchOrType, callback) {
    try {
      if (!batchOrType) {
        batchOrType = new Batch();
      } else if (typeof batchOrType === "function") {
        callback = batchOrType;
        batchOrType = new Batch();
      } else if (!(batchOrType instanceof Batch)) {
        batchOrType = new Batch(batchOrType);
      }
      this._pendingChanges.push({ batch: batchOrType, callback });
      if (this._pendingChanges.length == 1) {
        this._runPendingChanges();
      }
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  /**
   * {@link module:utils/observablemixin~Observable#decorate Decorated} function for applying
   * {@link module:engine/model/operation/operation~Operation operations} to the model.
   *
   * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).
   * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.
   * See also {@glink framework/architecture/editing-engine#changing-the-model Changing the model} section
   * of the {@glink framework/architecture/editing-engine Editing architecture} guide.
   *
   * @param operation The operation to apply.
   */
  applyOperation(operation) {
    operation._execute();
  }
  // @if CK_DEBUG_ENGINE // public getAppliedOperation(): string {
  // @if CK_DEBUG_ENGINE // 	if ( !this._appliedOperations ) {
  // @if CK_DEBUG_ENGINE // 		return '';
  // @if CK_DEBUG_ENGINE // 	}
  // @if CK_DEBUG_ENGINE // 	return this._appliedOperations.map( operation => JSON.stringify( operation ) ).join( '-------' );
  // @if CK_DEBUG_ENGINE // }
  // @if CK_DEBUG_ENGINE // public createReplayer( stringifiedOperations: string ): typeof OperationReplayer {
  // @if CK_DEBUG_ENGINE // 	return new OperationReplayer( this, '-------', stringifiedOperations );
  // @if CK_DEBUG_ENGINE // }
  /**
   * Inserts content at the position in the editor specified by the selection, as one would expect the paste
   * functionality to work.
   *
   * **Note**: If you want to insert an {@glink framework/deep-dive/schema#object-elements object element}
   * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.
   *
   * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting
   * the content, clears the given selection's content before inserting nodes and moves the selection
   * to its target position at the end of the process.
   * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &ndash; just like the
   * pasting feature should do.
   *
   * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.
   *
   * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used
   * inside a {@link #change `change()` block}.
   *
   * # Conversion and schema
   *
   * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content
   * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does
   * is only adding nodes to the model. Additionally, you need to define
   * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
   * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
   *
   * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods
   * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML
   * unless converters are defined for all elements and attributes in that HTML.
   *
   * # Examples
   *
   * Using `insertContent()` with a manually created model structure:
   *
   * ```ts
   * // Let's create a document fragment containing such content as:
   * //
   * // <paragraph>foo</paragraph>
   * // <blockQuote>
   * //    <paragraph>bar</paragraph>
   * // </blockQuote>
   * const docFrag = editor.model.change( writer => {
   * 	const p1 = writer.createElement( 'paragraph' );
   * 	const p2 = writer.createElement( 'paragraph' );
   * 	const blockQuote = writer.createElement( 'blockQuote' );
   * 	const docFrag = writer.createDocumentFragment();
   *
   * 	writer.append( p1, docFrag );
   * 	writer.append( blockQuote, docFrag );
   * 	writer.append( p2, blockQuote );
   * 	writer.insertText( 'foo', p1 );
   * 	writer.insertText( 'bar', p2 );
   *
   * 	return docFrag;
   * } );
   *
   * // insertContent() does not have to be used in a change() block. It can, though,
   * // so this code could be moved to the callback defined above.
   * editor.model.insertContent( docFrag );
   * ```
   *
   * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):
   *
   * ```ts
   * // You can create your own HtmlDataProcessor instance or use editor.data.processor
   * // if you have not overridden the default one (which is the HtmlDataProcessor instance).
   * const htmlDP = new HtmlDataProcessor( viewDocument );
   *
   * // Convert an HTML string to a view document fragment:
   * const viewFragment = htmlDP.toView( htmlString );
   *
   * // Convert the view document fragment to a model document fragment
   * // in the context of $root. This conversion takes the schema into
   * // account so if, for example, the view document fragment contained a bare text node,
   * // this text node cannot be a child of $root, so it will be automatically
   * // wrapped with a <paragraph>. You can define the context yourself (in the second parameter),
   * // and e.g. convert the content like it would happen in a <paragraph>.
   * // Note: The clipboard feature uses a custom context called $clipboardHolder
   * // which has a loosened schema.
   * const modelFragment = editor.data.toModel( viewFragment );
   *
   * editor.model.insertContent( modelFragment );
   * ```
   *
   * By default this method will use the document selection but it can also be used with a position, range or selection instance.
   *
   * ```ts
   * // Insert text at the current document selection position.
   * editor.model.change( writer => {
   * 	editor.model.insertContent( writer.createText( 'x' ) );
   * } );
   *
   * // Insert text at a given position - the document selection will not be modified.
   * editor.model.change( writer => {
   * 	editor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );
   *
   * 	// Which is a shorthand for:
   * 	editor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );
   * } );
   * ```
   *
   * If you want the document selection to be moved to the inserted content, use the
   * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting
   * the content:
   *
   * ```ts
   * editor.model.change( writer => {
   * 	const paragraph = writer.createElement( 'paragraph' );
   *
   * 	// Insert an empty paragraph at the beginning of the root.
   * 	editor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );
   *
   * 	// Move the document selection to the inserted paragraph.
   * 	writer.setSelection( paragraph, 'in' );
   * } );
   * ```
   *
   * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,
   * the new content will be inserted at the passed selection (instead of document selection):
   *
   * ```ts
   * editor.model.change( writer => {
   * 	// Create a selection in a paragraph that will be used as a place of insertion.
   * 	const selection = writer.createSelection( paragraph, 'in' );
   *
   * 	// Insert the new text at the created selection.
   * 	editor.model.insertContent( writer.createText( 'x' ), selection );
   *
   * 	// insertContent() modifies the passed selection instance so it can be used to set the document selection.
   * 	// Note: This is not necessary when you passed the document selection to insertContent().
   * 	writer.setSelection( selection );
   * } );
   * ```
   *
   * @fires insertContent
   * @param content The content to insert.
   * @param selectable The selection into which the content should be inserted.
   * If not provided the current model document selection will be used.
   * @param placeOrOffset To be used when a model item was passed as `selectable`.
   * This param defines a position in relation to that item.
   * at the insertion position.
   */
  insertContent(content, selectable, placeOrOffset, ...rest) {
    const selection = normalizeSelectable(selectable, placeOrOffset);
    return this.fire("insertContent", [content, selection, placeOrOffset, ...rest]);
  }
  /**
   * Inserts an {@glink framework/deep-dive/schema#object-elements object element} at a specific position in the editor content.
   *
   * This is a high-level API:
   * * It takes the {@link #schema schema} into consideration,
   * * It clears the content of passed `selectable` before inserting,
   * * It can move the selection at the end of the process,
   * * It will copy the selected block's attributes to preserve them upon insertion,
   * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,
   * * etc.
   *
   * # Notes
   *
   * * If you want to insert a non-object content, see {@link #insertContent} instead.
   * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.
   * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside
   * a {@link #change `change()` block}.
   * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.
   * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does
   * is only adding nodes to the model. Additionally, you need to define
   * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
   * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
   *
   * # Examples
   *
   * Use the following code to insert an object at the current selection and keep the selection on the inserted element:
   *
   * ```ts
   * const rawHtmlEmbedElement = writer.createElement( 'rawHtml' );
   *
   * model.insertObject( rawHtmlEmbedElement, null, null, {
   * 	setSelection: 'on'
   * } );
   * ```
   *
   * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:
   *
   * ```ts
   * const pageBreakElement = writer.createElement( 'pageBreak' );
   *
   * model.insertObject( pageBreakElement, null, null, {
   * 	setSelection: 'after'
   * } );
   * ```
   *
   * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):
   *
   * ```ts
   * const tableElement = writer.createElement( 'table' );
   *
   * model.insertObject( tableElement, null, null, {
   * 	findOptimalPosition: 'auto'
   * } );
   * ```
   *
   * Use the following code to insert an object at the specific range (also: replace the content of the range):
   *
   * ```ts
   * const tableElement = writer.createElement( 'table' );
   * const range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );
   *
   * model.insertObject( tableElement, range );
   * ```
   *
   * @param element An object to be inserted into the model document.
   * @param selectable A selectable where the content should be inserted. If not specified, the current
   * {@link module:engine/model/document~Document#selection document selection} will be used instead.
   * @param placeOrOffset Specifies the exact place or offset for the insertion to take place, relative to `selectable`.
   * @param options Additional options.
   * @param options.findOptimalPosition An option that, when set, adjusts the insertion position (relative to
   * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).
   * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.
   * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.
   * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.
   *
   * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.
   * @param options.setSelection An option that, when set, moves the
   * {@link module:engine/model/document~Document#selection document selection} after inserting the object.
   * * When `'on'`, the document selection will be set on the inserted object.
   * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no
   * such text node, a paragraph will be created and the document selection will be moved inside it.
   * at the insertion position.
   */
  insertObject(element, selectable, placeOrOffset, options, ...rest) {
    const selection = normalizeSelectable(selectable, placeOrOffset);
    return this.fire("insertObject", [element, selection, options, options, ...rest]);
  }
  /**
   * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
   *
   * **Note:** For the sake of predictability, the resulting selection should always be collapsed.
   * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
   * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
   * then that behavior should be implemented in the view's listener. At the same time, the table feature
   * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
   * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
   * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
   *
   * @fires deleteContent
   * @param selection Selection of which the content should be deleted.
   * @param options.leaveUnmerged Whether to merge elements after removing the content of the selection.
   *
   * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:
   *
   * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)
   * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
   *
   * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}
   * elements will not be merged.
   *
   * @param options.doNotResetEntireContent Whether to skip replacing the entire content with a
   * paragraph when the entire content was selected.
   *
   * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:
   *
   * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
   * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)
   *
   * @param options.doNotAutoparagraph Whether to create a paragraph if after content deletion selection is moved
   * to a place where text cannot be inserted.
   *
   * For example `<paragraph>x</paragraph>[<imageBlock src="foo.jpg"></imageBlock>]` will become:
   *
   * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
   * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).
   *
   * **Note:** if there is no valid position for the selection, the paragraph will always be created:
   *
   * `[<imageBlock src="foo.jpg"></imageBlock>]` -> `<paragraph>[]</paragraph>`.
   *
   * @param options.direction The direction in which the content is being consumed.
   * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to
   * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.
   */
  deleteContent(selection, options) {
    deleteContent(this, selection, options);
  }
  /**
   * Modifies the selection. Currently, the supported modifications are:
   *
   * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
   * Possible values for `unit` are:
   *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
   *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
   *  with a symbol before it ("base character") to create one user-perceived character. For example, `q` is a normal
   *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
   *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
   *  why `'character'` value is most natural and common method of modifying selection.
   *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
   *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
   *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
   *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
   *  For example `` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
   *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
   *  extension will include whole "surrogate pair".
   *  * `'word'` - moves selection by a whole word.
   *
   * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
   *
   * @fires modifySelection
   * @param selection The selection to modify.
   * @param options.direction The direction in which the selection should be modified.
   * @param options.unit The unit by which selection should be modified.
   * @param options.treatEmojiAsSingleUnit Whether multi-characer emoji sequences should be handled as single unit.
   */
  modifySelection(selection, options) {
    modifySelection(this, selection, options);
  }
  /**
   * Gets a clone of the selected content.
   *
   * For example, for the following selection:
   *
   * ```html
   * <paragraph>x</paragraph>
   * <blockQuote>
   * 	<paragraph>y</paragraph>
   * 	<heading1>fir[st</heading1>
   * </blockQuote>
   * <paragraph>se]cond</paragraph>
   * <paragraph>z</paragraph>
   * ```
   *
   * It will return a document fragment with such a content:
   *
   * ```html
   * <blockQuote>
   * 	<heading1>st</heading1>
   * </blockQuote>
   * <paragraph>se</paragraph>
   * ```
   *
   * @fires getSelectedContent
   * @param selection The selection of which content will be returned.
   */
  getSelectedContent(selection) {
    return getSelectedContent(this, selection);
  }
  /**
   * Checks whether the given {@link module:engine/model/range~Range range} or
   * {@link module:engine/model/element~Element element} has any meaningful content.
   *
   * Meaningful content is:
   *
   * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain
   * any non-whitespace characters),
   * * or any {@link module:engine/model/schema~Schema#isContent content element},
   * * or any {@link module:engine/model/markercollection~Marker marker} which
   * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.
   *
   * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.
   * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)
   * is considered non-empty.
   *
   * @param rangeOrElement Range or element to check.
   * @param options.ignoreWhitespaces Whether text node with whitespaces only should be considered empty.
   * @param options.ignoreMarkers Whether markers should be ignored.
   */
  hasContent(rangeOrElement, options = {}) {
    const range = rangeOrElement instanceof Range2 ? rangeOrElement : Range2._createIn(rangeOrElement);
    if (range.isCollapsed) {
      return false;
    }
    const { ignoreWhitespaces = false, ignoreMarkers = false } = options;
    if (!ignoreMarkers) {
      for (const intersectingMarker of this.markers.getMarkersIntersectingRange(range)) {
        if (intersectingMarker.affectsData) {
          return true;
        }
      }
    }
    for (const item of range.getItems()) {
      if (this.schema.isContent(item)) {
        if (item.is("$textProxy")) {
          if (!ignoreWhitespaces) {
            return true;
          } else if (item.data.search(/\S/) !== -1) {
            return true;
          }
        } else {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Check whether given selectable is at a place in the model where it can be edited (returns `true`) or not (returns `false`).
   *
   * Should be used instead of {@link module:core/editor/editor~Editor#isReadOnly} to check whether a user action can happen at
   * given selectable. It may be decorated and used differently in different environment (e.g. multi-root editor can disable
   * a particular root).
   *
   * This method is decorated. Although this method accepts any parameter of `Selectable` type, the
   * {@link ~Model#event:canEditAt `canEditAt` event} is fired with `selectable` normalized to an instance of
   * {@link module:engine/model/selection~Selection} or {@link module:engine/model/documentselection~DocumentSelection}
   *
   * @fires canEditAt
   */
  canEditAt(selectable) {
    const selection = normalizeSelectable(selectable);
    return this.fire("canEditAt", [selection]);
  }
  /**
   * Creates a position from the given root and path in that root.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.
   *
   * @param root Root of the position.
   * @param path Position path. See {@link module:engine/model/position~Position#path}.
   * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
   */
  createPositionFromPath(root, path, stickiness) {
    return new Position2(root, path, stickiness);
  }
  /**
   * Creates position at the given location. The location can be specified as:
   *
   * * a {@link module:engine/model/position~Position position},
   * * a parent element and offset in that element,
   * * a parent element and `'end'` (the position will be set at the end of that element),
   * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`
   * (the position will be set before or after the given model item).
   *
   * This method is a shortcut to other factory methods such as:
   *
   * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},
   * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},
   *
   * @param itemOrPosition
   * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
   */
  createPositionAt(itemOrPosition, offset) {
    return Position2._createAt(itemOrPosition, offset);
  }
  /**
   * Creates a new position after the given {@link module:engine/model/item~Item model item}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.
   *
   * @param item Item after which the position should be placed.
   */
  createPositionAfter(item) {
    return Position2._createAfter(item);
  }
  /**
   * Creates a new position before the given {@link module:engine/model/item~Item model item}.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.
   *
   * @param item Item before which the position should be placed.
   */
  createPositionBefore(item) {
    return Position2._createBefore(item);
  }
  /**
   * Creates a range spanning from the `start` position to the `end` position.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRange( start, end );
   * } );
   * ```
   *
   * @param start Start position.
   * @param end End position. If not set, the range will be collapsed to the `start` position.
   */
  createRange(start, end) {
    return new Range2(start, end);
  }
  /**
   * Creates a range inside the given element which starts before the first child of
   * that element and ends after the last child of that element.
   *
   * Note: This method is also available as
   * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRangeIn( paragraph );
   * } );
   * ```
   *
   * @param element Element which is a parent for the range.
   */
  createRangeIn(element) {
    return Range2._createIn(element);
  }
  /**
   * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.
   *
   * Note: This method is also available on `writer` instance as
   * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:
   *
   * ```ts
   * model.change( writer => {
   * 	const range = writer.createRangeOn( paragraph );
   * } );
   * ```
   *
   * @param item
   */
  createRangeOn(item) {
    return Range2._createOn(item);
  }
  createSelection(...args) {
    return new Selection2(...args);
  }
  /**
   * Creates a {@link module:engine/model/batch~Batch} instance.
   *
   * **Note:** In most cases creating a batch instance is not necessary as they are created when using:
   *
   * * {@link #change `change()`},
   * * {@link #enqueueChange `enqueueChange()`}.
   *
   * @param type {@link module:engine/model/batch~Batch#constructor The type} of the batch.
   */
  createBatch(type) {
    return new Batch(type);
  }
  /**
   * Creates an operation instance from a JSON object (parsed JSON string).
   *
   * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.
   *
   * @param json Deserialized JSON object.
   */
  createOperationFromJSON(json) {
    return OperationFactory.fromJSON(json, this.document);
  }
  /**
   * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.
   */
  destroy() {
    this.document.destroy();
    this.stopListening();
  }
  /**
   * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}
   * which calls callbacks and returns array of values returned by these callbacks.
   */
  _runPendingChanges() {
    const ret = [];
    this.fire("_beforeChanges");
    try {
      while (this._pendingChanges.length) {
        const currentBatch = this._pendingChanges[0].batch;
        this._currentWriter = new Writer(this, currentBatch);
        const callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);
        ret.push(callbackReturnValue);
        this.document._handleChangeBlock(this._currentWriter);
        this._pendingChanges.shift();
        this._currentWriter = null;
      }
    } finally {
      this._pendingChanges.length = 0;
      this._currentWriter = null;
      this.fire("_afterChanges");
    }
    return ret;
  }
};
function normalizeSelectable(selectable, placeOrOffset) {
  if (!selectable) {
    return;
  }
  if (selectable instanceof Selection2 || selectable instanceof DocumentSelection2) {
    return selectable;
  }
  if (selectable instanceof Node3) {
    if (placeOrOffset || placeOrOffset === 0) {
      return new Selection2(selectable, placeOrOffset);
    } else if (selectable.is("rootElement")) {
      return new Selection2(selectable, "in");
    } else {
      return new Selection2(selectable, "on");
    }
  }
  return new Selection2(selectable);
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver.js
var MouseObserver = class extends DomEventObserver {
  constructor() {
    super(...arguments);
    this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
  }
  /**
   * @inheritDoc
   */
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/dev-utils/view.js
var ELEMENT_RANGE_START_TOKEN = "[";
var ELEMENT_RANGE_END_TOKEN = "]";
var TEXT_RANGE_START_TOKEN = "{";
var TEXT_RANGE_END_TOKEN = "}";
var allowedTypes = {
  "container": ContainerElement,
  "attribute": attributeelement_default,
  "empty": EmptyElement,
  "ui": UIElement,
  "raw": RawElement
};
var domConverterStub = {
  setContentOf: (node, html2) => {
    node.innerHTML = html2;
  }
};
function getData(view, options = {}) {
  if (!(view instanceof View2)) {
    throw new TypeError("View needs to be an instance of module:engine/view/view~View.");
  }
  const document2 = view.document;
  const withoutSelection = !!options.withoutSelection;
  const rootName = options.rootName || "main";
  const root = document2.getRoot(rootName);
  const stringifyOptions = {
    showType: options.showType,
    showPriority: options.showPriority,
    renderUIElements: options.renderUIElements,
    renderRawElements: options.renderRawElements,
    ignoreRoot: true,
    domConverter: options.domConverter
  };
  return withoutSelection ? getData._stringify(root, null, stringifyOptions) : getData._stringify(root, document2.selection, stringifyOptions);
}
getData._stringify = stringify;
function setData(view, data, options = {}) {
  if (!(view instanceof View2)) {
    throw new TypeError("View needs to be an instance of module:engine/view/view~View.");
  }
  const document2 = view.document;
  const rootName = options.rootName || "main";
  const root = document2.getRoot(rootName);
  view.change((writer) => {
    const result = setData._parse(data, { rootElement: root });
    if (result.view && result.selection) {
      writer.setSelection(result.selection);
    }
  });
}
setData._parse = parse;
function stringify(node, selectionOrPositionOrRange = null, options = {}) {
  let selection;
  if (selectionOrPositionOrRange instanceof Position || selectionOrPositionOrRange instanceof Range) {
    selection = new DocumentSelection(selectionOrPositionOrRange);
  } else {
    selection = selectionOrPositionOrRange;
  }
  const viewStringify = new ViewStringify(node, selection, options);
  return viewStringify.stringify();
}
function parse(data, options = {}) {
  const viewDocument = new Document(new StylesProcessor());
  options.order = options.order || [];
  const rangeParser = new RangeParser({
    sameSelectionCharacters: options.sameSelectionCharacters
  });
  const processor = new XmlDataProcessor(viewDocument, {
    namespaces: Object.keys(allowedTypes)
  });
  if (options.inlineObjectElements) {
    processor.domConverter.inlineObjectElements.push(...options.inlineObjectElements);
  }
  let view = processor.toView(data);
  view = _convertViewElements(view);
  if (options.rootElement) {
    const root = options.rootElement;
    const nodes = view._removeChildren(0, view.childCount);
    root._removeChildren(0, root.childCount);
    root._appendChild(nodes);
    view = root;
  }
  const ranges = rangeParser.parse(view, options.order);
  if (view.is("documentFragment") && view.childCount === 1) {
    view = view.getChild(0);
  }
  if (ranges.length) {
    const selection = new DocumentSelection(ranges, { backward: !!options.lastRangeBackward });
    return {
      view,
      selection
    };
  }
  if (view.parent) {
    view._remove();
  }
  return view;
}
var RangeParser = class {
  /**
   * Creates a range parser instance.
   *
   * @param options The range parser configuration.
   * @param options.sameSelectionCharacters When set to `true`, the selection inside the text is marked as
   * `{` and `}` and the selection outside the text as `[` and `]`. When set to `false`, both are marked as `[` and `]`.
   */
  constructor(options) {
    this.sameSelectionCharacters = !!options.sameSelectionCharacters;
  }
  /**
   * Parses the view and returns ranges represented inside {@link module:engine/view/text~Text text nodes}.
   * The method will remove all occurrences of `{`, `}`, `[` and `]` from found text nodes. If a text node is empty after
   * the process, it will be removed, too.
   *
   * @param node The starting node.
   * @param order The order of ranges. Each element should represent the desired position of the range after
   * sorting. For example: `[2, 3, 1]` means that the first range will be placed as the second, the second as the third and the third
   * as the first.
   * @returns An array with ranges found.
   */
  parse(node, order) {
    this._positions = [];
    this._getPositions(node);
    let ranges = this._createRanges();
    if (order.length) {
      if (order.length != ranges.length) {
        throw new Error(`Parse error - there are ${ranges.length} ranges found, but ranges order array contains ${order.length} elements.`);
      }
      ranges = this._sortRanges(ranges, order);
    }
    return ranges;
  }
  /**
   * Gathers positions of brackets inside the view tree starting from the provided node. The method will remove all occurrences of
   * `{`, `}`, `[` and `]` from found text nodes. If a text node is empty after the process, it will be removed, too.
   *
   * @param node Staring node.
   */
  _getPositions(node) {
    if (node.is("documentFragment") || node.is("element")) {
      const children = [...node.getChildren()];
      for (const child of children) {
        this._getPositions(child);
      }
    }
    if (node.is("$text")) {
      const regexp = new RegExp(`[${TEXT_RANGE_START_TOKEN}${TEXT_RANGE_END_TOKEN}\\${ELEMENT_RANGE_END_TOKEN}\\${ELEMENT_RANGE_START_TOKEN}]`, "g");
      let text2 = node.data;
      let match;
      let offset = 0;
      const brackets = [];
      while (match = regexp.exec(text2)) {
        const index2 = match.index;
        const bracket = match[0];
        brackets.push({
          bracket,
          textOffset: index2 - offset
        });
        offset++;
      }
      text2 = text2.replace(regexp, "");
      node._data = text2;
      const index = node.index;
      const parent = node.parent;
      if (!text2) {
        node._remove();
      }
      for (const item of brackets) {
        if (text2) {
          if (this.sameSelectionCharacters || !this.sameSelectionCharacters && (item.bracket == TEXT_RANGE_START_TOKEN || item.bracket == TEXT_RANGE_END_TOKEN)) {
            this._positions.push({
              bracket: item.bracket,
              position: new Position(node, item.textOffset)
            });
          } else {
            if (!this.sameSelectionCharacters && item.textOffset !== 0 && item.textOffset !== text2.length) {
              throw new Error(`Parse error - range delimiter '${item.bracket}' is placed inside text node.`);
            }
            const offset2 = item.textOffset === 0 ? index : index + 1;
            this._positions.push({
              bracket: item.bracket,
              position: new Position(parent, offset2)
            });
          }
        } else {
          if (!this.sameSelectionCharacters && item.bracket == TEXT_RANGE_START_TOKEN || item.bracket == TEXT_RANGE_END_TOKEN) {
            throw new Error(`Parse error - text range delimiter '${item.bracket}' is placed inside empty text node. `);
          }
          this._positions.push({
            bracket: item.bracket,
            position: new Position(parent, index)
          });
        }
      }
    }
  }
  /**
   * Sorts ranges in a given order. Range order should be an array and each element should represent the desired position
   * of the range after sorting.
   * For example: `[2, 3, 1]` means that the first range will be placed as the second, the second as the third and the third
   * as the first.
   *
   * @param ranges Ranges to sort.
   * @param rangesOrder An array with new range order.
   * @returns Sorted ranges array.
   */
  _sortRanges(ranges, rangesOrder) {
    const sortedRanges = [];
    let index = 0;
    for (const newPosition of rangesOrder) {
      if (ranges[newPosition - 1] === void 0) {
        throw new Error("Parse error - provided ranges order is invalid.");
      }
      sortedRanges[newPosition - 1] = ranges[index];
      index++;
    }
    return sortedRanges;
  }
  /**
   * Uses all found bracket positions to create ranges from them.
   */
  _createRanges() {
    const ranges = [];
    let range = null;
    for (const item of this._positions) {
      if (!range && (item.bracket == ELEMENT_RANGE_END_TOKEN || item.bracket == TEXT_RANGE_END_TOKEN)) {
        throw new Error(`Parse error - end of range was found '${item.bracket}' but range was not started before.`);
      }
      if (range && (item.bracket == ELEMENT_RANGE_START_TOKEN || item.bracket == TEXT_RANGE_START_TOKEN)) {
        throw new Error(`Parse error - start of range was found '${item.bracket}' but one range is already started.`);
      }
      if (item.bracket == ELEMENT_RANGE_START_TOKEN || item.bracket == TEXT_RANGE_START_TOKEN) {
        range = new Range(item.position, item.position);
      } else {
        range.end = item.position;
        ranges.push(range);
        range = null;
      }
    }
    if (range !== null) {
      throw new Error("Parse error - range was started but no end delimiter was found.");
    }
    return ranges;
  }
};
var ViewStringify = class {
  /**
   * Creates a view stringify instance.
   *
   * @param selection A selection whose ranges should also be converted to a string.
   * @param options An options object.
   * @param options.showType When set to `true`, the type of elements will be printed (`<container:p>`
   * instead of `<p>`, `<attribute:b>` instead of `<b>` and `<empty:img>` instead of `<img>`).
   * @param options.showPriority When set to `true`, the attribute element's priority will be printed.
   * @param options.ignoreRoot When set to `true`, the root's element opening and closing tag will not
   * be outputted.
   * @param options.sameSelectionCharacters When set to `true`, the selection inside the text is marked as
   * `{` and `}` and the selection outside the text as `[` and `]`. When set to `false`, both are marked as `[` and `]`.
   * @param options.renderUIElements When set to `true`, the inner content of each
   * {@link module:engine/view/uielement~UIElement} will be printed.
   * @param options.renderRawElements When set to `true`, the inner content of each
   * @param options.domConverter When set to an actual {@link module:engine/view/domconverter~DomConverter DomConverter}
   * instance, it lets the conversion go through exactly the same flow the editing view is going through,
   * i.e. with view data filtering. Otherwise the simple stub is used.
   * {@link module:engine/view/rawelement~RawElement} will be printed.
   */
  constructor(root, selection, options) {
    this.root = root;
    this.selection = selection;
    this.ranges = [];
    if (selection) {
      this.ranges = [...selection.getRanges()];
    }
    this.showType = !!options.showType;
    this.showPriority = !!options.showPriority;
    this.showAttributeElementId = !!options.showAttributeElementId;
    this.ignoreRoot = !!options.ignoreRoot;
    this.sameSelectionCharacters = !!options.sameSelectionCharacters;
    this.renderUIElements = !!options.renderUIElements;
    this.renderRawElements = !!options.renderRawElements;
    this.domConverter = options.domConverter || domConverterStub;
  }
  /**
   * Converts the view to a string.
   *
   * @returns String representation of the view elements.
   */
  stringify() {
    let result = "";
    this._walkView(this.root, (chunk) => {
      result += chunk;
    });
    return result;
  }
  /**
   * Executes a simple walker that iterates over all elements in the view tree starting from the root element.
   * Calls the `callback` with parsed chunks of string data.
   */
  _walkView(root, callback) {
    const ignore = this.ignoreRoot && this.root === root;
    if (root.is("element") || root.is("documentFragment")) {
      if (root.is("element") && !ignore) {
        callback(this._stringifyElementOpen(root));
      }
      if (this.renderUIElements && root.is("uiElement")) {
        callback(root.render(document, this.domConverter).innerHTML);
      } else if (this.renderRawElements && root.is("rawElement")) {
        const rawContentContainer = document.createElement("div");
        root.render(rawContentContainer, this.domConverter);
        callback(rawContentContainer.innerHTML);
      } else {
        let offset = 0;
        callback(this._stringifyElementRanges(root, offset));
        for (const child of root.getChildren()) {
          this._walkView(child, callback);
          offset++;
          callback(this._stringifyElementRanges(root, offset));
        }
      }
      if (root.is("element") && !ignore) {
        callback(this._stringifyElementClose(root));
      }
    }
    if (root.is("$text")) {
      callback(this._stringifyTextRanges(root));
    }
  }
  /**
   * Checks if a given {@link module:engine/view/element~Element element} has a {@link module:engine/view/range~Range#start range start}
   * or a {@link module:engine/view/range~Range#start range end} placed at a given offset and returns its string representation.
   */
  _stringifyElementRanges(element, offset) {
    let start = "";
    let end = "";
    let collapsed = "";
    for (const range of this.ranges) {
      if (range.start.parent == element && range.start.offset === offset) {
        if (range.isCollapsed) {
          collapsed += ELEMENT_RANGE_START_TOKEN + ELEMENT_RANGE_END_TOKEN;
        } else {
          start += ELEMENT_RANGE_START_TOKEN;
        }
      }
      if (range.end.parent === element && range.end.offset === offset && !range.isCollapsed) {
        end += ELEMENT_RANGE_END_TOKEN;
      }
    }
    return end + collapsed + start;
  }
  /**
   * Checks if a given {@link module:engine/view/element~Element Text node} has a
   * {@link module:engine/view/range~Range#start range start} or a
   * {@link module:engine/view/range~Range#start range end} placed somewhere inside. Returns a string representation of text
   * with range delimiters placed inside.
   */
  _stringifyTextRanges(node) {
    const length = node.data.length;
    const data = node.data.split("");
    let rangeStartToken, rangeEndToken;
    if (this.sameSelectionCharacters) {
      rangeStartToken = ELEMENT_RANGE_START_TOKEN;
      rangeEndToken = ELEMENT_RANGE_END_TOKEN;
    } else {
      rangeStartToken = TEXT_RANGE_START_TOKEN;
      rangeEndToken = TEXT_RANGE_END_TOKEN;
    }
    data[length] = "";
    const result = data.map((letter) => {
      return {
        letter,
        start: "",
        end: "",
        collapsed: ""
      };
    });
    for (const range of this.ranges) {
      const start = range.start;
      const end = range.end;
      if (start.parent == node && start.offset >= 0 && start.offset <= length) {
        if (range.isCollapsed) {
          result[end.offset].collapsed += rangeStartToken + rangeEndToken;
        } else {
          result[start.offset].start += rangeStartToken;
        }
      }
      if (end.parent == node && end.offset >= 0 && end.offset <= length && !range.isCollapsed) {
        result[end.offset].end += rangeEndToken;
      }
    }
    return result.map((item) => item.end + item.collapsed + item.start + item.letter).join("");
  }
  /**
   * Converts the passed {@link module:engine/view/element~Element element} to an opening tag.
   *
   * Depending on the current configuration, the opening tag can be simple (`<a>`), contain a type prefix (`<container:p>`,
   * `<attribute:a>` or `<empty:img>`), contain priority information ( `<attribute:a view-priority="20">` ),
   * or contain element id ( `<attribute:span view-id="foo">` ). Element attributes will also be included
   * (`<a href="https://ckeditor.com" name="foobar">`).
   */
  _stringifyElementOpen(element) {
    const priority = this._stringifyElementPriority(element);
    const id = this._stringifyElementId(element);
    const type = this._stringifyElementType(element);
    const name = [type, element.name].filter((i) => i !== "").join(":");
    const attributes = this._stringifyElementAttributes(element);
    const parts = [name, priority, id, attributes];
    return `<${parts.filter((i) => i !== "").join(" ")}>`;
  }
  /**
   * Converts the passed {@link module:engine/view/element~Element element} to a closing tag.
   * Depending on the current configuration, the closing tag can be simple (`</a>`) or contain a type prefix (`</container:p>`,
   * `</attribute:a>` or `</empty:img>`).
   */
  _stringifyElementClose(element) {
    const type = this._stringifyElementType(element);
    const name = [type, element.name].filter((i) => i !== "").join(":");
    return `</${name}>`;
  }
  /**
   * Converts the passed {@link module:engine/view/element~Element element's} type to its string representation
   *
   * Returns:
   * * 'attribute' for {@link module:engine/view/attributeelement~AttributeElement attribute elements},
   * * 'container' for {@link module:engine/view/containerelement~ContainerElement container elements},
   * * 'empty' for {@link module:engine/view/emptyelement~EmptyElement empty elements},
   * * 'ui' for {@link module:engine/view/uielement~UIElement UI elements},
   * * 'raw' for {@link module:engine/view/rawelement~RawElement raw elements},
   * * an empty string when the current configuration is preventing showing elements' types.
   */
  _stringifyElementType(element) {
    if (this.showType) {
      for (const type in allowedTypes) {
        if (element instanceof allowedTypes[type]) {
          return type;
        }
      }
    }
    return "";
  }
  /**
   * Converts the passed {@link module:engine/view/element~Element element} to its priority representation.
   *
   * The priority string representation will be returned when the passed element is an instance of
   * {@link module:engine/view/attributeelement~AttributeElement attribute element} and the current configuration allows to show the
   * priority. Otherwise returns an empty string.
   */
  _stringifyElementPriority(element) {
    if (this.showPriority && element.is("attributeElement")) {
      return `view-priority="${element.priority}"`;
    }
    return "";
  }
  /**
   * Converts the passed {@link module:engine/view/element~Element element} to its id representation.
   *
   * The id string representation will be returned when the passed element is an instance of
   * {@link module:engine/view/attributeelement~AttributeElement attribute element}, the element has an id
   * and the current configuration allows to show the id. Otherwise returns an empty string.
   */
  _stringifyElementId(element) {
    if (this.showAttributeElementId && element.is("attributeElement") && element.id) {
      return `view-id="${element.id}"`;
    }
    return "";
  }
  /**
   * Converts the passed {@link module:engine/view/element~Element element} attributes to their string representation.
   * If an element has no attributes, an empty string is returned.
   */
  _stringifyElementAttributes(element) {
    const attributes = [];
    const keys = [...element.getAttributeKeys()].sort();
    for (const attribute of keys) {
      let attributeValue;
      if (attribute === "class") {
        attributeValue = [...element.getClassNames()].sort().join(" ");
      } else if (attribute === "style") {
        attributeValue = [...element.getStyleNames()].sort().map((style) => `${style}:${element.getStyle(style).replace(/"/g, "&quot;")}`).join(";");
      } else {
        attributeValue = element.getAttribute(attribute);
      }
      attributes.push(`${attribute}="${attributeValue}"`);
    }
    return attributes.join(" ");
  }
};
function _convertViewElements(rootNode) {
  if (rootNode.is("element") || rootNode.is("documentFragment")) {
    const convertedElement = rootNode.is("documentFragment") ? new DocumentFragment(rootNode.document) : _convertElement(rootNode.document, rootNode);
    for (const child of [...rootNode.getChildren()]) {
      if (convertedElement.is("emptyElement")) {
        throw new Error("Parse error - cannot parse inside EmptyElement.");
      } else if (convertedElement.is("uiElement")) {
        throw new Error("Parse error - cannot parse inside UIElement.");
      } else if (convertedElement.is("rawElement")) {
        throw new Error("Parse error - cannot parse inside RawElement.");
      }
      convertedElement._appendChild(_convertViewElements(child));
    }
    return convertedElement;
  }
  return rootNode;
}
function _convertElement(viewDocument, viewElement) {
  const info = _convertElementNameAndInfo(viewElement);
  const ElementConstructor = allowedTypes[info.type];
  const newElement = ElementConstructor ? new ElementConstructor(viewDocument, info.name) : new Element(viewDocument, info.name);
  if (newElement.is("attributeElement")) {
    if (info.priority !== null) {
      newElement._priority = info.priority;
    }
    if (info.id !== null) {
      newElement._id = info.id;
    }
  }
  for (const attributeKey of viewElement.getAttributeKeys()) {
    newElement._setAttribute(attributeKey, viewElement.getAttribute(attributeKey));
  }
  return newElement;
}
function _convertElementNameAndInfo(viewElement) {
  const parts = viewElement.name.split(":");
  const priority = _convertPriority(viewElement.getAttribute("view-priority"));
  const id = viewElement.hasAttribute("view-id") ? viewElement.getAttribute("view-id") : null;
  viewElement._removeAttribute("view-priority");
  viewElement._removeAttribute("view-id");
  if (parts.length == 1) {
    return {
      name: parts[0],
      type: priority !== null ? "attribute" : null,
      priority,
      id
    };
  }
  const type = _convertType(parts[0]);
  if (type) {
    return {
      name: parts[1],
      type,
      priority,
      id
    };
  }
  throw new Error(`Parse error - cannot parse element's name: ${viewElement.name}.`);
}
function _convertType(type) {
  return type in allowedTypes ? type : null;
}
function _convertPriority(priorityString) {
  const priority = parseInt(priorityString, 10);
  if (!isNaN(priority)) {
    return priority;
  }
  return null;
}

// node_modules/@ckeditor/ckeditor5-engine/src/dev-utils/model.js
function getData2(model, options = {}) {
  if (!(model instanceof Model)) {
    throw new TypeError("Model needs to be an instance of module:engine/model/model~Model.");
  }
  const rootName = options.rootName || "main";
  const root = model.document.getRoot(rootName);
  return getData2._stringify(root, options.withoutSelection ? null : model.document.selection, options.convertMarkers ? model.markers : null);
}
getData2._stringify = stringify2;
function setData2(model, data, options = {}) {
  if (!(model instanceof Model)) {
    throw new TypeError("Model needs to be an instance of module:engine/model/model~Model.");
  }
  let modelDocumentFragment;
  let selection = null;
  const modelRoot = model.document.getRoot(options.rootName || "main");
  const parsedResult = setData2._parse(data, model.schema, {
    lastRangeBackward: options.lastRangeBackward,
    selectionAttributes: options.selectionAttributes,
    context: [modelRoot.name],
    inlineObjectElements: options.inlineObjectElements
  });
  if ("model" in parsedResult) {
    modelDocumentFragment = parsedResult.model;
    selection = parsedResult.selection;
  } else {
    modelDocumentFragment = parsedResult;
  }
  if (options.batchType !== void 0) {
    model.enqueueChange(options.batchType, writeToModel);
  } else {
    model.change(writeToModel);
  }
  function writeToModel(writer) {
    writer.remove(writer.createRangeIn(modelRoot));
    writer.insert(modelDocumentFragment, modelRoot);
    writer.setSelection(null);
    writer.removeSelectionAttribute(model.document.selection.getAttributeKeys());
    if (selection) {
      const ranges = [];
      for (const range of selection.getRanges()) {
        const start = new Position2(modelRoot, range.start.path);
        const end = new Position2(modelRoot, range.end.path);
        ranges.push(new Range2(start, end));
      }
      writer.setSelection(ranges, { backward: selection.isBackward });
      if (options.selectionAttributes) {
        writer.setSelectionAttribute(selection.getAttributes());
      }
    }
  }
}
setData2._parse = parse2;
function stringify2(node, selectionOrPositionOrRange = null, markers = null) {
  const model = new Model();
  const mapper = new Mapper();
  let selection = null;
  let range;
  if (node instanceof RootElement || node instanceof DocumentFragment2) {
    range = model.createRangeIn(node);
  } else {
    if (!node.parent) {
      const fragment = new DocumentFragment2(node);
      range = model.createRangeIn(fragment);
    } else {
      range = new Range2(model.createPositionBefore(node), model.createPositionAfter(node));
    }
  }
  if (selectionOrPositionOrRange instanceof Selection2) {
    selection = selectionOrPositionOrRange;
  } else if (selectionOrPositionOrRange instanceof DocumentSelection2) {
    selection = selectionOrPositionOrRange;
  } else if (selectionOrPositionOrRange instanceof Range2) {
    selection = new Selection2(selectionOrPositionOrRange);
  } else if (selectionOrPositionOrRange instanceof Position2) {
    selection = new Selection2(selectionOrPositionOrRange);
  }
  const stylesProcessor = new StylesProcessor();
  const view = new View2(stylesProcessor);
  const viewDocument = view.document;
  const viewRoot = new RootEditableElement(viewDocument, "div");
  viewRoot.rootName = "main";
  viewDocument.roots.add(viewRoot);
  const downcastDispatcher = new DowncastDispatcher({ mapper, schema: model.schema });
  mapper.bindElements(node.root, viewRoot);
  downcastDispatcher.on("insert:$text", insertText());
  downcastDispatcher.on("insert", insertAttributesAndChildren(), { priority: "lowest" });
  downcastDispatcher.on("attribute", (evt, data2, conversionApi) => {
    if (data2.item instanceof Selection2 || data2.item instanceof DocumentSelection2 || data2.item.is("$textProxy")) {
      const converter = wrap((modelAttributeValue, { writer: writer2 }) => {
        return writer2.createAttributeElement("model-text-with-attributes", { [data2.attributeKey]: stringifyAttributeValue(modelAttributeValue) });
      });
      converter(evt, data2, conversionApi);
    }
  });
  downcastDispatcher.on("insert", insertElement((modelItem) => {
    const attributes = convertAttributes(modelItem.getAttributes(), stringifyAttributeValue);
    return new ContainerElement(viewDocument, modelItem.name, attributes);
  }));
  downcastDispatcher.on("selection", convertRangeSelection());
  downcastDispatcher.on("selection", convertCollapsedSelection());
  downcastDispatcher.on("addMarker", insertUIElement((data2, { writer: writer2 }) => {
    const name = data2.markerName + ":" + (data2.isOpening ? "start" : "end");
    return writer2.createUIElement(name);
  }));
  const markersMap = /* @__PURE__ */ new Map();
  if (markers) {
    for (const marker of Array.from(markers).sort((a, b) => a.name < b.name ? 1 : -1)) {
      markersMap.set(marker.name, marker.getRange());
    }
  }
  const writer = view._writer;
  downcastDispatcher.convert(range, markersMap, writer);
  if (selection) {
    downcastDispatcher.convertSelection(selection, markers || model.markers, writer);
  }
  let data = stringify(viewRoot, viewDocument.selection, { sameSelectionCharacters: true });
  data = data.substr(5, data.length - 11);
  view.destroy();
  return data.replace(new RegExp("model-text-with-attributes", "g"), "$text");
}
function parse2(data, schema, options = {}) {
  const mapper = new Mapper();
  data = data.replace(new RegExp("\\$text", "g"), "model-text-with-attributes");
  const parsedResult = parse(data, {
    sameSelectionCharacters: true,
    lastRangeBackward: !!options.lastRangeBackward,
    inlineObjectElements: options.inlineObjectElements
  });
  let viewDocumentFragment;
  let viewSelection = null;
  let selection = null;
  if ("view" in parsedResult && "selection" in parsedResult) {
    viewDocumentFragment = parsedResult.view;
    viewSelection = parsedResult.selection;
  } else {
    viewDocumentFragment = parsedResult;
  }
  const modelController = new Model();
  const upcastDispatcher = new UpcastDispatcher({ schema });
  upcastDispatcher.on("documentFragment", convertToModelFragment2(mapper));
  upcastDispatcher.on("element:model-text-with-attributes", convertToModelText());
  upcastDispatcher.on("element", convertToModelElement(mapper));
  upcastDispatcher.on("text", convertToModelText());
  let model = modelController.change((writer) => upcastDispatcher.convert(viewDocumentFragment.root, writer, options.context || "$root"));
  mapper.bindElements(model, viewDocumentFragment.root);
  if (model.childCount == 1) {
    model = model.getChild(0);
  }
  if (viewSelection) {
    const ranges = [];
    for (const viewRange of viewSelection.getRanges()) {
      ranges.push(mapper.toModelRange(viewRange));
    }
    selection = new Selection2(ranges, { backward: viewSelection.isBackward });
    for (const [key, value] of toMap(options.selectionAttributes || [])) {
      selection.setAttribute(key, value);
    }
  }
  if (selection) {
    return { model, selection };
  }
  return model;
}
function convertToModelFragment2(mapper) {
  return (evt, data, conversionApi) => {
    const childrenResult = conversionApi.convertChildren(data.viewItem, data.modelCursor);
    mapper.bindElements(data.modelCursor.parent, data.viewItem);
    data = Object.assign(data, childrenResult);
    evt.stop();
  };
}
function convertToModelElement(mapper) {
  return (evt, data, conversionApi) => {
    const elementName = data.viewItem.name;
    if (!conversionApi.schema.checkChild(data.modelCursor, elementName)) {
      throw new Error(`Element '${elementName}' was not allowed in given position.`);
    }
    const attributes = convertAttributes(data.viewItem.getAttributes(), parseAttributeValue);
    const element = conversionApi.writer.createElement(data.viewItem.name, attributes);
    conversionApi.writer.insert(element, data.modelCursor);
    mapper.bindElements(element, data.viewItem);
    conversionApi.convertChildren(data.viewItem, element);
    data.modelRange = Range2._createOn(element);
    data.modelCursor = data.modelRange.end;
    evt.stop();
  };
}
function convertToModelText() {
  return (evt, data, conversionApi) => {
    if (!conversionApi.schema.checkChild(data.modelCursor, "$text")) {
      throw new Error("Text was not allowed in given position.");
    }
    let node;
    if (data.viewItem.is("element")) {
      const attributes = convertAttributes(data.viewItem.getAttributes(), parseAttributeValue);
      const viewText = data.viewItem.getChild(0);
      node = conversionApi.writer.createText(viewText.data, attributes);
    } else {
      node = conversionApi.writer.createText(data.viewItem.data);
    }
    conversionApi.writer.insert(node, data.modelCursor);
    data.modelRange = Range2._createFromPositionAndShift(data.modelCursor, node.offsetSize);
    data.modelCursor = data.modelRange.end;
    evt.stop();
  };
}
function parseAttributeValue(attribute) {
  try {
    return JSON.parse(attribute);
  } catch (e) {
    return attribute;
  }
}
function stringifyAttributeValue(data) {
  if (isPlainObject_default(data)) {
    return JSON.stringify(data);
  }
  return data;
}
function* convertAttributes(attributes, converter) {
  for (const [key, value] of attributes) {
    yield [key, converter(value)];
  }
}

// node_modules/@ckeditor/ckeditor5-watchdog/src/watchdog.js
var Watchdog = class {
  /**
   * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
   */
  constructor(config) {
    this.crashes = [];
    this.state = "initializing";
    this._now = Date.now;
    this.crashes = [];
    this._crashNumberLimit = typeof config.crashNumberLimit === "number" ? config.crashNumberLimit : 3;
    this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === "number" ? config.minimumNonErrorTimePeriod : 5e3;
    this._boundErrorHandler = (evt) => {
      const error = "error" in evt ? evt.error : evt.reason;
      if (error instanceof Error) {
        this._handleError(error, evt);
      }
    };
    this._listeners = {};
    if (!this._restart) {
      throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
    }
  }
  /**
   * Destroys the watchdog and releases the resources.
   */
  destroy() {
    this._stopErrorHandling();
    this._listeners = {};
  }
  /**
   * Starts listening to a specific event name by registering a callback that will be executed
   * whenever an event with a given name fires.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   *
   * @param eventName The event name.
   * @param callback A callback which will be added to event listeners.
   */
  on(eventName, callback) {
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push(callback);
  }
  /**
   * Stops listening to the specified event name by removing the callback from event listeners.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   *
   * @param eventName The event name.
   * @param callback A callback which will be removed from event listeners.
   */
  off(eventName, callback) {
    this._listeners[eventName] = this._listeners[eventName].filter((cb) => cb !== callback);
  }
  /**
   * Fires an event with a given event name and arguments.
   *
   * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
   */
  _fire(eventName, ...args) {
    const callbacks = this._listeners[eventName] || [];
    for (const callback of callbacks) {
      callback.apply(this, [null, ...args]);
    }
  }
  /**
   * Starts error handling by attaching global error handlers.
   */
  _startErrorHandling() {
    window.addEventListener("error", this._boundErrorHandler);
    window.addEventListener("unhandledrejection", this._boundErrorHandler);
  }
  /**
   * Stops error handling by detaching global error handlers.
   */
  _stopErrorHandling() {
    window.removeEventListener("error", this._boundErrorHandler);
    window.removeEventListener("unhandledrejection", this._boundErrorHandler);
  }
  /**
   * Checks if an error comes from the watched item and restarts it.
   * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
   *
   * @fires error
   * @param error Error.
   * @param evt An error event.
   */
  _handleError(error, evt) {
    if (this._shouldReactToError(error)) {
      this.crashes.push({
        message: error.message,
        stack: error.stack,
        // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
        filename: evt instanceof ErrorEvent ? evt.filename : void 0,
        lineno: evt instanceof ErrorEvent ? evt.lineno : void 0,
        colno: evt instanceof ErrorEvent ? evt.colno : void 0,
        date: this._now()
      });
      const causesRestart = this._shouldRestart();
      this.state = "crashed";
      this._fire("stateChange");
      this._fire("error", { error, causesRestart });
      if (causesRestart) {
        this._restart();
      } else {
        this.state = "crashedPermanently";
        this._fire("stateChange");
      }
    }
  }
  /**
   * Checks whether an error should be handled by the watchdog.
   *
   * @param error An error that was caught by the error handling process.
   */
  _shouldReactToError(error) {
    return error.is && error.is("CKEditorError") && error.context !== void 0 && // In some cases the watched item should not be restarted - e.g. during the item initialization.
    // That's why the `null` was introduced as a correct error context which does cause restarting.
    error.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
    this.state === "ready" && this._isErrorComingFromThisItem(error);
  }
  /**
   * Checks if the watchdog should restart the underlying item.
   */
  _shouldRestart() {
    if (this.crashes.length <= this._crashNumberLimit) {
      return true;
    }
    const lastErrorTime = this.crashes[this.crashes.length - 1].date;
    const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
    const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;
    return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;
  }
};

// node_modules/@ckeditor/ckeditor5-watchdog/src/utils/getsubnodes.js
function getSubNodes(head, excludedProperties = /* @__PURE__ */ new Set()) {
  const nodes = [head];
  const subNodes = /* @__PURE__ */ new Set();
  let nodeIndex = 0;
  while (nodes.length > nodeIndex) {
    const node = nodes[nodeIndex++];
    if (subNodes.has(node) || !shouldNodeBeIncluded(node) || excludedProperties.has(node)) {
      continue;
    }
    subNodes.add(node);
    if (Symbol.iterator in node) {
      try {
        for (const n of node) {
          nodes.push(n);
        }
      } catch (err) {
      }
    } else {
      for (const key in node) {
        if (key === "defaultValue") {
          continue;
        }
        nodes.push(node[key]);
      }
    }
  }
  return subNodes;
}
function shouldNodeBeIncluded(node) {
  const type = Object.prototype.toString.call(node);
  const typeOfNode = typeof node;
  return !(typeOfNode === "number" || typeOfNode === "boolean" || typeOfNode === "string" || typeOfNode === "symbol" || typeOfNode === "function" || type === "[object Date]" || type === "[object RegExp]" || type === "[object Module]" || node === void 0 || node === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
  // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
  // until a better solution is found.
  // More in https://github.com/ckeditor/ckeditor5/issues/12292.
  node._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
  node instanceof EventTarget || node instanceof Event);
}

// node_modules/@ckeditor/ckeditor5-watchdog/src/utils/areconnectedthroughproperties.js
function areConnectedThroughProperties(target1, target2, excludedNodes = /* @__PURE__ */ new Set()) {
  if (target1 === target2 && isObject(target1)) {
    return true;
  }
  const subNodes1 = getSubNodes(target1, excludedNodes);
  const subNodes2 = getSubNodes(target2, excludedNodes);
  for (const node of subNodes1) {
    if (subNodes2.has(node)) {
      return true;
    }
  }
  return false;
}
function isObject(structure) {
  return typeof structure === "object" && structure !== null;
}

// node_modules/@ckeditor/ckeditor5-watchdog/src/editorwatchdog.js
var EditorWatchdog = class extends Watchdog {
  /**
   * @param Editor The editor class.
   * @param watchdogConfig The watchdog plugin configuration.
   */
  constructor(Editor2, watchdogConfig = {}) {
    super(watchdogConfig);
    this._editor = null;
    this._lifecyclePromise = null;
    this._initUsingData = true;
    this._editables = {};
    this._throttledSave = throttle_default(this._save.bind(this), typeof watchdogConfig.saveInterval === "number" ? watchdogConfig.saveInterval : 5e3);
    if (Editor2) {
      this._creator = (elementOrData, config) => Editor2.create(elementOrData, config);
    }
    this._destructor = (editor) => editor.destroy();
  }
  /**
   * The current editor instance.
   */
  get editor() {
    return this._editor;
  }
  /**
   * @internal
   */
  get _item() {
    return this._editor;
  }
  /**
   * Sets the function that is responsible for the editor creation.
   * It expects a function that should return a promise.
   *
   * ```ts
   * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
   * ```
   */
  setCreator(creator) {
    this._creator = creator;
  }
  /**
   * Sets the function that is responsible for the editor destruction.
   * Overrides the default destruction function, which destroys only the editor instance.
   * It expects a function that should return a promise or `undefined`.
   *
   * ```ts
   * watchdog.setDestructor( editor => {
   * 	// Do something before the editor is destroyed.
   *
   * 	return editor
   * 		.destroy()
   * 		.then( () => {
   * 			// Do something after the editor is destroyed.
   * 		} );
   * } );
   * ```
   */
  setDestructor(destructor) {
    this._destructor = destructor;
  }
  /**
   * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
   * the state to `initializing`.
   *
   * @fires restart
   */
  _restart() {
    return Promise.resolve().then(() => {
      this.state = "initializing";
      this._fire("stateChange");
      return this._destroy();
    }).catch((err) => {
      console.error("An error happened during the editor destroying.", err);
    }).then(() => {
      const existingRoots = {};
      const lazyRoots = [];
      const oldRootsAttributes = this._config.rootsAttributes || {};
      const rootsAttributes = {};
      for (const [rootName, rootData] of Object.entries(this._data.roots)) {
        if (rootData.isLoaded) {
          existingRoots[rootName] = "";
          rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};
        } else {
          lazyRoots.push(rootName);
        }
      }
      const updatedConfig = {
        ...this._config,
        extraPlugins: this._config.extraPlugins || [],
        lazyRoots,
        rootsAttributes,
        _watchdogInitialData: this._data
      };
      delete updatedConfig.initialData;
      updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);
      if (this._initUsingData) {
        return this.create(existingRoots, updatedConfig, updatedConfig.context);
      } else {
        if (isElement_default(this._elementOrData)) {
          return this.create(this._elementOrData, updatedConfig, updatedConfig.context);
        } else {
          return this.create(this._editables, updatedConfig, updatedConfig.context);
        }
      }
    }).then(() => {
      this._fire("restart");
    });
  }
  /**
   * Creates the editor instance and keeps it running, using the defined creator and destructor.
   *
   * @param elementOrData The editor source element or the editor data.
   * @param config The editor configuration.
   * @param context A context for the editor.
   */
  create(elementOrData = this._elementOrData, config = this._config, context) {
    this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
      super._startErrorHandling();
      this._elementOrData = elementOrData;
      this._initUsingData = typeof elementOrData == "string" || Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == "string";
      this._config = this._cloneEditorConfiguration(config) || {};
      this._config.context = context;
      return this._creator(elementOrData, this._config);
    }).then((editor) => {
      this._editor = editor;
      editor.model.document.on("change:data", this._throttledSave);
      this._lastDocumentVersion = editor.model.document.version;
      this._data = this._getData();
      if (!this._initUsingData) {
        this._editables = this._getEditables();
      }
      this.state = "ready";
      this._fire("stateChange");
    }).finally(() => {
      this._lifecyclePromise = null;
    });
    return this._lifecyclePromise;
  }
  /**
   * Destroys the watchdog and the current editor instance. It fires the callback
   * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
   * It also sets the state to `destroyed`.
   */
  destroy() {
    this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
      this.state = "destroyed";
      this._fire("stateChange");
      super.destroy();
      return this._destroy();
    }).finally(() => {
      this._lifecyclePromise = null;
    });
    return this._lifecyclePromise;
  }
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      this._throttledSave.cancel();
      const editor = this._editor;
      this._editor = null;
      editor.model.document.off("change:data", this._throttledSave);
      return this._destructor(editor);
    });
  }
  /**
   * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
   * the moment of the crash.
   */
  _save() {
    const version = this._editor.model.document.version;
    try {
      this._data = this._getData();
      if (!this._initUsingData) {
        this._editables = this._getEditables();
      }
      this._lastDocumentVersion = version;
    } catch (err) {
      console.error(err, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
    }
  }
  /**
   * @internal
   */
  _setExcludedProperties(props) {
    this._excludedProps = props;
  }
  /**
   * Gets all data that is required to reinitialize editor instance.
   */
  _getData() {
    const editor = this._editor;
    const roots = editor.model.document.roots.filter((root) => root.isAttached() && root.rootName != "$graveyard");
    const { plugins } = editor;
    const commentsRepository = plugins.has("CommentsRepository") && plugins.get("CommentsRepository");
    const trackChanges = plugins.has("TrackChanges") && plugins.get("TrackChanges");
    const data = {
      roots: {},
      markers: {},
      commentThreads: JSON.stringify([]),
      suggestions: JSON.stringify([])
    };
    roots.forEach((root) => {
      data.roots[root.rootName] = {
        content: JSON.stringify(Array.from(root.getChildren())),
        attributes: JSON.stringify(Array.from(root.getAttributes())),
        isLoaded: root._isLoaded
      };
    });
    for (const marker of editor.model.markers) {
      if (!marker._affectsData) {
        continue;
      }
      data.markers[marker.name] = {
        rangeJSON: marker.getRange().toJSON(),
        usingOperation: marker._managedUsingOperations,
        affectsData: marker._affectsData
      };
    }
    if (commentsRepository) {
      data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({ toJSON: true, skipNotAttached: true }));
    }
    if (trackChanges) {
      data.suggestions = JSON.stringify(trackChanges.getSuggestions({ toJSON: true, skipNotAttached: true }));
    }
    return data;
  }
  /**
   * For each attached model root, returns its HTML editable element (if available).
   */
  _getEditables() {
    const editables = {};
    for (const rootName of this.editor.model.document.getRootNames()) {
      const editable = this.editor.ui.getEditableElement(rootName);
      if (editable) {
        editables[rootName] = editable;
      }
    }
    return editables;
  }
  /**
   * Traverses the error context and the current editor to find out whether these structures are connected
   * to each other via properties.
   *
   * @internal
   */
  _isErrorComingFromThisItem(error) {
    return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);
  }
  /**
   * Clones the editor configuration.
   */
  _cloneEditorConfiguration(config) {
    return cloneDeepWith_default(config, (value, key) => {
      if (isElement_default(value)) {
        return value;
      }
      if (key === "context") {
        return value;
      }
    });
  }
};
var EditorWatchdogInitPlugin = class {
  constructor(editor) {
    this.editor = editor;
    this._data = editor.config.get("_watchdogInitialData");
  }
  /**
   * @inheritDoc
   */
  init() {
    this.editor.data.on("init", (evt) => {
      evt.stop();
      this.editor.model.enqueueChange({ isUndoable: false }, (writer) => {
        this._restoreCollaborationData();
        this._restoreEditorData(writer);
      });
      this.editor.data.fire("ready");
    }, { priority: 1e3 - 1 });
  }
  /**
   * Creates a model node (element or text) based on provided JSON.
   */
  _createNode(writer, jsonNode) {
    if ("name" in jsonNode) {
      const element = writer.createElement(jsonNode.name, jsonNode.attributes);
      if (jsonNode.children) {
        for (const child of jsonNode.children) {
          element._appendChild(this._createNode(writer, child));
        }
      }
      return element;
    } else {
      return writer.createText(jsonNode.data, jsonNode.attributes);
    }
  }
  /**
   * Restores the editor by setting the document data, roots attributes and markers.
   */
  _restoreEditorData(writer) {
    const editor = this.editor;
    Object.entries(this._data.roots).forEach(([rootName, { content, attributes }]) => {
      const parsedNodes = JSON.parse(content);
      const parsedAttributes = JSON.parse(attributes);
      const rootElement = editor.model.document.getRoot(rootName);
      for (const [key, value] of parsedAttributes) {
        writer.setAttribute(key, value, rootElement);
      }
      for (const child of parsedNodes) {
        const node = this._createNode(writer, child);
        writer.insert(node, rootElement, "end");
      }
    });
    Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {
      const { document: document2 } = editor.model;
      const { rangeJSON: { start, end }, ...options } = markerOptions;
      const root = document2.getRoot(start.root);
      const startPosition = writer.createPositionFromPath(root, start.path, start.stickiness);
      const endPosition = writer.createPositionFromPath(root, end.path, end.stickiness);
      const range = writer.createRange(startPosition, endPosition);
      writer.addMarker(markerName, {
        range,
        ...options
      });
    });
  }
  /**
   * Restores the editor collaboration data - comment threads and suggestions.
   */
  _restoreCollaborationData() {
    const parsedCommentThreads = JSON.parse(this._data.commentThreads);
    const parsedSuggestions = JSON.parse(this._data.suggestions);
    parsedCommentThreads.forEach((commentThreadData) => {
      const channelId = this.editor.config.get("collaboration.channelId");
      const commentsRepository = this.editor.plugins.get("CommentsRepository");
      if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {
        const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);
        commentThread.remove();
      }
      commentsRepository.addCommentThread({ channelId, ...commentThreadData });
    });
    parsedSuggestions.forEach((suggestionData) => {
      const trackChangesEditing = this.editor.plugins.get("TrackChangesEditing");
      if (trackChangesEditing.hasSuggestion(suggestionData.id)) {
        const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);
        suggestion.attributes = suggestionData.attributes;
      } else {
        trackChangesEditing.addSuggestionData(suggestionData);
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js
var mainQueueId = Symbol("MainQueueId");
var ContextWatchdog = class extends Watchdog {
  /**
   * The context watchdog class constructor.
   *
   * ```ts
   * const watchdog = new ContextWatchdog( Context );
   *
   * await watchdog.create( contextConfiguration );
   *
   * await watchdog.add( item );
   * ```
   *
   * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
   *
   * @param Context The {@link module:core/context~Context} class.
   * @param watchdogConfig The watchdog configuration.
   */
  constructor(Context2, watchdogConfig = {}) {
    super(watchdogConfig);
    this._watchdogs = /* @__PURE__ */ new Map();
    this._context = null;
    this._contextProps = /* @__PURE__ */ new Set();
    this._actionQueues = new ActionQueues();
    this._watchdogConfig = watchdogConfig;
    this._creator = (contextConfig) => Context2.create(contextConfig);
    this._destructor = (context) => context.destroy();
    this._actionQueues.onEmpty(() => {
      if (this.state === "initializing") {
        this.state = "ready";
        this._fire("stateChange");
      }
    });
  }
  /**
   * Sets the function that is responsible for the context creation.
   * It expects a function that should return a promise (or `undefined`).
   *
   * ```ts
   * watchdog.setCreator( config => Context.create( config ) );
   * ```
   */
  setCreator(creator) {
    this._creator = creator;
  }
  /**
   * Sets the function that is responsible for the context destruction.
   * Overrides the default destruction function, which destroys only the context instance.
   * It expects a function that should return a promise (or `undefined`).
   *
   * ```ts
   * watchdog.setDestructor( context => {
   * 	// Do something before the context is destroyed.
   *
   * 	return context
   * 		.destroy()
   * 		.then( () => {
   * 			// Do something after the context is destroyed.
   * 		} );
   * } );
   * ```
   */
  setDestructor(destructor) {
    this._destructor = destructor;
  }
  /**
   * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
   * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
   */
  get context() {
    return this._context;
  }
  /**
   * Initializes the context watchdog. Once it is created, the watchdog takes care about
   * recreating the context and the provided items, and starts the error handling mechanism.
   *
   * ```ts
   * await watchdog.create( {
   * 	plugins: []
   * } );
   * ```
   *
   * @param contextConfig The context configuration. See {@link module:core/context~Context}.
   */
  create(contextConfig = {}) {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this._contextConfig = contextConfig;
      return this._create();
    });
  }
  /**
   * Returns an item instance with the given `itemId`.
   *
   * ```ts
   * const editor1 = watchdog.getItem( 'editor1' );
   * ```
   *
   * @param itemId The item ID.
   * @returns The item instance or `undefined` if an item with a given ID has not been found.
   */
  getItem(itemId) {
    const watchdog = this._getWatchdog(itemId);
    return watchdog._item;
  }
  /**
   * Gets the state of the given item. See {@link #state} for a list of available states.
   *
   * ```ts
   * const editor1State = watchdog.getItemState( 'editor1' );
   * ```
   *
   * @param itemId Item ID.
   * @returns The state of the item.
   */
  getItemState(itemId) {
    const watchdog = this._getWatchdog(itemId);
    return watchdog.state;
  }
  /**
   * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
   *
   * Items can be passed together as an array of objects:
   *
   * ```ts
   * await watchdog.add( [ {
   * 	id: 'editor1',
   * 	type: 'editor',
   * 	sourceElementOrData: document.querySelector( '#editor' ),
   * 	config: {
   * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
   * 		toolbar: [ 'bold', 'italic', 'alignment' ]
   * 	},
   * 	creator: ( element, config ) => ClassicEditor.create( element, config )
   * } ] );
   * ```
   *
   * Or one by one as objects:
   *
   * ```ts
   * await watchdog.add( {
   * 	id: 'editor1',
   * 	type: 'editor',
   * 	sourceElementOrData: document.querySelector( '#editor' ),
   * 	config: {
   * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
   * 		toolbar: [ 'bold', 'italic', 'alignment' ]
   * 	},
   * 	creator: ( element, config ) => ClassicEditor.create( element, config )
   * ] );
   * ```
   *
   * Then an instance can be retrieved using the {@link #getItem} method:
   *
   * ```ts
   * const editor1 = watchdog.getItem( 'editor1' );
   * ```
   *
   * Note that this method can be called multiple times, but for performance reasons it is better
   * to pass all items together.
   *
   * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
   */
  add(itemConfigurationOrItemConfigurations) {
    const itemConfigurations = toArray2(itemConfigurationOrItemConfigurations);
    return Promise.all(itemConfigurations.map((item) => {
      return this._actionQueues.enqueue(item.id, () => {
        if (this.state === "destroyed") {
          throw new Error("Cannot add items to destroyed watchdog.");
        }
        if (!this._context) {
          throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
        }
        let watchdog;
        if (this._watchdogs.has(item.id)) {
          throw new Error(`Item with the given id is already added: '${item.id}'.`);
        }
        if (item.type === "editor") {
          watchdog = new EditorWatchdog(null, this._watchdogConfig);
          watchdog.setCreator(item.creator);
          watchdog._setExcludedProperties(this._contextProps);
          if (item.destructor) {
            watchdog.setDestructor(item.destructor);
          }
          this._watchdogs.set(item.id, watchdog);
          watchdog.on("error", (evt, { error, causesRestart }) => {
            this._fire("itemError", { itemId: item.id, error });
            if (!causesRestart) {
              return;
            }
            this._actionQueues.enqueue(item.id, () => new Promise((res) => {
              const rethrowRestartEventOnce = () => {
                watchdog.off("restart", rethrowRestartEventOnce);
                this._fire("itemRestart", { itemId: item.id });
                res();
              };
              watchdog.on("restart", rethrowRestartEventOnce);
            }));
          });
          return watchdog.create(item.sourceElementOrData, item.config, this._context);
        } else {
          throw new Error(`Not supported item type: '${item.type}'.`);
        }
      });
    }));
  }
  /**
   * Removes and destroys item(s) with given ID(s).
   *
   * ```ts
   * await watchdog.remove( 'editor1' );
   * ```
   *
   * Or
   *
   * ```ts
   * await watchdog.remove( [ 'editor1', 'editor2' ] );
   * ```
   *
   * @param itemIdOrItemIds Item ID or an array of item IDs.
   */
  remove(itemIdOrItemIds) {
    const itemIds = toArray2(itemIdOrItemIds);
    return Promise.all(itemIds.map((itemId) => {
      return this._actionQueues.enqueue(itemId, () => {
        const watchdog = this._getWatchdog(itemId);
        this._watchdogs.delete(itemId);
        return watchdog.destroy();
      });
    }));
  }
  /**
   * Destroys the context watchdog and all added items.
   * Once the context watchdog is destroyed, new items cannot be added.
   *
   * ```ts
   * await watchdog.destroy();
   * ```
   */
  destroy() {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this.state = "destroyed";
      this._fire("stateChange");
      super.destroy();
      return this._destroy();
    });
  }
  /**
   * Restarts the context watchdog.
   */
  _restart() {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this.state = "initializing";
      this._fire("stateChange");
      return this._destroy().catch((err) => {
        console.error("An error happened during destroying the context or items.", err);
      }).then(() => this._create()).then(() => this._fire("restart"));
    });
  }
  /**
   * Initializes the context watchdog.
   */
  _create() {
    return Promise.resolve().then(() => {
      this._startErrorHandling();
      return this._creator(this._contextConfig);
    }).then((context) => {
      this._context = context;
      this._contextProps = getSubNodes(this._context);
      return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => {
        watchdog._setExcludedProperties(this._contextProps);
        return watchdog.create(void 0, void 0, this._context);
      }));
    });
  }
  /**
   * Destroys the context instance and all added items.
   */
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      const context = this._context;
      this._context = null;
      this._contextProps = /* @__PURE__ */ new Set();
      return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => watchdog.destroy())).then(() => this._destructor(context));
    });
  }
  /**
   * Returns the watchdog for a given item ID.
   *
   * @param itemId Item ID.
   */
  _getWatchdog(itemId) {
    const watchdog = this._watchdogs.get(itemId);
    if (!watchdog) {
      throw new Error(`Item with the given id was not registered: ${itemId}.`);
    }
    return watchdog;
  }
  /**
   * Checks whether an error comes from the context instance and not from the item instances.
   *
   * @internal
   */
  _isErrorComingFromThisItem(error) {
    for (const watchdog of this._watchdogs.values()) {
      if (watchdog._isErrorComingFromThisItem(error)) {
        return false;
      }
    }
    return areConnectedThroughProperties(this._context, error.context);
  }
};
var ActionQueues = class {
  constructor() {
    this._onEmptyCallbacks = [];
    this._queues = /* @__PURE__ */ new Map();
    this._activeActions = 0;
  }
  /**
   * Used to register callbacks that will be run when the queue becomes empty.
   *
   * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
   */
  onEmpty(onEmptyCallback) {
    this._onEmptyCallbacks.push(onEmptyCallback);
  }
  /**
   * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
   *
   * @param queueId The action queue ID.
   * @param action A function that should be enqueued.
   */
  enqueue(queueId, action) {
    const isMainAction = queueId === mainQueueId;
    this._activeActions++;
    if (!this._queues.get(queueId)) {
      this._queues.set(queueId, Promise.resolve());
    }
    const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);
    const queueWithAction = awaitedActions.then(action);
    const nonErrorQueue = queueWithAction.catch(() => {
    });
    this._queues.set(queueId, nonErrorQueue);
    return queueWithAction.finally(() => {
      this._activeActions--;
      if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {
        this._onEmptyCallbacks.forEach((cb) => cb());
      }
    });
  }
};
function toArray2(elementOrArray) {
  return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];
}

// node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js
var PluginCollection = class extends EmitterMixin() {
  /**
   * Creates an instance of the plugin collection class.
   * Allows loading and initializing plugins and their dependencies.
   * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.
   *
   * @param availablePlugins Plugins (constructors) which the collection will be able to use
   * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).
   * Usually, the editor will pass its built-in plugins to the collection so they can later be
   * used in `config.plugins` or `config.removePlugins` by names.
   * @param contextPlugins A list of already initialized plugins represented by a `[ PluginConstructor, pluginInstance ]` pair.
   */
  constructor(context, availablePlugins = [], contextPlugins = []) {
    super();
    this._plugins = /* @__PURE__ */ new Map();
    this._context = context;
    this._availablePlugins = /* @__PURE__ */ new Map();
    for (const PluginConstructor of availablePlugins) {
      if (PluginConstructor.pluginName) {
        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
      }
    }
    this._contextPlugins = /* @__PURE__ */ new Map();
    for (const [PluginConstructor, pluginInstance] of contextPlugins) {
      this._contextPlugins.set(PluginConstructor, pluginInstance);
      this._contextPlugins.set(pluginInstance, PluginConstructor);
      if (PluginConstructor.pluginName) {
        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
      }
    }
  }
  /**
   * Iterable interface.
   *
   * Returns `[ PluginConstructor, pluginInstance ]` pairs.
   */
  *[Symbol.iterator]() {
    for (const entry of this._plugins) {
      if (typeof entry[0] == "function") {
        yield entry;
      }
    }
  }
  /**
   * Gets the plugin instance by its constructor or name.
   *
   * ```ts
   * // Check if 'Clipboard' plugin was loaded.
   * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
   * 	// Get clipboard plugin instance
   * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
   *
   * 	this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
   * 		// Do something on clipboard input.
   * 	} );
   * }
   * ```
   *
   * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`
   * to check if a plugin is available.
   *
   * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
   */
  get(key) {
    const plugin = this._plugins.get(key);
    if (!plugin) {
      let pluginName = key;
      if (typeof key == "function") {
        pluginName = key.pluginName || key.name;
      }
      throw new CKEditorError("plugincollection-plugin-not-loaded", this._context, { plugin: pluginName });
    }
    return plugin;
  }
  /**
   * Checks if a plugin is loaded.
   *
   * ```ts
   * // Check if the 'Clipboard' plugin was loaded.
   * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
   * 	// Now use the clipboard plugin instance:
   * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
   *
   * 	// ...
   * }
   * ```
   *
   * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
   */
  has(key) {
    return this._plugins.has(key);
  }
  /**
   * Initializes a set of plugins and adds them to the collection.
   *
   * @param plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
   * or {@link module:core/plugin~PluginStaticMembers#pluginName plugin names}.
   * @param pluginsToRemove Names of the plugins or plugin constructors
   * that should not be loaded (despite being specified in the `plugins` array).
   * @param pluginsSubstitutions An array of {@link module:core/plugin~PluginInterface plugin constructors}
   * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.
   * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced
   * must follow these rules:
   *   * The new plugin must be a class.
   *   * The new plugin must be named.
   *   * Both plugins must not depend on other plugins.
   * @returns A promise which gets resolved once all plugins are loaded and available in the collection.
   */
  init(plugins, pluginsToRemove = [], pluginsSubstitutions = []) {
    const that = this;
    const context = this._context;
    findAvailablePluginConstructors(plugins);
    validatePlugins(plugins);
    const pluginsToLoad = plugins.filter((plugin) => !isPluginRemoved(plugin, pluginsToRemove));
    const pluginConstructors = [...getPluginConstructors(pluginsToLoad)];
    substitutePlugins(pluginConstructors, pluginsSubstitutions);
    const pluginInstances = loadPlugins(pluginConstructors);
    return initPlugins(pluginInstances, "init").then(() => initPlugins(pluginInstances, "afterInit")).then(() => pluginInstances);
    function isPluginConstructor(plugin) {
      return typeof plugin === "function";
    }
    function isContextPlugin(plugin) {
      return isPluginConstructor(plugin) && !!plugin.isContextPlugin;
    }
    function isPluginRemoved(plugin, pluginsToRemove2) {
      return pluginsToRemove2.some((removedPlugin) => {
        if (removedPlugin === plugin) {
          return true;
        }
        if (getPluginName(plugin) === removedPlugin) {
          return true;
        }
        if (getPluginName(removedPlugin) === plugin) {
          return true;
        }
        return false;
      });
    }
    function getPluginName(plugin) {
      return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;
    }
    function findAvailablePluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
      plugins2.forEach((plugin) => {
        if (!isPluginConstructor(plugin)) {
          return;
        }
        if (processed.has(plugin)) {
          return;
        }
        processed.add(plugin);
        if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {
          that._availablePlugins.set(plugin.pluginName, plugin);
        }
        if (plugin.requires) {
          findAvailablePluginConstructors(plugin.requires, processed);
        }
      });
    }
    function getPluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
      return plugins2.map((plugin) => {
        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);
      }).reduce((result, plugin) => {
        if (processed.has(plugin)) {
          return result;
        }
        processed.add(plugin);
        if (plugin.requires) {
          validatePlugins(plugin.requires, plugin);
          getPluginConstructors(plugin.requires, processed).forEach((plugin2) => result.add(plugin2));
        }
        return result.add(plugin);
      }, /* @__PURE__ */ new Set());
    }
    function validatePlugins(plugins2, parentPluginConstructor = null) {
      plugins2.map((plugin) => {
        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;
      }).forEach((plugin) => {
        checkMissingPlugin(plugin, parentPluginConstructor);
        checkContextPlugin(plugin, parentPluginConstructor);
        checkRemovedPlugin(plugin, parentPluginConstructor);
      });
    }
    function checkMissingPlugin(plugin, parentPluginConstructor) {
      if (isPluginConstructor(plugin)) {
        return;
      }
      if (parentPluginConstructor) {
        throw new CKEditorError("plugincollection-soft-required", context, { missingPlugin: plugin, requiredBy: getPluginName(parentPluginConstructor) });
      }
      throw new CKEditorError("plugincollection-plugin-not-found", context, { plugin });
    }
    function checkContextPlugin(plugin, parentPluginConstructor) {
      if (!isContextPlugin(parentPluginConstructor)) {
        return;
      }
      if (isContextPlugin(plugin)) {
        return;
      }
      throw new CKEditorError("plugincollection-context-required", context, { plugin: getPluginName(plugin), requiredBy: getPluginName(parentPluginConstructor) });
    }
    function checkRemovedPlugin(plugin, parentPluginConstructor) {
      if (!parentPluginConstructor) {
        return;
      }
      if (!isPluginRemoved(plugin, pluginsToRemove)) {
        return;
      }
      throw new CKEditorError("plugincollection-required", context, { plugin: getPluginName(plugin), requiredBy: getPluginName(parentPluginConstructor) });
    }
    function loadPlugins(pluginConstructors2) {
      return pluginConstructors2.map((PluginConstructor) => {
        let pluginInstance = that._contextPlugins.get(PluginConstructor);
        pluginInstance = pluginInstance || new PluginConstructor(context);
        that._add(PluginConstructor, pluginInstance);
        return pluginInstance;
      });
    }
    function initPlugins(pluginInstances2, method) {
      return pluginInstances2.reduce((promise, plugin) => {
        if (!plugin[method]) {
          return promise;
        }
        if (that._contextPlugins.has(plugin)) {
          return promise;
        }
        return promise.then(plugin[method].bind(plugin));
      }, Promise.resolve());
    }
    function substitutePlugins(pluginConstructors2, pluginsSubstitutions2) {
      for (const pluginItem of pluginsSubstitutions2) {
        if (typeof pluginItem != "function") {
          throw new CKEditorError("plugincollection-replace-plugin-invalid-type", null, { pluginItem });
        }
        const pluginName = pluginItem.pluginName;
        if (!pluginName) {
          throw new CKEditorError("plugincollection-replace-plugin-missing-name", null, { pluginItem });
        }
        if (pluginItem.requires && pluginItem.requires.length) {
          throw new CKEditorError("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName });
        }
        const pluginToReplace = that._availablePlugins.get(pluginName);
        if (!pluginToReplace) {
          throw new CKEditorError("plugincollection-plugin-for-replacing-not-exist", null, { pluginName });
        }
        const indexInPluginConstructors = pluginConstructors2.indexOf(pluginToReplace);
        if (indexInPluginConstructors === -1) {
          if (that._contextPlugins.has(pluginToReplace)) {
            return;
          }
          throw new CKEditorError("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName });
        }
        if (pluginToReplace.requires && pluginToReplace.requires.length) {
          throw new CKEditorError("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName });
        }
        pluginConstructors2.splice(indexInPluginConstructors, 1, pluginItem);
        that._availablePlugins.set(pluginName, pluginItem);
      }
    }
  }
  /**
   * Destroys all loaded plugins.
   */
  destroy() {
    const promises = [];
    for (const [, pluginInstance] of this) {
      if (typeof pluginInstance.destroy == "function" && !this._contextPlugins.has(pluginInstance)) {
        promises.push(pluginInstance.destroy());
      }
    }
    return Promise.all(promises);
  }
  /**
   * Adds the plugin to the collection. Exposed mainly for testing purposes.
   *
   * @param PluginConstructor The plugin constructor.
   * @param plugin The instance of the plugin.
   */
  _add(PluginConstructor, plugin) {
    this._plugins.set(PluginConstructor, plugin);
    const pluginName = PluginConstructor.pluginName;
    if (!pluginName) {
      return;
    }
    if (this._plugins.has(pluginName)) {
      throw new CKEditorError("plugincollection-plugin-name-conflict", null, { pluginName, plugin1: this._plugins.get(pluginName).constructor, plugin2: PluginConstructor });
    }
    this._plugins.set(pluginName, plugin);
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/context.js
var Context = class {
  /**
   * Creates a context instance with a given configuration.
   *
   * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
   *
   * @param config The context configuration.
   */
  constructor(config) {
    this._contextOwner = null;
    const { translations, ...rest } = config || {};
    this.config = new Config(rest, this.constructor.defaultConfig);
    const availablePlugins = this.constructor.builtinPlugins;
    this.config.define("plugins", availablePlugins);
    this.plugins = new PluginCollection(this, availablePlugins);
    const languageConfig = this.config.get("language") || {};
    this.locale = new Locale({
      uiLanguage: typeof languageConfig === "string" ? languageConfig : languageConfig.ui,
      contentLanguage: this.config.get("language.content"),
      translations
    });
    this.t = this.locale.t;
    this.editors = new Collection();
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
   */
  initPlugins() {
    const plugins = this.config.get("plugins") || [];
    const substitutePlugins = this.config.get("substitutePlugins") || [];
    for (const Plugin2 of plugins.concat(substitutePlugins)) {
      if (typeof Plugin2 != "function") {
        throw new CKEditorError("context-initplugins-constructor-only", null, { Plugin: Plugin2 });
      }
      if (Plugin2.isContextPlugin !== true) {
        throw new CKEditorError("context-initplugins-invalid-plugin", null, { Plugin: Plugin2 });
      }
    }
    return this.plugins.init(plugins, [], substitutePlugins);
  }
  /**
   * Destroys the context instance and all editors used with the context,
   * releasing all resources used by the context.
   *
   * @returns A promise that resolves once the context instance is fully destroyed.
   */
  destroy() {
    return Promise.all(Array.from(this.editors, (editor) => editor.destroy())).then(() => this.plugins.destroy());
  }
  /**
   * Adds a reference to the editor which is used with this context.
   *
   * When the given editor has created the context, the reference to this editor will be stored
   * as a {@link ~Context#_contextOwner}.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @param isContextOwner Stores the given editor as a context owner.
   */
  _addEditor(editor, isContextOwner) {
    if (this._contextOwner) {
      throw new CKEditorError("context-addeditor-private-context");
    }
    this.editors.add(editor);
    if (isContextOwner) {
      this._contextOwner = editor;
    }
  }
  /**
   * Removes a reference to the editor which was used with this context.
   * When the context was created by the given editor, the context will be destroyed.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @return A promise that resolves once the editor is removed from the context or when the context was destroyed.
   */
  _removeEditor(editor) {
    if (this.editors.has(editor)) {
      this.editors.remove(editor);
    }
    if (this._contextOwner === editor) {
      return this.destroy();
    }
    return Promise.resolve();
  }
  /**
   * Returns the context configuration which will be copied to the editors created using this context.
   *
   * The configuration returned by this method has the plugins configuration removed &ndash; plugins are shared with all editors
   * through another mechanism.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @returns Configuration as a plain object.
   */
  _getEditorConfig() {
    const result = {};
    for (const name of this.config.names()) {
      if (!["plugins", "removePlugins", "extraPlugins"].includes(name)) {
        result[name] = this.config.get(name);
      }
    }
    return result;
  }
  /**
   * Creates and initializes a new context instance.
   *
   * ```ts
   * const commonConfig = { ... }; // Configuration for all the plugins and editors.
   * const editorPlugins = [ ... ]; // Regular plugins here.
   *
   * Context
   * 	.create( {
   * 		// Only context plugins here.
   * 		plugins: [ ... ],
   *
   * 		// Configure the language for all the editors (it cannot be overwritten).
   * 		language: { ... },
   *
   * 		// Configuration for context plugins.
   * 		comments: { ... },
   * 		...
   *
   * 		// Default configuration for editor plugins.
   * 		toolbar: { ... },
   * 		image: { ... },
   * 		...
   * 	} )
   * 	.then( context => {
   * 		const promises = [];
   *
   * 		promises.push( ClassicEditor.create(
   * 			document.getElementById( 'editor1' ),
   * 			{
   * 				editorPlugins,
   * 				context
   * 			}
   * 		) );
   *
   * 		promises.push( ClassicEditor.create(
   * 			document.getElementById( 'editor2' ),
   * 			{
   * 				editorPlugins,
   * 				context,
   * 				toolbar: { ... } // You can overwrite the configuration of the context.
   * 			}
   * 		) );
   *
   * 		return Promise.all( promises );
   * 	} );
   * ```
   *
   * @param config The context configuration.
   * @returns A promise resolved once the context is ready. The promise resolves with the created context instance.
   */
  static create(config) {
    return new Promise((resolve) => {
      const context = new this(config);
      resolve(context.initPlugins().then(() => context));
    });
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/commandcollection.js
var CommandCollection = class {
  /**
   * Creates collection instance.
   */
  constructor() {
    this._commands = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a new command.
   *
   * @param commandName The name of the command.
   */
  add(commandName, command) {
    this._commands.set(commandName, command);
  }
  /**
   * Retrieves a command from the collection.
   *
   * @param commandName The name of the command.
   */
  get(commandName) {
    return this._commands.get(commandName);
  }
  /**
   * Executes a command.
   *
   * @param commandName The name of the command.
   * @param commandParams Command parameters.
   * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
   */
  execute(commandName, ...commandParams) {
    const command = this.get(commandName);
    if (!command) {
      throw new CKEditorError("commandcollection-command-not-found", this, { commandName });
    }
    return command.execute(...commandParams);
  }
  /**
   * Returns iterator of command names.
   */
  *names() {
    yield* this._commands.keys();
  }
  /**
   * Returns iterator of command instances.
   */
  *commands() {
    yield* this._commands.values();
  }
  /**
   * Iterable interface.
   *
   * Returns `[ commandName, commandInstance ]` pairs.
   */
  [Symbol.iterator]() {
    return this._commands[Symbol.iterator]();
  }
  /**
   * Destroys all collection commands.
   */
  destroy() {
    for (const command of this.commands()) {
      command.destroy();
    }
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/editingkeystrokehandler.js
var EditingKeystrokeHandler = class extends KeystrokeHandler {
  /**
   * Creates an instance of the keystroke handler.
   */
  constructor(editor) {
    super();
    this.editor = editor;
  }
  /**
   * Registers a handler for the specified keystroke.
   *
   * The handler can be specified as a command name or a callback.
   *
   * @param keystroke Keystroke defined in a format accepted by
   * the {@link module:utils/keyboard~parseKeystroke} function.
   * @param callback If a string is passed, then the keystroke will
   * {@link module:core/editor/editor~Editor#execute execute a command}.
   * If a function, then it will be called with the
   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
   * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
   * @param options Additional options.
   * @param options.priority The priority of the keystroke callback. The higher the priority value
   * the sooner the callback will be executed. Keystrokes having the same priority
   * are called in the order they were added.
   */
  set(keystroke, callback, options = {}) {
    if (typeof callback == "string") {
      const commandName = callback;
      callback = (evtData, cancel2) => {
        this.editor.execute(commandName);
        cancel2();
      };
    }
    super.set(keystroke, callback, options);
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/accessibility.js
var DEFAULT_CATEGORY_ID = "contentEditing";
var DEFAULT_GROUP_ID = "common";
var Accessibility = class {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    this.keystrokeInfos = /* @__PURE__ */ new Map();
    this._editor = editor;
    const isMenuBarVisible = editor.config.get("menuBar.isVisible");
    const t = editor.locale.t;
    this.addKeystrokeInfoCategory({
      id: DEFAULT_CATEGORY_ID,
      label: t("Content editing keystrokes"),
      description: t("These keyboard shortcuts allow for quick access to content editing features.")
    });
    const navigationKeystrokes = [
      {
        label: t("Close contextual balloons, dropdowns, and dialogs"),
        keystroke: "Esc"
      },
      {
        label: t("Open the accessibility help dialog"),
        keystroke: "Alt+0"
      },
      {
        label: t("Move focus between form fields (inputs, buttons, etc.)"),
        keystroke: [["Tab"], ["Shift+Tab"]]
      },
      {
        label: t("Move focus to the toolbar, navigate between toolbars"),
        keystroke: "Alt+F10",
        mayRequireFn: true
      },
      {
        label: t("Navigate through the toolbar or menu bar"),
        keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
      },
      {
        // eslint-disable-next-line max-len
        label: t("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
        keystroke: [["Enter"], ["Space"]]
      }
    ];
    if (isMenuBarVisible) {
      navigationKeystrokes.push({
        label: t("Move focus to the menu bar, navigate between menu bars"),
        keystroke: "Alt+F9",
        mayRequireFn: true
      });
    }
    this.addKeystrokeInfoCategory({
      id: "navigation",
      label: t("User interface and content navigation keystrokes"),
      description: t("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
      groups: [
        {
          id: "common",
          keystrokes: navigationKeystrokes
        }
      ]
    });
  }
  /**
   * Adds a top-level category in the {@link #keystrokeInfos keystroke information database} with a label and optional description.
   *
   * Categories organize keystrokes and help users to find the right keystroke. Each category can have multiple groups
   * of keystrokes that narrow down the context in which the keystrokes are available. Every keystroke category comes
   * with a `'common'` group by default.
   *
   * By default, two categories are available:
   * * `'contentEditing'` for keystrokes related to content creation,
   * * `'navigation'` for keystrokes related to navigation in the UI and the content.
   *
   * To create a new keystroke category with new groups, use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfoCategory( {
   * 			id: 'myCategory',
   * 			label: t( 'My category' ),
   * 			description: t( 'My category description.' ),
   * 			groups: [
   * 				{
   * 					id: 'myGroup',
   * 					label: t( 'My keystroke group' ),
   * 					keystrokes: [
   * 						{
   * 							label: t( 'Keystroke label 1' ),
   * 							keystroke: 'Ctrl+Shift+N'
   * 						},
   * 						{
   * 							label: t( 'Keystroke label 2' ),
   * 							keystroke: 'Ctrl+Shift+M'
   * 						}
   * 					]
   * 				}
   * 			]
   * 		};
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}.
   */
  addKeystrokeInfoCategory({ id, label, description, groups }) {
    this.keystrokeInfos.set(id, {
      id,
      label,
      description,
      groups: /* @__PURE__ */ new Map()
    });
    this.addKeystrokeInfoGroup({
      categoryId: id,
      id: DEFAULT_GROUP_ID
    });
    if (groups) {
      groups.forEach((group) => {
        this.addKeystrokeInfoGroup({
          categoryId: id,
          ...group
        });
      });
    }
  }
  /**
   * Adds a group of keystrokes in a specific category to the {@link #keystrokeInfos keystroke information database}.
   *
   * Groups narrow down the context in which the keystrokes are available. When `categoryId` is not specified,
   * the group goes to the `'contentEditing'` category (default).
   *
   * To create a new group within an existing category, use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfoGroup( {
   * 			id: 'myGroup',
   * 			categoryId: 'navigation',
   * 			label: t( 'My keystroke group' ),
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label 1' ),
   * 					keystroke: 'Ctrl+Shift+N'
   * 				},
   * 				{
   * 					label: t( 'Keystroke label 2' ),
   * 					keystroke: 'Ctrl+Shift+M'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoCategory}, and {@link #addKeystrokeInfos}.
   */
  addKeystrokeInfoGroup({ categoryId = DEFAULT_CATEGORY_ID, id, label, keystrokes }) {
    const category = this.keystrokeInfos.get(categoryId);
    if (!category) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, { groupId: id, categoryId });
    }
    category.groups.set(id, {
      id,
      label,
      keystrokes: keystrokes || []
    });
  }
  /**
   * Adds information about keystrokes to the {@link #keystrokeInfos keystroke information database}.
   *
   * Keystrokes without specified `groupId` or `categoryId` go to the `'common'` group in the `'contentEditing'` category (default).
   *
   * To add a keystroke brought by your plugin (using default group and category), use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label' ),
   * 					keystroke: 'CTRL+B'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   * To add a keystroke in a specific existing `'widget'` group in the default `'contentEditing'` category:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			// Add a keystroke to the existing "widget" group.
   * 			groupId: 'widget',
   * 			keystrokes: [
   * 				{
   * 					label: t( 'A an action on a selected widget' ),
   * 					keystroke: 'Ctrl+D',
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * To add a keystroke to another existing category (using default group):
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			// Add keystrokes to the "navigation" category (one of defaults).
   * 			categoryId: 'navigation',
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label' ),
   * 					keystroke: 'CTRL+B'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfoCategory}.
   */
  addKeystrokeInfos({ categoryId = DEFAULT_CATEGORY_ID, groupId = DEFAULT_GROUP_ID, keystrokes }) {
    if (!this.keystrokeInfos.has(categoryId)) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, { categoryId, keystrokes });
    }
    const category = this.keystrokeInfos.get(categoryId);
    if (!category.groups.has(groupId)) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-group", this._editor, { groupId, categoryId, keystrokes });
    }
    category.groups.get(groupId).keystrokes.push(...keystrokes);
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/editorusagedata.js
function getEditorUsageData(editor) {
  return {
    sessionId: getSessionId(),
    pageSessionId: getPageSessionID(),
    hostname: window.location.hostname,
    version: globalThis.CKEDITOR_VERSION,
    type: getEditorType(editor),
    plugins: getPluginsUsageData(editor.plugins),
    distribution: getDistributionUsageData(),
    env: getEnvUsageData(),
    integration: /* @__PURE__ */ Object.create(null),
    menuBar: {
      isVisible: !!editor.config.get("menuBar.isVisible")
    },
    language: {
      ui: editor.locale.uiLanguage,
      content: editor.locale.contentLanguage
    },
    toolbar: {
      main: getToolbarUsageData(editor.config.get("toolbar")),
      block: getToolbarUsageData(editor.config.get("blockToolbar")),
      balloon: getToolbarUsageData(editor.config.get("balloonToolbar"))
    }
  };
}
function getEditorType(editor) {
  return Object.getPrototypeOf(editor).constructor.editorName;
}
function getPluginsUsageData(collection) {
  return Array.from(collection).filter(([PluginConstructor]) => !!PluginConstructor.pluginName).map(([PluginConstructor]) => {
    const { pluginName, isContextPlugin, isOfficialPlugin, isPremiumPlugin } = PluginConstructor;
    return {
      isContext: !!isContextPlugin,
      isOfficial: !!isOfficialPlugin,
      isPremium: !!isPremiumPlugin,
      name: pluginName
    };
  });
}
function getToolbarUsageData(toolbarConfig) {
  if (!toolbarConfig) {
    return void 0;
  }
  const normalizedToolbar = Array.isArray(toolbarConfig) ? { items: toolbarConfig } : toolbarConfig;
  const flattenToolbarConfigNames = extractToolbarConfigItemsNames(normalizedToolbar.items || []);
  const isMultiline = flattenToolbarConfigNames.includes("-");
  return {
    isMultiline,
    shouldNotGroupWhenFull: !!normalizedToolbar.shouldNotGroupWhenFull,
    items: stripToolbarSeparatorItems(flattenToolbarConfigNames)
  };
  function stripToolbarSeparatorItems(items) {
    return items.filter((item) => item !== "|" && item !== "-");
  }
  function extractToolbarConfigItemsNames(items) {
    return items.flatMap((item) => {
      if (typeof item === "string") {
        return [item];
      }
      return extractToolbarConfigItemsNames(item.items);
    });
  }
}
function getDistributionUsageData() {
  return {
    channel: window[Symbol.for("cke distribution")] || "sh"
  };
}
function getEnvUsageData() {
  let os = "unknown";
  let browser = "unknown";
  if (env_default.isMac) {
    os = "mac";
  } else if (env_default.isWindows) {
    os = "windows";
  } else if (env_default.isiOS) {
    os = "ios";
  } else if (env_default.isAndroid) {
    os = "android";
  }
  if (env_default.isGecko) {
    browser = "gecko";
  } else if (env_default.isBlink) {
    browser = "blink";
  } else if (env_default.isSafari) {
    browser = "safari";
  }
  return {
    os,
    browser
  };
}
function getSessionId() {
  if (!localStorage.getItem("__ckeditor-session-id")) {
    localStorage.setItem("__ckeditor-session-id", uid());
  }
  return localStorage.getItem("__ckeditor-session-id");
}
function getPageSessionID() {
  global_default.window.CKEDITOR_PAGE_SESSION_ID = global_default.window.CKEDITOR_PAGE_SESSION_ID || uid();
  return global_default.window.CKEDITOR_PAGE_SESSION_ID;
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/editor.js
var Editor = class extends ObservableMixin() {
  /**
   * A required name of the editor class. The name should reflect the constructor name.
   */
  static get editorName() {
    return "Editor";
  }
  /**
   * Creates a new instance of the editor class.
   *
   * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
   *
   * @param config The editor configuration.
   */
  constructor(config = {}) {
    super();
    if ("sanitizeHtml" in config) {
      throw new CKEditorError("editor-config-sanitizehtml-not-supported");
    }
    const constructor = this.constructor;
    const { translations: defaultTranslations, ...defaultConfig } = constructor.defaultConfig || {};
    const { translations = defaultTranslations, ...rest } = config;
    const language = config.language || defaultConfig.language;
    this._context = config.context || new Context({ language, translations });
    this._context._addEditor(this, !config.context);
    const availablePlugins = Array.from(constructor.builtinPlugins || []);
    this.config = new Config(rest, defaultConfig);
    this.config.define("plugins", availablePlugins);
    this.config.define(this._context._getEditorConfig());
    checkLicenseKeyIsDefined(this.config);
    this.plugins = new PluginCollection(this, availablePlugins, this._context.plugins);
    this.locale = this._context.locale;
    this.t = this.locale.t;
    this._readOnlyLocks = /* @__PURE__ */ new Set();
    this.commands = new CommandCollection();
    this.set("state", "initializing");
    this.once("ready", () => this.state = "ready", { priority: "high" });
    this.once("destroy", () => this.state = "destroyed", { priority: "high" });
    this.model = new Model();
    this.on("change:isReadOnly", () => {
      this.model.document.isReadOnly = this.isReadOnly;
    });
    const stylesProcessor = new StylesProcessor();
    this.data = new DataController(this.model, stylesProcessor);
    this.editing = new EditingController(this.model, stylesProcessor);
    this.editing.view.document.bind("isReadOnly").to(this);
    this.conversion = new Conversion([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
    this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
    this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
    this.keystrokes = new EditingKeystrokeHandler(this);
    this.keystrokes.listenTo(this.editing.view.document);
    this.accessibility = new Accessibility(this);
    verifyLicenseKey(this);
    function checkLicenseKeyIsDefined(config2) {
      let licenseKey = config2.get("licenseKey");
      if (!licenseKey && window.CKEDITOR_GLOBAL_LICENSE_KEY) {
        licenseKey = window.CKEDITOR_GLOBAL_LICENSE_KEY;
        config2.set("licenseKey", licenseKey);
      }
      if (!licenseKey) {
        throw new CKEditorError("license-key-missing");
      }
    }
    function verifyLicenseKey(editor) {
      const licenseKey = editor.config.get("licenseKey");
      const distributionChannel = window[Symbol.for("cke distribution")] || "sh";
      function blockEditor(reason) {
        editor.enableReadOnlyMode(Symbol("invalidLicense"));
        editor._showLicenseError(reason);
      }
      function getPayload(licenseKey2) {
        const parts = licenseKey2.split(".");
        if (parts.length != 3) {
          return null;
        }
        return parts[1];
      }
      function hasAllRequiredFields(licensePayload2) {
        const requiredFields = ["exp", "jti", "vc"];
        return requiredFields.every((field) => field in licensePayload2);
      }
      function getCrcInputData(licensePayload2) {
        const keysToCheck = Object.getOwnPropertyNames(licensePayload2).sort();
        const filteredValues = keysToCheck.filter((key) => key != "vc" && licensePayload2[key] != null).map((key) => licensePayload2[key]);
        return filteredValues;
      }
      function checkLicensedHosts(licensedHosts2) {
        const { hostname } = new URL(window.location.href);
        if (licensedHosts2.includes(hostname)) {
          return true;
        }
        const segments = hostname.split(".");
        return licensedHosts2.filter((host) => host.includes("*")).map((host) => host.split(".")).filter((host) => host.length <= segments.length).map((host) => Array(segments.length - host.length).fill(host[0] === "*" ? "*" : "").concat(host)).some((octets) => segments.every((segment, index) => octets[index] === segment || octets[index] === "*"));
      }
      if (licenseKey == "GPL") {
        if (distributionChannel == "cloud") {
          blockEditor("distributionChannel");
        }
        return;
      }
      const encodedPayload = getPayload(licenseKey);
      if (!encodedPayload) {
        blockEditor("invalid");
        return;
      }
      const licensePayload = parseBase64EncodedObject(encodedPayload);
      if (!licensePayload) {
        blockEditor("invalid");
        return;
      }
      if (!hasAllRequiredFields(licensePayload)) {
        blockEditor("invalid");
        return;
      }
      if (licensePayload.distributionChannel && !toArray(licensePayload.distributionChannel).includes(distributionChannel)) {
        blockEditor("distributionChannel");
        return;
      }
      if (crc32(getCrcInputData(licensePayload)) != licensePayload.vc.toLowerCase()) {
        blockEditor("invalid");
        return;
      }
      const expirationDate = new Date(licensePayload.exp * 1e3);
      if (expirationDate < releaseDate) {
        blockEditor("expired");
        return;
      }
      const licensedHosts = licensePayload.licensedHosts;
      if (licensedHosts && licensedHosts.length > 0 && !checkLicensedHosts(licensedHosts)) {
        blockEditor("domainLimit");
        return;
      }
      if (["evaluation", "trial"].includes(licensePayload.licenseType) && licensePayload.exp * 1e3 < Date.now()) {
        blockEditor("expired");
        return;
      }
      if (["evaluation", "trial", "development"].includes(licensePayload.licenseType)) {
        const licenseType = licensePayload.licenseType;
        console.info(`You are using the ${licenseType} version of CKEditor 5 with limited usage. Make sure you will not use it in the production environment.`);
        const timerId = setTimeout(() => {
          blockEditor(`${licenseType}Limit`);
        }, 6e5);
        editor.on("destroy", () => {
          clearTimeout(timerId);
        });
      }
      if (licensePayload.usageEndpoint) {
        editor.once("ready", () => {
          const request = {
            requestId: uid(),
            requestTime: Math.round(Date.now() / 1e3),
            license: licenseKey,
            editor: collectUsageData(editor)
          };
          editor._sendUsageRequest(licensePayload.usageEndpoint, request).then((response) => {
            const { status, message } = response;
            if (message) {
              console.warn(message);
            }
            if (status != "ok") {
              blockEditor("usageLimit");
            }
          }, () => {
            logError("license-key-validation-endpoint-not-reachable", { url: licensePayload.usageEndpoint });
          });
        }, { priority: "high" });
      }
    }
  }
  /**
   * Defines whether the editor is in the read-only mode.
   *
   * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
   * to modify the document by using them. Also, the editable element(s) become non-editable.
   *
   * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'feature-id' );
   * ```
   *
   * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:
   *
   * ```ts
   * editor.disableReadOnlyMode( 'feature-id' );
   * ```
   *
   * @readonly
   * @observable
   */
  get isReadOnly() {
    return this._readOnlyLocks.size > 0;
  }
  set isReadOnly(value) {
    throw new CKEditorError("editor-isreadonly-has-no-setter");
  }
  /**
   * Turns on the read-only mode in the editor.
   *
   * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking
   * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at
   * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which
   * could lead to errors).
   *
   * Each read-only mode request is identified by a unique id (also called "lock"). If multiple plugins requested to turn on the
   * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).
   *
   * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.
   *
   * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:
   *
   * ```ts
   * editor.isReadOnly; // `false`.
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `true`.
   * ```
   *
   * You can turn off the read-only mode ("clear the lock") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * // ...
   * editor.disableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `false`.
   * ```
   *
   * All "locks" need to be removed to enable editing:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * editor.enableReadOnlyMode( 'my-other-feature-id' );
   * // ...
   * editor.disableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `true`.
   * editor.disableReadOnlyMode( 'my-other-feature-id' );
   * editor.isReadOnly; // `false`.
   * ```
   *
   * @param lockId A unique ID for setting the editor to the read-only state.
   */
  enableReadOnlyMode(lockId) {
    if (typeof lockId !== "string" && typeof lockId !== "symbol") {
      throw new CKEditorError("editor-read-only-lock-id-invalid", null, { lockId });
    }
    if (this._readOnlyLocks.has(lockId)) {
      return;
    }
    this._readOnlyLocks.add(lockId);
    if (this._readOnlyLocks.size === 1) {
      this.fire("change:isReadOnly", "isReadOnly", true, false);
    }
  }
  /**
   * Removes the read-only lock from the editor with given lock ID.
   *
   * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.
   *
   * @param lockId The lock ID for setting the editor to the read-only state.
   */
  disableReadOnlyMode(lockId) {
    if (typeof lockId !== "string" && typeof lockId !== "symbol") {
      throw new CKEditorError("editor-read-only-lock-id-invalid", null, { lockId });
    }
    if (!this._readOnlyLocks.has(lockId)) {
      return;
    }
    this._readOnlyLocks.delete(lockId);
    if (this._readOnlyLocks.size === 0) {
      this.fire("change:isReadOnly", "isReadOnly", false, true);
    }
  }
  /**
   * Sets the data in the editor.
   *
   * ```ts
   * editor.setData( '<p>This is editor!</p>' );
   * ```
   *
   * If your editor implementation uses multiple roots, you should pass an object with keys corresponding
   * to the editor root names and values equal to the data that should be set in each root:
   *
   * ```ts
   * editor.setData( {
   *     header: '<p>Content for header part.</p>',
   *     content: '<p>Content for main part.</p>',
   *     footer: '<p>Content for footer part.</p>'
   * } );
   * ```
   *
   * By default the editor accepts HTML. This can be controlled by injecting a different data processor.
   * See the {@glink features/markdown Markdown output} guide for more details.
   *
   * @param data Input data.
   */
  setData(data) {
    this.data.set(data);
  }
  /**
   * Gets the data from the editor.
   *
   * ```ts
   * editor.getData(); // -> '<p>This is editor!</p>'
   * ```
   *
   * If your editor implementation uses multiple roots, you should pass root name as one of the options:
   *
   * ```ts
   * editor.getData( { rootName: 'header' } ); // -> '<p>Content for header part.</p>'
   * ```
   *
   * By default, the editor outputs HTML. This can be controlled by injecting a different data processor.
   * See the {@glink features/markdown Markdown output} guide for more details.
   *
   * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
   * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
   *
   * @param options Additional configuration for the retrieved data.
   * Editor features may introduce more configuration options that can be set through this parameter.
   * @param options.rootName Root name. Defaults to `'main'`.
   * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
   * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
   * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
   * @returns Output data.
   */
  getData(options) {
    return this.data.get(options);
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
   */
  initPlugins() {
    const config = this.config;
    const plugins = config.get("plugins");
    const removePlugins = config.get("removePlugins") || [];
    const extraPlugins = config.get("extraPlugins") || [];
    const substitutePlugins = config.get("substitutePlugins") || [];
    return this.plugins.init(plugins.concat(extraPlugins), removePlugins, substitutePlugins);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * **Note** The editor cannot be destroyed during the initialization phase so if it is called
   * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
   *
   * @fires destroy
   * @returns A promise that resolves once the editor instance is fully destroyed.
   */
  destroy() {
    let readyPromise = Promise.resolve();
    if (this.state == "initializing") {
      readyPromise = new Promise((resolve) => this.once("ready", resolve));
    }
    return readyPromise.then(() => {
      this.fire("destroy");
      this.stopListening();
      this.commands.destroy();
    }).then(() => this.plugins.destroy()).then(() => {
      this.model.destroy();
      this.data.destroy();
      this.editing.destroy();
      this.keystrokes.destroy();
    }).then(() => this._context._removeEditor(this));
  }
  /**
   * Executes the specified command with given parameters.
   *
   * Shorthand for:
   *
   * ```ts
   * editor.commands.get( commandName ).execute( ... );
   * ```
   *
   * @param commandName The name of the command to execute.
   * @param commandParams Command parameters.
   * @returns The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.
   */
  execute(commandName, ...commandParams) {
    try {
      return this.commands.execute(commandName, ...commandParams);
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  /**
   * Focuses the editor.
   *
   * **Note** To explicitly focus the editing area of the editor, use the
   * {@link module:engine/view/view~View#focus `editor.editing.view.focus()`} method of the editing view.
   *
   * Check out the {@glink framework/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section
   * of the {@glink framework/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.
   */
  focus() {
    this.editing.view.focus();
  }
  /* istanbul ignore next -- @preserve */
  /**
   * Creates and initializes a new editor instance.
   *
   * This is an abstract method. Every editor type needs to implement its own initialization logic.
   *
   * See the `create()` methods of the existing editor types to learn how to use them:
   *
   * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
   * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
   * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
   * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
   */
  static create(...args) {
    throw new Error("This is an abstract method.");
  }
  _showLicenseError(reason, pluginName) {
    setTimeout(() => {
      if (reason == "invalid") {
        throw new CKEditorError("invalid-license-key");
      }
      if (reason == "expired") {
        throw new CKEditorError("license-key-expired");
      }
      if (reason == "domainLimit") {
        throw new CKEditorError("license-key-domain-limit");
      }
      if (reason == "featureNotAllowed") {
        throw new CKEditorError("license-key-plugin-not-allowed", null, { pluginName });
      }
      if (reason == "evaluationLimit") {
        throw new CKEditorError("license-key-evaluation-limit");
      }
      if (reason == "trialLimit") {
        throw new CKEditorError("license-key-trial-limit");
      }
      if (reason == "developmentLimit") {
        throw new CKEditorError("license-key-development-limit");
      }
      if (reason == "usageLimit") {
        throw new CKEditorError("license-key-usage-limit");
      }
      if (reason == "distributionChannel") {
        throw new CKEditorError("license-key-invalid-distribution-channel");
      }
      const unreachable = reason;
    }, 0);
    this._showLicenseError = () => {
    };
  }
  /**
   * This part of the code is _not_ executed in installations under the GPL license (with `config.licenseKey = 'GPL'`).
   *
   * It is only executed when a specific license key is provided. If you are uncertain whether
   * this applies to your installation, please contact our support team.
   */
  async _sendUsageRequest(endpoint, request) {
    const headers = new Headers({ "Content-Type": "application/json" });
    const response = await fetch(new URL(endpoint), {
      method: "POST",
      headers,
      body: JSON.stringify(request)
    });
    if (!response.ok) {
      throw new Error(`HTTP Response: ${response.status}`);
    }
    return response.json();
  }
};
Editor.Context = Context;
Editor.EditorWatchdog = EditorWatchdog;
Editor.ContextWatchdog = ContextWatchdog;
var editor_default = Editor;
function collectUsageData(editor) {
  const collectedData = getEditorUsageData(editor);
  function setUsageData(path, value) {
    if (get_default(collectedData, path) !== void 0) {
      throw new CKEditorError("editor-usage-data-path-already-set", { path });
    }
    set_default(collectedData, path, value);
  }
  editor.fire("collectUsageData", {
    setUsageData
  });
  return collectedData;
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/attachtoform.js
function attachToForm(editor) {
  if (!isFunction_default(editor.updateSourceElement)) {
    throw new CKEditorError("attachtoform-missing-elementapi-interface", editor);
  }
  const sourceElement = editor.sourceElement;
  if (isTextArea(sourceElement) && sourceElement.form) {
    let originalSubmit;
    const form = sourceElement.form;
    const onSubmit = () => editor.updateSourceElement();
    if (isFunction_default(form.submit)) {
      originalSubmit = form.submit;
      form.submit = () => {
        onSubmit();
        originalSubmit.apply(form);
      };
    }
    form.addEventListener("submit", onSubmit);
    editor.on("destroy", () => {
      form.removeEventListener("submit", onSubmit);
      if (originalSubmit) {
        form.submit = originalSubmit;
      }
    });
  }
}
function isTextArea(sourceElement) {
  return !!sourceElement && sourceElement.tagName.toLowerCase() === "textarea";
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin.js
function ElementApiMixin(base) {
  class Mixin extends base {
    updateSourceElement(data) {
      if (!this.sourceElement) {
        throw new CKEditorError("editor-missing-sourceelement", this);
      }
      const shouldUpdateSourceElement = this.config.get("updateSourceElementOnDestroy");
      const isSourceElementTextArea = this.sourceElement instanceof HTMLTextAreaElement;
      if (!shouldUpdateSourceElement && !isSourceElementTextArea) {
        setDataInElement(this.sourceElement, "");
        return;
      }
      const dataToSet = typeof data === "string" ? data : this.data.get();
      setDataInElement(this.sourceElement, dataToSet);
    }
  }
  return Mixin;
}
ElementApiMixin.updateSourceElement = ElementApiMixin(Object).prototype.updateSourceElement;

// node_modules/@ckeditor/ckeditor5-core/src/command.js
var Command = class extends ObservableMixin() {
  /**
   * Creates a new `Command` instance.
   *
   * @param editor The editor on which this command will be used.
   */
  constructor(editor) {
    super();
    this.editor = editor;
    this.set("value", void 0);
    this.set("isEnabled", false);
    this._affectsData = true;
    this._isEnabledBasedOnSelection = true;
    this._disableStack = /* @__PURE__ */ new Set();
    this.decorate("execute");
    this.listenTo(this.editor.model.document, "change", () => {
      this.refresh();
    });
    this.listenTo(editor, "change:isReadOnly", () => {
      this.refresh();
    });
    this.on("set:isEnabled", (evt) => {
      if (!this.affectsData) {
        return;
      }
      const selection = editor.model.document.selection;
      const selectionInGraveyard = selection.getFirstPosition().root.rootName == "$graveyard";
      const canEditAtSelection = !selectionInGraveyard && editor.model.canEditAt(selection);
      if (editor.isReadOnly || this._isEnabledBasedOnSelection && !canEditAtSelection) {
        evt.return = false;
        evt.stop();
      }
    }, { priority: "highest" });
    this.on("execute", (evt) => {
      if (!this.isEnabled) {
        evt.stop();
      }
    }, { priority: "high" });
  }
  /**
   * A flag indicating whether a command execution changes the editor data or not.
   *
   * Commands with `affectsData` set to `false` will not be automatically disabled in
   * the {@link module:core/editor/editor~Editor#isReadOnly read-only mode} and
   * {@glink features/read-only#related-features other editor modes} with restricted user write permissions.
   *
   * **Note:** You do not have to set it for your every command. It is `true` by default.
   *
   * @default true
   */
  get affectsData() {
    return this._affectsData;
  }
  set affectsData(affectsData) {
    this._affectsData = affectsData;
  }
  /**
   * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
   * in this method.
   *
   * This method is automatically called when
   * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.
   */
  refresh() {
    this.isEnabled = true;
  }
  /**
   * Disables the command.
   *
   * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
   * (e.g. the feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
   * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
   *
   * Disabling and enabling a command:
   *
   * ```ts
   * command.isEnabled; // -> true
   * command.forceDisabled( 'MyFeature' );
   * command.isEnabled; // -> false
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * Command disabled by multiple features:
   *
   * ```ts
   * command.forceDisabled( 'MyFeature' );
   * command.forceDisabled( 'OtherFeature' );
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> false
   * command.clearForceDisabled( 'OtherFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * Multiple disabling with the same identifier is redundant:
   *
   * ```ts
   * command.forceDisabled( 'MyFeature' );
   * command.forceDisabled( 'MyFeature' );
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
   * so the command might be still disabled after {@link #clearForceDisabled} was used.
   *
   * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
   */
  forceDisabled(id) {
    this._disableStack.add(id);
    if (this._disableStack.size == 1) {
      this.on("set:isEnabled", forceDisable, { priority: "highest" });
      this.isEnabled = false;
    }
  }
  /**
   * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
   *
   * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
   */
  clearForceDisabled(id) {
    this._disableStack.delete(id);
    if (this._disableStack.size == 0) {
      this.off("set:isEnabled", forceDisable);
      this.refresh();
    }
  }
  /**
   * Executes the command.
   *
   * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
   * to the command.
   *
   * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
   * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
   *
   * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
   *
   * This method may return a value, which would be forwarded all the way down to the
   * {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
   *
   * @fires execute
   */
  execute(...args) {
    return void 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Destroys the command.
   */
  destroy() {
    this.stopListening();
  }
};
function forceDisable(evt) {
  evt.return = false;
  evt.stop();
}

// node_modules/@ckeditor/ckeditor5-core/src/contextplugin.js
var ContextPlugin = class extends ObservableMixin() {
  /**
   * Creates a new plugin instance.
   */
  constructor(context) {
    super();
    this.context = context;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.stopListening();
  }
  /**
   * @inheritDoc
   */
  static get isContextPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return false;
  }
  /**
   * @inheritDoc
   */
  static get isPremiumPlugin() {
    return false;
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/index.js
import cancel from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/cancel.svg";
import caption from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/caption.svg";
import check from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/check.svg";
import cog from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/cog.svg";
import colorPalette from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/color-palette.svg";
import eraser from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/eraser.svg";
import history from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/history.svg";
import lowVision from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/low-vision.svg";
import textAlternative from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/text-alternative.svg";
import loupe from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/loupe.svg";
import previousArrow from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/previous-arrow.svg";
import nextArrow from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/next-arrow.svg";
import image from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/image.svg";
import imageUpload from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/image-upload.svg";
import imageAssetManager from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/image-asset-manager.svg";
import imageUrl from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/image-url.svg";
import alignBottom from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-bottom.svg";
import alignMiddle from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-middle.svg";
import alignTop from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-top.svg";
import alignLeft from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-left.svg";
import alignCenter from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-center.svg";
import alignRight from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-right.svg";
import alignJustify from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-justify.svg";
import objectBlockLeft from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-left.svg";
import objectCenter from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-center.svg";
import objectBlockRight from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-right.svg";
import objectFullWidth from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-full-width.svg";
import objectInline from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline.svg";
import objectLeft from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline-left.svg";
import objectRight from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline-right.svg";
import objectSizeFull from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-full.svg";
import objectSizeCustom from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-custom.svg";
import objectSizeLarge from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-large.svg";
import objectSizeSmall from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-small.svg";
import objectSizeMedium from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-medium.svg";
import pencil from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/pencil.svg";
import pilcrow from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/pilcrow.svg";
import quote from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/quote.svg";
import threeVerticalDots from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/three-vertical-dots.svg";
import dragIndicator from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/drag-indicator.svg";
import bold from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/bold.svg";
import paragraph from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/paragraph.svg";
import plus from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/plus.svg";
import text from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/text.svg";
import importExport from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/importexport.svg";
import redo from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/redo.svg";
import undo from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/undo.svg";
import bulletedList from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/bulletedlist.svg";
import numberedList from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/numberedlist.svg";
import todoList from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/todolist.svg";
import codeBlock from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/codeblock.svg";
import browseFiles from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/browse-files.svg";
import heading1 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading1.svg";
import heading2 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading2.svg";
import heading3 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading3.svg";
import heading4 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading4.svg";
import heading5 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading5.svg";
import heading6 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading6.svg";
import horizontalLine from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/horizontalline.svg";
import html from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/html.svg";
import indent from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/indent.svg";
import outdent from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/outdent.svg";
import table from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/table.svg";
import remove3 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/remove.svg";
import bookmark from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/bookmark.svg";
import bookmarkInline from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-core/theme/icons/bookmark_inline.svg";
var icons = {
  bold,
  cancel,
  caption,
  check,
  cog,
  colorPalette,
  eraser,
  history,
  image,
  imageUpload,
  imageAssetManager,
  imageUrl,
  lowVision,
  textAlternative,
  loupe,
  previousArrow,
  nextArrow,
  importExport,
  paragraph,
  plus,
  text,
  alignBottom,
  alignMiddle,
  alignTop,
  alignLeft,
  alignCenter,
  alignRight,
  alignJustify,
  objectLeft,
  objectCenter,
  objectRight,
  objectFullWidth,
  objectInline,
  objectBlockLeft,
  objectBlockRight,
  objectSizeCustom,
  objectSizeFull,
  objectSizeLarge,
  objectSizeSmall,
  objectSizeMedium,
  pencil,
  pilcrow,
  quote,
  threeVerticalDots,
  dragIndicator,
  redo,
  undo,
  bulletedList,
  numberedList,
  todoList,
  codeBlock,
  browseFiles,
  heading1,
  heading2,
  heading3,
  heading4,
  heading5,
  heading6,
  horizontalLine,
  html,
  indent,
  outdent,
  table,
  remove: remove3,
  bookmark,
  bookmarkInline
};

// node_modules/@ckeditor/ckeditor5-ui/src/formheader/formheaderview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css";
var FormHeaderView = class extends View {
  /**
   * Creates an instance of the form header class.
   *
   * @param locale The locale instance.
   * @param options.label A label.
   * @param options.class An additional class.
   */
  constructor(locale, options = {}) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("label", options.label || "");
    this.set("class", options.class || null);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__header",
          bind.to("class")
        ]
      },
      children: this.children
    });
    if (options.icon) {
      this.iconView = new iconview_default();
      this.iconView.content = options.icon;
      this.children.add(this.iconView);
    }
    const label = new View(locale);
    label.setTemplate({
      tag: "h2",
      attributes: {
        class: [
          "ck",
          "ck-form__header__label"
        ],
        role: "presentation"
      },
      children: [
        { text: bind.to("label") }
      ]
    });
    this.children.add(label);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/focuscycler.js
var FocusCycler = class extends EmitterMixin() {
  /**
   * Creates an instance of the focus cycler utility.
   *
   * @param options Configuration options.
   */
  constructor(options) {
    super();
    this.focusables = options.focusables;
    this.focusTracker = options.focusTracker;
    this.keystrokeHandler = options.keystrokeHandler;
    this.actions = options.actions;
    if (options.actions && options.keystrokeHandler) {
      for (const methodName in options.actions) {
        let actions = options.actions[methodName];
        if (typeof actions == "string") {
          actions = [actions];
        }
        for (const keystroke of actions) {
          options.keystrokeHandler.set(keystroke, (data, cancel2) => {
            this[methodName]();
            cancel2();
          }, options.keystrokeHandlerOptions);
        }
      }
    }
    this.on("forwardCycle", () => this.focusFirst(), { priority: "low" });
    this.on("backwardCycle", () => this.focusLast(), { priority: "low" });
  }
  /**
   * Returns the first focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get first() {
    return this.focusables.find(isDomFocusable) || null;
  }
  /**
   * Returns the last focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get last() {
    return this.focusables.filter(isDomFocusable).slice(-1)[0] || null;
  }
  /**
   * Returns the next focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get next() {
    return this._getDomFocusableItem(1);
  }
  /**
   * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
   * Returns `null` if there is none.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  get previous() {
    return this._getDomFocusableItem(-1);
  }
  /**
   * An index of the view in the {@link #focusables} which is focused according
   * to {@link #focusTracker}. Returns `null` when there is no such view.
   */
  get current() {
    let index = null;
    if (this.focusTracker.focusedElement === null) {
      return null;
    }
    this.focusables.find((view, viewIndex) => {
      const focused = view.element === this.focusTracker.focusedElement;
      if (focused) {
        index = viewIndex;
      }
      return focused;
    });
    return index;
  }
  /**
   * Focuses the {@link #first} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusFirst() {
    this._focus(this.first, 1);
  }
  /**
   * Focuses the {@link #last} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusLast() {
    this._focus(this.last, -1);
  }
  /**
   * Focuses the {@link #next} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusNext() {
    const next = this.next;
    if (next && this.focusables.getIndex(next) === this.current) {
      this.fire("forwardCycle");
      return;
    }
    if (next === this.first) {
      this.fire("forwardCycle");
    } else {
      this._focus(next, 1);
    }
  }
  /**
   * Focuses the {@link #previous} item in {@link #focusables}.
   *
   * **Note**: Hidden views (e.g. with `display: none`) are ignored.
   */
  focusPrevious() {
    const previous = this.previous;
    if (previous && this.focusables.getIndex(previous) === this.current) {
      this.fire("backwardCycle");
      return;
    }
    if (previous === this.last) {
      this.fire("backwardCycle");
    } else {
      this._focus(previous, -1);
    }
  }
  /**
   * Allows for creating continuous focus cycling across multiple focus cyclers and their collections of {@link #focusables}.
   *
   * It starts listening to the {@link module:ui/focuscycler~FocusCyclerForwardCycleEvent} and
   * {@link module:ui/focuscycler~FocusCyclerBackwardCycleEvent} events of the chained focus cycler and engages,
   * whenever the user reaches the last (forwards navigation) or first (backwards navigation) focusable view
   * and would normally start over. Instead, the navigation continues on the higher level (flattens).
   *
   * For instance, for the following nested focus navigation structure, the focus would get stuck the moment
   * the AB gets focused and its focus cycler starts managing it:
   *
   *	         
   *	    AA             AB                                   AC         
   *	                                                                   
   *	                                              
   *	                    ABA  ABB  ABC                 
   *	                                         
   *	                                                                 
   *	                                                                 
   *	                                   
   *	                                                                   
   *	         
   *
   * Chaining a focus tracker that manages AA, AB, and AC with the focus tracker that manages ABA, ABB, and ABC
   * creates a seamless navigation experience instead:
   *
   *	         
   *	    AA             AB                                   AC         
   *	                                                                   
   *	                                              
   *	                    ABA  ABB  ABC                  
   *	                                
   *	                                                                    
   *	                                                                    
   *	                                                                    
   *	                                                                    
   *	          
   *	                                                                          
   *	                                                                          
   *	
   *
   * See {@link #unchain} to reverse the chaining.
   */
  chain(chainedFocusCycler) {
    const getCurrentFocusedView = () => {
      if (this.current === null) {
        return null;
      }
      return this.focusables.get(this.current);
    };
    this.listenTo(chainedFocusCycler, "forwardCycle", (evt) => {
      const oldCurrent = getCurrentFocusedView();
      this.focusNext();
      if (oldCurrent !== getCurrentFocusedView()) {
        evt.stop();
      }
    }, { priority: "low" });
    this.listenTo(chainedFocusCycler, "backwardCycle", (evt) => {
      const oldCurrent = getCurrentFocusedView();
      this.focusPrevious();
      if (oldCurrent !== getCurrentFocusedView()) {
        evt.stop();
      }
    }, { priority: "low" });
  }
  /**
   * Reverses a chaining made by {@link #chain}.
   */
  unchain(otherFocusCycler) {
    this.stopListening(otherFocusCycler);
  }
  /**
   * Focuses the given view if it exists.
   *
   * @param view The view to be focused
   * @param direction The direction of the focus if the view has focusable children.
   * @returns
   */
  _focus(view, direction) {
    if (view && this.focusTracker.focusedElement !== view.element) {
      view.focus(direction);
    }
  }
  /**
   * Returns the next or previous focusable view in {@link #focusables} with respect
   * to {@link #current}.
   *
   * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
   */
  _getDomFocusableItem(step) {
    const collectionLength = this.focusables.length;
    if (!collectionLength) {
      return null;
    }
    const current = this.current;
    if (current === null) {
      return this[step === 1 ? "first" : "last"];
    }
    let focusableItem = this.focusables.get(current);
    let index = (current + collectionLength + step) % collectionLength;
    do {
      const focusableItemCandidate = this.focusables.get(index);
      if (isDomFocusable(focusableItemCandidate)) {
        focusableItem = focusableItemCandidate;
        break;
      }
      index = (index + collectionLength + step) % collectionLength;
    } while (index !== current);
    return focusableItem;
  }
};
function isDomFocusable(view) {
  return isFocusable(view) && isVisible(view.element);
}
function isFocusable(view) {
  return !!("focus" in view && typeof view.focus == "function");
}
function isViewWithFocusCycler(view) {
  return isFocusable(view) && "focusCycler" in view && view.focusCycler instanceof FocusCycler;
}

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/draggableviewmixin.js
function DraggableViewMixin(view) {
  class DraggableMixin extends view {
    /**
     * @inheritDoc
     */
    constructor(...args) {
      super(...args);
      this._onDragBound = this._onDrag.bind(this);
      this._onDragEndBound = this._onDragEnd.bind(this);
      this._lastDraggingCoordinates = { x: 0, y: 0 };
      this.on("render", () => {
        this._attachListeners();
      });
      this.set("isDragging", false);
    }
    /**
     * Attaches the listeners for the drag start.
     */
    _attachListeners() {
      this.listenTo(this.element, "mousedown", this._onDragStart.bind(this));
      this.listenTo(this.element, "touchstart", this._onDragStart.bind(this));
    }
    /**
     * Attaches the listeners for the dragging and drag end.
     */
    _attachDragListeners() {
      this.listenTo(global_default.document, "mouseup", this._onDragEndBound);
      this.listenTo(global_default.document, "touchend", this._onDragEndBound);
      this.listenTo(global_default.document, "mousemove", this._onDragBound);
      this.listenTo(global_default.document, "touchmove", this._onDragBound);
    }
    /**
     * Detaches the listeners after the drag end.
     */
    _detachDragListeners() {
      this.stopListening(global_default.document, "mouseup", this._onDragEndBound);
      this.stopListening(global_default.document, "touchend", this._onDragEndBound);
      this.stopListening(global_default.document, "mousemove", this._onDragBound);
      this.stopListening(global_default.document, "touchmove", this._onDragBound);
    }
    /**
     * Starts the dragging listeners and sets the initial view coordinates.
     */
    _onDragStart(evt, domEvt) {
      if (!this._isHandleElementPressed(domEvt)) {
        return;
      }
      this._attachDragListeners();
      let x = 0;
      let y = 0;
      if (domEvt instanceof MouseEvent) {
        x = domEvt.clientX;
        y = domEvt.clientY;
      } else {
        x = domEvt.touches[0].clientX;
        y = domEvt.touches[0].clientY;
      }
      this._lastDraggingCoordinates = { x, y };
      this.isDragging = true;
    }
    /**
     * Updates the view coordinates and fires the `drag` event.
     */
    _onDrag(evt, domEvt) {
      if (!this.isDragging) {
        this._detachDragListeners();
        return;
      }
      let newX = 0;
      let newY = 0;
      if (domEvt instanceof MouseEvent) {
        newX = domEvt.clientX;
        newY = domEvt.clientY;
      } else {
        newX = domEvt.touches[0].clientX;
        newY = domEvt.touches[0].clientY;
      }
      domEvt.preventDefault();
      this.fire("drag", {
        deltaX: Math.round(newX - this._lastDraggingCoordinates.x),
        deltaY: Math.round(newY - this._lastDraggingCoordinates.y)
      });
      this._lastDraggingCoordinates = { x: newX, y: newY };
    }
    /**
     * Stops the dragging and detaches the listeners.
     */
    _onDragEnd() {
      this._detachDragListeners();
      this.isDragging = false;
    }
    /**
     * Checks if the drag handle element was pressed.
     */
    _isHandleElementPressed(domEvt) {
      if (!this.dragHandleElement) {
        return false;
      }
      return this.dragHandleElement === domEvt.target || domEvt.target instanceof HTMLElement && this.dragHandleElement.contains(domEvt.target);
    }
  }
  return DraggableMixin;
}

// node_modules/@ckeditor/ckeditor5-ui/src/dialog/dialogactionsview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dialog/dialogactions.css";
var DialogActionsView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.children = this.createCollection();
    this.keystrokes = new KeystrokeHandler();
    this._focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this.focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this._focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dialog__actions"
        ]
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
  }
  /**
   * Creates the button views based on the given definitions.
   * Then adds them to the {@link #children} collection and to the focus cycler.
   */
  setButtons(definitions) {
    for (const definition of definitions) {
      const button = new ButtonView(this.locale);
      let property;
      button.on("execute", () => definition.onExecute());
      if (definition.onCreate) {
        definition.onCreate(button);
      }
      for (property in definition) {
        if (property != "onExecute" && property != "onCreate") {
          button.set(property, definition[property]);
        }
      }
      this.children.add(button);
    }
    this._updateFocusCyclableItems();
  }
  /**
   * @inheritDoc
   */
  focus(direction) {
    if (direction === -1) {
      this.focusCycler.focusLast();
    } else {
      this.focusCycler.focusFirst();
    }
  }
  /**
   * Adds all elements from the {@link #children} collection to the {@link #_focusables} collection
   * and to the {@link #_focusTracker} instance.
   */
  _updateFocusCyclableItems() {
    Array.from(this.children).forEach((v) => {
      this._focusables.add(v);
      this._focusTracker.add(v.element);
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dialog/dialogcontentview.js
var DialogContentView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-dialog__content"]
      },
      children: this.children
    });
  }
  /**
   * Removes all the child views.
   */
  reset() {
    while (this.children.length) {
      this.children.remove(0);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dialog/dialogview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dialog/dialog.css";
var DialogViewPosition = {
  SCREEN_CENTER: "screen-center",
  EDITOR_CENTER: "editor-center",
  EDITOR_TOP_SIDE: "editor-top-side",
  EDITOR_TOP_CENTER: "editor-top-center",
  EDITOR_BOTTOM_CENTER: "editor-bottom-center",
  EDITOR_ABOVE_CENTER: "editor-above-center",
  EDITOR_BELOW_CENTER: "editor-below-center"
};
var toPx = toUnit("px");
var DialogView = class _DialogView extends DraggableViewMixin(View) {
  /**
   * @inheritDoc
   */
  constructor(locale, { getCurrentDomRoot, getViewportOffset }) {
    super(locale);
    this.wasMoved = false;
    const bind = this.bindTemplate;
    const t = locale.t;
    this.set("className", "");
    this.set("ariaLabel", t("Editor dialog"));
    this.set("isModal", false);
    this.set("position", DialogViewPosition.SCREEN_CENTER);
    this.set("_isVisible", false);
    this.set("_isTransparent", false);
    this.set("_top", 0);
    this.set("_left", 0);
    this._getCurrentDomRoot = getCurrentDomRoot;
    this._getViewportOffset = getViewportOffset;
    this.decorate("moveTo");
    this.parts = this.createCollection();
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dialog-overlay",
          bind.if("isModal", "ck-dialog-overlay__transparent", (isModal) => !isModal),
          bind.if("_isVisible", "ck-hidden", (value) => !value)
        ],
        // Prevent from editor losing focus when clicking on the modal overlay.
        tabindex: "-1"
      },
      children: [
        {
          tag: "div",
          attributes: {
            tabindex: "-1",
            class: [
              "ck",
              "ck-dialog",
              bind.if("isModal", "ck-dialog_modal"),
              bind.to("className")
            ],
            role: "dialog",
            "aria-label": bind.to("ariaLabel"),
            style: {
              top: bind.to("_top", (top) => toPx(top)),
              left: bind.to("_left", (left) => toPx(left)),
              visibility: bind.if("_isTransparent", "hidden")
            }
          },
          children: this.parts
        }
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.keystrokes.set("Esc", (data, cancel2) => {
      if (!data.defaultPrevented) {
        this.fire("close", { source: "escKeyPress" });
        cancel2();
      }
    });
    this.on("drag", (evt, { deltaX, deltaY }) => {
      this.wasMoved = true;
      this.moveBy(deltaX, deltaY);
    });
    this.listenTo(global_default.window, "resize", () => {
      if (this._isVisible && !this.wasMoved) {
        this.updatePosition();
      }
    });
    this.listenTo(global_default.document, "scroll", () => {
      if (this._isVisible && !this.wasMoved) {
        this.updatePosition();
      }
    });
    this.on("change:_isVisible", (evt, name, isVisible2) => {
      if (isVisible2) {
        this._isTransparent = true;
        setTimeout(() => {
          this.updatePosition();
          this._isTransparent = false;
          this.focus();
        }, 10);
      }
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
   * Returns the element that should be used as a drag handle.
   */
  get dragHandleElement() {
    if (this.headerView && !this.isModal) {
      return this.headerView.element;
    } else {
      return null;
    }
  }
  /**
   * Creates the dialog parts. Which of them are created depends on the arguments passed to the method.
   * There are no rules regarding the dialog construction, that is, no part is mandatory.
   * Each part can only be created once.
   *
   * @internal
   */
  setupParts({ icon, title, hasCloseButton = true, content, actionButtons }) {
    if (title) {
      this.headerView = new FormHeaderView(this.locale, { icon });
      if (hasCloseButton) {
        this.closeButtonView = this._createCloseButton();
        this.headerView.children.add(this.closeButtonView);
      }
      this.headerView.label = title;
      this.ariaLabel = title;
      this.parts.add(this.headerView, 0);
    }
    if (content) {
      if (content instanceof View) {
        content = [content];
      }
      this.contentView = new DialogContentView(this.locale);
      this.contentView.children.addMany(content);
      this.parts.add(this.contentView);
    }
    if (actionButtons) {
      this.actionsView = new DialogActionsView(this.locale);
      this.actionsView.setButtons(actionButtons);
      this.parts.add(this.actionsView);
    }
    this._updateFocusCyclableItems();
  }
  /**
   * Focuses the first focusable element inside the dialog.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Normalizes the passed coordinates to make sure the dialog view
   * is displayed within the visible viewport and moves it there.
   *
   * @internal
   */
  moveTo(left, top) {
    const viewportRect = this._getViewportRect();
    const dialogRect = this._getDialogRect();
    if (left + dialogRect.width > viewportRect.right) {
      left = viewportRect.right - dialogRect.width;
    }
    if (left < viewportRect.left) {
      left = viewportRect.left;
    }
    if (top < viewportRect.top) {
      top = viewportRect.top;
    }
    this._moveTo(left, top);
  }
  /**
   * Moves the dialog to the specified coordinates.
   */
  _moveTo(left, top) {
    this._left = left;
    this._top = top;
  }
  /**
   * Moves the dialog by the specified offset.
   *
   * @internal
   */
  moveBy(left, top) {
    this.moveTo(this._left + left, this._top + top);
  }
  /**
   * Moves the dialog view to the off-screen position.
   * Used when there is no space to display the dialog.
   */
  _moveOffScreen() {
    this._moveTo(-9999, -9999);
  }
  /**
   * Recalculates the dialog according to the set position and viewport,
   * and moves it to the new position.
   */
  updatePosition() {
    if (!this.element || !this.element.parentNode) {
      return;
    }
    const viewportRect = this._getViewportRect();
    let configuredPosition = this.position;
    let domRootRect;
    if (!this._getCurrentDomRoot()) {
      configuredPosition = DialogViewPosition.SCREEN_CENTER;
    } else {
      domRootRect = this._getVisibleDomRootRect(viewportRect);
    }
    const defaultOffset = _DialogView.defaultOffset;
    const dialogRect = this._getDialogRect();
    switch (configuredPosition) {
      case DialogViewPosition.EDITOR_TOP_SIDE: {
        if (domRootRect) {
          const leftCoordinate = this.locale.contentLanguageDirection === "ltr" ? domRootRect.right - dialogRect.width - defaultOffset : domRootRect.left + defaultOffset;
          this.moveTo(leftCoordinate, domRootRect.top + defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.EDITOR_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), Math.round(domRootRect.top + domRootRect.height / 2 - dialogRect.height / 2));
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.SCREEN_CENTER: {
        this.moveTo(Math.round((viewportRect.width - dialogRect.width) / 2), Math.round((viewportRect.height - dialogRect.height) / 2));
        break;
      }
      case DialogViewPosition.EDITOR_TOP_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.top + defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.EDITOR_BOTTOM_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.bottom - dialogRect.height - defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.EDITOR_ABOVE_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.top - dialogRect.height - defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
      case DialogViewPosition.EDITOR_BELOW_CENTER: {
        if (domRootRect) {
          this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.bottom + defaultOffset);
        } else {
          this._moveOffScreen();
        }
        break;
      }
    }
  }
  /**
   * Calculates the visible DOM root part.
   */
  _getVisibleDomRootRect(viewportRect) {
    let visibleDomRootRect = new Rect(this._getCurrentDomRoot()).getVisible();
    if (!visibleDomRootRect) {
      return null;
    } else {
      visibleDomRootRect = viewportRect.getIntersection(visibleDomRootRect);
      if (!visibleDomRootRect) {
        return null;
      }
    }
    return visibleDomRootRect;
  }
  /**
   * Calculates the dialog element rect.
   */
  _getDialogRect() {
    return new Rect(this.element.firstElementChild);
  }
  /**
   * Returns a viewport `Rect` shrunk by the viewport offset config from all sides.
   *
   * TODO: This is a duplicate from position.ts module. It should either be exported there or land somewhere in utils.
   */
  _getViewportRect() {
    const viewportRect = new Rect(global_default.window);
    if (this.isModal) {
      return viewportRect;
    }
    const viewportOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      ...this._getViewportOffset()
    };
    viewportRect.top += viewportOffset.top;
    viewportRect.height -= viewportOffset.top;
    viewportRect.bottom -= viewportOffset.bottom;
    viewportRect.height -= viewportOffset.bottom;
    viewportRect.left += viewportOffset.left;
    viewportRect.right -= viewportOffset.right;
    viewportRect.width -= viewportOffset.left + viewportOffset.right;
    return viewportRect;
  }
  /**
   * Collects all focusable elements inside the dialog parts
   * and adds them to the focus tracker and focus cycler.
   */
  _updateFocusCyclableItems() {
    const focusables = [];
    if (this.contentView) {
      for (const child of this.contentView.children) {
        if (isFocusable(child)) {
          focusables.push(child);
        }
      }
    }
    if (this.actionsView) {
      focusables.push(this.actionsView);
    }
    if (this.closeButtonView) {
      focusables.push(this.closeButtonView);
    }
    focusables.forEach((focusable) => {
      this._focusables.add(focusable);
      this.focusTracker.add(focusable.element);
      if (isViewWithFocusCycler(focusable)) {
        this._focusCycler.chain(focusable.focusCycler);
      }
    });
  }
  /**
   * Creates the close button view that is displayed in the header view corner.
   */
  _createCloseButton() {
    const buttonView = new ButtonView(this.locale);
    const t = this.locale.t;
    buttonView.set({
      label: t("Close"),
      tooltip: true,
      icon: icons.cancel
    });
    buttonView.on("execute", () => this.fire("close", { source: "closeButton" }));
    return buttonView;
  }
};
DialogView.defaultOffset = 15;
var dialogview_default = DialogView;

// node_modules/@ckeditor/ckeditor5-ui/src/dialog/dialog.js
var Dialog = class _Dialog extends Plugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "Dialog";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super(editor);
    const t = editor.t;
    this._initShowHideListeners();
    this._initFocusToggler();
    this._initMultiRootIntegration();
    this.set({
      id: null,
      isOpen: false
    });
    editor.accessibility.addKeystrokeInfos({
      categoryId: "navigation",
      keystrokes: [{
        label: t("Move focus in and out of an active dialog window"),
        keystroke: "Ctrl+F6",
        mayRequireFn: true
      }]
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this._unlockBodyScroll();
  }
  /**
   * Initiates listeners for the `show` and `hide` events emitted by this plugin.
   *
   * We could not simply decorate the {@link #show} and {@link #hide} methods to fire events,
   * because they would be fired in the wrong order &ndash; first would be `show` and then `hide`
   * (because showing the dialog actually starts with hiding the previously visible one).
   * Hence, we added private methods {@link #_show} and {@link #_hide} which are called on events
   * in the desired sequence.
   */
  _initShowHideListeners() {
    this.on("show", (evt, args) => {
      this._show(args);
    });
    this.on("show", (evt, args) => {
      if (args.onShow) {
        args.onShow(this);
      }
    }, { priority: "low" });
    this.on("hide", () => {
      if (_Dialog._visibleDialogPlugin) {
        _Dialog._visibleDialogPlugin._hide();
      }
    });
    this.on("hide", () => {
      if (this._onHide) {
        this._onHide(this);
        this._onHide = void 0;
      }
    }, { priority: "low" });
  }
  /**
   * Initiates keystroke handler for toggling the focus between the editor and the dialog view.
   */
  _initFocusToggler() {
    const editor = this.editor;
    editor.keystrokes.set("Ctrl+F6", (data, cancel2) => {
      if (!this.isOpen || this.view.isModal) {
        return;
      }
      if (this.view.focusTracker.isFocused) {
        editor.editing.view.focus();
      } else {
        this.view.focus();
      }
      cancel2();
    });
  }
  /**
   * Provides an integration between the root attaching and detaching and positioning of the view.
   */
  _initMultiRootIntegration() {
    const model = this.editor.model;
    model.document.on("change:data", () => {
      if (!this.view) {
        return;
      }
      const changedRoots = model.document.differ.getChangedRoots();
      for (const changes of changedRoots) {
        if (changes.state) {
          this.view.updatePosition();
        }
      }
    });
  }
  /**
   * Displays a dialog window.
   *
   * This method requires a {@link ~DialogDefinition} that defines the dialog's content, title, icon, action buttons, etc.
   *
   * For example, the following definition will create a dialog with:
   * * A header consisting of an icon, a title, and a "Close" button (it is added by default).
   * * A content consisting of a view with a single paragraph.
   * * A footer consisting of two buttons: "Yes" and "No".
   *
   * ```js
   * // Create the view that will be used as the dialog's content.
   * const textView = new View( locale );
   *
   * textView.setTemplate( {
   * 	tag: 'div',
   * 	attributes: {
   * 		style: {
   * 			padding: 'var(--ck-spacing-large)',
   * 			whiteSpace: 'initial',
   * 			width: '100%',
   * 			maxWidth: '500px'
   * 		},
   * 		tabindex: -1
   * 	},
   * 	children: [
   * 		'Lorem ipsum dolor sit amet...'
   * 	]
   * } );
   *
   * // Show the dialog.
   * editor.plugins.get( 'Dialog' ).show( {
   *	id: 'myDialog',
   * 	icon: 'myIcon', // This should be an SVG string.
   * 	title: 'My dialog',
   * 	content: textView,
   * 	actionButtons: [
   *		{
   *			label: t( 'Yes' ),
   *			class: 'ck-button-action',
   *			withText: true,
   *			onExecute: () => dialog.hide()
   *		},
   *		{
   *			label: t( 'No' ),
   *			withText: true,
   *			onExecute: () => dialog.hide()
   *		}
   *	]
   * } );
   * ```
   *
   * By specifying the {@link ~DialogDefinition#onShow} and {@link ~DialogDefinition#onHide} callbacks
   * it is also possible to add callbacks that will be called when the dialog is shown or hidden.
   *
   * For example, the callbacks in the following definition:
   * * Disable the default behavior of the <kbd>Esc</kbd> key.
   * * Fire a custom event when the dialog gets hidden.
   *
   * ```js
   * editor.plugins.get( 'Dialog' ).show( {
   * 	// ...
   * 	onShow: dialog => {
   * 		dialog.view.on( 'close', ( evt, data ) => {
   * 			// Only prevent the event from the "Esc" key - do not affect the other ways of closing the dialog.
   * 			if ( data.source === 'escKeyPress' ) {
   * 				evt.stop();
   * 			}
   * 		} );
   * 	},
   * 	onHide: dialog => {
   * 		dialog.fire( 'dialogDestroyed' );
   * 	}
   * } );
   * ```
   *
   * Internally, calling this method:
   * 1. Hides the currently visible dialog (if any) calling the {@link #hide} method
   * (fires the {@link ~DialogHideEvent hide event}).
   * 2. Fires the {@link ~DialogShowEvent show event} which allows for adding callbacks that customize the
   * behavior of the dialog.
   * 3. Shows the dialog.
   */
  show(dialogDefinition) {
    this.hide();
    this.fire(`show:${dialogDefinition.id}`, dialogDefinition);
  }
  /**
   * Handles creating the {@link module:ui/dialog/dialogview~DialogView} instance and making it visible.
   */
  _show({ id, icon, title, hasCloseButton = true, content, actionButtons, className, isModal, position, onHide }) {
    const editor = this.editor;
    this.view = new dialogview_default(editor.locale, {
      getCurrentDomRoot: () => {
        return editor.editing.view.getDomRoot(editor.model.document.selection.anchor.root.rootName);
      },
      getViewportOffset: () => {
        return editor.ui.viewportOffset;
      }
    });
    const view = this.view;
    view.on("close", () => {
      this.hide();
    });
    editor.ui.view.body.add(view);
    editor.keystrokes.listenTo(view.element);
    if (!position) {
      position = isModal ? DialogViewPosition.SCREEN_CENTER : DialogViewPosition.EDITOR_CENTER;
    }
    if (isModal) {
      this._lockBodyScroll();
    }
    view.set({
      position,
      _isVisible: true,
      className,
      isModal
    });
    view.setupParts({
      icon,
      title,
      hasCloseButton,
      content,
      actionButtons
    });
    this.id = id;
    if (onHide) {
      this._onHide = onHide;
    }
    this.isOpen = true;
    _Dialog._visibleDialogPlugin = this;
  }
  /**
   * Hides the dialog. This method is decorated to enable interacting on the {@link ~DialogHideEvent hide event}.
   *
   * See {@link #show}.
   */
  hide() {
    if (_Dialog._visibleDialogPlugin) {
      _Dialog._visibleDialogPlugin.fire(`hide:${_Dialog._visibleDialogPlugin.id}`);
    }
  }
  /**
   * Destroys the {@link module:ui/dialog/dialogview~DialogView} and cleans up the stored dialog state.
   */
  _hide() {
    if (!this.view) {
      return;
    }
    const editor = this.editor;
    const view = this.view;
    if (view.isModal) {
      this._unlockBodyScroll();
    }
    if (view.contentView) {
      view.contentView.reset();
    }
    editor.ui.view.body.remove(view);
    editor.ui.focusTracker.remove(view.element);
    editor.keystrokes.stopListening(view.element);
    view.destroy();
    editor.editing.view.focus();
    this.id = null;
    this.isOpen = false;
    _Dialog._visibleDialogPlugin = null;
  }
  /**
   * Makes the <body> unscrollable (e.g. when the modal shows up).
   */
  _lockBodyScroll() {
    document.documentElement.classList.add("ck-dialog-scroll-locked");
  }
  /**
   * Makes the <body> scrollable again (e.g. once the modal hides).
   */
  _unlockBodyScroll() {
    document.documentElement.classList.remove("ck-dialog-scroll-locked");
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/button/listitembuttonview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/button/listitembutton.css";
var ListItemButtonView = class extends ButtonView {
  /**
   * @inheritDoc
   */
  constructor(locale, labelView = new ButtonLabelView()) {
    super(locale, labelView);
    this._checkIconHolderView = new CheckIconHolderView();
    this.set({
      hasCheckSpace: false,
      _hasCheck: this.isToggleable
    });
    const bind = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        class: [
          "ck-list-item-button",
          bind.if("isToggleable", "ck-list-item-button_toggleable")
        ]
      }
    });
    this.bind("_hasCheck").to(this, "hasCheckSpace", this, "isToggleable", (hasCheckSpace, isToggleable) => hasCheckSpace || isToggleable);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    if (this._hasCheck) {
      this.children.add(this._checkIconHolderView, 0);
    }
    this._watchCheckIconHolderMount();
  }
  /**
   * Renders the check icon if the button is toggleable.
   */
  _watchCheckIconHolderMount() {
    this._checkIconHolderView.bind("isOn").to(this, "isOn", (value) => this.isToggleable && value);
    this.on("change:_hasCheck", (evt, propertyName, hasCheck) => {
      const { children, _checkIconHolderView } = this;
      if (hasCheck) {
        children.add(_checkIconHolderView, 0);
      } else {
        children.remove(_checkIconHolderView);
      }
    });
  }
};
var CheckIconHolderView = class extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    this._checkIconView = this._createCheckIconView();
    const bind = this.bindTemplate;
    this.children = this.createCollection();
    this.set("isOn", false);
    this.setTemplate({
      tag: "span",
      children: this.children,
      attributes: {
        class: [
          "ck",
          "ck-list-item-button__check-holder",
          bind.to("isOn", (isOn) => isOn ? "ck-on" : "ck-off")
        ]
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    if (this.isOn) {
      this.children.add(this._checkIconView, 0);
    }
    this._watchCheckIconMount();
  }
  /**
   * Renders the check icon if the button is toggleable.
   */
  _watchCheckIconMount() {
    this.on("change:isOn", (evt, propertyName, isOn) => {
      const { children, _checkIconView } = this;
      if (isOn && !children.has(_checkIconView)) {
        children.add(_checkIconView);
      } else if (!isOn && children.has(_checkIconView)) {
        children.remove(_checkIconView);
      }
    });
  }
  /**
   * Creates a check icon view.
   */
  _createCheckIconView() {
    const iconView = new iconview_default();
    iconView.content = icons.check;
    iconView.extendTemplate({
      attributes: {
        class: "ck-list-item-button__check-icon"
      }
    });
    return iconView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/menubarmenulistitembuttonview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/menubar/menubarmenulistitembutton.css";
var MenuBarMenuListItemButtonView = class extends ListItemButtonView {
  /**
   * Creates an instance of the menu bar list button view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    this.set({
      withText: true,
      withKeystroke: true,
      tooltip: false,
      role: "menuitem"
    });
    this.extendTemplate({
      attributes: {
        class: ["ck-menu-bar__menu__item__button"]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/label/labelview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css";
var LabelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("text", void 0);
    this.set("for", void 0);
    this.id = `ck-editor__label_${uid()}`;
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "label",
      attributes: {
        class: [
          "ck",
          "ck-label"
        ],
        id: this.id,
        for: bind.to("for")
      },
      children: [
        {
          text: bind.to("text")
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/accessibilityhelp/accessibilityhelpcontentview.js
var AccessibilityHelpContentView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale, keystrokes) {
    super(locale);
    const t = locale.t;
    const helpLabel = new LabelView();
    helpLabel.text = t("Help Contents. To close this dialog press ESC.");
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-accessibility-help-dialog__content"],
        "aria-labelledby": helpLabel.id,
        role: "document",
        tabindex: -1
      },
      children: [
        createElement(document, "p", {}, t("Below, you can find a list of keyboard shortcuts that can be used in the editor.")),
        ...this._createCategories(Array.from(keystrokes.values())),
        helpLabel
      ]
    });
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.element.focus();
  }
  /**
   * Creates `<section><h3>Category label</h3>...</section>` elements for each category of keystrokes.
   */
  _createCategories(categories) {
    return categories.map((categoryDefinition) => {
      const elements = [
        // Category header.
        createElement(document, "h3", {}, categoryDefinition.label),
        // Category definitions (<dl>) and their optional headers (<h4>).
        ...Array.from(categoryDefinition.groups.values()).map((groupDefinition) => this._createGroup(groupDefinition)).flat()
      ];
      if (categoryDefinition.description) {
        elements.splice(1, 0, createElement(document, "p", {}, categoryDefinition.description));
      }
      return createElement(document, "section", {}, elements);
    });
  }
  /**
   * Creates `[<h4>Optional label</h4>]<dl>...</dl>` elements for each group of keystrokes in a category.
   */
  _createGroup(groupDefinition) {
    const definitionAndDescriptionElements = groupDefinition.keystrokes.sort((a, b) => a.label.localeCompare(b.label)).map((keystrokeDefinition) => this._createGroupRow(keystrokeDefinition)).flat();
    const elements = [
      createElement(document, "dl", {}, definitionAndDescriptionElements)
    ];
    if (groupDefinition.label) {
      elements.unshift(createElement(document, "h4", {}, groupDefinition.label));
    }
    return elements;
  }
  /**
   * Creates `<dt>Keystroke label</dt><dd>Keystroke definition</dd>` elements for each keystroke in a group.
   */
  _createGroupRow(keystrokeDefinition) {
    const t = this.locale.t;
    const dt = createElement(document, "dt");
    const dd = createElement(document, "dd");
    const normalizedKeystrokeDefinition = normalizeKeystrokeDefinition(keystrokeDefinition.keystroke);
    const keystrokeAlternativeHTMLs = [];
    for (const keystrokeAlternative of normalizedKeystrokeDefinition) {
      keystrokeAlternativeHTMLs.push(keystrokeAlternative.map(keystrokeToEnvKbd).join(""));
    }
    dt.innerHTML = keystrokeDefinition.label;
    dd.innerHTML = keystrokeAlternativeHTMLs.join(", ") + (keystrokeDefinition.mayRequireFn && env_default.isMac ? ` ${t("(may require <kbd>Fn</kbd>)")}` : "");
    return [dt, dd];
  }
};
function keystrokeToEnvKbd(keystroke) {
  return getEnvKeystrokeText(keystroke).split("+").map((part) => `<kbd>${part}</kbd>`).join("+");
}
function normalizeKeystrokeDefinition(definition) {
  if (typeof definition === "string") {
    return [[definition]];
  }
  if (typeof definition[0] === "string") {
    return [definition];
  }
  return definition;
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/accessibilityhelp/accessibilityhelp.js
import accessibilityIcon from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/icons/accessibility.svg";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/editorui/accessibilityhelp.css";
var AccessibilityHelp = class extends Plugin {
  constructor() {
    super(...arguments);
    this.contentView = null;
  }
  /**
   * @inheritDoc
   */
  static get requires() {
    return [Dialog];
  }
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "AccessibilityHelp";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    const editor = this.editor;
    const t = editor.locale.t;
    editor.ui.componentFactory.add("accessibilityHelp", () => {
      const button = this._createButton(ButtonView);
      button.set({
        tooltip: true,
        withText: false,
        label: t("Accessibility help")
      });
      return button;
    });
    editor.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
      const button = this._createButton(MenuBarMenuListItemButtonView);
      button.label = t("Accessibility");
      return button;
    });
    editor.keystrokes.set("Alt+0", (evt, cancel2) => {
      this._toggleDialog();
      cancel2();
    });
    this._setupRootLabels();
  }
  /**
   * Creates a button to show accessibility help dialog, for use either in toolbar or in menu bar.
   */
  _createButton(ButtonClass) {
    const editor = this.editor;
    const dialog = editor.plugins.get("Dialog");
    const locale = editor.locale;
    const view = new ButtonClass(locale);
    view.set({
      keystroke: "Alt+0",
      icon: accessibilityIcon,
      isToggleable: true
    });
    view.on("execute", () => this._toggleDialog());
    view.bind("isOn").to(dialog, "id", (id) => id === "accessibilityHelp");
    return view;
  }
  /**
   * Injects a help text into each editing root's `aria-label` attribute allowing assistive technology users
   * to discover the availability of the Accessibility help dialog.
   */
  _setupRootLabels() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const t = editor.t;
    editor.ui.on("ready", () => {
      editingView.change((writer) => {
        for (const root of editingView.document.roots) {
          addAriaLabelTextToRoot(writer, root);
        }
      });
      editor.on("addRoot", (evt, modelRoot) => {
        const viewRoot = editor.editing.view.document.getRoot(modelRoot.rootName);
        editingView.change((writer) => addAriaLabelTextToRoot(writer, viewRoot));
      }, { priority: "low" });
    });
    function addAriaLabelTextToRoot(writer, viewRoot) {
      const currentAriaLabel = viewRoot.getAttribute("aria-label");
      const newAriaLabel = [currentAriaLabel, t("Press %0 for help.", [getEnvKeystrokeText("Alt+0")])].filter((segment) => segment).join(". ");
      writer.setAttribute("aria-label", newAriaLabel, viewRoot);
    }
  }
  /**
   * Shows the accessibility help dialog. Also, creates {@link #contentView} on demand.
   */
  _toggleDialog() {
    const editor = this.editor;
    const dialog = editor.plugins.get("Dialog");
    const t = editor.locale.t;
    if (!this.contentView) {
      this.contentView = new AccessibilityHelpContentView(editor.locale, editor.accessibility.keystrokeInfos);
    }
    if (dialog.id === "accessibilityHelp") {
      dialog.hide();
    } else {
      dialog.show({
        id: "accessibilityHelp",
        className: "ck-accessibility-help-dialog",
        title: t("Accessibility help"),
        icon: accessibilityIcon,
        hasCloseButton: true,
        content: this.contentView
      });
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler.js
function clickOutsideHandler({ emitter, activator, callback, contextElements, listenerOptions }) {
  emitter.listenTo(document, "mousedown", (evt, domEvt) => {
    if (!activator()) {
      return;
    }
    const path = typeof domEvt.composedPath == "function" ? domEvt.composedPath() : [];
    const contextElementsList = typeof contextElements == "function" ? contextElements() : contextElements;
    for (const contextElement of contextElementsList) {
      if (contextElement.contains(domEvt.target) || path.includes(contextElement)) {
        return;
      }
    }
    callback();
  }, listenerOptions);
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/bodycollection.js
var BodyCollection = class _BodyCollection extends ViewCollection {
  /**
   * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
   *
   * @param locale The {@link module:core/editor/editor~Editor editor's locale} instance.
   * @param initialItems The initial items of the collection.
   */
  constructor(locale, initialItems = []) {
    super(initialItems);
    this.locale = locale;
  }
  /**
   * The element holding elements of the body collection.
   */
  get bodyCollectionContainer() {
    return this._bodyCollectionContainer;
  }
  /**
   * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
   * the body collection.
   */
  attachToDom() {
    this._bodyCollectionContainer = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset_all",
          "ck-body",
          "ck-rounded-corners"
        ],
        dir: this.locale.uiLanguageDirection,
        role: "application"
      },
      children: this
    }).render();
    if (!_BodyCollection._bodyWrapper || !_BodyCollection._bodyWrapper.isConnected) {
      _BodyCollection._bodyWrapper = createElement(document, "div", { class: "ck-body-wrapper" });
      document.body.appendChild(_BodyCollection._bodyWrapper);
    }
    _BodyCollection._bodyWrapper.appendChild(this._bodyCollectionContainer);
  }
  /**
   * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
   * anymore to clean-up the DOM structure.
   */
  detachFromDom() {
    super.destroy();
    if (this._bodyCollectionContainer) {
      this._bodyCollectionContainer.remove();
    }
    if (_BodyCollection._bodyWrapper && !_BodyCollection._bodyWrapper.childElementCount) {
      _BodyCollection._bodyWrapper.remove();
      delete _BodyCollection._bodyWrapper;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/button/switchbuttonview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css";
var SwitchButtonView = class extends ButtonView {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.isToggleable = true;
    this.toggleSwitchView = this._createToggleView();
    this.extendTemplate({
      attributes: {
        class: "ck-switchbutton"
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.add(this.toggleSwitchView);
  }
  /**
   * Creates a toggle child view.
   */
  _createToggleView() {
    const toggleSwitchView = new View();
    toggleSwitchView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__toggle"
        ]
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__toggle__inner"
            ]
          }
        }
      ]
    });
    return toggleSwitchView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/button/filedialogbuttonview.js
var FileDialogButtonView = class extends FileDialogViewMixin(ButtonView) {
};
var FileDialogListItemButtonView = class extends FileDialogViewMixin(ListItemButtonView) {
};
function FileDialogViewMixin(view) {
  class FileDialogView extends view {
    /**
     * @inheritDoc
     */
    constructor(...args) {
      super(...args);
      this.buttonView = this;
      this._fileInputView = new FileInputView(this.locale);
      this._fileInputView.bind("acceptedType").to(this);
      this._fileInputView.bind("allowMultipleFiles").to(this);
      this._fileInputView.delegate("done").to(this);
      this.on("execute", () => {
        this._fileInputView.open();
      });
      this.extendTemplate({
        attributes: {
          class: "ck-file-dialog-button"
        }
      });
    }
    /**
     * @inheritDoc
     */
    render() {
      super.render();
      this.children.add(this._fileInputView);
    }
  }
  return FileDialogView;
}
var FileInputView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("acceptedType", void 0);
    this.set("allowMultipleFiles", false);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck-hidden"
        ],
        type: "file",
        tabindex: "-1",
        accept: bind.to("acceptedType"),
        multiple: bind.to("allowMultipleFiles")
      },
      on: {
        // Removing from code coverage since we cannot programmatically set input element files.
        change: bind.to(
          /* istanbul ignore next -- @preserve */
          () => {
            if (this.element && this.element.files && this.element.files.length) {
              this.fire("done", this.element.files);
            }
            this.element.value = "";
          }
        )
      }
    });
  }
  /**
   * Opens file dialog.
   */
  open() {
    this.element.click();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/collapsible/collapsibleview.js
import dropdownArrowIcon from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/collapsible/collapsible.css";

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colortileview.js
import checkIcon from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-tile-check.svg";

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colorgridview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css";

// node_modules/@ckeditor/ckeditor5-ui/src/colorpicker/utils.js
var convert = __toESM(require_color_convert(), 1);

// node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/labeledfieldview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css";
var LabeledFieldView = class extends View {
  /**
   * Creates an instance of the labeled field view class using a provided creator function
   * that provides the view to be labeled.
   *
   * @param locale The locale instance.
   * @param viewCreator A function that returns a {@link module:ui/view~View}
   * that will be labeled. The following arguments are passed to the creator function:
   *
   * * an instance of the `LabeledFieldView` to allow binding observable properties,
   * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
   * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
   */
  constructor(locale, viewCreator) {
    super(locale);
    const viewUid = `ck-labeled-field-view-${uid()}`;
    const statusUid = `ck-labeled-field-view-status-${uid()}`;
    this.fieldView = viewCreator(this, viewUid, statusUid);
    this.set("label", void 0);
    this.set("isEnabled", true);
    this.set("isEmpty", true);
    this.set("isFocused", false);
    this.set("errorText", null);
    this.set("infoText", null);
    this.set("class", void 0);
    this.set("placeholder", void 0);
    this.labelView = this._createLabelView(viewUid);
    this.statusView = this._createStatusView(statusUid);
    this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]);
    this.bind("_statusText").to(this, "errorText", this, "infoText", (errorText, infoText) => errorText || infoText);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isEmpty", "ck-labeled-field-view_empty"),
          bind.if("isFocused", "ck-labeled-field-view_focused"),
          bind.if("placeholder", "ck-labeled-field-view_placeholder"),
          bind.if("errorText", "ck-error")
        ]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__input-wrapper"
            ]
          },
          children: this.fieldWrapperChildren
        },
        this.statusView
      ]
    });
  }
  /**
   * Creates label view class instance and bind with view.
   *
   * @param id Unique id to set as labelView#for attribute.
   */
  _createLabelView(id) {
    const labelView = new LabelView(this.locale);
    labelView.for = id;
    labelView.bind("text").to(this, "label");
    return labelView;
  }
  /**
   * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
   * next to the {@link #fieldView}. See {@link #_statusText}.
   *
   * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
   * `aria-describedby` attribute.
   */
  _createStatusView(statusUid) {
    const statusView = new View(this.locale);
    const bind = this.bindTemplate;
    statusView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view__status",
          bind.if("errorText", "ck-labeled-field-view__status_error"),
          bind.if("_statusText", "ck-hidden", (value) => !value)
        ],
        id: statusUid,
        role: bind.if("errorText", "alert")
      },
      children: [
        {
          text: bind.to("_statusText")
        }
      ]
    });
    return statusView;
  }
  /**
   * Focuses the {@link #fieldView}.
   */
  focus(direction) {
    this.fieldView.focus(direction);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/input/inputbase.js
var InputBase = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("value", void 0);
    this.set("id", void 0);
    this.set("placeholder", void 0);
    this.set("tabIndex", void 0);
    this.set("isReadOnly", false);
    this.set("hasError", false);
    this.set("ariaDescribedById", void 0);
    this.set("ariaLabel", void 0);
    this.focusTracker = new FocusTracker();
    this.bind("isFocused").to(this.focusTracker);
    this.set("isEmpty", true);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck",
          "ck-input",
          bind.if("isFocused", "ck-input_focused"),
          bind.if("isEmpty", "ck-input-text_empty"),
          bind.if("hasError", "ck-error")
        ],
        id: bind.to("id"),
        placeholder: bind.to("placeholder"),
        tabindex: bind.to("tabIndex"),
        readonly: bind.to("isReadOnly"),
        "aria-invalid": bind.if("hasError", true),
        "aria-describedby": bind.to("ariaDescribedById"),
        "aria-label": bind.to("ariaLabel")
      },
      on: {
        input: bind.to((...args) => {
          this.fire("input", ...args);
          this._updateIsEmpty();
        }),
        change: bind.to(this._updateIsEmpty.bind(this))
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.element);
    this._setDomElementValue(this.value);
    this._updateIsEmpty();
    this.on("change:value", (evt, name, value) => {
      this._setDomElementValue(value);
      this._updateIsEmpty();
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
  }
  /**
   * Moves the focus to the input and selects the value.
   */
  select() {
    this.element.select();
  }
  /**
   * Focuses the input.
   */
  focus() {
    this.element.focus();
  }
  /**
   * Resets the value of the input
   */
  reset() {
    this.value = this.element.value = "";
    this._updateIsEmpty();
  }
  /**
   * Updates the {@link #isEmpty} property value on demand.
   */
  _updateIsEmpty() {
    this.isEmpty = isInputElementEmpty(this.element);
  }
  /**
   * Sets the `value` property of the {@link #element DOM element} on demand.
   */
  _setDomElementValue(value) {
    this.element.value = !value && value !== 0 ? "" : value;
  }
};
function isInputElementEmpty(domElement) {
  return !domElement.value;
}

// node_modules/@ckeditor/ckeditor5-ui/src/input/inputview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/input/input.css";
var InputView = class extends InputBase {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.set("inputMode", "text");
    const bind = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        inputmode: bind.to("inputMode")
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/inputtext/inputtextview.js
var InputTextView = class extends InputView {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.extendTemplate({
      attributes: {
        type: "text",
        class: [
          "ck-input-text"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/textarea/textareaview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/input/input.css";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/textarea/textarea.css";

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownpanelview.js
var DropdownPanelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", false);
    this.set("position", "se");
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-dropdown__panel",
          bind.to("position", (value) => `ck-dropdown__panel_${value}`),
          bind.if("isVisible", "ck-dropdown__panel-visible")
        ],
        tabindex: "-1"
      },
      children: this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: bind.to((evt) => {
          if (evt.target.tagName.toLocaleLowerCase() === "input") {
            return;
          }
          evt.preventDefault();
        })
      }
    });
  }
  /**
   * Focuses the first view in the {@link #children} collection.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */
  focus() {
    if (this.children.length) {
      const firstChild = this.children.first;
      if (typeof firstChild.focus === "function") {
        firstChild.focus();
      } else {
        logWarning("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
      }
    }
  }
  /**
   * Focuses the view element or last item in view collection on opening dropdown's panel.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */
  focusLast() {
    if (this.children.length) {
      const lastChild = this.children.last;
      if (typeof lastChild.focusLast === "function") {
        lastChild.focusLast();
      } else {
        lastChild.focus();
      }
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css";
var DropdownView = class _DropdownView extends View {
  /**
   * Creates an instance of the dropdown.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(locale, buttonView, panelView) {
    super(locale);
    const bind = this.bindTemplate;
    this.buttonView = buttonView;
    this.panelView = panelView;
    this.set("isOpen", false);
    this.set("isEnabled", true);
    this.set("class", void 0);
    this.set("id", void 0);
    this.set("panelPosition", "auto");
    this.panelView.bind("isVisible").to(this, "isOpen");
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value)
        ],
        id: bind.to("id"),
        "aria-describedby": bind.to("ariaDescribedById")
      },
      children: [
        buttonView,
        panelView
      ]
    });
    buttonView.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown__button"
        ],
        "data-cke-tooltip-disabled": bind.to("isOpen")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.listenTo(this.buttonView, "open", () => {
      this.isOpen = !this.isOpen;
    });
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen) {
        return;
      }
      if (this.panelPosition === "auto") {
        const optimalPanelPosition = _DropdownView._getOptimalPosition({
          element: this.panelView.element,
          target: this.buttonView.element,
          fitInViewport: true,
          positions: this._panelPositions
        });
        this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._defaultPanelPositionName;
      } else {
        this.panelView.position = this.panelPosition;
      }
    });
    this.keystrokes.listenTo(this.element);
    const closeDropdown = (data, cancel2) => {
      if (this.isOpen) {
        this.isOpen = false;
        cancel2();
      }
    };
    this.keystrokes.set("arrowdown", (data, cancel2) => {
      if (this.buttonView.isEnabled && !this.isOpen) {
        this.isOpen = true;
        cancel2();
      }
    });
    this.keystrokes.set("arrowright", (data, cancel2) => {
      if (this.isOpen) {
        cancel2();
      }
    });
    this.keystrokes.set("arrowleft", closeDropdown);
    this.keystrokes.set("esc", closeDropdown);
  }
  /**
   * Focuses the {@link #buttonView}.
   */
  focus() {
    this.buttonView.focus();
  }
  /**
   * Returns {@link #panelView panel} positions to be used by the
   * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
   * utility considering the direction of the language the UI of the editor is displayed in.
   */
  get _panelPositions() {
    const { south, north, southEast, southWest, northEast, northWest, southMiddleEast, southMiddleWest, northMiddleEast, northMiddleWest } = _DropdownView.defaultPanelPositions;
    if (this.locale.uiLanguageDirection !== "rtl") {
      return [
        southEast,
        southWest,
        southMiddleEast,
        southMiddleWest,
        south,
        northEast,
        northWest,
        northMiddleEast,
        northMiddleWest,
        north
      ];
    } else {
      return [
        southWest,
        southEast,
        southMiddleWest,
        southMiddleEast,
        south,
        northWest,
        northEast,
        northMiddleWest,
        northMiddleEast,
        north
      ];
    }
  }
  /**
   * Returns the default position of the dropdown panel based on the direction of the UI language.
   * It is used when the {@link #panelPosition} is set to `'auto'` and the panel has not found a
   * suitable position to fit into the viewport.
   */
  get _defaultPanelPositionName() {
    return this.locale.uiLanguageDirection === "rtl" ? "sw" : "se";
  }
};
DropdownView.defaultPanelPositions = {
  south: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "s"
    };
  },
  southEast: (buttonRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left,
      name: "se"
    };
  },
  southWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "sw"
    };
  },
  southMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "sme"
    };
  },
  southMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "smw"
    };
  },
  north: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "n"
    };
  },
  northEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left,
      name: "ne"
    };
  },
  northWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "nw"
    };
  },
  northMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "nme"
    };
  },
  northMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "nmw"
    };
  }
};
DropdownView._getOptimalPosition = getOptimalPosition;
var dropdownview_default = DropdownView;

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/dropdownbuttonview.js
import dropdownArrowIcon2 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
var DropdownButtonView = class extends ButtonView {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.arrowView = this._createArrowView();
    this.extendTemplate({
      attributes: {
        "aria-haspopup": true,
        "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value))
      }
    });
    this.delegate("execute").to(this, "open");
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.add(this.arrowView);
  }
  /**
   * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
   */
  _createArrowView() {
    const arrowView = new iconview_default();
    arrowView.content = dropdownArrowIcon2;
    arrowView.extendTemplate({
      attributes: {
        class: "ck-dropdown__arrow"
      }
    });
    return arrowView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenulistitembuttonview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/menu/dropdownmenulistitembutton.css";

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenubuttonview.js
import dropdownArrowIcon3 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/menu/dropdownmenubutton.css";
var DropdownMenuButtonView = class extends ListItemButtonView {
  /**
   * Creates an instance of the dropdown menu button view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set({
      withText: true,
      role: "menuitem"
    });
    this.arrowView = this._createArrowView();
    this.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown-menu-list__nested-menu__button"
        ],
        "aria-haspopup": true,
        "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value)),
        "data-cke-tooltip-disabled": bind.to("isOn")
      },
      on: {
        "mouseenter": bind.to("mouseenter")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.add(this.arrowView);
  }
  /**
   * Creates the arrow view instance.
   *
   * @private
   */
  _createArrowView() {
    const arrowView = new iconview_default();
    arrowView.content = dropdownArrowIcon3;
    arrowView.extendTemplate({
      attributes: {
        class: "ck-dropdown-menu-list__nested-menu__button__arrow"
      }
    });
    return arrowView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/list/listitemview.js
var ListItemView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", true);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__item",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ],
        role: "presentation"
      },
      children: this.children
    });
  }
  /**
   * Focuses the list item.
   */
  focus() {
    if (this.children.first) {
      this.children.first.focus();
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/list/listseparatorview.js
var ListSeparatorView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__separator"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/list/listitemgroupview.js
var ListItemGroupView = class extends View {
  /**
   * Creates an instance of the list item group view class.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param labelView The instance of the group's label. If not provided, an instance of
   * {@link module:ui/label/labelview~LabelView} is used.
   */
  constructor(locale, labelView = new LabelView()) {
    super(locale);
    const bind = this.bindTemplate;
    const nestedList = new ListView(locale);
    this.set({
      label: "",
      isVisible: true
    });
    this.labelView = labelView;
    this.labelView.bind("text").to(this, "label");
    this.children = this.createCollection();
    this.children.addMany([this.labelView, nestedList]);
    nestedList.set({
      role: "group",
      ariaLabelledBy: labelView.id
    });
    nestedList.focusTracker.destroy();
    nestedList.keystrokes.destroy();
    this.items = nestedList.items;
    this.setTemplate({
      tag: "li",
      attributes: {
        role: "presentation",
        class: [
          "ck",
          "ck-list__group",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.children
    });
  }
  /**
   * Focuses the list item (which is not a separator).
   */
  focus() {
    if (this.items) {
      const firstListItem = this.items.find((item) => !(item instanceof ListSeparatorView));
      if (firstListItem) {
        firstListItem.focus();
      }
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/list/listview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css";
var ListView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this._listItemGroupToChangeListeners = /* @__PURE__ */ new WeakMap();
    const bind = this.bindTemplate;
    this.focusables = new ViewCollection();
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this._focusCycler = new FocusCycler({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate list items backwards using the arrowup key.
        focusPrevious: "arrowup",
        // Navigate toolbar items forwards using the arrowdown key.
        focusNext: "arrowdown"
      }
    });
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", void 0);
    this.set("role", void 0);
    this.setTemplate({
      tag: "ul",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-list"
        ],
        role: bind.to("role"),
        "aria-label": bind.to("ariaLabel"),
        "aria-labelledby": bind.to("ariaLabelledBy")
      },
      children: this.items
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const item of this.items) {
      if (item instanceof ListItemGroupView) {
        this._registerFocusableItemsGroup(item);
      } else if (item instanceof ListItemView) {
        this._registerFocusableListItem(item);
      }
    }
    this.items.on("change", (evt, data) => {
      for (const removed of data.removed) {
        if (removed instanceof ListItemGroupView) {
          this._deregisterFocusableItemsGroup(removed);
        } else if (removed instanceof ListItemView) {
          this._deregisterFocusableListItem(removed);
        }
      }
      for (const added of Array.from(data.added).reverse()) {
        if (added instanceof ListItemGroupView) {
          this._registerFocusableItemsGroup(added, data.index);
        } else {
          this._registerFocusableListItem(added, data.index);
        }
      }
    });
    this.keystrokes.listenTo(this.element);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable in {@link #items}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
   * Registers a list item view in the focus tracker.
   *
   * @param item The list item view to be registered.
   * @param index Index of the list item view in the {@link #items} collection. If not specified, the item will be added at the end.
   */
  _registerFocusableListItem(item, index) {
    this.focusTracker.add(item.element);
    this.focusables.add(item, index);
  }
  /**
   * Removes a list item view from the focus tracker.
   *
   * @param item The list item view to be removed.
   */
  _deregisterFocusableListItem(item) {
    this.focusTracker.remove(item.element);
    this.focusables.remove(item);
  }
  /**
   * Gets a callback that will be called when the `items` collection of a {@link module:ui/list/listitemgroupview~ListItemGroupView}
   * change.
   *
   * @param groupView The group view for which the callback will be created.
   * @returns The callback function to be used for the items `change` event listener in a group.
   */
  _getOnGroupItemsChangeCallback(groupView) {
    return (evt, data) => {
      for (const removed of data.removed) {
        this._deregisterFocusableListItem(removed);
      }
      for (const added of Array.from(data.added).reverse()) {
        this._registerFocusableListItem(added, this.items.getIndex(groupView) + data.index);
      }
    };
  }
  /**
   * Registers a list item group view (and its children) in the focus tracker.
   *
   * @param groupView A group view to be registered.
   * @param groupIndex Index of the group view in the {@link #items} collection. If not specified, the group will be added at the end.
   */
  _registerFocusableItemsGroup(groupView, groupIndex) {
    Array.from(groupView.items).forEach((child, childIndex) => {
      const registeredChildIndex = typeof groupIndex !== "undefined" ? groupIndex + childIndex : void 0;
      this._registerFocusableListItem(child, registeredChildIndex);
    });
    const groupItemsChangeCallback = this._getOnGroupItemsChangeCallback(groupView);
    this._listItemGroupToChangeListeners.set(groupView, groupItemsChangeCallback);
    groupView.items.on("change", groupItemsChangeCallback);
  }
  /**
   * Removes a list item group view (and its children) from the focus tracker.
   *
   * @param groupView The group view to be removed.
   */
  _deregisterFocusableItemsGroup(groupView) {
    for (const child of groupView.items) {
      this._deregisterFocusableListItem(child);
    }
    groupView.items.off("change", this._listItemGroupToChangeListeners.get(groupView));
    this._listItemGroupToChangeListeners.delete(groupView);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenulistview.js
var DropdownMenuListView = class extends ListView {
  /**
   * Creates an instance of the dropdown menu list view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.role = "menu";
    this.set("isVisible", true);
    this.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown-menu-list",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/menu/utils.js
var NESTED_PANEL_HORIZONTAL_OFFSET = 5;
var DropdownMenuPanelPositioningFunctions = {
  eastSouth: (buttonRect) => ({
    top: buttonRect.top,
    left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET,
    name: "es"
  }),
  eastNorth: (buttonRect, panelRect) => ({
    top: buttonRect.top - panelRect.height + buttonRect.height,
    left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET,
    name: "en"
  }),
  westSouth: (buttonRect, panelRect) => ({
    top: buttonRect.top,
    left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET,
    name: "ws"
  }),
  westNorth: (buttonRect, panelRect) => ({
    top: buttonRect.top - panelRect.height + buttonRect.height,
    left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET,
    name: "wn"
  })
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenulistitemview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/menu/dropdownmenulistitem.css";

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenubehaviors.js
var DropdownMenuBehaviors = {
  /**
   * Open the menu on the right arrow key press (left, in RTL mode). This allows for navigating to sub-menus using the keyboard.
   */
  openOnArrowRightKey(menuView) {
    const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
    menuView.keystrokes.set(keystroke, (data, cancel2) => {
      if (menuView.focusTracker.focusedElement !== menuView.buttonView.element || !menuView.isEnabled) {
        return;
      }
      if (!menuView.isOpen) {
        menuView.isOpen = true;
      }
      menuView.panelView.focus();
      cancel2();
    });
  },
  /**
   * Opens the menu on its button click as well as enter and space keys press (if the button is focused).
   */
  openOnButtonClick(menuView) {
    menuView.buttonView.on("execute", () => {
      if (menuView.isEnabled) {
        menuView.isOpen = true;
      }
    });
  },
  /**
   * Opens the menu and focuses the panel content upon pressing the Enter key.
   */
  openAndFocusOnEnterKeyPress(menuView) {
    menuView.keystrokes.set("enter", (data, cancel2) => {
      if (menuView.focusTracker.focusedElement !== menuView.buttonView.element) {
        return;
      }
      menuView.isOpen = true;
      menuView.panelView.focus();
      cancel2();
    });
  },
  /**
   * Closes the menu on the left key press (right, in RTL mode). This allows for navigating to sub-menus using the keyboard.
   */
  closeOnArrowLeftKey(menuView) {
    const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
    menuView.keystrokes.set(keystroke, (data, cancel2) => {
      if (menuView.isOpen) {
        menuView.focus();
        menuView.isOpen = false;
        cancel2();
      }
    });
  },
  closeOnEscKey(menuView) {
    menuView.keystrokes.set("esc", (data, cancel2) => {
      if (menuView.isOpen) {
        menuView.focus();
        menuView.isOpen = false;
        cancel2();
      }
    });
  },
  /**
   * Closes the menu when its parent menu closes. This prevents from leaving orphaned open menus.
   */
  closeOnParentClose(menuView, parentMenuView) {
    parentMenuView.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen && evt.source === parentMenuView) {
        menuView.isOpen = false;
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css";
var toPx2 = toUnit("px");
var POSITION_OFF_SCREEN = {
  top: -99999,
  left: -99999,
  name: "arrowless",
  config: {
    withArrow: false
  }
};
var BalloonPanelView = class _BalloonPanelView extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("top", 0);
    this.set("left", 0);
    this.set("position", "arrow_nw");
    this.set("isVisible", false);
    this.set("withArrow", true);
    this.set("class", void 0);
    this._pinWhenIsVisibleCallback = null;
    this._resizeObserver = null;
    this.content = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-panel",
          bind.to("position", (value) => `ck-balloon-panel_${value}`),
          bind.if("isVisible", "ck-balloon-panel_visible"),
          bind.if("withArrow", "ck-balloon-panel_with-arrow"),
          bind.to("class")
        ],
        style: {
          top: bind.to("top", toPx2),
          left: bind.to("left", toPx2)
        }
      },
      children: this.content
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.hide();
    super.destroy();
  }
  /**
   * Shows the panel.
   *
   * See {@link #isVisible}.
   */
  show() {
    this.isVisible = true;
  }
  /**
   * Hides the panel.
   *
   * See {@link #isVisible}.
   */
  hide() {
    this.isVisible = false;
  }
  /**
   * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
   * smart positioning heuristics that chooses from available positions to make sure the panel
   * is visible to the user i.e. within the limits of the viewport.
   *
   * This method accepts configuration {@link module:utils/dom/position~Options options}
   * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Attach the panel to an element with the "target" id DOM.
   * panel.attachTo( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * **Note**: Attaching the panel will also automatically {@link #show} it.
   *
   * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
   * See the {@link #pin} method for a more permanent positioning strategy.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   * @returns Whether the balloon was shown and successfully attached or not. Attaching can fail if the target
   * provided in the options is invisible (e.g. element detached from DOM).
   */
  attachTo(options) {
    const target = getDomElement(options.target);
    if (target && !isVisible(target)) {
      return false;
    }
    this.show();
    const defaultPositions = _BalloonPanelView.defaultPositions;
    const positionOptions = Object.assign({}, {
      element: this.element,
      positions: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthMiddleWest,
        defaultPositions.southArrowNorthMiddleEast,
        defaultPositions.southArrowNorthWest,
        defaultPositions.southArrowNorthEast,
        defaultPositions.northArrowSouth,
        defaultPositions.northArrowSouthMiddleWest,
        defaultPositions.northArrowSouthMiddleEast,
        defaultPositions.northArrowSouthWest,
        defaultPositions.northArrowSouthEast,
        defaultPositions.viewportStickyNorth
      ],
      limiter: global_default.document.body,
      fitInViewport: true
    }, options);
    const optimalPosition = _BalloonPanelView._getOptimalPosition(positionOptions) || POSITION_OFF_SCREEN;
    const left = parseInt(optimalPosition.left);
    const top = parseInt(optimalPosition.top);
    const position = optimalPosition.name;
    const config = optimalPosition.config || {};
    const { withArrow = true } = config;
    this.top = top;
    this.left = left;
    this.position = position;
    this.withArrow = withArrow;
    return true;
  }
  /**
   * Works the same way as the {@link #attachTo} method except that the position of the panel is
   * continuously updated when:
   *
   * * any ancestor of the {@link module:utils/dom/position~Options#target}
   * or {@link module:utils/dom/position~Options#limiter} is scrolled,
   * * the browser window gets resized or scrolled.
   *
   * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
   * and is immune to the changing environment.
   *
   * ```ts
   * const panel = new BalloonPanelView( locale );
   * const positions = BalloonPanelView.defaultPositions;
   *
   * panel.render();
   *
   * // Pin the panel to an element with the "target" id DOM.
   * panel.pin( {
   * 	target: document.querySelector( '#target' ),
   * 	positions: [
   * 		positions.northArrowSouth,
   * 		positions.southArrowNorth
   * 	]
   * } );
   * ```
   *
   * To leave the pinned state, use the {@link #unpin} method.
   *
   * **Note**: Pinning the panel will also automatically {@link #show} it.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   */
  pin(options) {
    this.unpin();
    if (!this._startPinning(options)) {
      return;
    }
    this._pinWhenIsVisibleCallback = () => {
      if (this.isVisible) {
        this._startPinning(options);
      } else {
        this._stopPinning();
      }
    };
    this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
  }
  /**
   * Stops pinning the panel, as set up by {@link #pin}.
   */
  unpin() {
    if (this._pinWhenIsVisibleCallback) {
      this._stopPinning();
      this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
      this._pinWhenIsVisibleCallback = null;
      this.hide();
    }
  }
  /**
   * Starts managing the pinned state of the panel. See {@link #pin}.
   *
   * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
   * @returns Whether the balloon was shown and successfully attached or not. Attaching can fail if the target
   * provided in the options is invisible (e.g. element detached from DOM).
   */
  _startPinning(options) {
    if (!this.attachTo(options)) {
      return false;
    }
    let targetElement = getDomElement(options.target);
    const limiterElement = options.limiter ? getDomElement(options.limiter) : global_default.document.body;
    this.listenTo(global_default.document, "scroll", (evt, domEvt) => {
      const scrollTarget = domEvt.target;
      const isWithinScrollTarget = targetElement && scrollTarget.contains(targetElement);
      const isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains(limiterElement);
      if (isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement) {
        this.attachTo(options);
      }
    }, { useCapture: true });
    this.listenTo(global_default.window, "resize", () => {
      this.attachTo(options);
    });
    if (!this._resizeObserver) {
      if (targetElement && isText(targetElement)) {
        targetElement = targetElement.parentElement;
      }
      if (targetElement) {
        const checkVisibility = () => {
          if (!isVisible(targetElement)) {
            this.unpin();
          }
        };
        this._resizeObserver = new resizeobserver_default(targetElement, checkVisibility);
      }
    }
    return true;
  }
  /**
   * Stops managing the pinned state of the panel. See {@link #pin}.
   */
  _stopPinning() {
    this.stopListening(global_default.document, "scroll");
    this.stopListening(global_default.window, "resize");
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
      this._resizeObserver = null;
    }
  }
  /**
   * Returns available {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView}
   * {@link module:utils/dom/position~PositioningFunction positioning functions} adjusted by the specific offsets.
   *
   * @internal
   * @param options Options to generate positions. If not specified, this helper will simply return
   * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
   * @param options.sideOffset A custom side offset (in pixels) of each position. If
   * not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowSideOffset the default value}
   * will be used.
   * @param options.heightOffset A custom height offset (in pixels) of each position. If
   * not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowHeightOffset the default value}
   * will be used.
   * @param options.stickyVerticalOffset A custom offset (in pixels) of the `viewportStickyNorth` positioning function.
   * If not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.stickyVerticalOffset the default value}
   * will be used.
   * @param options.config Additional configuration of the balloon balloon panel view.
   * Currently only {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#withArrow} is supported. Learn more
   * about {@link module:utils/dom/position~PositioningFunction positioning functions}.
   */
  static generatePositions(options = {}) {
    const { sideOffset = _BalloonPanelView.arrowSideOffset, heightOffset = _BalloonPanelView.arrowHeightOffset, stickyVerticalOffset = _BalloonPanelView.stickyVerticalOffset, config } = options;
    return {
      // ------- North west
      northWestArrowSouthWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - sideOffset,
        name: "arrow_sw",
        ...config && { config }
      }),
      northWestArrowSouthMiddleWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_smw",
        ...config && { config }
      }),
      northWestArrowSouth: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - balloonRect.width / 2,
        name: "arrow_s",
        ...config && { config }
      }),
      northWestArrowSouthMiddleEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_sme",
        ...config && { config }
      }),
      northWestArrowSouthEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left - balloonRect.width + sideOffset,
        name: "arrow_se",
        ...config && { config }
      }),
      // ------- North
      northArrowSouthWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - sideOffset,
        name: "arrow_sw",
        ...config && { config }
      }),
      northArrowSouthMiddleWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_smw",
        ...config && { config }
      }),
      northArrowSouth: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
        name: "arrow_s",
        ...config && { config }
      }),
      northArrowSouthMiddleEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_sme",
        ...config && { config }
      }),
      northArrowSouthEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
        name: "arrow_se",
        ...config && { config }
      }),
      // ------- North east
      northEastArrowSouthWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - sideOffset,
        name: "arrow_sw",
        ...config && { config }
      }),
      northEastArrowSouthMiddleWest: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_smw",
        ...config && { config }
      }),
      northEastArrowSouth: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - balloonRect.width / 2,
        name: "arrow_s",
        ...config && { config }
      }),
      northEastArrowSouthMiddleEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_sme",
        ...config && { config }
      }),
      northEastArrowSouthEast: (targetRect, balloonRect) => ({
        top: getNorthTop(targetRect, balloonRect),
        left: targetRect.right - balloonRect.width + sideOffset,
        name: "arrow_se",
        ...config && { config }
      }),
      // ------- South west
      southWestArrowNorthWest: (targetRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - sideOffset,
        name: "arrow_nw",
        ...config && { config }
      }),
      southWestArrowNorthMiddleWest: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_nmw",
        ...config && { config }
      }),
      southWestArrowNorth: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - balloonRect.width / 2,
        name: "arrow_n",
        ...config && { config }
      }),
      southWestArrowNorthMiddleEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_nme",
        ...config && { config }
      }),
      southWestArrowNorthEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left - balloonRect.width + sideOffset,
        name: "arrow_ne",
        ...config && { config }
      }),
      // ------- South
      southArrowNorthWest: (targetRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - sideOffset,
        name: "arrow_nw",
        ...config && { config }
      }),
      southArrowNorthMiddleWest: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_nmw",
        ...config && { config }
      }),
      southArrowNorth: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
        name: "arrow_n",
        ...config && { config }
      }),
      southArrowNorthMiddleEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_nme",
        ...config && { config }
      }),
      southArrowNorthEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
        name: "arrow_ne",
        ...config && { config }
      }),
      // ------- South east
      southEastArrowNorthWest: (targetRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - sideOffset,
        name: "arrow_nw",
        ...config && { config }
      }),
      southEastArrowNorthMiddleWest: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
        name: "arrow_nmw",
        ...config && { config }
      }),
      southEastArrowNorth: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - balloonRect.width / 2,
        name: "arrow_n",
        ...config && { config }
      }),
      southEastArrowNorthMiddleEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
        name: "arrow_nme",
        ...config && { config }
      }),
      southEastArrowNorthEast: (targetRect, balloonRect) => ({
        top: getSouthTop(targetRect),
        left: targetRect.right - balloonRect.width + sideOffset,
        name: "arrow_ne",
        ...config && { config }
      }),
      // ------- West
      westArrowEast: (targetRect, balloonRect) => ({
        top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
        left: targetRect.left - balloonRect.width - heightOffset,
        name: "arrow_e",
        ...config && { config }
      }),
      // ------- East
      eastArrowWest: (targetRect, balloonRect) => ({
        top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
        left: targetRect.right + heightOffset,
        name: "arrow_w",
        ...config && { config }
      }),
      // ------- Sticky
      viewportStickyNorth: (targetRect, balloonRect, viewportRect, limiterRect) => {
        const boundaryRect = limiterRect || viewportRect;
        if (!targetRect.getIntersection(boundaryRect)) {
          return null;
        }
        if (boundaryRect.height - targetRect.height > stickyVerticalOffset) {
          return null;
        }
        return {
          top: boundaryRect.top + stickyVerticalOffset,
          left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
          name: "arrowless",
          config: {
            withArrow: false,
            ...config
          }
        };
      }
    };
    function getNorthTop(targetRect, balloonRect) {
      return targetRect.top - balloonRect.height - heightOffset;
    }
    function getSouthTop(targetRect) {
      return targetRect.bottom + heightOffset;
    }
  }
};
BalloonPanelView.arrowSideOffset = 25;
BalloonPanelView.arrowHeightOffset = 10;
BalloonPanelView.stickyVerticalOffset = 20;
BalloonPanelView._getOptimalPosition = getOptimalPosition;
BalloonPanelView.defaultPositions = BalloonPanelView.generatePositions();
var balloonpanelview_default = BalloonPanelView;
function getDomElement(object) {
  if (isElement_default(object)) {
    return object;
  }
  if (isRange(object)) {
    return object.commonAncestorContainer;
  }
  if (typeof object == "function") {
    return getDomElement(object());
  }
  return null;
}

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenunestedmenupanelview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/menu/dropdownmenupanel.css";
var DropdownMenuNestedMenuPanelView = class extends balloonpanelview_default {
  /**
   * Creates an instance of the menu panel view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set({
      isVisible: false,
      position: "se",
      class: null,
      top: 0,
      left: 0
    });
    this.extendTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-reset",
          "ck-dropdown-menu__nested-menu__panel"
        ],
        tabindex: "-1"
      },
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: bind.to((evt) => {
          if (evt.target.tagName.toLocaleLowerCase() === "input") {
            return;
          }
          evt.preventDefault();
        })
      }
    });
  }
  /**
   * Focuses the first child of the panel (default) or the last one if the `direction` is `-1`.
   *
   * @param direction The direction to focus. Default is `1`.
   */
  focus(direction = 1) {
    const { content } = this;
    if (content.length) {
      if (direction === 1) {
        content.first.focus();
      } else {
        content.last.focus();
      }
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenunestedmenuview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/menu/dropdownmenu.css";
var DropdownMenuNestedMenuView = class _DropdownMenuNestedMenuView extends View {
  /**
   * Creates a new instance of the DropdownMenuView class.
   *
   * @param locale
   * @param bodyCollection
   * @param id
   * @param label The label for the dropdown menu button.
   * @param parentMenuView The parent dropdown menu view, if any.
   */
  constructor(locale, bodyCollection, id, label, parentMenuView) {
    super(locale);
    this._bodyCollection = bodyCollection;
    this.id = id;
    this.set({
      isOpen: false,
      isEnabled: true,
      panelPosition: "w",
      class: void 0,
      parentMenuView: null
    });
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.buttonView = new DropdownMenuButtonView(locale);
    this.buttonView.delegate("mouseenter").to(this);
    this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled");
    this.buttonView.label = label;
    this.panelView = new DropdownMenuNestedMenuPanelView(locale);
    this.panelView.isVisible = true;
    this.listView = new DropdownMenuListView(locale);
    this.listView.bind("ariaLabel").to(this.buttonView, "label");
    this.panelView.content.add(this.listView);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown-menu-list__nested-menu",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value)
        ],
        role: "presentation"
      },
      children: [
        this.buttonView
      ]
    });
    this.parentMenuView = parentMenuView;
    if (this.parentMenuView) {
      this._handleParentMenuView();
    }
    this._attachBehaviors();
  }
  /**
   * An array of positioning functions used to determine the position of the dropdown menu panel.
   * The order of the functions in the array determines the priority of the positions to be tried.
   * The first function that returns a valid position will be used.
   *
   * @returns {Array<PositioningFunction>} An array of positioning functions.
   * @internal
   */
  get _panelPositions() {
    const { westSouth, eastSouth, westNorth, eastNorth } = DropdownMenuPanelPositioningFunctions;
    if (this.locale.uiLanguageDirection === "ltr") {
      return [eastSouth, eastNorth, westSouth, westNorth];
    } else {
      return [westSouth, westNorth, eastSouth, eastNorth];
    }
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.panelView.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.focusTracker.add(this.listView);
    this.keystrokes.listenTo(this.element);
    this._mountPanelOnOpen();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._removePanelFromBody();
    this.panelView.destroy();
    super.destroy();
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.buttonView.focus();
  }
  _handleParentMenuView() {
    this.delegate(..._DropdownMenuNestedMenuView.DELEGATED_EVENTS).to(this.parentMenuView);
    DropdownMenuBehaviors.closeOnParentClose(this, this.parentMenuView);
  }
  /**
   * Attach all keyboard behaviors for the menu view.
   */
  _attachBehaviors() {
    DropdownMenuBehaviors.openOnButtonClick(this);
    DropdownMenuBehaviors.openAndFocusOnEnterKeyPress(this);
    DropdownMenuBehaviors.openOnArrowRightKey(this);
    DropdownMenuBehaviors.closeOnEscKey(this);
    DropdownMenuBehaviors.closeOnArrowLeftKey(this);
  }
  /**
   * Mounts the portal view in the body when the menu is open and removes it when the menu is closed.
   * Binds keystrokes to the portal view when the menu is open.
   */
  _mountPanelOnOpen() {
    const { panelView } = this;
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (evt.source !== this) {
        return;
      }
      if (!isOpen && this._bodyCollection.has(panelView)) {
        this._removePanelFromBody();
        return;
      }
      if (isOpen && !this._bodyCollection.has(panelView)) {
        this._addPanelToBody();
      }
    });
  }
  /**
   * Removes the panel view from the editor's body and removes it from the focus tracker.
   */
  _removePanelFromBody() {
    const { panelView, keystrokes } = this;
    if (this._bodyCollection.has(panelView)) {
      this._bodyCollection.remove(panelView);
      keystrokes.stopListening(panelView.element);
    }
  }
  /**
   * Adds the panel view to the editor's body and sets up event listeners.
   */
  _addPanelToBody() {
    const { panelView, buttonView, keystrokes } = this;
    if (!this._bodyCollection.has(panelView)) {
      this._bodyCollection.add(panelView);
      keystrokes.listenTo(panelView.element);
      panelView.pin({
        positions: this._panelPositions,
        limiter: global_default.document.body,
        element: panelView.element,
        target: buttonView.element,
        fitInViewport: true
      });
    }
  }
};
DropdownMenuNestedMenuView.DELEGATED_EVENTS = [
  "mouseenter",
  "execute",
  "change:isOpen"
];

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarseparatorview.js
var ToolbarSeparatorView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__separator"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarlinebreakview.js
var ToolbarLineBreakView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__line-break"
        ]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/preventdefault.js
function preventDefault(view) {
  return view.bindTemplate.to((evt) => {
    if (evt.target === view.element) {
      evt.preventDefault();
    }
  });
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/normalizetoolbarconfig.js
function normalizeToolbarConfig(config) {
  if (Array.isArray(config)) {
    return {
      items: config,
      removeItems: []
    };
  }
  const predefinedConfigOptions = {
    items: [],
    removeItems: []
  };
  if (!config) {
    return predefinedConfigOptions;
  }
  return {
    ...predefinedConfigOptions,
    ...config
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css";
var NESTED_TOOLBAR_ICONS = (() => ({
  alignLeft: icons.alignLeft,
  bold: icons.bold,
  importExport: icons.importExport,
  paragraph: icons.paragraph,
  plus: icons.plus,
  text: icons.text,
  threeVerticalDots: icons.threeVerticalDots,
  pilcrow: icons.pilcrow,
  dragIndicator: icons.dragIndicator
}))();
var ToolbarView = class extends View {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   * @param options Configuration options of the toolbar.
   */
  constructor(locale, options) {
    super(locale);
    const bind = this.bindTemplate;
    const t = this.t;
    this.options = options || {};
    this.set("ariaLabel", t("Editor toolbar"));
    this.set("maxWidth", "auto");
    this.items = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.set("class", void 0);
    this.set("isCompact", false);
    this.itemsView = new ItemsView(locale);
    this.children = this.createCollection();
    this.children.add(this.itemsView);
    this.focusables = this.createCollection();
    const isRtl = locale.uiLanguageDirection === "rtl";
    this._focusCycler = new FocusCycler({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate toolbar items backwards using the arrow[left,up] keys.
        focusPrevious: [isRtl ? "arrowright" : "arrowleft", "arrowup"],
        // Navigate toolbar items forwards using the arrow[right,down] keys.
        focusNext: [isRtl ? "arrowleft" : "arrowright", "arrowdown"]
      }
    });
    const classes = [
      "ck",
      "ck-toolbar",
      bind.to("class"),
      bind.if("isCompact", "ck-toolbar_compact")
    ];
    if (this.options.shouldGroupWhenFull && this.options.isFloating) {
      classes.push("ck-toolbar_floating");
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: classes,
        role: "toolbar",
        "aria-label": bind.to("ariaLabel"),
        style: {
          maxWidth: bind.to("maxWidth")
        },
        tabindex: -1
      },
      children: this.children,
      on: {
        // https://github.com/ckeditor/ckeditor5-ui/issues/206
        mousedown: preventDefault(this)
      }
    });
    this._behavior = this.options.shouldGroupWhenFull ? new DynamicGrouping(this) : new StaticLayout(this);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.element);
    for (const item of this.items) {
      this.focusTracker.add(item);
    }
    this.items.on("add", (evt, item) => {
      this.focusTracker.add(item);
    });
    this.items.on("remove", (evt, item) => {
      this.focusTracker.remove(item);
    });
    this.keystrokes.listenTo(this.element);
    this._behavior.render(this);
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this._behavior.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
    return super.destroy();
  }
  /**
   * Focuses the first focusable in {@link #focusables}.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last focusable in {@link #focusables}.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
  /**
   * A utility that expands the plain toolbar configuration into
   * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
   *
   * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration. When present, applies
   * to this toolbar and all nested ones as well.
   */
  fillFromConfig(itemsOrConfig, factory, removeItems) {
    this.items.addMany(this._buildItemsFromConfig(itemsOrConfig, factory, removeItems));
  }
  /**
   * A utility that expands the plain toolbar configuration into a list of view items using a given component factory.
   *
   * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration. When present, applies
   * to this toolbar and all nested ones as well.
   */
  _buildItemsFromConfig(itemsOrConfig, factory, removeItems) {
    const config = normalizeToolbarConfig(itemsOrConfig);
    const normalizedRemoveItems = removeItems || config.removeItems;
    const itemsToAdd = this._cleanItemsConfiguration(config.items, factory, normalizedRemoveItems).map((item) => {
      if (isObject_default(item)) {
        return this._createNestedToolbarDropdown(item, factory, normalizedRemoveItems);
      } else if (item === "|") {
        return new ToolbarSeparatorView();
      } else if (item === "-") {
        return new ToolbarLineBreakView();
      }
      return factory.create(item);
    }).filter((item) => !!item);
    return itemsToAdd;
  }
  /**
   * Cleans up the {@link module:ui/toolbar/toolbarview~ToolbarView#items} of the toolbar by removing unwanted items and
   * duplicated (obsolete) separators or line breaks.
   *
   * @param items The toolbar items configuration.
   * @param factory A factory producing toolbar items.
   * @param removeItems An array of items names to be removed from the configuration.
   * @returns Items after the clean-up.
   */
  _cleanItemsConfiguration(items, factory, removeItems) {
    const filteredItems = items.filter((item, idx, items2) => {
      if (item === "|") {
        return true;
      }
      if (removeItems.indexOf(item) !== -1) {
        return false;
      }
      if (item === "-") {
        if (this.options.shouldGroupWhenFull) {
          logWarning("toolbarview-line-break-ignored-when-grouping-items", items2);
          return false;
        }
        return true;
      }
      if (!isObject_default(item) && !factory.has(item)) {
        logWarning("toolbarview-item-unavailable", { item });
        return false;
      }
      return true;
    });
    return this._cleanSeparatorsAndLineBreaks(filteredItems);
  }
  /**
   * Remove leading, trailing, and duplicated separators (`-` and `|`).
   *
   * @returns Toolbar items after the separator and line break clean-up.
   */
  _cleanSeparatorsAndLineBreaks(items) {
    const nonSeparatorPredicate = (item) => item !== "-" && item !== "|";
    const count2 = items.length;
    const firstCommandItemIndex = items.findIndex(nonSeparatorPredicate);
    if (firstCommandItemIndex === -1) {
      return [];
    }
    const lastCommandItemIndex = count2 - items.slice().reverse().findIndex(nonSeparatorPredicate);
    return items.slice(firstCommandItemIndex, lastCommandItemIndex).filter((name, idx, items2) => {
      if (nonSeparatorPredicate(name)) {
        return true;
      }
      const isDuplicated = idx > 0 && items2[idx - 1] === name;
      return !isDuplicated;
    });
  }
  /**
   * Creates a user-defined dropdown containing a toolbar with items.
   *
   * @param definition A definition of the nested toolbar dropdown.
   * @param definition.label A label of the dropdown.
   * @param definition.icon An icon of the drop-down. One of 'bold', 'plus', 'text', 'importExport', 'alignLeft',
   * 'paragraph' or an SVG string. When `false` is passed, no icon will be used.
   * @param definition.withText When set `true`, the label of the dropdown will be visible. See
   * {@link module:ui/button/buttonview~ButtonView#withText} to learn more.
   * @param definition.tooltip A tooltip of the dropdown button. See
   * {@link module:ui/button/buttonview~ButtonView#tooltip} to learn more. Defaults to `true`.
   * @param componentFactory Component factory used to create items
   * of the nested toolbar.
   */
  _createNestedToolbarDropdown(definition, componentFactory, removeItems) {
    let { label, icon, items, tooltip = true, withText = false } = definition;
    items = this._cleanItemsConfiguration(items, componentFactory, removeItems);
    if (!items.length) {
      return null;
    }
    const locale = this.locale;
    const dropdownView = createDropdown(locale);
    if (!label) {
      logWarning("toolbarview-nested-toolbar-dropdown-missing-label", definition);
    }
    dropdownView.class = "ck-toolbar__nested-toolbar-dropdown";
    dropdownView.buttonView.set({
      label,
      tooltip,
      withText: !!withText
    });
    if (icon !== false) {
      dropdownView.buttonView.icon = NESTED_TOOLBAR_ICONS[icon] || icon || icons.threeVerticalDots;
    } else {
      dropdownView.buttonView.withText = true;
    }
    addToolbarToDropdown(dropdownView, () => dropdownView.toolbarView._buildItemsFromConfig(items, componentFactory, removeItems));
    return dropdownView;
  }
};
var ItemsView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__items"
        ]
      },
      children: this.children
    });
  }
};
var StaticLayout = class {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
   * behavior.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  constructor(view) {
    const bind = view.bindTemplate;
    view.set("isVertical", false);
    view.itemsView.children.bindTo(view.items).using((item) => item);
    view.focusables.bindTo(view.items).using((item) => isFocusable(item) ? item : null);
    view.extendTemplate({
      attributes: {
        class: [
          // When vertical, the toolbar has an additional CSS class.
          bind.if("isVertical", "ck-toolbar_vertical")
        ]
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
  }
  /**
   * @inheritDoc
   */
  destroy() {
  }
};
var DynamicGrouping = class {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
   * behavior.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  constructor(view) {
    this.resizeObserver = null;
    this.cachedPadding = null;
    this.shouldUpdateGroupingOnNextResize = false;
    this.view = view;
    this.viewChildren = view.children;
    this.viewFocusables = view.focusables;
    this.viewItemsView = view.itemsView;
    this.viewFocusTracker = view.focusTracker;
    this.viewLocale = view.locale;
    this.ungroupedItems = view.createCollection();
    this.groupedItems = view.createCollection();
    this.groupedItemsDropdown = this._createGroupedItemsDropdown();
    view.itemsView.children.bindTo(this.ungroupedItems).using((item) => item);
    this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this));
    view.children.on("change", this._updateFocusCyclableItems.bind(this));
    view.items.on("change", (evt, changeData) => {
      const index = changeData.index;
      const added = Array.from(changeData.added);
      for (const removedItem of changeData.removed) {
        if (index >= this.ungroupedItems.length) {
          this.groupedItems.remove(removedItem);
        } else {
          this.ungroupedItems.remove(removedItem);
        }
      }
      for (let currentIndex = index; currentIndex < index + added.length; currentIndex++) {
        const addedItem = added[currentIndex - index];
        if (currentIndex > this.ungroupedItems.length) {
          this.groupedItems.add(addedItem, currentIndex - this.ungroupedItems.length);
        } else {
          this.ungroupedItems.add(addedItem, currentIndex);
        }
      }
      this._updateGrouping();
    });
    view.extendTemplate({
      attributes: {
        class: [
          // To group items dynamically, the toolbar needs a dedicated CSS class.
          "ck-toolbar_grouping"
        ]
      }
    });
  }
  /**
   * Enables dynamic items grouping based on the dimensions of the toolbar.
   *
   * @param view An instance of the toolbar that this behavior is added to.
   */
  render(view) {
    this.viewElement = view.element;
    this._enableGroupingOnResize();
    this._enableGroupingOnMaxWidthChange(view);
  }
  /**
   * Cleans up the internals used by this behavior.
   */
  destroy() {
    this.groupedItemsDropdown.destroy();
    this.resizeObserver.destroy();
  }
  /**
   * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
   * and it will move them to the {@link #groupedItems} when it happens.
   *
   * At the same time, it will also check if there is enough space in the toolbar for the first of the
   * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
   * without the toolbar wrapping.
   */
  _updateGrouping() {
    if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
      return;
    }
    if (!isVisible(this.viewElement)) {
      this.shouldUpdateGroupingOnNextResize = true;
      return;
    }
    const initialGroupedItemsCount = this.groupedItems.length;
    let wereItemsGrouped;
    while (this._areItemsOverflowing) {
      this._groupLastItem();
      wereItemsGrouped = true;
    }
    if (!wereItemsGrouped && this.groupedItems.length) {
      while (this.groupedItems.length && !this._areItemsOverflowing) {
        this._ungroupFirstItem();
      }
      if (this._areItemsOverflowing) {
        this._groupLastItem();
      }
    }
    if (this.groupedItems.length !== initialGroupedItemsCount) {
      this.view.fire("groupedItemsUpdate");
    }
  }
  /**
   * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
   * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
   */
  get _areItemsOverflowing() {
    if (!this.ungroupedItems.length) {
      return false;
    }
    const element = this.viewElement;
    const uiLanguageDirection = this.viewLocale.uiLanguageDirection;
    const lastChildRect = new Rect(element.lastChild);
    const toolbarRect = new Rect(element);
    if (!this.cachedPadding) {
      const computedStyle = global_default.window.getComputedStyle(element);
      const paddingProperty = uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
      this.cachedPadding = Number.parseInt(computedStyle[paddingProperty]);
    }
    if (uiLanguageDirection === "ltr") {
      return lastChildRect.right > toolbarRect.right - this.cachedPadding;
    } else {
      return lastChildRect.left < toolbarRect.left + this.cachedPadding;
    }
  }
  /**
   * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
   * upon resize when there is little space available. Instead, the toolbar items are moved to the
   * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
   *
   * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
   * them in the dropdown if necessary. It will also observe the browser window for size changes in
   * the future and respond to them by grouping more items or reverting already grouped back, depending
   * on the visual space available.
   */
  _enableGroupingOnResize() {
    let previousWidth;
    this.resizeObserver = new resizeobserver_default(this.viewElement, (entry) => {
      if (!previousWidth || previousWidth !== entry.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
        this.shouldUpdateGroupingOnNextResize = false;
        this._updateGrouping();
        previousWidth = entry.contentRect.width;
      }
    });
    this._updateGrouping();
  }
  /**
   * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
   * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
   */
  _enableGroupingOnMaxWidthChange(view) {
    view.on("change:maxWidth", () => {
      this._updateGrouping();
    });
  }
  /**
   * When called, it will remove the last item from {@link #ungroupedItems} and move it back
   * to the {@link #groupedItems} collection.
   *
   * The opposite of {@link #_ungroupFirstItem}.
   */
  _groupLastItem() {
    if (!this.groupedItems.length) {
      this.viewChildren.add(new ToolbarSeparatorView());
      this.viewChildren.add(this.groupedItemsDropdown);
      this.viewFocusTracker.add(this.groupedItemsDropdown.element);
    }
    this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
  }
  /**
   * Moves the very first item belonging to {@link #groupedItems} back
   * to the {@link #ungroupedItems} collection.
   *
   * The opposite of {@link #_groupLastItem}.
   */
  _ungroupFirstItem() {
    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
    if (!this.groupedItems.length) {
      this.viewChildren.remove(this.groupedItemsDropdown);
      this.viewChildren.remove(this.viewChildren.last);
      this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
    }
  }
  /**
   * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
   * collection when there is not enough space in the toolbar to display all items in a single row.
   */
  _createGroupedItemsDropdown() {
    const locale = this.viewLocale;
    const t = locale.t;
    const dropdown = createDropdown(locale);
    dropdown.class = "ck-toolbar__grouped-dropdown";
    dropdown.panelPosition = locale.uiLanguageDirection === "ltr" ? "sw" : "se";
    addToolbarToDropdown(dropdown, this.groupedItems);
    dropdown.buttonView.set({
      label: t("Show more items"),
      tooltip: true,
      tooltipPosition: locale.uiLanguageDirection === "rtl" ? "se" : "sw",
      icon: icons.threeVerticalDots
    });
    return dropdown;
  }
  /**
   * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focuscyclable items}
   * collection so it represents the uptodate state of the UI from the perspective of the user.
   *
   * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
   * it must be subject to focus cycling in the toolbar.
   *
   * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
   * to learn more about the purpose of this method.
   */
  _updateFocusCyclableItems() {
    this.viewFocusables.clear();
    this.ungroupedItems.map((item) => {
      if (isFocusable(item)) {
        this.viewFocusables.add(item);
      }
    });
    if (this.groupedItems.length) {
      this.viewFocusables.add(this.groupedItemsDropdown);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/splitbuttonview.js
import dropdownArrowIcon4 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css";
var SplitButtonView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale, actionButton) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isToggleable", false);
    this.set("isVisible", true);
    this.set("keystroke", void 0);
    this.set("withKeystroke", false);
    this.set("label", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.children = this.createCollection();
    this.actionView = this._createActionView(actionButton);
    this.arrowView = this._createArrowView();
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-splitbutton",
          bind.to("class"),
          bind.if("isVisible", "ck-hidden", (value) => !value),
          this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
        ]
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.add(this.actionView);
    this.children.add(this.arrowView);
    this.focusTracker.add(this.actionView.element);
    this.focusTracker.add(this.arrowView.element);
    this.keystrokes.listenTo(this.element);
    this.keystrokes.set("arrowright", (evt, cancel2) => {
      if (this.focusTracker.focusedElement === this.actionView.element) {
        this.arrowView.focus();
        cancel2();
      }
    });
    this.keystrokes.set("arrowleft", (evt, cancel2) => {
      if (this.focusTracker.focusedElement === this.arrowView.element) {
        this.actionView.focus();
        cancel2();
      }
    });
  }
  /**
   * @inheritDoc
   */
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  /**
   * Focuses the {@link module:ui/button/buttonview~ButtonView#element} of the action part of split button.
   */
  focus() {
    this.actionView.focus();
  }
  /**
   * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
   * attributes.
   */
  _createActionView(actionButton) {
    const actionView = actionButton || new ButtonView();
    if (!actionButton) {
      actionView.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
    }
    actionView.extendTemplate({
      attributes: {
        class: "ck-splitbutton__action"
      }
    });
    actionView.delegate("execute").to(this);
    return actionView;
  }
  /**
   * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
   * attributes.
   */
  _createArrowView() {
    const arrowView = new ButtonView();
    const bind = arrowView.bindTemplate;
    arrowView.icon = dropdownArrowIcon4;
    arrowView.extendTemplate({
      attributes: {
        class: [
          "ck-splitbutton__arrow"
        ],
        "data-cke-tooltip-disabled": bind.to("isOn"),
        "aria-haspopup": true,
        "aria-expanded": bind.to("isOn", (value) => String(value))
      }
    });
    arrowView.bind("isEnabled").to(this);
    arrowView.bind("label").to(this);
    arrowView.bind("tooltip").to(this);
    arrowView.delegate("execute").to(this, "open");
    return arrowView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/utils.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/listdropdown.css";
function createDropdown(locale, ButtonClassOrInstance = DropdownButtonView) {
  const buttonView = typeof ButtonClassOrInstance == "function" ? new ButtonClassOrInstance(locale) : ButtonClassOrInstance;
  const panelView = new DropdownPanelView(locale);
  const dropdownView = new dropdownview_default(locale, buttonView, panelView);
  buttonView.bind("isEnabled").to(dropdownView);
  if (buttonView instanceof SplitButtonView) {
    buttonView.arrowView.bind("isOn").to(dropdownView, "isOpen");
  } else {
    buttonView.bind("isOn").to(dropdownView, "isOpen");
  }
  addDefaultBehaviors(dropdownView);
  return dropdownView;
}
function addToolbarToDropdown(dropdownView, buttonsOrCallback, options = {}) {
  dropdownView.extendTemplate({
    attributes: {
      class: ["ck-toolbar-dropdown"]
    }
  });
  if (dropdownView.isOpen) {
    addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options);
  } else {
    dropdownView.once("change:isOpen", () => addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options), { priority: "highest" });
  }
  if (options.enableActiveItemFocusOnDropdownOpen) {
    focusChildOnDropdownOpen(dropdownView, () => dropdownView.toolbarView.items.find((item) => item.isOn));
  }
}
function addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options) {
  const locale = dropdownView.locale;
  const t = locale.t;
  const toolbarView = dropdownView.toolbarView = new ToolbarView(locale);
  const buttons = typeof buttonsOrCallback == "function" ? buttonsOrCallback() : buttonsOrCallback;
  toolbarView.ariaLabel = options.ariaLabel || t("Dropdown toolbar");
  if (options.maxWidth) {
    toolbarView.maxWidth = options.maxWidth;
  }
  if (options.class) {
    toolbarView.class = options.class;
  }
  if (options.isCompact) {
    toolbarView.isCompact = options.isCompact;
  }
  if (options.isVertical) {
    toolbarView.isVertical = true;
  }
  if (buttons instanceof ViewCollection) {
    toolbarView.items.bindTo(buttons).using((item) => item);
  } else {
    toolbarView.items.addMany(buttons);
  }
  dropdownView.panelView.children.add(toolbarView);
  dropdownView.focusTracker.add(toolbarView);
  toolbarView.items.delegate("execute").to(dropdownView);
}
function focusChildOnDropdownOpen(dropdownView, childSelectorCallback) {
  dropdownView.on("change:isOpen", () => {
    if (!dropdownView.isOpen) {
      return;
    }
    const childToFocus = childSelectorCallback();
    if (!childToFocus) {
      return;
    }
    if (typeof childToFocus.focus === "function") {
      childToFocus.focus();
    } else {
      logWarning("ui-dropdown-focus-child-on-open-child-missing-focus", { view: childToFocus });
    }
  }, { priority: priorities_default.low - 10 });
}
function addDefaultBehaviors(dropdownView) {
  closeDropdownOnClickOutside(dropdownView);
  closeDropdownOnExecute(dropdownView);
  closeDropdownOnBlur(dropdownView);
  focusDropdownContentsOnArrows(dropdownView);
  focusDropdownButtonOnClose(dropdownView);
  focusDropdownPanelOnOpen(dropdownView);
}
function closeDropdownOnClickOutside(dropdownView) {
  clickOutsideHandler({
    emitter: dropdownView,
    activator: () => dropdownView.isRendered && dropdownView.isOpen,
    callback: () => {
      dropdownView.isOpen = false;
    },
    contextElements: () => [
      dropdownView.element,
      // Include all elements connected to the dropdown's focus tracker, but exclude those that are direct children
      // of DropdownView#element. They would be identified as descendants of #element anyway upon clicking and would
      // not contribute to the logic.
      ...getFocusTrackerTreeElements(dropdownView.focusTracker).filter((element) => !dropdownView.element.contains(element))
    ]
  });
}
function getFocusTrackerTreeElements(focusTracker) {
  return [
    ...focusTracker.elements,
    ...focusTracker.externalViews.flatMap((view) => getFocusTrackerTreeElements(view.focusTracker))
  ];
}
function closeDropdownOnExecute(dropdownView) {
  dropdownView.on("execute", (evt) => {
    if (evt.source instanceof SwitchButtonView) {
      return;
    }
    dropdownView.isOpen = false;
  });
}
function closeDropdownOnBlur(dropdownView) {
  dropdownView.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
    if (isFocused || !dropdownView.isOpen) {
      return;
    }
    dropdownView.isOpen = false;
  });
}
function focusDropdownContentsOnArrows(dropdownView) {
  dropdownView.keystrokes.set("arrowdown", (data, cancel2) => {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focus();
      cancel2();
    }
  });
  dropdownView.keystrokes.set("arrowup", (data, cancel2) => {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focusLast();
      cancel2();
    }
  });
}
function focusDropdownButtonOnClose(dropdownView) {
  dropdownView.on("change:isOpen", (evt, name, isOpen) => {
    if (isOpen) {
      return;
    }
    const elements = dropdownView.focusTracker.elements;
    if (elements.some((element) => element.contains(global_default.document.activeElement))) {
      dropdownView.buttonView.focus();
    }
  });
}
function focusDropdownPanelOnOpen(dropdownView) {
  dropdownView.on("change:isOpen", (evt, name, isOpen) => {
    if (!isOpen) {
      return;
    }
    dropdownView.panelView.focus();
  }, { priority: "low" });
}

// node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/utils.js
var createLabeledInputText = (labeledFieldView, viewUid, statusUid) => {
  const inputView = new InputTextView(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  inputView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
  return inputView;
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorpicker/colorpickerview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorpicker/colorpicker.css";

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/documentcolorcollection.js
var DocumentColorCollection = class extends ObservableMixin(Collection) {
  constructor(options) {
    super(options);
    this.set("isEmpty", true);
    this.on("change", () => {
      this.set("isEmpty", this.length === 0);
    });
  }
  /**
   * Adds a color to the document color collection.
   *
   * This method ensures that no color duplicates are inserted (compared using
   * the color value of the {@link module:ui/colorgrid/colorgridview~ColorDefinition}).
   *
   * If the item does not have an ID, it will be automatically generated and set on the item.
   *
   * @param index The position of the item in the collection. The item is pushed to the collection when `index` is not specified.
   * @fires add
   * @fires change
   */
  add(item, index) {
    if (this.find((element) => element.color === item.color)) {
      return this;
    }
    return super.add(item, index);
  }
  /**
   * Checks if an object with given colors is present in the document color collection.
   */
  hasColor(color) {
    return !!this.find((item) => item.color === color);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorselectorview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/colorselector/colorselector.css";

// node_modules/@ckeditor/ckeditor5-ui/src/componentfactory.js
var ComponentFactory = class {
  /**
   * Creates an instance of the factory.
   *
   * @param editor The editor instance.
   */
  constructor(editor) {
    this._components = /* @__PURE__ */ new Map();
    this.editor = editor;
  }
  /**
   * Returns an iterator of registered component names. Names are returned in lower case.
   */
  *names() {
    for (const value of this._components.values()) {
      yield value.originalName;
    }
  }
  /**
   * Registers a component factory function that will be used by the
   * {@link #create create} method and called with the
   * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
   * allowing localization of the {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @param callback The callback that returns the component.
   */
  add(name, callback) {
    this._components.set(getNormalized(name), { callback, originalName: name });
  }
  /**
   * Creates an instance of a component registered in the factory under a specific name.
   *
   * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
   * the previously {@link #add added} factory function, allowing localization of the
   * {@link module:ui/view~View view}.
   *
   * @param name The name of the component.
   * @returns The instantiated component view.
   */
  create(name) {
    if (!this.has(name)) {
      throw new CKEditorError("componentfactory-item-missing", this, { name });
    }
    return this._components.get(getNormalized(name)).callback(this.editor.locale);
  }
  /**
   * Checks if a component of a given name is registered in the factory.
   *
   * @param name The name of the component.
   */
  has(name) {
    return this._components.has(getNormalized(name));
  }
};
function getNormalized(name) {
  return String(name).toLowerCase();
}

// node_modules/@ckeditor/ckeditor5-ui/src/tooltipmanager.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css";
var BALLOON_CLASS = "ck-tooltip";
var TooltipManager = class _TooltipManager extends DomEmitterMixin() {
  /**
   * Creates an instance of the tooltip manager.
   */
  constructor(editor) {
    super();
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    this._mutationObserver = null;
    _TooltipManager._editors.add(editor);
    if (_TooltipManager._instance) {
      return _TooltipManager._instance;
    }
    _TooltipManager._instance = this;
    this.tooltipTextView = new View(editor.locale);
    this.tooltipTextView.set("text", "");
    this.tooltipTextView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-tooltip__text"
        ]
      },
      children: [
        {
          text: this.tooltipTextView.bindTemplate.to("text")
        }
      ]
    });
    this.balloonPanelView = new balloonpanelview_default(editor.locale);
    this.balloonPanelView.class = BALLOON_CLASS;
    this.balloonPanelView.content.add(this.tooltipTextView);
    this._mutationObserver = createMutationObserver(() => {
      this._updateTooltipPosition();
    });
    this._pinTooltipDebounced = debounce_default(this._pinTooltip, 600);
    this._unpinTooltipDebounced = debounce_default(this._unpinTooltip, 400);
    this.listenTo(global_default.document, "keydown", this._onKeyDown.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true });
    this.listenTo(global_default.document, "scroll", this._onScroll.bind(this), { useCapture: true });
    this._watchdogExcluded = true;
  }
  /**
   * Destroys the tooltip manager.
   *
   * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
   *
   * @param editor The editor the manager was created for.
   */
  destroy(editor) {
    const editorBodyViewCollection = editor.ui.view && editor.ui.view.body;
    _TooltipManager._editors.delete(editor);
    this.stopListening(editor.ui);
    if (editorBodyViewCollection && editorBodyViewCollection.has(this.balloonPanelView)) {
      editorBodyViewCollection.remove(this.balloonPanelView);
    }
    if (!_TooltipManager._editors.size) {
      this._unpinTooltip();
      this.balloonPanelView.destroy();
      this.stopListening();
      _TooltipManager._instance = null;
    }
  }
  /**
   * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
   * name.
   *
   * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
   * @returns Positioning functions to be used by the {@link #balloonPanelView}.
   */
  static getPositioningFunctions(position) {
    const defaultPositions = _TooltipManager.defaultBalloonPositions;
    return {
      // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
      s: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthEast,
        defaultPositions.southArrowNorthWest
      ],
      n: [defaultPositions.northArrowSouth],
      e: [defaultPositions.eastArrowWest],
      w: [defaultPositions.westArrowEast],
      sw: [defaultPositions.southArrowNorthEast],
      se: [defaultPositions.southArrowNorthWest]
    }[position];
  }
  /**
   * Handles hiding tooltips on `keydown` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onKeyDown(evt, domEvent) {
    if (domEvent.key === "Escape" && this._currentElementWithTooltip) {
      this._unpinTooltip();
      domEvent.stopPropagation();
    }
  }
  /**
   * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onEnterOrFocus(evt, { target }) {
    const elementWithTooltipAttribute = getDescendantWithTooltip(target);
    if (!elementWithTooltipAttribute) {
      if (evt.name === "focus") {
        this._unpinTooltip();
      }
      return;
    }
    if (elementWithTooltipAttribute === this._currentElementWithTooltip) {
      return;
    }
    this._unpinTooltip();
    if (evt.name === "focus" && !elementWithTooltipAttribute.matches(":hover")) {
      this._pinTooltip(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
    } else {
      this._pinTooltipDebounced(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
    }
  }
  /**
   * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onLeaveOrBlur(evt, { target, relatedTarget }) {
    if (evt.name === "mouseleave") {
      if (!isElement_default(target)) {
        return;
      }
      const balloonElement = this.balloonPanelView.element;
      const isEnteringBalloon = balloonElement && (balloonElement === relatedTarget || balloonElement.contains(relatedTarget));
      const isLeavingBalloon = !isEnteringBalloon && target === balloonElement;
      if (isEnteringBalloon) {
        this._unpinTooltipDebounced.cancel();
        return;
      }
      if (!isLeavingBalloon && this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      const descendantWithTooltip = getDescendantWithTooltip(target);
      const relatedDescendantWithTooltip = getDescendantWithTooltip(relatedTarget);
      if (isLeavingBalloon || descendantWithTooltip && descendantWithTooltip !== relatedDescendantWithTooltip) {
        this._unpinTooltipDebounced();
      }
    } else {
      if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      this._unpinTooltipDebounced();
    }
  }
  /**
   * Handles hiding tooltips on `scroll` in DOM.
   *
   * @param evt An object containing information about the fired event.
   * @param domEvent The DOM event.
   */
  _onScroll(evt, { target }) {
    if (!this._currentElementWithTooltip) {
      return;
    }
    if (target.contains(this.balloonPanelView.element) && target.contains(this._currentElementWithTooltip)) {
      return;
    }
    this._unpinTooltip();
  }
  /**
   * Pins the tooltip to a specific DOM element.
   *
   * @param options.text Text of the tooltip to display.
   * @param options.position The position of the tooltip.
   * @param options.cssClass Additional CSS class of the balloon with the tooltip.
   */
  _pinTooltip(targetDomElement, { text: text2, position, cssClass }) {
    this._unpinTooltip();
    const bodyViewCollection = first(_TooltipManager._editors.values()).ui.view.body;
    if (!bodyViewCollection.has(this.balloonPanelView)) {
      bodyViewCollection.add(this.balloonPanelView);
    }
    this.tooltipTextView.text = text2;
    this.balloonPanelView.class = [BALLOON_CLASS, cssClass].filter((className) => className).join(" ");
    this.balloonPanelView.pin({
      target: targetDomElement,
      positions: _TooltipManager.getPositioningFunctions(position)
    });
    this._mutationObserver.attach(targetDomElement);
    for (const editor of _TooltipManager._editors) {
      this.listenTo(editor.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
    }
    this._currentElementWithTooltip = targetDomElement;
    this._currentTooltipPosition = position;
  }
  /**
   * Unpins the tooltip and cancels all queued pinning.
   */
  _unpinTooltip() {
    this._unpinTooltipDebounced.cancel();
    this._pinTooltipDebounced.cancel();
    this.balloonPanelView.unpin();
    for (const editor of _TooltipManager._editors) {
      this.stopListening(editor.ui, "update");
    }
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    this.tooltipTextView.text = "";
    this._mutationObserver.detach();
  }
  /**
   * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
   *
   * Hides the tooltip when the element is no longer visible in DOM or the tooltip text was removed.
   */
  _updateTooltipPosition() {
    if (!this._currentElementWithTooltip) {
      return;
    }
    const tooltipData = getTooltipData(this._currentElementWithTooltip);
    if (!isVisible(this._currentElementWithTooltip) || !tooltipData.text) {
      this._unpinTooltip();
      return;
    }
    this.balloonPanelView.pin({
      target: this._currentElementWithTooltip,
      positions: _TooltipManager.getPositioningFunctions(tooltipData.position)
    });
  }
};
TooltipManager.defaultBalloonPositions = balloonpanelview_default.generatePositions({
  heightOffset: 5,
  sideOffset: 13
});
TooltipManager._editors = /* @__PURE__ */ new Set();
TooltipManager._instance = null;
var tooltipmanager_default = TooltipManager;
function getDescendantWithTooltip(element) {
  if (!isElement_default(element)) {
    return null;
  }
  return element.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])");
}
function getTooltipData(element) {
  return {
    text: element.dataset.ckeTooltipText,
    position: element.dataset.ckeTooltipPosition || "s",
    cssClass: element.dataset.ckeTooltipClass || ""
  };
}
function createMutationObserver(callback) {
  const mutationObserver = new MutationObserver(() => {
    callback();
  });
  return {
    attach(element) {
      mutationObserver.observe(element, {
        attributes: true,
        attributeFilter: ["data-cke-tooltip-text", "data-cke-tooltip-position"]
      });
    },
    detach() {
      mutationObserver.disconnect();
    }
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/badge/badge.js
var NARROW_ROOT_HEIGHT_THRESHOLD = 50;
var NARROW_ROOT_WIDTH_THRESHOLD = 350;
var Badge = class extends DomEmitterMixin() {
  /**
   * Creates a badge for a given editor. The feature is initialized on Editor#ready
   * event.
   */
  constructor(editor, options = {}) {
    super();
    this._balloonView = null;
    this._showBalloonThrottled = throttle_default(() => this._showBalloon(), 50, { leading: true });
    this._lastFocusedEditableElement = null;
    this.editor = editor;
    this._balloonClass = options.balloonClass;
    editor.on("ready", () => this._handleEditorReady());
  }
  /**
   * Destroys the badge along with its view.
   */
  destroy() {
    const balloon = this._balloonView;
    if (balloon) {
      balloon.unpin();
      this._balloonView = null;
    }
    this._showBalloonThrottled.cancel();
    this.stopListening();
  }
  /**
   * Enables badge label once the editor (ui) is ready.
   */
  _handleEditorReady() {
    const editor = this.editor;
    if (!this._isEnabled()) {
      return;
    }
    if (!editor.ui.view) {
      return;
    }
    editor.ui.focusTracker.on("change:isFocused", (evt, data, isFocused) => {
      this._updateLastFocusedEditableElement();
      if (isFocused) {
        this._showBalloon();
      } else {
        this._hideBalloon();
      }
    });
    editor.ui.focusTracker.on("change:focusedElement", (evt, data, focusedElement) => {
      this._updateLastFocusedEditableElement();
      if (focusedElement) {
        this._showBalloon();
      }
    });
    editor.ui.on("update", () => {
      this._showBalloonThrottled();
    });
  }
  /**
   * Returns normalized configuration for the badge.
   */
  _getNormalizedConfig() {
    return {
      side: this.editor.locale.contentLanguageDirection === "ltr" ? "right" : "left",
      position: "border",
      verticalOffset: 0,
      horizontalOffset: 5
    };
  }
  /**
   * Attempts to display the balloon with the badge view.
   */
  _showBalloon() {
    const attachOptions = this._getBalloonAttachOptions();
    if (!attachOptions) {
      return;
    }
    if (!this._balloonView) {
      this._balloonView = this._createBalloonView();
    }
    this._balloonView.pin(attachOptions);
  }
  /**
   * Hides the badge balloon if already visible.
   */
  _hideBalloon() {
    if (this._balloonView) {
      this._balloonView.unpin();
    }
  }
  /**
   * Creates an instance of the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon panel}
   * with the badge view inside ready for positioning.
   */
  _createBalloonView() {
    const editor = this.editor;
    const balloon = new balloonpanelview_default();
    const view = this._createBadgeContent();
    balloon.content.add(view);
    if (this._balloonClass) {
      balloon.class = this._balloonClass;
    }
    editor.ui.view.body.add(balloon);
    return balloon;
  }
  /**
   * Returns the options for attaching the balloon to the focused editable element.
   */
  _getBalloonAttachOptions() {
    if (!this._lastFocusedEditableElement) {
      return null;
    }
    const badgeConfig = this._getNormalizedConfig();
    const positioningFunction = badgeConfig.side === "right" ? getLowerRightCornerPosition(this._lastFocusedEditableElement, badgeConfig) : getLowerLeftCornerPosition(this._lastFocusedEditableElement, badgeConfig);
    return {
      target: this._lastFocusedEditableElement,
      positions: [positioningFunction]
    };
  }
  /**
   * Updates the {@link #_lastFocusedEditableElement} based on the state of the global focus tracker.
   */
  _updateLastFocusedEditableElement() {
    const editor = this.editor;
    const isFocused = editor.ui.focusTracker.isFocused;
    const focusedElement = editor.ui.focusTracker.focusedElement;
    if (!isFocused || !focusedElement) {
      this._lastFocusedEditableElement = null;
      return;
    }
    const editableEditorElements = Array.from(editor.ui.getEditableElementsNames()).map((name) => {
      return editor.ui.getEditableElement(name);
    });
    if (editableEditorElements.includes(focusedElement)) {
      this._lastFocusedEditableElement = focusedElement;
    } else {
      this._lastFocusedEditableElement = editableEditorElements[0];
    }
  }
};
function getLowerRightCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect, balloonRect) => {
    return rootRect.left + rootRect.width - balloonRect.width - config.horizontalOffset;
  });
}
function getLowerLeftCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect) => rootRect.left + config.horizontalOffset);
}
function getLowerCornerPosition(focusedEditableElement, config, getBalloonLeft) {
  return (visibleEditableElementRect, balloonRect) => {
    const editableElementRect = new Rect(focusedEditableElement);
    if (editableElementRect.width < NARROW_ROOT_WIDTH_THRESHOLD || editableElementRect.height < NARROW_ROOT_HEIGHT_THRESHOLD) {
      return null;
    }
    let balloonTop;
    if (config.position === "inside") {
      balloonTop = editableElementRect.bottom - balloonRect.height;
    } else {
      balloonTop = editableElementRect.bottom - balloonRect.height / 2;
    }
    balloonTop -= config.verticalOffset;
    const balloonLeft = getBalloonLeft(editableElementRect, balloonRect);
    const newBalloonPositionRect = visibleEditableElementRect.clone().moveTo(balloonLeft, balloonTop).getIntersection(balloonRect.clone().moveTo(balloonLeft, balloonTop));
    const newBalloonPositionVisibleRect = newBalloonPositionRect.getVisible();
    if (!newBalloonPositionVisibleRect || newBalloonPositionVisibleRect.getArea() < balloonRect.getArea()) {
      return null;
    }
    return {
      top: balloonTop,
      left: balloonLeft,
      name: `position_${config.position}-side_${config.side}`,
      config: {
        withArrow: false
      }
    };
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/poweredby.js
import poweredByIcon from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/icons/project-logo.svg";
var DEFAULT_LABEL = "Powered by";
var PoweredBy = class extends Badge {
  constructor(editor) {
    super(editor, { balloonClass: "ck-powered-by-balloon" });
  }
  /**
   * Enables "powered by" label.
   */
  _isEnabled() {
    const editor = this.editor;
    const forceVisible = editor.config.get("ui.poweredBy.forceVisible");
    if (forceVisible) {
      return true;
    }
    const licenseKey = editor.config.get("licenseKey");
    if (licenseKey == "GPL") {
      return true;
    }
    const licenseContent = parseBase64EncodedObject(licenseKey.split(".")[1]);
    if (!licenseContent) {
      return true;
    }
    return !licenseContent.whiteLabel;
  }
  /**
   * Creates a "powered by" badge content.
   */
  _createBadgeContent() {
    return new PoweredByView(this.editor.locale, this._getNormalizedConfig().label);
  }
  /**
   * Returns the normalized configuration for the "powered by" badge.
   * It takes the user configuration into account and falls back to the default one.
   */
  _getNormalizedConfig() {
    const badgeConfig = super._getNormalizedConfig();
    const userConfig = this.editor.config.get("ui.poweredBy") || {};
    const position = userConfig.position || badgeConfig.position;
    const verticalOffset = position === "inside" ? 5 : badgeConfig.verticalOffset;
    return {
      position,
      side: userConfig.side || badgeConfig.side,
      label: userConfig.label === void 0 ? DEFAULT_LABEL : userConfig.label,
      verticalOffset: userConfig.verticalOffset !== void 0 ? userConfig.verticalOffset : verticalOffset,
      horizontalOffset: userConfig.horizontalOffset !== void 0 ? userConfig.horizontalOffset : badgeConfig.horizontalOffset,
      forceVisible: !!userConfig.forceVisible
    };
  }
};
var PoweredByView = class extends View {
  /**
   * Creates an instance of the "powered by" view.
   *
   * @param locale The localization services instance.
   * @param label The label text.
   */
  constructor(locale, label) {
    super(locale);
    const iconView = new iconview_default();
    const bind = this.bindTemplate;
    iconView.set({
      content: poweredByIcon,
      isColorInherited: false
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-powered-by"],
        "aria-hidden": true
      },
      children: [
        {
          tag: "a",
          attributes: {
            href: "https://ckeditor.com/powered-by-ckeditor/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
            target: "_blank",
            tabindex: "-1"
          },
          children: [
            ...label ? [
              {
                tag: "span",
                attributes: {
                  class: ["ck", "ck-powered-by__label"]
                },
                children: [label]
              }
            ] : [],
            iconView
          ],
          on: {
            dragstart: bind.to((evt) => evt.preventDefault())
          }
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/evaluationbadge.js
var EvaluationBadge = class extends Badge {
  constructor(editor) {
    super(editor, { balloonClass: "ck-evaluation-badge-balloon" });
    this.licenseTypeMessage = {
      evaluation: "For evaluation purposes only",
      trial: "For evaluation purposes only",
      development: "For development purposes only"
    };
  }
  /**
   * Enables "evaluation badge" label.
   */
  _isEnabled() {
    const editor = this.editor;
    const licenseKey = editor.config.get("licenseKey");
    const licenseType = getLicenseTypeFromLicenseKey(licenseKey);
    return Boolean(licenseType && this.licenseTypeMessage[licenseType]);
  }
  /**
   * Creates the content of the "evaluation badge".
   */
  _createBadgeContent() {
    const licenseKey = this.editor.config.get("licenseKey");
    const licenseType = getLicenseTypeFromLicenseKey(licenseKey);
    return new EvaluationBadgeView(this.editor.locale, this.licenseTypeMessage[licenseType]);
  }
  /**
   * Returns the normalized configuration for the "evaluation badge".
   * It takes 'ui.poweredBy' configuration into account to determine the badge position and side.
   */
  _getNormalizedConfig() {
    const badgeConfig = super._getNormalizedConfig();
    const userConfig = this.editor.config.get("ui.poweredBy") || {};
    const position = userConfig.position || badgeConfig.position;
    const poweredBySide = userConfig.side || badgeConfig.side;
    return {
      position,
      side: poweredBySide === "left" ? "right" : "left",
      verticalOffset: badgeConfig.verticalOffset,
      horizontalOffset: badgeConfig.horizontalOffset
    };
  }
};
var EvaluationBadgeView = class extends View {
  /**
   * Creates an instance of the "evaluation badge" view.
   *
   * @param locale The localization services instance.
   * @param label The label text.
   */
  constructor(locale, label) {
    super(locale);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-evaluation-badge"],
        "aria-hidden": true
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: ["ck", "ck-evaluation-badge__label"]
          },
          children: [label]
        }
      ]
    });
  }
};
function getLicenseTypeFromLicenseKey(licenseKey) {
  if (licenseKey == "GPL") {
    return "GPL";
  }
  const licenseContent = parseBase64EncodedObject(licenseKey.split(".")[1]);
  if (!licenseContent) {
    return null;
  }
  return licenseContent.licenseType || "production";
}

// node_modules/@ckeditor/ckeditor5-ui/src/arialiveannouncer.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/arialiveannouncer/arialiveannouncer.css";
var AriaLiveAnnouncerPoliteness = {
  POLITE: "polite",
  ASSERTIVE: "assertive"
};
var AriaLiveAnnouncer = class {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    this.editor = editor;
    editor.once("ready", () => {
      for (const politeness of Object.values(AriaLiveAnnouncerPoliteness)) {
        this.announce("", politeness);
      }
    });
  }
  /**
   * Sets an announcement text to an aria region that is then announced by a screen reader to the user.
   *
   * If the aria region of a specified politeness does not exist, it will be created and can be re-used later.
   *
   * The default announcement politeness level is `'polite'`.
   *
   * ```ts
   * // Most screen readers will queue announcements from multiple aria-live regions and read them out in the order they were emitted.
   * editor.ui.ariaLiveAnnouncer.announce( 'Image uploaded.' );
   * editor.ui.ariaLiveAnnouncer.announce( 'Connection lost. Reconnecting.' );
   * ```
   */
  announce(announcement, attributes = AriaLiveAnnouncerPoliteness.POLITE) {
    const editor = this.editor;
    if (!editor.ui.view) {
      return;
    }
    if (!this.view) {
      this.view = new AriaLiveAnnouncerView(editor.locale);
      editor.ui.view.body.add(this.view);
    }
    const { politeness, isUnsafeHTML } = typeof attributes === "string" ? {
      politeness: attributes
    } : attributes;
    let politenessRegionView = this.view.regionViews.find((view) => view.politeness === politeness);
    if (!politenessRegionView) {
      politenessRegionView = new AriaLiveAnnouncerRegionView(editor, politeness);
      this.view.regionViews.add(politenessRegionView);
    }
    politenessRegionView.announce({
      announcement,
      isUnsafeHTML
    });
  }
};
var AriaLiveAnnouncerView = class extends View {
  constructor(locale) {
    super(locale);
    this.regionViews = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-aria-live-announcer"
        ]
      },
      children: this.regionViews
    });
  }
};
var AriaLiveAnnouncerRegionView = class extends View {
  constructor(editor, politeness) {
    super(editor.locale);
    this.setTemplate({
      tag: "div",
      attributes: {
        "aria-live": politeness,
        "aria-relevant": "additions"
      },
      children: [
        {
          tag: "ul",
          attributes: {
            class: [
              "ck",
              "ck-aria-live-region-list"
            ]
          }
        }
      ]
    });
    editor.on("destroy", () => {
      if (this._pruneAnnouncementsInterval !== null) {
        clearInterval(this._pruneAnnouncementsInterval);
        this._pruneAnnouncementsInterval = null;
      }
    });
    this.politeness = politeness;
    this._domConverter = editor.data.htmlProcessor.domConverter;
    this._pruneAnnouncementsInterval = setInterval(() => {
      if (this.element && this._listElement.firstChild) {
        this._listElement.firstChild.remove();
      }
    }, 5e3);
  }
  /**
   * Appends new announcement to region.
   */
  announce({ announcement, isUnsafeHTML }) {
    if (!announcement.trim().length) {
      return;
    }
    const messageListItem = document.createElement("li");
    if (isUnsafeHTML) {
      this._domConverter.setContentOf(messageListItem, announcement);
    } else {
      messageListItem.innerText = announcement;
    }
    this._listElement.appendChild(messageListItem);
  }
  /**
   * Return current announcements list HTML element.
   */
  get _listElement() {
    return this.element.querySelector("ul");
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/menubarmenulistitemview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/menubar/menubarmenulistitem.css";
var MenuBarMenuListItemView = class extends ListItemView {
  /**
   * Creates an instance of the list item view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale, parentMenuView) {
    super(locale);
    const bind = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        class: [
          "ck-menu-bar__menu__item"
        ]
      },
      on: {
        "mouseenter": bind.to("mouseenter")
      }
    });
    this.delegate("mouseenter").to(parentMenuView);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/utils.js
var NESTED_PANEL_HORIZONTAL_OFFSET2 = 5;
var MenuBarBehaviors = {
  /**
   * When the bar is already open:
   * * Opens the menu when the user hovers over its button.
   * * Closes open menu when another menu's button gets hovered.
   */
  toggleMenusAndFocusItemsOnHover(menuBarView) {
    menuBarView.on("menu:mouseenter", (evt) => {
      if (!menuBarView.isFocusBorderEnabled && !menuBarView.isOpen) {
        return;
      }
      if (menuBarView.isOpen) {
        for (const menuView of menuBarView.menus) {
          const pathLeaf = evt.path[0];
          const isListItemContainingMenu = pathLeaf instanceof MenuBarMenuListItemView && pathLeaf.children.first === menuView;
          menuView.isOpen = (evt.path.includes(menuView) || isListItemContainingMenu) && menuView.isEnabled;
        }
      }
      evt.source.focus();
    });
  },
  /**
   * Moves between top-level menus using the arrow left and right keys.
   *
   * If the menubar has already been open, the arrow keys move focus between top-level menu buttons and open them.
   * If the menubar is closed, the arrow keys only move focus between top-level menu buttons.
   */
  focusCycleMenusOnArrows(menuBarView) {
    const isContentRTL = menuBarView.locale.uiLanguageDirection === "rtl";
    menuBarView.on("menu:arrowright", (evt) => {
      cycleTopLevelMenus(evt.source, isContentRTL ? -1 : 1);
    });
    menuBarView.on("menu:arrowleft", (evt) => {
      cycleTopLevelMenus(evt.source, isContentRTL ? 1 : -1);
    });
    function cycleTopLevelMenus(currentMenuView, step) {
      const currentIndex = menuBarView.children.getIndex(currentMenuView);
      const isCurrentMenuViewOpen = currentMenuView.isOpen;
      const menusCount = menuBarView.children.length;
      const menuViewToOpen = menuBarView.children.get((currentIndex + menusCount + step) % menusCount);
      currentMenuView.isOpen = false;
      if (isCurrentMenuViewOpen) {
        menuViewToOpen.isOpen = true;
      }
      menuViewToOpen.buttonView.focus();
    }
  },
  /**
   * Closes the entire sub-menu structure when the bar is closed. This prevents sub-menus from being open if the user
   * closes the entire bar, and then re-opens some top-level menu.
   */
  closeMenusWhenTheBarCloses(menuBarView) {
    menuBarView.on("change:isOpen", () => {
      if (!menuBarView.isOpen) {
        menuBarView.menus.forEach((menuView) => {
          menuView.isOpen = false;
        });
      }
    });
  },
  /**
   * Handles the following case:
   * 1. Hover to open a sub-menu (A). The button has focus.
   * 2. Press arrow up/down to move focus to another sub-menu (B) button.
   * 3. Press arrow right to open the sub-menu (B).
   * 4. The sub-menu (A) should close as it would with `toggleMenusAndFocusItemsOnHover()`.
   */
  closeMenuWhenAnotherOnTheSameLevelOpens(menuBarView) {
    menuBarView.on("menu:change:isOpen", (evt, name, isOpen) => {
      if (isOpen) {
        menuBarView.menus.filter((menuView) => {
          return evt.source.parentMenuView === menuView.parentMenuView && evt.source !== menuView && menuView.isOpen;
        }).forEach((menuView) => {
          menuView.isOpen = false;
        });
      }
    });
  },
  /**
   * Closes the bar when the user clicked outside of it (page body, editor root, etc.).
   */
  closeOnClickOutside(menuBarView) {
    clickOutsideHandler({
      emitter: menuBarView,
      activator: () => menuBarView.isOpen,
      callback: () => menuBarView.close(),
      contextElements: () => menuBarView.children.map((child) => child.element)
    });
  },
  /**
   * Tracks the keyboard focus interaction on the menu bar view. It is used to determine if the nested items
   * of the menu bar should render focus rings after first interaction with the keyboard.
   */
  enableFocusHighlightOnInteraction(menuBarView) {
    let isKeyPressed = false;
    menuBarView.on("change:isOpen", (_, evt, isOpen) => {
      if (!isOpen) {
        if (!isKeyPressed) {
          menuBarView.isFocusBorderEnabled = false;
        }
        isKeyPressed = false;
      }
    });
    menuBarView.listenTo(menuBarView.element, "keydown", () => {
      isKeyPressed = true;
    }, { useCapture: true });
    menuBarView.listenTo(menuBarView.element, "keyup", () => {
      isKeyPressed = false;
    }, { useCapture: true });
    menuBarView.listenTo(menuBarView.element, "focus", () => {
      if (isKeyPressed) {
        menuBarView.isFocusBorderEnabled = true;
      }
    }, { useCapture: true });
  }
};
var MenuBarMenuBehaviors = {
  /**
   * If the button of the menu is focused, pressing the arrow down key should open the panel and focus it.
   * This is analogous to the {@link module:ui/dropdown/dropdownview~DropdownView}.
   */
  openAndFocusPanelOnArrowDownKey(menuView) {
    menuView.keystrokes.set("arrowdown", (data, cancel2) => {
      if (menuView.focusTracker.focusedElement === menuView.buttonView.element) {
        if (!menuView.isOpen) {
          menuView.isOpen = true;
        }
        menuView.panelView.focus();
        cancel2();
      }
    });
  },
  /**
   * Open the menu on the right arrow key press. This allows for navigating to sub-menus using the keyboard.
   */
  openOnArrowRightKey(menuView) {
    const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
    menuView.keystrokes.set(keystroke, (data, cancel2) => {
      if (menuView.focusTracker.focusedElement !== menuView.buttonView.element || !menuView.isEnabled) {
        return;
      }
      if (!menuView.isOpen) {
        menuView.isOpen = true;
      }
      menuView.panelView.focus();
      cancel2();
    });
  },
  /**
   * Opens the menu on its button click. Note that this behavior only opens but never closes the menu (unlike
   * {@link module:ui/dropdown/dropdownview~DropdownView}).
   */
  openOnButtonClick(menuView) {
    menuView.buttonView.on("execute", () => {
      menuView.isOpen = true;
    });
  },
  /**
   * Toggles the menu on its button click. This behavior is analogous to {@link module:ui/dropdown/dropdownview~DropdownView}.
   */
  toggleOnButtonClick(menuView) {
    menuView.buttonView.on("execute", () => {
      menuView.isOpen = !menuView.isOpen;
    });
  },
  /**
   * Opens the menu and focuses the panel content upon pressing the Enter key.
   */
  openAndFocusOnEnterKeyPress(menuView) {
    menuView.keystrokes.set("enter", (data, cancel2) => {
      if (menuView.focusTracker.focusedElement !== menuView.buttonView.element) {
        return;
      }
      menuView.isOpen = true;
      menuView.panelView.focus();
      cancel2();
    });
  },
  /**
   * Closes the menu on the right left key press. This allows for navigating to sub-menus using the keyboard.
   */
  closeOnArrowLeftKey(menuView) {
    const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
    menuView.keystrokes.set(keystroke, (data, cancel2) => {
      if (menuView.isOpen) {
        menuView.isOpen = false;
        menuView.focus();
        cancel2();
      }
    });
  },
  /**
   * Closes the menu on the esc key press. This allows for navigating to sub-menus using the keyboard.
   */
  closeOnEscKey(menuView) {
    menuView.keystrokes.set("esc", (data, cancel2) => {
      if (menuView.isOpen) {
        menuView.isOpen = false;
        menuView.focus();
        cancel2();
      }
    });
  },
  /**
   * Closes the menu when its parent menu also closed. This prevents from orphaned open menus when the parent menu re-opens.
   */
  closeOnParentClose(menuView) {
    menuView.parentMenuView.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen && evt.source === menuView.parentMenuView) {
        menuView.isOpen = false;
      }
    });
  }
};
var MenuBarMenuViewPanelPositioningFunctions = {
  southEast: (buttonRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left,
      name: "se"
    };
  },
  southWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "sw"
    };
  },
  northEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left,
      name: "ne"
    };
  },
  northWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "nw"
    };
  },
  eastSouth: (buttonRect) => {
    return {
      top: buttonRect.top,
      left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET2,
      name: "es"
    };
  },
  eastNorth: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET2,
      name: "en"
    };
  },
  westSouth: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top,
      left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET2,
      name: "ws"
    };
  },
  westNorth: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET2,
      name: "wn"
    };
  }
};
var DefaultMenuBarItems = [
  {
    menuId: "file",
    label: "File",
    groups: [
      {
        groupId: "export",
        items: [
          "menuBar:exportPdf",
          "menuBar:exportWord"
        ]
      },
      {
        groupId: "import",
        items: [
          "menuBar:importWord"
        ]
      },
      {
        groupId: "revisionHistory",
        items: [
          "menuBar:revisionHistory"
        ]
      }
    ]
  },
  {
    menuId: "edit",
    label: "Edit",
    groups: [
      {
        groupId: "undo",
        items: [
          "menuBar:undo",
          "menuBar:redo"
        ]
      },
      {
        groupId: "selectAll",
        items: [
          "menuBar:selectAll"
        ]
      },
      {
        groupId: "findAndReplace",
        items: [
          "menuBar:findAndReplace"
        ]
      }
    ]
  },
  {
    menuId: "view",
    label: "View",
    groups: [
      {
        groupId: "sourceEditing",
        items: [
          "menuBar:sourceEditing"
        ]
      },
      {
        groupId: "showBlocks",
        items: [
          "menuBar:showBlocks"
        ]
      },
      {
        groupId: "previewMergeFields",
        items: [
          "menuBar:previewMergeFields"
        ]
      },
      {
        groupId: "restrictedEditing",
        items: [
          "menuBar:restrictedEditing"
        ]
      }
    ]
  },
  {
    menuId: "insert",
    label: "Insert",
    groups: [
      {
        groupId: "insertMainWidgets",
        items: [
          "menuBar:insertImage",
          "menuBar:ckbox",
          "menuBar:ckfinder",
          "menuBar:insertTable"
        ]
      },
      {
        groupId: "insertInline",
        items: [
          "menuBar:link",
          "menuBar:bookmark",
          "menuBar:comment",
          "menuBar:insertMergeField"
        ]
      },
      {
        groupId: "insertMinorWidgets",
        items: [
          "menuBar:mediaEmbed",
          "menuBar:insertTemplate",
          "menuBar:specialCharacters",
          "menuBar:blockQuote",
          "menuBar:codeBlock",
          "menuBar:htmlEmbed"
        ]
      },
      {
        groupId: "insertStructureWidgets",
        items: [
          "menuBar:horizontalLine",
          "menuBar:pageBreak",
          "menuBar:tableOfContents"
        ]
      },
      {
        groupId: "restrictedEditingException",
        items: [
          "menuBar:restrictedEditingException"
        ]
      }
    ]
  },
  {
    menuId: "format",
    label: "Format",
    groups: [
      {
        groupId: "textAndFont",
        items: [
          {
            menuId: "text",
            label: "Text",
            groups: [
              {
                groupId: "basicStyles",
                items: [
                  "menuBar:bold",
                  "menuBar:italic",
                  "menuBar:underline",
                  "menuBar:strikethrough",
                  "menuBar:superscript",
                  "menuBar:subscript",
                  "menuBar:code"
                ]
              },
              {
                groupId: "textPartLanguage",
                items: [
                  "menuBar:textPartLanguage"
                ]
              }
            ]
          },
          {
            menuId: "font",
            label: "Font",
            groups: [
              {
                groupId: "fontProperties",
                items: [
                  "menuBar:fontSize",
                  "menuBar:fontFamily"
                ]
              },
              {
                groupId: "fontColors",
                items: [
                  "menuBar:fontColor",
                  "menuBar:fontBackgroundColor"
                ]
              },
              {
                groupId: "highlight",
                items: [
                  "menuBar:highlight"
                ]
              }
            ]
          },
          "menuBar:heading"
        ]
      },
      {
        groupId: "list",
        items: [
          "menuBar:bulletedList",
          "menuBar:numberedList",
          "menuBar:multiLevelList",
          "menuBar:todoList"
        ]
      },
      {
        groupId: "indent",
        items: [
          "menuBar:alignment",
          "menuBar:indent",
          "menuBar:outdent"
        ]
      },
      {
        groupId: "caseChange",
        items: [
          "menuBar:caseChange"
        ]
      },
      {
        groupId: "removeFormat",
        items: [
          "menuBar:removeFormat"
        ]
      }
    ]
  },
  {
    menuId: "tools",
    label: "Tools",
    groups: [
      {
        groupId: "aiTools",
        items: [
          "menuBar:aiAssistant",
          "menuBar:aiCommands"
        ]
      },
      {
        groupId: "tools",
        items: [
          "menuBar:trackChanges",
          "menuBar:commentsArchive"
        ]
      }
    ]
  },
  {
    menuId: "help",
    label: "Help",
    groups: [
      {
        groupId: "help",
        items: [
          "menuBar:accessibilityHelp"
        ]
      }
    ]
  }
];
function normalizeMenuBarConfig(config) {
  let configObject;
  if (!("items" in config) || !config.items) {
    configObject = {
      items: cloneDeep_default(DefaultMenuBarItems),
      addItems: [],
      removeItems: [],
      isVisible: true,
      isUsingDefaultConfig: true,
      ...config
    };
  } else {
    configObject = {
      items: config.items,
      removeItems: [],
      addItems: [],
      isVisible: true,
      isUsingDefaultConfig: false,
      ...config
    };
  }
  return configObject;
}
function processMenuBarConfig({ normalizedConfig, locale, componentFactory, extraItems }) {
  const configClone = cloneDeep_default(normalizedConfig);
  handleAdditions(normalizedConfig, configClone, extraItems);
  handleRemovals(normalizedConfig, configClone);
  handleAdditions(normalizedConfig, configClone, configClone.addItems);
  purgeUnavailableComponents(normalizedConfig, configClone, componentFactory);
  purgeEmptyMenus(normalizedConfig, configClone);
  localizeMenuLabels(configClone, locale);
  return configClone;
}
function handleRemovals(originalConfig, config) {
  const itemsToBeRemoved = config.removeItems;
  const successfullyRemovedItems = [];
  config.items = config.items.filter(({ menuId }) => {
    if (itemsToBeRemoved.includes(menuId)) {
      successfullyRemovedItems.push(menuId);
      return false;
    }
    return true;
  });
  walkConfigMenus(config.items, (menuDefinition) => {
    menuDefinition.groups = menuDefinition.groups.filter(({ groupId }) => {
      if (itemsToBeRemoved.includes(groupId)) {
        successfullyRemovedItems.push(groupId);
        return false;
      }
      return true;
    });
    for (const groupDefinition of menuDefinition.groups) {
      groupDefinition.items = groupDefinition.items.filter((item) => {
        const itemId = getIdFromGroupItem(item);
        if (itemsToBeRemoved.includes(itemId)) {
          successfullyRemovedItems.push(itemId);
          return false;
        }
        return true;
      });
    }
  });
  for (const itemName of itemsToBeRemoved) {
    if (!successfullyRemovedItems.includes(itemName)) {
      logWarning("menu-bar-item-could-not-be-removed", {
        menuBarConfig: originalConfig,
        itemName
      });
    }
  }
}
function handleAdditions(originalConfig, config, items) {
  const successFullyAddedItems = [];
  if (items.length == 0) {
    return;
  }
  for (const itemToAdd of items) {
    const relation = getRelationFromPosition(itemToAdd.position);
    const relativeId = getRelativeIdFromPosition(itemToAdd.position);
    if (isMenuBarMenuAddition(itemToAdd)) {
      if (!relativeId) {
        if (relation === "start") {
          config.items.unshift(itemToAdd.menu);
          successFullyAddedItems.push(itemToAdd);
        } else if (relation === "end") {
          config.items.push(itemToAdd.menu);
          successFullyAddedItems.push(itemToAdd);
        }
      } else {
        const topLevelMenuDefinitionIndex = config.items.findIndex((menuDefinition) => menuDefinition.menuId === relativeId);
        if (topLevelMenuDefinitionIndex != -1) {
          if (relation === "before") {
            config.items.splice(topLevelMenuDefinitionIndex, 0, itemToAdd.menu);
            successFullyAddedItems.push(itemToAdd);
          } else if (relation === "after") {
            config.items.splice(topLevelMenuDefinitionIndex + 1, 0, itemToAdd.menu);
            successFullyAddedItems.push(itemToAdd);
          }
        } else {
          const wasAdded = addMenuOrItemToGroup(config, itemToAdd.menu, relativeId, relation);
          if (wasAdded) {
            successFullyAddedItems.push(itemToAdd);
          }
        }
      }
    } else if (isMenuBarMenuGroupAddition(itemToAdd)) {
      walkConfigMenus(config.items, (menuDefinition) => {
        if (menuDefinition.menuId === relativeId) {
          if (relation === "start") {
            menuDefinition.groups.unshift(itemToAdd.group);
            successFullyAddedItems.push(itemToAdd);
          } else if (relation === "end") {
            menuDefinition.groups.push(itemToAdd.group);
            successFullyAddedItems.push(itemToAdd);
          }
        } else {
          const relativeGroupIndex = menuDefinition.groups.findIndex((group) => group.groupId === relativeId);
          if (relativeGroupIndex !== -1) {
            if (relation === "before") {
              menuDefinition.groups.splice(relativeGroupIndex, 0, itemToAdd.group);
              successFullyAddedItems.push(itemToAdd);
            } else if (relation === "after") {
              menuDefinition.groups.splice(relativeGroupIndex + 1, 0, itemToAdd.group);
              successFullyAddedItems.push(itemToAdd);
            }
          }
        }
      });
    } else {
      const wasAdded = addMenuOrItemToGroup(config, itemToAdd.item, relativeId, relation);
      if (wasAdded) {
        successFullyAddedItems.push(itemToAdd);
      }
    }
  }
  for (const addedItemConfig of items) {
    if (!successFullyAddedItems.includes(addedItemConfig)) {
      logWarning("menu-bar-item-could-not-be-added", {
        menuBarConfig: originalConfig,
        addedItemConfig
      });
    }
  }
}
function addMenuOrItemToGroup(config, itemOrMenuToAdd, relativeId, relation) {
  let wasAdded = false;
  walkConfigMenus(config.items, (menuDefinition) => {
    for (const { groupId, items: groupItems } of menuDefinition.groups) {
      if (wasAdded) {
        return;
      }
      if (groupId === relativeId) {
        if (relation === "start") {
          groupItems.unshift(itemOrMenuToAdd);
          wasAdded = true;
        } else if (relation === "end") {
          groupItems.push(itemOrMenuToAdd);
          wasAdded = true;
        }
      } else {
        const relativeItemIndex = groupItems.findIndex((groupItem) => {
          return getIdFromGroupItem(groupItem) === relativeId;
        });
        if (relativeItemIndex !== -1) {
          if (relation === "before") {
            groupItems.splice(relativeItemIndex, 0, itemOrMenuToAdd);
            wasAdded = true;
          } else if (relation === "after") {
            groupItems.splice(relativeItemIndex + 1, 0, itemOrMenuToAdd);
            wasAdded = true;
          }
        }
      }
    }
  });
  return wasAdded;
}
function purgeUnavailableComponents(originalConfig, config, componentFactory) {
  walkConfigMenus(config.items, (menuDefinition) => {
    for (const groupDefinition of menuDefinition.groups) {
      groupDefinition.items = groupDefinition.items.filter((item) => {
        const isItemUnavailable = typeof item === "string" && !componentFactory.has(item);
        if (isItemUnavailable && !config.isUsingDefaultConfig) {
          logWarning("menu-bar-item-unavailable", {
            menuBarConfig: originalConfig,
            parentMenuConfig: cloneDeep_default(menuDefinition),
            componentName: item
          });
        }
        return !isItemUnavailable;
      });
    }
  });
}
function purgeEmptyMenus(originalConfig, config) {
  const isUsingDefaultConfig = config.isUsingDefaultConfig;
  let wasSubMenuPurged = false;
  config.items = config.items.filter((menuDefinition) => {
    if (!menuDefinition.groups.length) {
      warnAboutEmptyMenu(originalConfig, menuDefinition, isUsingDefaultConfig);
      return false;
    }
    return true;
  });
  if (!config.items.length) {
    warnAboutEmptyMenu(originalConfig, originalConfig, isUsingDefaultConfig);
    return;
  }
  walkConfigMenus(config.items, (menuDefinition) => {
    menuDefinition.groups = menuDefinition.groups.filter((groupDefinition) => {
      if (!groupDefinition.items.length) {
        wasSubMenuPurged = true;
        return false;
      }
      return true;
    });
    for (const groupDefinition of menuDefinition.groups) {
      groupDefinition.items = groupDefinition.items.filter((item) => {
        if (isMenuDefinition(item) && !item.groups.length) {
          warnAboutEmptyMenu(originalConfig, item, isUsingDefaultConfig);
          wasSubMenuPurged = true;
          return false;
        }
        return true;
      });
    }
  });
  if (wasSubMenuPurged) {
    purgeEmptyMenus(originalConfig, config);
  }
}
function warnAboutEmptyMenu(originalConfig, emptyMenuConfig, isUsingDefaultConfig) {
  if (isUsingDefaultConfig) {
    return;
  }
  logWarning("menu-bar-menu-empty", {
    menuBarConfig: originalConfig,
    emptyMenuConfig
  });
}
function localizeMenuLabels(config, locale) {
  const t = locale.t;
  const localizedCategoryLabels = {
    // Top-level categories.
    "File": t({
      string: "File",
      id: "MENU_BAR_MENU_FILE"
    }),
    "Edit": t({
      string: "Edit",
      id: "MENU_BAR_MENU_EDIT"
    }),
    "View": t({
      string: "View",
      id: "MENU_BAR_MENU_VIEW"
    }),
    "Insert": t({
      string: "Insert",
      id: "MENU_BAR_MENU_INSERT"
    }),
    "Format": t({
      string: "Format",
      id: "MENU_BAR_MENU_FORMAT"
    }),
    "Tools": t({
      string: "Tools",
      id: "MENU_BAR_MENU_TOOLS"
    }),
    "Help": t({
      string: "Help",
      id: "MENU_BAR_MENU_HELP"
    }),
    // Sub-menus.
    "Text": t({
      string: "Text",
      id: "MENU_BAR_MENU_TEXT"
    }),
    "Font": t({
      string: "Font",
      id: "MENU_BAR_MENU_FONT"
    })
  };
  walkConfigMenus(config.items, (definition) => {
    if (definition.label in localizedCategoryLabels) {
      definition.label = localizedCategoryLabels[definition.label];
    }
  });
}
function walkConfigMenus(definition, callback) {
  if (Array.isArray(definition)) {
    for (const topLevelMenuDefinition of definition) {
      walk(topLevelMenuDefinition);
    }
  }
  function walk(menuDefinition) {
    callback(menuDefinition);
    for (const groupDefinition of menuDefinition.groups) {
      for (const groupItem of groupDefinition.items) {
        if (isMenuDefinition(groupItem)) {
          walk(groupItem);
        }
      }
    }
  }
}
function isMenuBarMenuAddition(definition) {
  return typeof definition === "object" && "menu" in definition;
}
function isMenuBarMenuGroupAddition(definition) {
  return typeof definition === "object" && "group" in definition;
}
function getRelationFromPosition(position) {
  if (position.startsWith("start")) {
    return "start";
  } else if (position.startsWith("end")) {
    return "end";
  } else if (position.startsWith("after")) {
    return "after";
  } else {
    return "before";
  }
}
function getRelativeIdFromPosition(position) {
  const match = position.match(/^[^:]+:(.+)/);
  if (match) {
    return match[1];
  }
  return null;
}
function getIdFromGroupItem(item) {
  return typeof item === "string" ? item : item.menuId;
}
function isMenuDefinition(definition) {
  return typeof definition === "object" && "menuId" in definition;
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/editorui.js
var EditorUI = class extends ObservableMixin() {
  /**
   * Creates an instance of the editor UI class.
   *
   * @param editor The editor instance.
   */
  constructor(editor) {
    super();
    this.isReady = false;
    this._editableElementsMap = /* @__PURE__ */ new Map();
    this._focusableToolbarDefinitions = [];
    this._extraMenuBarElements = [];
    this._lastFocusedForeignElement = null;
    const editingView = editor.editing.view;
    this.editor = editor;
    this.componentFactory = new ComponentFactory(editor);
    this.focusTracker = new FocusTracker();
    this.tooltipManager = new tooltipmanager_default(editor);
    this.poweredBy = new PoweredBy(editor);
    this.evaluationBadge = new EvaluationBadge(editor);
    this.ariaLiveAnnouncer = new AriaLiveAnnouncer(editor);
    this.set("viewportOffset", this._readViewportOffsetFromConfig());
    this.once("ready", () => {
      this._bindBodyCollectionWithFocusTracker();
      this.isReady = true;
    });
    this.listenTo(editingView.document, "layoutChanged", this.update.bind(this));
    this.listenTo(editingView, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this));
    this._initFocusTracking();
  }
  /**
   * The main (outermost) DOM element of the editor UI.
   *
   * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
   * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
   * it is the editable element itself (as there is no other wrapper). However, in
   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
   * come with a single "main" HTML element (its editable element and toolbar are separate).
   *
   * This property can be understood as a shorthand for retrieving the element that a specific editor integration
   * considers to be its main DOM element.
   */
  get element() {
    return null;
  }
  /**
   * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
   *
   * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
   * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
   */
  update() {
    this.fire("update");
  }
  /**
   * Destroys the UI.
   */
  destroy() {
    this.stopListening();
    this.focusTracker.destroy();
    this.tooltipManager.destroy(this.editor);
    this.poweredBy.destroy();
    this.evaluationBadge.destroy();
    for (const domElement of this._editableElementsMap.values()) {
      domElement.ckeditorInstance = null;
      this.editor.keystrokes.stopListening(domElement);
    }
    this._editableElementsMap = /* @__PURE__ */ new Map();
    this._focusableToolbarDefinitions = [];
  }
  /**
   * Stores the native DOM editable element used by the editor under a unique name.
   *
   * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
   * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
   *
   * @param rootName The unique name of the editable element.
   * @param domElement The native DOM editable element.
   */
  setEditableElement(rootName, domElement) {
    this._editableElementsMap.set(rootName, domElement);
    if (!domElement.ckeditorInstance) {
      domElement.ckeditorInstance = this.editor;
    }
    this.focusTracker.add(domElement);
    const setUpKeystrokeHandler = () => {
      if (this.editor.editing.view.getDomRoot(rootName)) {
        return;
      }
      this.editor.keystrokes.listenTo(domElement);
    };
    if (this.isReady) {
      setUpKeystrokeHandler();
    } else {
      this.once("ready", setUpKeystrokeHandler);
    }
  }
  /**
   * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
   *
   * @param rootName The name of the editable element to remove.
   */
  removeEditableElement(rootName) {
    const domElement = this._editableElementsMap.get(rootName);
    if (!domElement) {
      return;
    }
    this._editableElementsMap.delete(rootName);
    this.editor.keystrokes.stopListening(domElement);
    this.focusTracker.remove(domElement);
    domElement.ckeditorInstance = null;
  }
  /**
   * Returns the editable editor element with the given name or null if editable does not exist.
   *
   * @param rootName The editable name.
   */
  getEditableElement(rootName = "main") {
    return this._editableElementsMap.get(rootName);
  }
  /**
   * Returns array of names of all editor editable elements.
   */
  getEditableElementsNames() {
    return this._editableElementsMap.keys();
  }
  /**
   * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
   *
   * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
   * Successive keystroke presses navigate over available toolbars.
   *
   * @param toolbarView A instance of the toolbar to be registered.
   */
  addToolbar(toolbarView, options = {}) {
    if (toolbarView.isRendered) {
      this.focusTracker.add(toolbarView);
      this.editor.keystrokes.listenTo(toolbarView.element);
    } else {
      toolbarView.once("render", () => {
        this.focusTracker.add(toolbarView);
        this.editor.keystrokes.listenTo(toolbarView.element);
      });
    }
    this._focusableToolbarDefinitions.push({ toolbarView, options });
  }
  /**
   * Registers an extra menu bar element, which could be a single item, a group of items, or a menu containing groups.
   *
   * ```ts
   * // Register a new menu bar item.
   * editor.ui.extendMenuBar( {
   *   item: 'menuBar:customFunctionButton',
   *   position: 'after:menuBar:bold'
   * } );
   *
   * // Register a new menu bar group.
   * editor.ui.extendMenuBar( {
   *   group: {
   *     groupId: 'customGroup',
   *     items: [
   *       'menuBar:customFunctionButton'
   *     ]
   *   },
   *   position: 'start:help'
   * } );
   *
   * // Register a new menu bar menu.
   * editor.ui.extendMenuBar( {
   *   menu: {
   *     menuId: 'customMenu',
   *     label: 'customMenu',
   *     groups: [
   *       {
   *         groupId: 'customGroup',
   *         items: [
   *           'menuBar:customFunctionButton'
   *         ]
   *       }
   *     ]
   *   },
   *   position: 'after:help'
   * } );
   * ```
   */
  extendMenuBar(config) {
    this._extraMenuBarElements.push(config);
  }
  /**
   * Stores all editable elements used by the editor instance.
   *
   * @deprecated
   */
  get _editableElements() {
    console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this });
    return this._editableElementsMap;
  }
  /**
   * Initializes menu bar.
   */
  _initMenuBar(menuBarView) {
    const menuBarViewElement = menuBarView.element;
    this.focusTracker.add(menuBarViewElement);
    this.editor.keystrokes.listenTo(menuBarViewElement);
    const normalizedMenuBarConfig = normalizeMenuBarConfig(this.editor.config.get("menuBar") || {});
    menuBarView.fillFromConfig(normalizedMenuBarConfig, this.componentFactory, this._extraMenuBarElements);
    this.editor.keystrokes.set("Esc", (data, cancel2) => {
      if (!menuBarViewElement.contains(this.editor.ui.focusTracker.focusedElement)) {
        return;
      }
      if (this._lastFocusedForeignElement) {
        this._lastFocusedForeignElement.focus();
        this._lastFocusedForeignElement = null;
      } else {
        this.editor.editing.view.focus();
      }
      cancel2();
    });
    this.editor.keystrokes.set("Alt+F9", (data, cancel2) => {
      if (menuBarViewElement.contains(this.editor.ui.focusTracker.focusedElement)) {
        return;
      }
      this._saveLastFocusedForeignElement();
      menuBarView.isFocusBorderEnabled = true;
      menuBarView.focus();
      cancel2();
    });
  }
  /**
   * Returns viewport offsets object:
   *
   * ```js
   * {
   * 	top: Number,
   * 	right: Number,
   * 	bottom: Number,
   * 	left: Number
   * }
   * ```
   *
   * Only top property is currently supported.
   */
  _readViewportOffsetFromConfig() {
    const editor = this.editor;
    const viewportOffsetConfig = editor.config.get("ui.viewportOffset");
    if (viewportOffsetConfig) {
      return viewportOffsetConfig;
    }
    const legacyOffsetConfig = editor.config.get("toolbar.viewportTopOffset");
    if (legacyOffsetConfig) {
      console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.");
      return { top: legacyOffsetConfig };
    }
    return { top: 0 };
  }
  /**
   * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
   * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
   * to allow users navigate across the UI.
   */
  _initFocusTracking() {
    const editor = this.editor;
    let candidateDefinitions;
    editor.keystrokes.set("Alt+F10", (data, cancel2) => {
      this._saveLastFocusedForeignElement();
      const currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();
      if (!currentFocusedToolbarDefinition || !candidateDefinitions) {
        candidateDefinitions = this._getFocusableCandidateToolbarDefinitions();
      }
      for (let i = 0; i < candidateDefinitions.length; i++) {
        const candidateDefinition = candidateDefinitions.shift();
        candidateDefinitions.push(candidateDefinition);
        if (candidateDefinition !== currentFocusedToolbarDefinition && this._focusFocusableCandidateToolbar(candidateDefinition)) {
          if (currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur) {
            currentFocusedToolbarDefinition.options.afterBlur();
          }
          break;
        }
      }
      cancel2();
    });
    editor.keystrokes.set("Esc", (data, cancel2) => {
      const focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();
      if (!focusedToolbarDef) {
        return;
      }
      if (this._lastFocusedForeignElement) {
        this._lastFocusedForeignElement.focus();
        this._lastFocusedForeignElement = null;
      } else {
        editor.editing.view.focus();
      }
      if (focusedToolbarDef.options.afterBlur) {
        focusedToolbarDef.options.afterBlur();
      }
      cancel2();
    });
  }
  /**
   * Saves last focused element that doen not belong to editing view to restore focus on `Esc`.
   */
  _saveLastFocusedForeignElement() {
    const focusedElement = this.focusTracker.focusedElement;
    if (Array.from(this._editableElementsMap.values()).includes(focusedElement) && !Array.from(this.editor.editing.view.domRoots.values()).includes(focusedElement)) {
      this._lastFocusedForeignElement = focusedElement;
    }
  }
  /**
   * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
   *
   * Focusable toolbars candidates are either:
   * * already visible,
   * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
   * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
   * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
   *
   * **Note**: Contextual toolbars take precedence over regular toolbars.
   */
  _getFocusableCandidateToolbarDefinitions() {
    const definitions = [];
    for (const toolbarDef of this._focusableToolbarDefinitions) {
      const { toolbarView, options } = toolbarDef;
      if (isVisible(toolbarView.element) || options.beforeFocus) {
        definitions.push(toolbarDef);
      }
    }
    definitions.sort((defA, defB) => getToolbarDefinitionWeight(defA) - getToolbarDefinitionWeight(defB));
    return definitions;
  }
  /**
   * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
   *
   * `null` is returned when no toolbar is currently focused.
   */
  _getCurrentFocusedToolbarDefinition() {
    for (const definition of this._focusableToolbarDefinitions) {
      if (definition.toolbarView.element && definition.toolbarView.element.contains(this.focusTracker.focusedElement)) {
        return definition;
      }
    }
    return null;
  }
  /**
   * Focuses a focusable toolbar candidate using its definition.
   *
   * @param candidateToolbarDefinition A definition of the toolbar to focus.
   * @returns `true` when the toolbar candidate was focused. `false` otherwise.
   */
  _focusFocusableCandidateToolbar(candidateToolbarDefinition) {
    const { toolbarView, options: { beforeFocus } } = candidateToolbarDefinition;
    if (beforeFocus) {
      beforeFocus();
    }
    if (!isVisible(toolbarView.element)) {
      return false;
    }
    toolbarView.focus();
    return true;
  }
  /**
   * Provides an integration between {@link #viewportOffset} and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
   * It allows the UI-agnostic engine method to consider user-configured viewport offsets specific for the integration.
   *
   * @param evt The `scrollToTheSelection` event info.
   * @param data The payload carried by the `scrollToTheSelection` event.
   */
  _handleScrollToTheSelection(evt, data) {
    const configuredViewportOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      ...this.viewportOffset
    };
    data.viewportOffset.top += configuredViewportOffset.top;
    data.viewportOffset.bottom += configuredViewportOffset.bottom;
    data.viewportOffset.left += configuredViewportOffset.left;
    data.viewportOffset.right += configuredViewportOffset.right;
  }
  /**
   * Ensures that the focus tracker is aware of all views' DOM elements in the body collection.
   */
  _bindBodyCollectionWithFocusTracker() {
    const body = this.view.body;
    for (const view of body) {
      this.focusTracker.add(view.element);
    }
    body.on("add", (evt, view) => {
      this.focusTracker.add(view.element);
    });
    body.on("remove", (evt, view) => {
      this.focusTracker.remove(view.element);
    });
  }
};
function getToolbarDefinitionWeight(toolbarDef) {
  const { toolbarView, options } = toolbarDef;
  let weight = 10;
  if (isVisible(toolbarView.element)) {
    weight--;
  }
  if (options.isContextual) {
    weight--;
  }
  return weight;
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/editorui/editorui.css";
var EditorUIView = class extends View {
  /**
   * Creates an instance of the editor UI view class.
   *
   * @param locale The locale instance.
   */
  constructor(locale) {
    super(locale);
    this.body = new BodyCollection(locale);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.body.attachToDom();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.body.detachFromDom();
    return super.destroy();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/boxed/boxededitoruiview.js
var BoxedEditorUIView = class extends EditorUIView {
  /**
   * Creates an instance of the boxed editor UI view class.
   *
   * @param locale The locale instance..
   */
  constructor(locale) {
    super(locale);
    this.top = this.createCollection();
    this.main = this.createCollection();
    this._voiceLabelView = this._createVoiceLabel();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-editor",
          "ck-rounded-corners"
        ],
        role: "application",
        dir: locale.uiLanguageDirection,
        lang: locale.uiLanguage,
        "aria-labelledby": this._voiceLabelView.id
      },
      children: [
        this._voiceLabelView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__top",
              "ck-reset_all"
            ],
            role: "presentation"
          },
          children: this.top
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__main"
            ],
            role: "presentation"
          },
          children: this.main
        }
      ]
    });
  }
  /**
   * Creates a voice label view instance.
   */
  _createVoiceLabel() {
    const t = this.t;
    const voiceLabel = new LabelView();
    voiceLabel.text = t("Rich Text Editor");
    voiceLabel.extendTemplate({
      attributes: {
        class: "ck-voice-label"
      }
    });
    return voiceLabel;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editableui/editableuiview.js
var EditableUIView = class extends View {
  /**
   * Creates an instance of EditableUIView class.
   *
   * @param locale The locale instance.
   * @param editingView The editing view instance the editable is related to.
   * @param editableElement The editable element. If not specified, this view
   * should create it. Otherwise, the existing element should be used.
   */
  constructor(locale, editingView, editableElement) {
    super(locale);
    this.name = null;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-content",
          "ck-editor__editable",
          "ck-rounded-corners"
        ],
        lang: locale.contentLanguage,
        dir: locale.contentLanguageDirection
      }
    });
    this.set("isFocused", false);
    this._editableElement = editableElement;
    this._hasExternalElement = !!this._editableElement;
    this._editingView = editingView;
  }
  /**
   * Renders the view by either applying the {@link #template} to the existing
   * {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement} or assigning {@link #element}
   * as {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement}.
   */
  render() {
    super.render();
    if (this._hasExternalElement) {
      this.template.apply(this.element = this._editableElement);
    } else {
      this._editableElement = this.element;
    }
    this.on("change:isFocused", () => this._updateIsFocusedClasses());
    this._updateIsFocusedClasses();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    if (this._hasExternalElement) {
      this.template.revert(this._editableElement);
    }
    super.destroy();
  }
  /**
   * Whether an external {@link #_editableElement} was passed into the constructor, which also means
   * the view will not render its {@link #template}.
   */
  get hasExternalElement() {
    return this._hasExternalElement;
  }
  /**
   * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
   * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
   */
  _updateIsFocusedClasses() {
    const editingView = this._editingView;
    if (editingView.isRenderingInProgress) {
      updateAfterRender(this);
    } else {
      update(this);
    }
    function update(view) {
      editingView.change((writer) => {
        const viewRoot = editingView.document.getRoot(view.name);
        writer.addClass(view.isFocused ? "ck-focused" : "ck-blurred", viewRoot);
        writer.removeClass(view.isFocused ? "ck-blurred" : "ck-focused", viewRoot);
      });
    }
    function updateAfterRender(view) {
      editingView.once("change:isRenderingInProgress", (evt, name, value) => {
        if (!value) {
          update(view);
        } else {
          updateAfterRender(view);
        }
      });
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/editableui/inline/inlineeditableuiview.js
var InlineEditableUIView = class extends EditableUIView {
  /**
   * Creates an instance of the InlineEditableUIView class.
   *
   * @param locale The locale instance.
   * @param editingView The editing view instance the editable is related to.
   * @param editableElement The editable element. If not specified, the
   * {@link module:ui/editableui/editableuiview~EditableUIView}
   * will create it. Otherwise, the existing element will be used.
   * @param options Additional configuration of the view.
   * @param options.label The label of the editable for assistive technologies. If not provided, a default label is used or,
   * the existing `aria-label` attribute value from the specified `editableElement` is preserved.
   */
  constructor(locale, editingView, editableElement, options = {}) {
    super(locale, editingView, editableElement);
    this._options = options;
    this.extendTemplate({
      attributes: {
        role: "textbox",
        class: "ck-editor__editable_inline"
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    const editingView = this._editingView;
    editingView.change((writer) => {
      const viewRoot = editingView.document.getRoot(this.name);
      writer.setAttribute("aria-label", this.getEditableAriaLabel(), viewRoot);
    });
  }
  /**
   * Returns a normalized label for the editable view based on the environment.
   */
  getEditableAriaLabel() {
    const t = this.locale.t;
    const label = this._options.label;
    const editableElement = this._editableElement;
    const editableName = this.name;
    if (typeof label == "string") {
      return label;
    } else if (typeof label === "object") {
      return label[editableName];
    } else if (typeof label === "function") {
      return label(this);
    } else if (editableElement) {
      const existingLabel = editableElement.getAttribute("aria-label");
      if (existingLabel) {
        return existingLabel;
      }
    }
    return t("Rich Text Editor. Editing area: %0", editableName);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/model.js
var Model2 = class extends ObservableMixin() {
  /**
   * Creates a new Model instance.
   *
   * @param attributes The model state attributes to be defined during the instance creation.
   * @param properties The (out of state) properties to be appended to the instance during creation.
   */
  constructor(attributes, properties) {
    super();
    if (properties) {
      assignIn_default(this, properties);
    }
    if (attributes) {
      this.set(attributes);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css";
var toPx3 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css";
var toPx4 = toUnit("px");
var StickyPanelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isActive", false);
    this.set("isSticky", false);
    this.set("limiterElement", null);
    this.set("limiterBottomOffset", 50);
    this.set("viewportTopOffset", 0);
    this.set("_marginLeft", null);
    this.set("_isStickyToTheBottomOfLimiter", false);
    this.set("_stickyTopOffset", null);
    this.set("_stickyBottomOffset", null);
    this.content = this.createCollection();
    this._contentPanelPlaceholder = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__placeholder"
        ],
        style: {
          display: bind.to("isSticky", (isSticky) => isSticky ? "block" : "none"),
          height: bind.to("isSticky", (isSticky) => {
            return isSticky ? toPx4(this._contentPanelRect.height) : null;
          })
        }
      }
    }).render();
    this.contentPanelElement = new Template({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__content",
          // Toggle class of the panel when "sticky" state changes in the view.
          bind.if("isSticky", "ck-sticky-panel__content_sticky"),
          bind.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")
        ],
        style: {
          width: bind.to("isSticky", (isSticky) => {
            return isSticky ? toPx4(this._contentPanelPlaceholder.getBoundingClientRect().width) : null;
          }),
          top: bind.to("_stickyTopOffset", (value) => value ? toPx4(value) : value),
          bottom: bind.to("_stickyBottomOffset", (value) => value ? toPx4(value) : value),
          marginLeft: bind.to("_marginLeft")
        }
      },
      children: this.content
    }).render();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel"
        ]
      },
      children: [
        this._contentPanelPlaceholder,
        this.contentPanelElement
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.checkIfShouldBeSticky();
    this.listenTo(global_default.document, "scroll", () => {
      this.checkIfShouldBeSticky();
    }, { useCapture: true });
    this.listenTo(this, "change:isActive", () => {
      this.checkIfShouldBeSticky();
    });
  }
  /**
   * Analyzes the environment to decide whether the panel should be sticky or not.
   * Then handles the positioning of the panel.
   */
  checkIfShouldBeSticky() {
    if (!this.limiterElement || !this.isActive) {
      this._unstick();
      return;
    }
    const limiterRect = new Rect(this.limiterElement);
    let visibleLimiterRect = limiterRect.getVisible();
    if (visibleLimiterRect) {
      const windowRect = new Rect(global_default.window);
      windowRect.top += this.viewportTopOffset;
      windowRect.height -= this.viewportTopOffset;
      visibleLimiterRect = visibleLimiterRect.getIntersection(windowRect);
    }
    if (visibleLimiterRect && limiterRect.top < visibleLimiterRect.top) {
      const visibleLimiterTop = visibleLimiterRect.top;
      if (visibleLimiterTop + this._contentPanelRect.height + this.limiterBottomOffset > visibleLimiterRect.bottom) {
        const stickyBottomOffset = Math.max(limiterRect.bottom - visibleLimiterRect.bottom, 0) + this.limiterBottomOffset;
        if (limiterRect.bottom - stickyBottomOffset > limiterRect.top + this._contentPanelRect.height) {
          this._stickToBottomOfLimiter(stickyBottomOffset);
        } else {
          this._unstick();
        }
      } else {
        if (this._contentPanelRect.height + this.limiterBottomOffset < limiterRect.height) {
          this._stickToTopOfAncestors(visibleLimiterTop);
        } else {
          this._unstick();
        }
      }
    } else {
      this._unstick();
    }
  }
  /**
   * Sticks the panel at the given CSS `top` offset.
   *
   * @private
   * @param topOffset
   */
  _stickToTopOfAncestors(topOffset) {
    this.isSticky = true;
    this._isStickyToTheBottomOfLimiter = false;
    this._stickyTopOffset = topOffset;
    this._stickyBottomOffset = null;
    this._marginLeft = toPx4(-global_default.window.scrollX);
  }
  /**
   * Sticks the panel at the bottom of the limiter with a given CSS `bottom` offset.
   *
   * @private
   * @param stickyBottomOffset
   */
  _stickToBottomOfLimiter(stickyBottomOffset) {
    this.isSticky = true;
    this._isStickyToTheBottomOfLimiter = true;
    this._stickyTopOffset = null;
    this._stickyBottomOffset = stickyBottomOffset;
    this._marginLeft = toPx4(-global_default.window.scrollX);
  }
  /**
   * Unsticks the panel putting it back to its original position.
   *
   * @private
   */
  _unstick() {
    this.isSticky = false;
    this._isStickyToTheBottomOfLimiter = false;
    this._stickyTopOffset = null;
    this._stickyBottomOffset = null;
    this._marginLeft = null;
  }
  /**
   * Returns the bounding rect of the {@link #contentPanelElement}.
   *
   * @private
   */
  get _contentPanelRect() {
    return new Rect(this.contentPanelElement);
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/search/text/searchtextqueryview.js
var SearchTextQueryView = class extends LabeledFieldView {
  /**
   * @inheritDoc
   */
  constructor(locale, config) {
    const t = locale.t;
    const viewConfig = Object.assign({}, {
      showResetButton: true,
      showIcon: true,
      creator: createLabeledInputText
    }, config);
    super(locale, viewConfig.creator);
    this.label = config.label;
    this._viewConfig = viewConfig;
    if (this._viewConfig.showIcon) {
      this.iconView = new iconview_default();
      this.iconView.content = icons.loupe;
      this.fieldWrapperChildren.add(this.iconView, 0);
      this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-icon"
        }
      });
    }
    if (this._viewConfig.showResetButton) {
      this.resetButtonView = new ButtonView(locale);
      this.resetButtonView.set({
        label: t("Clear"),
        icon: icons.cancel,
        class: "ck-search__reset",
        isVisible: false,
        tooltip: true
      });
      this.resetButtonView.on("execute", () => {
        this.reset();
        this.focus();
        this.fire("reset");
      });
      this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (isEmpty) => !isEmpty);
      this.fieldWrapperChildren.add(this.resetButtonView);
      this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-reset"
        }
      });
    }
  }
  /**
   * Resets the search field to its default state.
   */
  reset() {
    this.fieldView.reset();
    if (this._viewConfig.showResetButton) {
      this.resetButtonView.isVisible = false;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/search/searchinfoview.js
var SearchInfoView = class extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set({
      isVisible: false,
      primaryText: "",
      secondaryText: ""
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__info",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ],
        tabindex: -1
      },
      children: [
        {
          tag: "span",
          children: [
            {
              text: [bind.to("primaryText")]
            }
          ]
        },
        {
          tag: "span",
          children: [
            {
              text: [bind.to("secondaryText")]
            }
          ]
        }
      ]
    });
  }
  /**
   * Focuses the view
   */
  focus() {
    this.element.focus();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/search/searchresultsview.js
var SearchResultsView = class extends View {
  /**
   * @inheritDoc
   */
  constructor(locale) {
    super(locale);
    this.children = this.createCollection();
    this.focusTracker = new FocusTracker();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__results"
        ],
        tabindex: -1
      },
      children: this.children
    });
    this._focusCycler = new FocusCycler({
      focusables: this.children,
      focusTracker: this.focusTracker
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    for (const child of this.children) {
      this.focusTracker.add(child.element);
    }
  }
  /**
   * Focuses the view.
   */
  focus() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the first child view.
   */
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  /**
   * Focuses the last child view.
   */
  focusLast() {
    this._focusCycler.focusLast();
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/search/text/searchtextview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/search/search.css";
var SearchTextView = class extends View {
  /**
   * Creates an instance of the {@link module:ui/search/text/searchtextview~SearchTextView} class.
   *
   * @param locale The localization services instance.
   * @param config Configuration of the view.
   */
  constructor(locale, config) {
    super(locale);
    this._config = config;
    this.filteredView = config.filteredView;
    this.queryView = this._createSearchTextQueryView();
    this.focusTracker = new FocusTracker();
    this.keystrokes = new KeystrokeHandler();
    this.resultsView = new SearchResultsView(locale);
    this.children = this.createCollection();
    this.focusableChildren = this.createCollection([this.queryView, this.resultsView]);
    this.set("isEnabled", true);
    this.set("resultsCount", 0);
    this.set("totalItemsCount", 0);
    if (config.infoView && config.infoView.instance) {
      this.infoView = config.infoView.instance;
    } else {
      this.infoView = new SearchInfoView();
      this._enableDefaultInfoViewBehavior();
      this.on("render", () => {
        this.search("");
      });
    }
    this.resultsView.children.addMany([this.infoView, this.filteredView]);
    this.focusCycler = new FocusCycler({
      focusables: this.focusableChildren,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: "shift + tab",
        // Navigate form fields forwards using the Tab key.
        focusNext: "tab"
      }
    });
    this.on("search", (evt, { resultsCount, totalItemsCount }) => {
      this.resultsCount = resultsCount;
      this.totalItemsCount = totalItemsCount;
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search",
          config.class || null
        ],
        tabindex: "-1"
      },
      children: this.children
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.addMany([
      this.queryView,
      this.resultsView
    ]);
    const stopPropagation = (data) => data.stopPropagation();
    for (const focusableChild of this.focusableChildren) {
      this.focusTracker.add(focusableChild.element);
    }
    this.keystrokes.listenTo(this.element);
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  /**
   * Focuses the {@link #queryView}.
   */
  focus() {
    this.queryView.focus();
  }
  /**
   * Resets the component to its initial state.
   */
  reset() {
    this.queryView.reset();
    this.search("");
    this.filteredView.element.scrollTo(0, 0);
  }
  /**
   * Searches the {@link #filteredView} for the given query.
   *
   * @internal
   * @param query The search query string.
   */
  search(query) {
    const regExp = query ? new RegExp(escapeRegExp_default(query), "ig") : null;
    const filteringResults = this.filteredView.filter(regExp);
    this.fire("search", { query, ...filteringResults });
  }
  /**
   * Creates a search field view based on configured creator..
   */
  _createSearchTextQueryView() {
    const queryView = new SearchTextQueryView(this.locale, this._config.queryView);
    this.listenTo(queryView.fieldView, "input", () => {
      this.search(queryView.fieldView.element.value);
    });
    queryView.on("reset", () => this.reset());
    queryView.bind("isEnabled").to(this);
    return queryView;
  }
  /**
   * Initializes the default {@link #infoView} behavior with default text labels when no custom info view
   * was specified in the view config.
   */
  _enableDefaultInfoViewBehavior() {
    const t = this.locale.t;
    const infoView = this.infoView;
    this.on("search", (evt, data) => {
      if (!data.resultsCount) {
        const defaultTextConfig = this._config.infoView && this._config.infoView.text;
        let primaryText, secondaryText;
        if (data.totalItemsCount) {
          if (defaultTextConfig && defaultTextConfig.notFound) {
            primaryText = defaultTextConfig.notFound.primary;
            secondaryText = defaultTextConfig.notFound.secondary;
          } else {
            primaryText = t("No results found");
            secondaryText = "";
          }
        } else {
          if (defaultTextConfig && defaultTextConfig.noSearchableItems) {
            primaryText = defaultTextConfig.noSearchableItems.primary;
            secondaryText = defaultTextConfig.noSearchableItems.secondary;
          } else {
            primaryText = t("No searchable items");
            secondaryText = "";
          }
        }
        infoView.set({
          primaryText: normalizeInfoText(primaryText, data),
          secondaryText: normalizeInfoText(secondaryText, data),
          isVisible: true
        });
      } else {
        infoView.set({
          isVisible: false
        });
      }
    });
    function normalizeInfoText(text2, { query, resultsCount, totalItemsCount }) {
      return typeof text2 === "function" ? text2(query, resultsCount, totalItemsCount) : text2;
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/autocomplete/autocompleteview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/autocomplete/autocomplete.css";
var AutocompleteView = class _AutocompleteView extends SearchTextView {
  /**
   * @inheritDoc
   */
  constructor(locale, config) {
    super(locale, config);
    this._config = config;
    const toPx8 = toUnit("px");
    this.extendTemplate({
      attributes: {
        class: ["ck-autocomplete"]
      }
    });
    const bindResultsView = this.resultsView.bindTemplate;
    this.resultsView.set("isVisible", false);
    this.resultsView.set("_position", "s");
    this.resultsView.set("_width", 0);
    this.resultsView.extendTemplate({
      attributes: {
        class: [
          bindResultsView.if("isVisible", "ck-hidden", (value) => !value),
          bindResultsView.to("_position", (value) => `ck-search__results_${value}`)
        ],
        style: {
          width: bindResultsView.to("_width", toPx8)
        }
      }
    });
    this.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
      this._updateResultsVisibility();
      if (isFocused) {
        this.resultsView.element.scrollTop = 0;
      } else if (config.resetOnBlur) {
        this.queryView.reset();
      }
    });
    this.on("search", () => {
      this._updateResultsVisibility();
      this._updateResultsViewWidthAndPosition();
    });
    this.keystrokes.set("esc", (evt, cancel2) => {
      if (!this.resultsView.isVisible) {
        return;
      }
      this.queryView.focus();
      this.resultsView.isVisible = false;
      cancel2();
    });
    this.listenTo(global_default.document, "scroll", () => {
      this._updateResultsViewWidthAndPosition();
    });
    this.on("change:isEnabled", () => {
      this._updateResultsVisibility();
    });
    this.filteredView.on("execute", (evt, { value }) => {
      this.focus();
      this.reset();
      this.queryView.fieldView.value = this.queryView.fieldView.element.value = value;
      this.resultsView.isVisible = false;
    });
    this.resultsView.on("change:isVisible", () => {
      this._updateResultsViewWidthAndPosition();
    });
  }
  /**
   * Updates the position of the results view on demand.
   */
  _updateResultsViewWidthAndPosition() {
    if (!this.resultsView.isVisible) {
      return;
    }
    this.resultsView._width = new Rect(this.queryView.fieldView.element).width;
    const optimalResultsPosition = _AutocompleteView._getOptimalPosition({
      element: this.resultsView.element,
      target: this.queryView.element,
      fitInViewport: true,
      positions: _AutocompleteView.defaultResultsPositions
    });
    this.resultsView._position = optimalResultsPosition ? optimalResultsPosition.name : "s";
  }
  /**
   * Updates the visibility of the results view on demand.
   */
  _updateResultsVisibility() {
    const queryMinChars = typeof this._config.queryMinChars === "undefined" ? 0 : this._config.queryMinChars;
    const queryLength = this.queryView.fieldView.element.value.length;
    this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && queryLength >= queryMinChars;
  }
};
AutocompleteView.defaultResultsPositions = [
  (fieldRect) => {
    return {
      top: fieldRect.bottom,
      left: fieldRect.left,
      name: "s"
    };
  },
  (fieldRect, resultsRect) => {
    return {
      top: fieldRect.top - resultsRect.height,
      left: fieldRect.left,
      name: "n"
    };
  }
];
AutocompleteView._getOptimalPosition = getOptimalPosition;

// node_modules/@ckeditor/ckeditor5-ui/src/highlightedtext/highlightedtextview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/highlightedtext/highlightedtext.css";

// node_modules/@ckeditor/ckeditor5-ui/src/spinner/spinnerview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/spinner/spinner.css";

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/balloon/balloontoolbar.js
var toPx5 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/block/blockbuttonview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css";
var toPx6 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/block/blocktoolbar.js
var toPx7 = toUnit("px");

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/menubarmenubuttonview.js
import dropdownArrowIcon5 from "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg";
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/menubar/menubarmenubutton.css";
var MenuBarMenuButtonView = class extends ListItemButtonView {
  /**
   * Creates an instance of the menu bar button view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set({
      withText: true,
      role: "menuitem"
    });
    this.arrowView = this._createArrowView();
    this.extendTemplate({
      attributes: {
        class: [
          "ck-menu-bar__menu__button"
        ],
        "aria-haspopup": true,
        "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value)),
        "data-cke-tooltip-disabled": bind.to("isOn")
      },
      on: {
        "mouseenter": bind.to("mouseenter")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.children.add(this.arrowView);
  }
  /**
   * Creates the {@link #arrowView} instance.
   */
  _createArrowView() {
    const arrowView = new iconview_default();
    arrowView.content = dropdownArrowIcon5;
    arrowView.extendTemplate({
      attributes: {
        class: "ck-menu-bar__menu__button__arrow"
      }
    });
    return arrowView;
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/menubarmenupanelview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/menubar/menubarmenupanel.css";
var MenuBarMenuPanelView = class extends View {
  /**
   * Creates an instance of the menu panel view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", false);
    this.set("position", "se");
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-menu-bar__menu__panel",
          bind.to("position", (value) => `ck-menu-bar__menu__panel_position_${value}`),
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ],
        tabindex: "-1"
      },
      children: this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: bind.to((evt) => {
          if (evt.target.tagName.toLocaleLowerCase() === "input") {
            return;
          }
          evt.preventDefault();
        })
      }
    });
  }
  /**
   * Focuses the first child of the panel (default) or the last one if the `direction` is `-1`.
   */
  focus(direction = 1) {
    if (this.children.length) {
      if (direction === 1) {
        this.children.first.focus();
      } else {
        this.children.last.focus();
      }
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/menubarmenuview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/menubar/menubarmenu.css";
var MenuBarMenuView = class _MenuBarMenuView extends View {
  /**
   * Creates an instance of the menu view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.buttonView = new MenuBarMenuButtonView(locale);
    this.buttonView.delegate("mouseenter").to(this);
    this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled");
    this.panelView = new MenuBarMenuPanelView(locale);
    this.panelView.bind("isVisible").to(this, "isOpen");
    this.keystrokes = new KeystrokeHandler();
    this.focusTracker = new FocusTracker();
    this.set("isOpen", false);
    this.set("isEnabled", true);
    this.set("panelPosition", "w");
    this.set("class", void 0);
    this.set("parentMenuView", null);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-menu-bar__menu",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("parentMenuView", "ck-menu-bar__menu_top-level", (value) => !value)
        ]
      },
      children: [
        this.buttonView,
        this.panelView
      ]
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.keystrokes.listenTo(this.element);
    MenuBarMenuBehaviors.closeOnEscKey(this);
    this._repositionPanelOnOpen();
  }
  // For now, this method cannot be called in the render process because the `parentMenuView` may be assigned
  // after the rendering process.
  //
  // TODO: We should reconsider the way we handle this logic.
  /**
   * Attach all keyboard behaviors for the menu bar view.
   *
   * @internal
   */
  _attachBehaviors() {
    if (!this.parentMenuView) {
      this._propagateArrowKeystrokeEvents();
      MenuBarMenuBehaviors.openAndFocusPanelOnArrowDownKey(this);
      MenuBarMenuBehaviors.toggleOnButtonClick(this);
    } else {
      MenuBarMenuBehaviors.openOnButtonClick(this);
      MenuBarMenuBehaviors.openOnArrowRightKey(this);
      MenuBarMenuBehaviors.closeOnArrowLeftKey(this);
      MenuBarMenuBehaviors.openAndFocusOnEnterKeyPress(this);
      MenuBarMenuBehaviors.closeOnParentClose(this);
    }
  }
  /**
   * Fires `arrowright` and `arrowleft` events when the user pressed corresponding arrow keys.
   */
  _propagateArrowKeystrokeEvents() {
    this.keystrokes.set("arrowright", (data, cancel2) => {
      this.fire("arrowright");
      cancel2();
    });
    this.keystrokes.set("arrowleft", (data, cancel2) => {
      this.fire("arrowleft");
      cancel2();
    });
  }
  /**
   * Sets the position of the panel when the menu opens. The panel is positioned
   * so that it optimally uses the available space in the viewport.
   */
  _repositionPanelOnOpen() {
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen) {
        return;
      }
      const optimalPanelPosition = _MenuBarMenuView._getOptimalPosition({
        element: this.panelView.element,
        target: this.buttonView.element,
        fitInViewport: true,
        positions: this._panelPositions
      });
      this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._defaultMenuPositionName;
    });
  }
  /**
   * @inheritDoc
   */
  focus() {
    this.buttonView.focus();
  }
  /**
   * Positioning functions for the {@link #panelView} . They change depending on the role of the menu (top-level vs sub-menu) in
   * the {@link module:ui/menubar/menubarview~MenuBarView menu bar} and the UI language direction.
   */
  get _panelPositions() {
    const { southEast, southWest, northEast, northWest, westSouth, eastSouth, westNorth, eastNorth } = MenuBarMenuViewPanelPositioningFunctions;
    if (this.locale.uiLanguageDirection === "ltr") {
      if (this.parentMenuView) {
        return [eastSouth, eastNorth, westSouth, westNorth];
      } else {
        return [southEast, southWest, northEast, northWest];
      }
    } else {
      if (this.parentMenuView) {
        return [westSouth, westNorth, eastSouth, eastNorth];
      } else {
        return [southWest, southEast, northWest, northEast];
      }
    }
  }
  /**
   * The default position of the panel when the menu is opened.
   * It is used when the optimal position cannot be calculated.
   */
  get _defaultMenuPositionName() {
    if (this.locale.uiLanguageDirection === "ltr") {
      if (this.parentMenuView) {
        return "es";
      } else {
        return "se";
      }
    } else {
      if (this.parentMenuView) {
        return "ws";
      } else {
        return "sw";
      }
    }
  }
};
MenuBarMenuView._getOptimalPosition = getOptimalPosition;
var menubarmenuview_default = MenuBarMenuView;

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/menubarmenulistview.js
var MenuBarMenuListView = class extends ListView {
  /**
   * Creates an instance of the list view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    this.role = "menu";
    this.items.on("change", this._setItemsCheckSpace.bind(this));
  }
  /**
   * This method adds empty space if there is any toggleable item in the list.
   * It makes the list properly aligned.
   */
  _setItemsCheckSpace() {
    const hasAnyToggleableItem = Array.from(this.items).some((item) => {
      const listButtonView = pickListButtonMenuViewIfPresent(item);
      return listButtonView && listButtonView.isToggleable;
    });
    this.items.forEach((item) => {
      const listButtonView = pickListButtonMenuViewIfPresent(item);
      if (listButtonView) {
        listButtonView.hasCheckSpace = hasAnyToggleableItem;
      }
    });
  }
};
function pickListButtonMenuViewIfPresent(item) {
  if (!(item instanceof ListItemView)) {
    return null;
  }
  return item.children.map((child) => isNestedMenuLikeView(child) ? child.buttonView : child).find((item2) => item2 instanceof ListItemButtonView);
}
function isNestedMenuLikeView(item) {
  return typeof item === "object" && "buttonView" in item && item.buttonView instanceof ButtonView;
}

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/menubarmenulistitemfiledialogbuttonview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/menubar/menubarmenulistitembutton.css";
var MenuBarMenuListItemFileDialogButtonView = class extends FileDialogListItemButtonView {
  /**
   * Creates an instance of the menu bar list button view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    this.set({
      withText: true,
      withKeystroke: true,
      tooltip: false,
      role: "menuitem"
    });
    this.extendTemplate({
      attributes: {
        class: ["ck-menu-bar__menu__item__button"]
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/menubar/menubarview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/menubar/menubar.css";
var EVENT_NAME_DELEGATES = ["mouseenter", "arrowleft", "arrowright", "change:isOpen"];
var MenuBarView = class extends View {
  /**
   * Creates an instance of the menu bar view.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super(locale);
    this.menus = [];
    const t = locale.t;
    const bind = this.bindTemplate;
    this.set({
      isOpen: false,
      isFocusBorderEnabled: false
    });
    this._setupIsOpenUpdater();
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-menu-bar",
          bind.if("isFocusBorderEnabled", "ck-menu-bar_focus-border-enabled")
        ],
        "aria-label": t("Editor menu bar"),
        role: "menubar"
      },
      children: this.children
    });
  }
  /**
   * A utility that expands a plain menu bar configuration into a structure of menus (also: sub-menus)
   * and items using a given {@link module:ui/componentfactory~ComponentFactory component factory}.
   *
   * See the {@link module:core/editor/editorconfig~EditorConfig#menuBar menu bar} in the editor
   * configuration reference to learn how to configure the menu bar.
   */
  fillFromConfig(config, componentFactory, extraItems = []) {
    const locale = this.locale;
    const processedConfig = processMenuBarConfig({
      normalizedConfig: config,
      locale,
      componentFactory,
      extraItems
    });
    const topLevelCategoryMenuViews = processedConfig.items.map((menuDefinition) => this._createMenu({
      componentFactory,
      menuDefinition
    }));
    this.children.addMany(topLevelCategoryMenuViews);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    MenuBarBehaviors.toggleMenusAndFocusItemsOnHover(this);
    MenuBarBehaviors.closeMenusWhenTheBarCloses(this);
    MenuBarBehaviors.closeMenuWhenAnotherOnTheSameLevelOpens(this);
    MenuBarBehaviors.focusCycleMenusOnArrows(this);
    MenuBarBehaviors.closeOnClickOutside(this);
    MenuBarBehaviors.enableFocusHighlightOnInteraction(this);
  }
  /**
   * Focuses the menu bar.
   */
  focus() {
    if (this.children.first) {
      this.children.first.focus();
    }
  }
  /**
   * Closes all menus in the bar.
   */
  close() {
    for (const topLevelCategoryMenuView of this.children) {
      topLevelCategoryMenuView.isOpen = false;
    }
  }
  /**
   * Registers a menu view in the menu bar. Every {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instance must be registered
   * in the menu bar to be properly managed.
   */
  registerMenu(menuView, parentMenuView = null) {
    if (parentMenuView) {
      menuView.delegate(...EVENT_NAME_DELEGATES).to(parentMenuView);
      menuView.parentMenuView = parentMenuView;
    } else {
      menuView.delegate(...EVENT_NAME_DELEGATES).to(this, (name) => "menu:" + name);
    }
    menuView._attachBehaviors();
    this.menus.push(menuView);
  }
  /**
   * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} based on the given definition.
   */
  _createMenu({ componentFactory, menuDefinition, parentMenuView }) {
    const locale = this.locale;
    const menuView = new menubarmenuview_default(locale);
    this.registerMenu(menuView, parentMenuView);
    menuView.buttonView.set({
      label: menuDefinition.label
    });
    menuView.once("change:isOpen", () => {
      const listView = new MenuBarMenuListView(locale);
      listView.ariaLabel = menuDefinition.label;
      menuView.panelView.children.add(listView);
      listView.items.addMany(this._createMenuItems({ menuDefinition, parentMenuView: menuView, componentFactory }));
    });
    return menuView;
  }
  /**
   * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} items based on the given definition.
   */
  _createMenuItems({ menuDefinition, parentMenuView, componentFactory }) {
    const locale = this.locale;
    const items = [];
    for (const menuGroupDefinition of menuDefinition.groups) {
      for (const itemDefinition of menuGroupDefinition.items) {
        const menuItemView = new MenuBarMenuListItemView(locale, parentMenuView);
        if (isObject_default(itemDefinition)) {
          menuItemView.children.add(this._createMenu({
            componentFactory,
            menuDefinition: itemDefinition,
            parentMenuView
          }));
        } else {
          const componentView = this._createMenuItemContentFromFactory({
            componentName: itemDefinition,
            componentFactory,
            parentMenuView
          });
          if (!componentView) {
            continue;
          }
          menuItemView.children.add(componentView);
        }
        items.push(menuItemView);
      }
      if (menuGroupDefinition !== menuDefinition.groups[menuDefinition.groups.length - 1]) {
        items.push(new ListSeparatorView(locale));
      }
    }
    return items;
  }
  /**
   * Uses the component factory to create a content of the menu item (a button or a sub-menu).
   */
  _createMenuItemContentFromFactory({ componentName, parentMenuView, componentFactory }) {
    const componentView = componentFactory.create(componentName);
    if (!(componentView instanceof menubarmenuview_default || componentView instanceof MenuBarMenuListItemButtonView || componentView instanceof MenuBarMenuListItemFileDialogButtonView)) {
      logWarning("menu-bar-component-unsupported", {
        componentName,
        componentView
      });
      return null;
    }
    this._registerMenuTree(componentView, parentMenuView);
    componentView.on("execute", () => {
      this.close();
    });
    return componentView;
  }
  /**
   * Checks component and its children recursively and calls {@link #registerMenu}
   * for each item that is {@link module:ui/menubar/menubarmenuview~MenuBarMenuView}.
   *
   * @internal
   */
  _registerMenuTree(componentView, parentMenuView) {
    if (!(componentView instanceof menubarmenuview_default)) {
      componentView.delegate("mouseenter").to(parentMenuView);
      return;
    }
    this.registerMenu(componentView, parentMenuView);
    const menuBarItemsList = componentView.panelView.children.filter((child) => child instanceof MenuBarMenuListView)[0];
    if (!menuBarItemsList) {
      componentView.delegate("mouseenter").to(parentMenuView);
      return;
    }
    const nonSeparatorItems = menuBarItemsList.items.filter((item) => item instanceof ListItemView);
    for (const item of nonSeparatorItems) {
      this._registerMenuTree(item.children.get(0), componentView);
    }
  }
  /**
   * Manages the state of the {@link #isOpen} property of the menu bar. Because the state is a sum of individual
   * top-level menus' states, it's necessary to listen to their changes and update the state accordingly.
   *
   * Additionally, it prevents from unnecessary changes of `isOpen` when one top-level menu opens and another closes
   * (regardless of in which order), maintaining a stable `isOpen === true` in that situation.
   */
  _setupIsOpenUpdater() {
    let closeTimeout;
    this.on("menu:change:isOpen", (evt, name, isOpen) => {
      clearTimeout(closeTimeout);
      if (isOpen) {
        this.isOpen = true;
      } else {
        closeTimeout = setTimeout(() => {
          this.isOpen = Array.from(this.children).some((menuView) => menuView.isOpen);
        }, 0);
      }
    });
  }
};

export {
  Command,
  enablePlaceholder,
  BubblingEventInfo,
  Observer,
  DomEventData,
  DomEventObserver,
  FocusObserver,
  DataTransfer,
  TreeWalker2 as TreeWalker,
  Range2 as Range,
  LiveRange,
  NoOperation,
  transformSets,
  MouseObserver,
  editor_default,
  attachToForm,
  ElementApiMixin,
  icons,
  dialogview_default,
  MenuBarMenuListItemButtonView,
  AccessibilityHelp,
  normalizeToolbarConfig,
  ToolbarView,
  EditorUI,
  BoxedEditorUIView,
  InlineEditableUIView,
  StickyPanelView,
  MenuBarView
};
/*! Bundled license information:

@ckeditor/ckeditor5-engine/src/view/placeholder.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/typecheckable.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/node.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/text.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/textproxy.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/matcher.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/stylesmap.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/element.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/containerelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/editableelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/rooteditableelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/treewalker.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/position.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/range.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/selection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/documentselection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/bubblingeventinfo.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/bubblingemittermixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-engine/src/view/document.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/attributeelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/emptyelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/uielement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/rawelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/documentfragment.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/downcastwriter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/filler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/renderer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/domconverter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/observer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/domeventdata.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/domeventobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/keyobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/fakeselectionobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/mutationobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/focusobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/selectionobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/compositionobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/datatransfer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/inputobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/arrowkeysobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/tabobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/view.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-engine/src/model/typecheckable.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/node.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/nodelist.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/text.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/textproxy.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/element.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/treewalker.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/position.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/range.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/mapper.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/selection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/liverange.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/documentselection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/conversionhelpers.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve *)

@ckeditor/ckeditor5-engine/src/model/utils/autoparagraphing.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/controller/editingcontroller.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/schema.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/dataprocessor/basichtmlwriter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/controller/datacontroller.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/conversion/conversion.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/dataprocessor/xmldataprocessor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/operation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/moveoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/insertoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/splitoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/mergeoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/markeroperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/attributeoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/nooperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/renameoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/rootattributeoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/rootoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/operationfactory.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/transform.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/liveposition.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/batch.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/differ.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/history.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/rootelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/document.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/markercollection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/operation/detachoperation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/documentfragment.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/writer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/utils/getselectedcontent.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)
  (* istanbul ignore if -- @preserve *)

@ckeditor/ckeditor5-engine/src/model/utils/insertobject.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/utils/modifyselection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/model/model.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-engine/src/view/observer/clickobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/upcastwriter.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/styles/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/styles/background.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/styles/border.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/styles/margin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/view/styles/padding.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/dev-utils/view.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/dev-utils/model.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-engine/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-watchdog/src/watchdog.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-watchdog/src/utils/getsubnodes.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-watchdog/src/utils/areconnectedthroughproperties.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-watchdog/src/editorwatchdog.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-watchdog/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-watchdog/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/plugincollection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/context.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/commandcollection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/editingkeystrokehandler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/accessibility.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/editor/utils/editorusagedata.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/editor/editor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-core/src/editor/utils/attachtoform.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/command.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/multicommand.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/contextplugin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/editor/utils/dataapimixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/editor/utils/securesourceelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/pendingactions.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-core/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/formheader/formheaderview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/focuscycler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/draggableviewmixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dialog/dialogactionsview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dialog/dialogcontentview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dialog/dialogview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dialog/dialog.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/listitembuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/menubarmenulistitembuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/label/labelview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/accessibilityhelp/accessibilityhelpcontentview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/accessibilityhelp/accessibilityhelp.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/injectcsstransitiondisabler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/csstransitiondisablermixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/submithandler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/addkeyboardhandlingforgrid.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/bodycollection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/switchbuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/filedialogbuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/collapsible/collapsibleview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/colortileview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorgrid/colorgridview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorpicker/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/labeledfield/labeledfieldview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/input/inputbase.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/input/inputview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/inputtext/inputtextview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/inputnumber/inputnumberview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/textarea/textareaview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/dropdownpanelview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/button/dropdownbuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenulistitembuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenubuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listitemview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listseparatorview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listitemgroupview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/list/listview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenulistview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenulistitemview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenubehaviors.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenunestedmenupanelview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenunestedmenuview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/menu/dropdownmenurootlistview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarseparatorview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarlinebreakview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/bindings/preventdefault.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/normalizetoolbarconfig.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/button/splitbuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/dropdown/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/labeledfield/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorpicker/colorpickerview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/documentcolorcollection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorgridsfragmentview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorpickerfragmentview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/colorselector/colorselectorview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/componentfactory.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/tooltipmanager.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/badge/badge.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/poweredby.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/evaluationbadge.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/arialiveannouncer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/menubarmenulistitemview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/utils.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/editorui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editorui/boxed/boxededitoruiview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editableui/editableuiview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/editableui/inline/inlineeditableuiview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/iframe/iframeview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/filtergroupanditemnames.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/notification/notification.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/model.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/text/searchtextqueryview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/searchinfoview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/searchresultsview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/search/text/searchtextview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/autocomplete/autocompleteview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/highlightedtext/highlightedtextview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/highlightedtext/buttonlabelwithhighlightview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/highlightedtext/labelwithhighlightview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/spinner/spinnerview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/balloon/balloontoolbar.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/block/blockbuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/toolbar/block/blocktoolbar.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/menubarmenubuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/menubarmenupanelview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/menubarmenuview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/menubarmenulistview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/menubarmenulistitemfiledialogbuttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/menubar/menubarview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/ui.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

ckeditor5/src/core.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-6E3JQ6U6.js.map
