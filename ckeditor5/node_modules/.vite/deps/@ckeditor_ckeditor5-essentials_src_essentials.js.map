{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js", "../../@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js", "../../@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js", "../../@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js", "../../@ckeditor/ckeditor5-clipboard/src/clipboardmarkersutils.js", "../../@ckeditor/ckeditor5-clipboard/src/clipboardpipeline.js", "../../@ckeditor/ckeditor5-typing/src/utils/changebuffer.js", "../../@ckeditor/ckeditor5-typing/src/inserttextcommand.js", "../../@ckeditor/ckeditor5-typing/src/inserttextobserver.js", "../../@ckeditor/ckeditor5-typing/src/input.js", "../../@ckeditor/ckeditor5-typing/src/deletecommand.js", "../../@ckeditor/ckeditor5-typing/src/deleteobserver.js", "../../@ckeditor/ckeditor5-typing/src/delete.js", "../../@ckeditor/ckeditor5-typing/src/typing.js", "../../@ckeditor/ckeditor5-typing/src/utils/getlasttextline.js", "../../@ckeditor/ckeditor5-typing/src/textwatcher.js", "../../@ckeditor/ckeditor5-typing/src/texttransformation.js", "../../@ckeditor/ckeditor5-enter/src/utils.js", "../../@ckeditor/ckeditor5-enter/src/entercommand.js", "../../@ckeditor/ckeditor5-enter/src/enterobserver.js", "../../@ckeditor/ckeditor5-enter/src/enter.js", "../../@ckeditor/ckeditor5-enter/src/shiftentercommand.js", "../../@ckeditor/ckeditor5-enter/src/shiftenter.js", "../../@ckeditor/ckeditor5-widget/src/highlightstack.js", "../../@ckeditor/ckeditor5-widget/src/utils.js", "../../@ckeditor/ckeditor5-widget/src/widgettypearound/utils.js", "../../@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js", "../../@ckeditor/ckeditor5-widget/src/verticalnavigation.js", "../../@ckeditor/ckeditor5-widget/src/widget.js", "../../@ckeditor/ckeditor5-widget/src/widgetresize/resizerstate.js", "../../@ckeditor/ckeditor5-widget/src/widgetresize/sizeview.js", "../../@ckeditor/ckeditor5-widget/src/widgetresize/resizer.js", "../../@ckeditor/ckeditor5-widget/src/widgetresize.js", "../../@ckeditor/ckeditor5-clipboard/src/lineview.js", "../../@ckeditor/ckeditor5-clipboard/src/dragdroptarget.js", "../../@ckeditor/ckeditor5-clipboard/src/dragdropblocktoolbar.js", "../../@ckeditor/ckeditor5-clipboard/src/dragdrop.js", "../../@ckeditor/ckeditor5-clipboard/src/pasteplaintext.js", "../../@ckeditor/ckeditor5-clipboard/src/clipboard.js", "../../@ckeditor/ckeditor5-select-all/src/selectallcommand.js", "../../@ckeditor/ckeditor5-select-all/src/selectallediting.js", "../../@ckeditor/ckeditor5-select-all/src/selectallui.js", "../../@ckeditor/ckeditor5-select-all/src/selectall.js", "../../@ckeditor/ckeditor5-undo/src/basecommand.js", "../../@ckeditor/ckeditor5-undo/src/undocommand.js", "../../@ckeditor/ckeditor5-undo/src/redocommand.js", "../../@ckeditor/ckeditor5-undo/src/undoediting.js", "../../@ckeditor/ckeditor5-undo/src/undoui.js", "../../@ckeditor/ckeditor5-undo/src/undo.js", "../../@ckeditor/ckeditor5-essentials/src/essentials.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboardobserver\n */\nimport { EventInfo, getRangeFromMouseEvent } from '@ckeditor/ckeditor5-utils';\nimport { DataTransfer, DomEventObserver } from '@ckeditor/ckeditor5-engine';\n/**\n * Clipboard events observer.\n *\n * Fires the following events:\n *\n * * {@link module:engine/view/document~Document#event:clipboardInput},\n * * {@link module:engine/view/document~Document#event:paste},\n * * {@link module:engine/view/document~Document#event:copy},\n * * {@link module:engine/view/document~Document#event:cut},\n * * {@link module:engine/view/document~Document#event:drop},\n * * {@link module:engine/view/document~Document#event:dragover},\n * * {@link module:engine/view/document~Document#event:dragging},\n * * {@link module:engine/view/document~Document#event:dragstart},\n * * {@link module:engine/view/document~Document#event:dragend},\n * * {@link module:engine/view/document~Document#event:dragenter},\n * * {@link module:engine/view/document~Document#event:dragleave}.\n *\n * **Note**: This observer is not available by default (ckeditor5-engine does not add it on its own).\n * To make it available, it needs to be added to {@link module:engine/view/document~Document} by using\n * the {@link module:engine/view/view~View#addObserver `View#addObserver()`} method. Alternatively, you can load the\n * {@link module:clipboard/clipboard~Clipboard} plugin which adds this observer automatically (because it uses it).\n */\nexport default class ClipboardObserver extends DomEventObserver {\n    constructor(view) {\n        super(view);\n        this.domEventType = [\n            'paste', 'copy', 'cut', 'drop', 'dragover', 'dragstart', 'dragend', 'dragenter', 'dragleave'\n        ];\n        const viewDocument = this.document;\n        this.listenTo(viewDocument, 'paste', handleInput('clipboardInput'), { priority: 'low' });\n        this.listenTo(viewDocument, 'drop', handleInput('clipboardInput'), { priority: 'low' });\n        this.listenTo(viewDocument, 'dragover', handleInput('dragging'), { priority: 'low' });\n        function handleInput(type) {\n            return (evt, data) => {\n                data.preventDefault();\n                const targetRanges = data.dropRange ? [data.dropRange] : null;\n                const eventInfo = new EventInfo(viewDocument, type);\n                viewDocument.fire(eventInfo, {\n                    dataTransfer: data.dataTransfer,\n                    method: evt.name,\n                    targetRanges,\n                    target: data.target,\n                    domEvent: data.domEvent\n                });\n                // If CKEditor handled the input, do not bubble the original event any further.\n                // This helps external integrations recognize that fact and act accordingly.\n                // https://github.com/ckeditor/ckeditor5-upload/issues/92\n                if (eventInfo.stop.called) {\n                    data.stopPropagation();\n                }\n            };\n        }\n    }\n    onDomEvent(domEvent) {\n        const nativeDataTransfer = 'clipboardData' in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;\n        const cacheFiles = domEvent.type == 'drop' || domEvent.type == 'paste';\n        const evtData = {\n            dataTransfer: new DataTransfer(nativeDataTransfer, { cacheFiles })\n        };\n        if (domEvent.type == 'drop' || domEvent.type == 'dragover') {\n            const domRange = getRangeFromMouseEvent(domEvent);\n            evtData.dropRange = domRange && this.view.domConverter.domRangeToView(domRange);\n        }\n        this.fire(domEvent.type, domEvent, evtData);\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/utils/plaintexttohtml\n */\n/**\n * Converts plain text to its HTML-ized version.\n *\n * @param text The plain text to convert.\n * @returns HTML generated from the plain text.\n */\nexport default function plainTextToHtml(text) {\n    text = text\n        // Encode &.\n        .replace(/&/g, '&amp;')\n        // Encode <>.\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        // Creates a paragraph for each double line break.\n        .replace(/\\r?\\n\\r?\\n/g, '</p><p>')\n        // Creates a line break for each single line break.\n        .replace(/\\r?\\n/g, '<br>')\n        // Replace tabs with four spaces.\n        .replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')\n        // Preserve trailing spaces (only the first and last one – the rest is handled below).\n        .replace(/^\\s/, '&nbsp;')\n        .replace(/\\s$/, '&nbsp;')\n        // Preserve other subsequent spaces now.\n        .replace(/\\s\\s/g, ' &nbsp;');\n    if (text.includes('</p><p>') || text.includes('<br>')) {\n        // If we created paragraphs above, add the trailing ones.\n        text = `<p>${text}</p>`;\n    }\n    // TODO:\n    // * What about '\\nfoo' vs ' foo'?\n    return text;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/utils/normalizeclipboarddata\n */\n/**\n * Removes some popular browser quirks out of the clipboard data (HTML).\n * Removes all HTML comments. These are considered an internal thing and it makes little sense if they leak into the editor data.\n *\n * @param data The HTML data to normalize.\n * @returns Normalized HTML.\n */\nexport default function normalizeClipboardData(data) {\n    return data\n        .replace(/<span(?: class=\"Apple-converted-space\"|)>(\\s+)<\\/span>/g, (fullMatch, spaces) => {\n        // Handle the most popular and problematic case when even a single space becomes an nbsp;.\n        // Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.\n        if (spaces.length == 1) {\n            return ' ';\n        }\n        return spaces;\n    })\n        // Remove all HTML comments.\n        .replace(/<!--[\\s\\S]*?-->/g, '');\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n// Elements which should not have empty-line padding.\n// Most `view.ContainerElement` want to be separate by new-line, but some are creating one structure\n// together (like `<li>`) so it is better to separate them by only one \"\\n\".\nconst smallPaddingElements = ['figcaption', 'li'];\nconst listElements = ['ol', 'ul'];\n/**\n * Converts {@link module:engine/view/item~Item view item} and all of its children to plain text.\n *\n * @param viewItem View item to convert.\n * @returns Plain text representation of `viewItem`.\n */\nexport default function viewToPlainText(viewItem) {\n    if (viewItem.is('$text') || viewItem.is('$textProxy')) {\n        return viewItem.data;\n    }\n    if (viewItem.is('element', 'img') && viewItem.hasAttribute('alt')) {\n        return viewItem.getAttribute('alt');\n    }\n    if (viewItem.is('element', 'br')) {\n        return '\\n'; // Convert soft breaks to single line break (#8045).\n    }\n    /**\n     * Item is a document fragment, attribute element or container element. It doesn't\n     * have it's own text value, so we need to convert its children elements.\n     */\n    let text = '';\n    let prev = null;\n    for (const child of viewItem.getChildren()) {\n        text += newLinePadding(child, prev) + viewToPlainText(child);\n        prev = child;\n    }\n    return text;\n}\n/**\n * Returns new line padding to prefix the given elements with.\n */\nfunction newLinePadding(element, previous) {\n    if (!previous) {\n        // Don't add padding to first elements in a level.\n        return '';\n    }\n    if (element.is('element', 'li') && !element.isEmpty && element.getChild(0).is('containerElement')) {\n        // Separate document list items with empty lines.\n        return '\\n\\n';\n    }\n    if (listElements.includes(element.name) && listElements.includes(previous.name)) {\n        /**\n         * Because `<ul>` and `<ol>` are AttributeElements, two consecutive lists will not have any padding between\n         * them (see the `if` statement below). To fix this, we need to make an exception for this case.\n         */\n        return '\\n\\n';\n    }\n    if (!element.is('containerElement') && !previous.is('containerElement')) {\n        // Don't add padding between non-container elements.\n        return '';\n    }\n    if (smallPaddingElements.includes(element.name) || smallPaddingElements.includes(previous.name)) {\n        // Add small padding between selected container elements.\n        return '\\n';\n    }\n    // Do not add padding around the elements that won't be rendered.\n    if (element.is('element') && element.getCustomProperty('dataPipeline:transparentRendering') ||\n        previous.is('element') && previous.getCustomProperty('dataPipeline:transparentRendering')) {\n        return '';\n    }\n    // Add empty lines between container elements.\n    return '\\n\\n';\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboardmarkersutils\n */\nimport { mapValues } from 'lodash-es';\nimport { uid } from '@ckeditor/ckeditor5-utils';\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { Range } from '@ckeditor/ckeditor5-engine';\n/**\n * Part of the clipboard logic. Responsible for collecting markers from selected fragments\n * and restoring them with proper positions in pasted elements.\n *\n * @internal\n */\nexport default class ClipboardMarkersUtils extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * Map of marker names that can be copied.\n         *\n         * @internal\n         */\n        this._markersToCopy = new Map();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ClipboardMarkersUtils';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * Registers marker name as copyable in clipboard pipeline.\n     *\n     * @param markerName Name of marker that can be copied.\n     * @param config Configuration that describes what can be performed on specified marker.\n     * @internal\n     */\n    _registerMarkerToCopy(markerName, config) {\n        this._markersToCopy.set(markerName, config);\n    }\n    /**\n     * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.\n     *\n     * \t1. Picks all markers in provided selection.\n     * \t2. Inserts fake markers to document.\n     * \t3. Gets copied selection fragment from document.\n     * \t4. Removes fake elements from fragment and document.\n     * \t5. Inserts markers in the place of removed fake markers.\n     *\n     * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.\n     * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.\n     *\n     * @param action Type of clipboard action.\n     * @param writer An instance of the model writer.\n     * @param selection Selection to be checked.\n     * @param getCopiedFragment\tCallback that performs copy of selection and returns it as fragment.\n     * @internal\n     */\n    _copySelectedFragmentWithMarkers(action, selection, getCopiedFragment = writer => writer.model.getSelectedContent(writer.model.document.selection)) {\n        return this.editor.model.change(writer => {\n            const oldSelection = writer.model.document.selection;\n            // In some scenarios, such like in drag & drop, passed `selection` parameter is not actually\n            // the same `selection` as the `writer.model.document.selection` which means that `_insertFakeMarkersToSelection`\n            // is not affecting passed `selection` `start` and `end` positions but rather modifies `writer.model.document.selection`.\n            //\n            // It is critical due to fact that when we have selection that starts [ 0, 0 ] and ends at [ 1, 0 ]\n            // and after inserting fake marker it will point to such marker instead of new widget position at start: [ 1, 0 ] end: [2, 0 ].\n            // `writer.insert` modifies only original `writer.model.document.selection`.\n            writer.setSelection(selection);\n            const sourceSelectionInsertedMarkers = this._insertFakeMarkersIntoSelection(writer, writer.model.document.selection, action);\n            const fragment = getCopiedFragment(writer);\n            const fakeMarkersRangesInsideRange = this._removeFakeMarkersInsideElement(writer, fragment);\n            // <fake-marker> [Foo] Bar</fake-marker>\n            //      ^                    ^\n            // In `_insertFakeMarkersIntoSelection` call we inserted fake marker just before first element.\n            // The problem is that the first element can be start position of selection so insertion fake-marker\n            // before such element shifts selection (so selection that was at [0, 0] now is at [0, 1]).\n            // It means that inserted fake-marker is no longer present inside such selection and is orphaned.\n            // This function checks special case of such problem. Markers that are orphaned at the start position\n            // and end position in the same time. Basically it means that they overlaps whole element.\n            for (const [markerName, elements] of Object.entries(sourceSelectionInsertedMarkers)) {\n                fakeMarkersRangesInsideRange[markerName] || (fakeMarkersRangesInsideRange[markerName] = writer.createRangeIn(fragment));\n                for (const element of elements) {\n                    writer.remove(element);\n                }\n            }\n            fragment.markers.clear();\n            for (const [markerName, range] of Object.entries(fakeMarkersRangesInsideRange)) {\n                fragment.markers.set(markerName, range);\n            }\n            // Revert back selection to previous one.\n            writer.setSelection(oldSelection);\n            return fragment;\n        });\n    }\n    /**\n     * Performs paste of markers on already pasted element.\n     *\n     * \t1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).\n     * \t2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.\n     * \t3. Removes all fake markers present in transformed element.\n     * \t4. Inserts new markers with removed fake markers ranges into pasted fragment.\n     *\n     * There are multiple edge cases that have to be considered before calling this function:\n     *\n     * \t* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.\n     * \t* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.\n     * \t* If `duplicateOnPaste` is `true` in marker config then associated marker ID is regenerated before pasting.\n     *\n     * @param action Type of clipboard action.\n     * @param markers Object that maps marker name to corresponding range.\n     * @param getPastedDocumentElement Getter used to get target markers element.\n     * @internal\n     */\n    _pasteMarkersIntoTransformedElement(markers, getPastedDocumentElement) {\n        const pasteMarkers = this._getPasteMarkersFromRangeMap(markers);\n        return this.editor.model.change(writer => {\n            // Inserts fake markers into source fragment / element that is later transformed inside `getPastedDocumentElement`.\n            const sourceFragmentFakeMarkers = this._insertFakeMarkersElements(writer, pasteMarkers);\n            // Modifies document fragment (for example, cloning table cells) and then inserts it into the document.\n            const transformedElement = getPastedDocumentElement(writer);\n            // Removes markers in pasted and transformed fragment in root document.\n            const removedFakeMarkers = this._removeFakeMarkersInsideElement(writer, transformedElement);\n            // Cleans up fake markers inserted into source fragment (that one before transformation which is not pasted).\n            for (const element of Object.values(sourceFragmentFakeMarkers).flat()) {\n                writer.remove(element);\n            }\n            // Inserts to root document fake markers.\n            for (const [markerName, range] of Object.entries(removedFakeMarkers)) {\n                if (!writer.model.markers.has(markerName)) {\n                    writer.addMarker(markerName, {\n                        usingOperation: true,\n                        affectsData: true,\n                        range\n                    });\n                }\n            }\n            return transformedElement;\n        });\n    }\n    /**\n     * Pastes document fragment with markers to document.\n     * If `duplicateOnPaste` is `true` in marker config then associated markers IDs\n     * are regenerated before pasting to avoid markers duplications in content.\n     *\n     * @param fragment Document fragment that should contain already processed by pipeline markers.\n     * @internal\n     */\n    _pasteFragmentWithMarkers(fragment) {\n        const pasteMarkers = this._getPasteMarkersFromRangeMap(fragment.markers);\n        fragment.markers.clear();\n        for (const copyableMarker of pasteMarkers) {\n            fragment.markers.set(copyableMarker.name, copyableMarker.range);\n        }\n        return this.editor.model.insertContent(fragment);\n    }\n    /**\n     * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass\n     * restrictions on markers that we want to copy.\n     *\n     * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy\n     * content, markers with the specified name will be copied to the clipboard as well.\n     *\n     * @param markerName Which markers should be copied.\n     * @param executor Callback executed.\n     * @param config Optional configuration flags used to copy (such like partial copy flag).\n     * @internal\n     */\n    _forceMarkersCopy(markerName, executor, config = {\n        allowedActions: 'all',\n        copyPartiallySelected: true,\n        duplicateOnPaste: true\n    }) {\n        const before = this._markersToCopy.get(markerName);\n        this._markersToCopy.set(markerName, config);\n        executor();\n        if (before) {\n            this._markersToCopy.set(markerName, before);\n        }\n        else {\n            this._markersToCopy.delete(markerName);\n        }\n    }\n    /**\n     * Checks if marker can be copied.\n     *\n     * @param markerName Name of checked marker.\n     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.\n     * @internal\n     */\n    _isMarkerCopyable(markerName, action) {\n        const config = this._getMarkerClipboardConfig(markerName);\n        if (!config) {\n            return false;\n        }\n        // If there is no action provided then only presence of marker is checked.\n        if (!action) {\n            return true;\n        }\n        const { allowedActions } = config;\n        return allowedActions === 'all' || allowedActions.includes(action);\n    }\n    /**\n     * Checks if marker has any clipboard copy behavior configuration.\n     *\n     * @param markerName Name of checked marker.\n     */\n    _hasMarkerConfiguration(markerName) {\n        return !!this._getMarkerClipboardConfig(markerName);\n    }\n    /**\n     * Returns marker's configuration flags passed during registration.\n     *\n     * @param markerName Name of marker that should be returned.\n     * @internal\n     */\n    _getMarkerClipboardConfig(markerName) {\n        const [markerNamePrefix] = markerName.split(':');\n        return this._markersToCopy.get(markerNamePrefix) || null;\n    }\n    /**\n     * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements\n     * at positions where document markers start or end. This way `$marker` elements can be easily copied together with\n     * the rest of the content of the selection.\n     *\n     * @param writer An instance of the model writer.\n     * @param selection Selection to be checked.\n     * @param action Type of clipboard action.\n     */\n    _insertFakeMarkersIntoSelection(writer, selection, action) {\n        const copyableMarkers = this._getCopyableMarkersFromSelection(writer, selection, action);\n        return this._insertFakeMarkersElements(writer, copyableMarkers);\n    }\n    /**\n     * Returns array of markers that can be copied in specified selection.\n     *\n     * If marker cannot be copied partially (according to `copyPartiallySelected` configuration flag) and\n     * is not present entirely in any selection range then it will be skipped.\n     *\n     * @param writer An instance of the model writer.\n     * @param selection  Selection which will be checked.\n     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.\n     */\n    _getCopyableMarkersFromSelection(writer, selection, action) {\n        const selectionRanges = Array.from(selection.getRanges());\n        // Picks all markers in provided ranges. Ensures that there are no duplications if\n        // there are multiple ranges that intersects with the same marker.\n        const markersInRanges = new Set(selectionRanges.flatMap(selectionRange => Array.from(writer.model.markers.getMarkersIntersectingRange(selectionRange))));\n        const isSelectionMarkerCopyable = (marker) => {\n            // Check if marker exists in configuration and provided action can be performed on it.\n            const isCopyable = this._isMarkerCopyable(marker.name, action);\n            if (!isCopyable) {\n                return false;\n            }\n            // Checks if configuration disallows to copy marker only if part of its content is selected.\n            //\n            // Example:\n            // \t<marker-a> Hello [ World ] </marker-a>\n            //\t\t\t\t\t\t^ selection\n            //\n            // In this scenario `marker-a` won't be copied because selection doesn't overlap its content entirely.\n            const { copyPartiallySelected } = this._getMarkerClipboardConfig(marker.name);\n            if (!copyPartiallySelected) {\n                const markerRange = marker.getRange();\n                return selectionRanges.some(selectionRange => selectionRange.containsRange(markerRange, true));\n            }\n            return true;\n        };\n        return Array\n            .from(markersInRanges)\n            .filter(isSelectionMarkerCopyable)\n            .map((copyableMarker) => {\n            // During `dragstart` event original marker is still present in tree.\n            // It is removed after the clipboard drop event, so none of the copied markers are inserted at the end.\n            // It happens because there already markers with specified `marker.name` when clipboard is trying to insert data\n            // and it aborts inserting.\n            const name = action === 'dragstart' ? this._getUniqueMarkerName(copyableMarker.name) : copyableMarker.name;\n            return {\n                name,\n                range: copyableMarker.getRange()\n            };\n        });\n    }\n    /**\n     * Picks all markers from markers map that can be pasted.\n     * If `duplicateOnPaste` is `true`, it regenerates their IDs to ensure uniqueness.\n     * If marker is not registered, it will be kept in the array anyway.\n     *\n     * @param markers Object that maps marker name to corresponding range.\n     * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.\n     */\n    _getPasteMarkersFromRangeMap(markers, action = null) {\n        const { model } = this.editor;\n        const entries = markers instanceof Map ? Array.from(markers.entries()) : Object.entries(markers);\n        return entries.flatMap(([markerName, range]) => {\n            if (!this._hasMarkerConfiguration(markerName)) {\n                return [\n                    {\n                        name: markerName,\n                        range\n                    }\n                ];\n            }\n            if (this._isMarkerCopyable(markerName, action)) {\n                const copyMarkerConfig = this._getMarkerClipboardConfig(markerName);\n                const isInGraveyard = model.markers.has(markerName) &&\n                    model.markers.get(markerName).getRange().root.rootName === '$graveyard';\n                if (copyMarkerConfig.duplicateOnPaste || isInGraveyard) {\n                    markerName = this._getUniqueMarkerName(markerName);\n                }\n                return [\n                    {\n                        name: markerName,\n                        range\n                    }\n                ];\n            }\n            return [];\n        });\n    }\n    /**\n     * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.\n     * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during\n     * steps between copy and paste.\n     *\n     * @param writer An instance of the model writer.\n     * @param markers Array of markers that will be inserted.\n     */\n    _insertFakeMarkersElements(writer, markers) {\n        const mappedMarkers = {};\n        const sortedMarkers = markers\n            .flatMap(marker => {\n            const { start, end } = marker.range;\n            return [\n                { position: start, marker, type: 'start' },\n                { position: end, marker, type: 'end' }\n            ];\n        })\n            // Markers position is sorted backwards to ensure that the insertion of fake markers will not change\n            // the position of the next markers.\n            .sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);\n        for (const { position, marker, type } of sortedMarkers) {\n            const fakeMarker = writer.createElement('$marker', {\n                'data-name': marker.name,\n                'data-type': type\n            });\n            if (!mappedMarkers[marker.name]) {\n                mappedMarkers[marker.name] = [];\n            }\n            mappedMarkers[marker.name].push(fakeMarker);\n            writer.insert(fakeMarker, position);\n        }\n        return mappedMarkers;\n    }\n    /**\n     * Removes all `$marker` elements from the given document fragment.\n     *\n     * Returns an object where keys are marker names, and values are ranges corresponding to positions\n     * where `$marker` elements were inserted.\n     *\n     * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically\n     * (to the end or start of the document fragment, respectively).\n     *\n     * @param writer An instance of the model writer.\n     * @param rootElement The element to be checked.\n     */\n    _removeFakeMarkersInsideElement(writer, rootElement) {\n        const fakeMarkersElements = this._getAllFakeMarkersFromElement(writer, rootElement);\n        const fakeMarkersRanges = fakeMarkersElements.reduce((acc, fakeMarker) => {\n            const position = fakeMarker.markerElement && writer.createPositionBefore(fakeMarker.markerElement);\n            let prevFakeMarker = acc[fakeMarker.name];\n            // Handle scenario when tables clone cells with the same fake node. Example:\n            //\n            // <cell><fake-marker-a></cell> <cell><fake-marker-a></cell> <cell><fake-marker-a></cell>\n            //                                          ^ cloned                    ^ cloned\n            //\n            // The easiest way to bypass this issue is to rename already existing in map nodes and\n            // set them new unique name.\n            let skipAssign = false;\n            if (prevFakeMarker && prevFakeMarker.start && prevFakeMarker.end) {\n                const config = this._getMarkerClipboardConfig(fakeMarker.name);\n                if (config.duplicateOnPaste) {\n                    acc[this._getUniqueMarkerName(fakeMarker.name)] = acc[fakeMarker.name];\n                }\n                else {\n                    skipAssign = true;\n                }\n                prevFakeMarker = null;\n            }\n            if (!skipAssign) {\n                acc[fakeMarker.name] = {\n                    ...prevFakeMarker,\n                    [fakeMarker.type]: position\n                };\n            }\n            if (fakeMarker.markerElement) {\n                writer.remove(fakeMarker.markerElement);\n            }\n            return acc;\n        }, {});\n        // We cannot construct ranges directly in previous reduce because element ranges can overlap.\n        // In other words lets assume we have such scenario:\n        // <fake-marker-start /> <paragraph /> <fake-marker-2-start /> <fake-marker-end /> <fake-marker-2-end />\n        //\n        // We have to remove `fake-marker-start` firstly and then remove `fake-marker-2-start`.\n        // Removal of `fake-marker-2-start` affects `fake-marker-end` position so we cannot create\n        // connection between `fake-marker-start` and `fake-marker-end` without iterating whole set firstly.\n        return mapValues(fakeMarkersRanges, range => new Range(range.start || writer.createPositionFromPath(rootElement, [0]), range.end || writer.createPositionAt(rootElement, 'end')));\n    }\n    /**\n     * Returns array that contains list of fake markers with corresponding `$marker` elements.\n     *\n     * For each marker, there can be two `$marker` elements or only one (if the document fragment contained\n     * only the beginning or only the end of a marker).\n     *\n     * @param writer An instance of the model writer.\n     * @param rootElement The element to be checked.\n     */\n    _getAllFakeMarkersFromElement(writer, rootElement) {\n        const foundFakeMarkers = Array\n            .from(writer.createRangeIn(rootElement))\n            .flatMap(({ item }) => {\n            if (!item.is('element', '$marker')) {\n                return [];\n            }\n            const name = item.getAttribute('data-name');\n            const type = item.getAttribute('data-type');\n            return [\n                {\n                    markerElement: item,\n                    name,\n                    type\n                }\n            ];\n        });\n        const prependFakeMarkers = [];\n        const appendFakeMarkers = [];\n        for (const fakeMarker of foundFakeMarkers) {\n            if (fakeMarker.type === 'end') {\n                // <fake-marker> [ phrase</fake-marker> phrase ]\n                //   ^\n                // Handle case when marker is just before start of selection.\n                // Only end marker is inside selection.\n                const hasMatchingStartMarker = foundFakeMarkers.some(otherFakeMarker => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === 'start');\n                if (!hasMatchingStartMarker) {\n                    prependFakeMarkers.push({\n                        markerElement: null,\n                        name: fakeMarker.name,\n                        type: 'start'\n                    });\n                }\n            }\n            if (fakeMarker.type === 'start') {\n                // [<fake-marker>phrase]</fake-marker>\n                //                           ^\n                // Handle case when fake marker is after selection.\n                // Only start marker is inside selection.\n                const hasMatchingEndMarker = foundFakeMarkers.some(otherFakeMarker => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === 'end');\n                if (!hasMatchingEndMarker) {\n                    appendFakeMarkers.unshift({\n                        markerElement: null,\n                        name: fakeMarker.name,\n                        type: 'end'\n                    });\n                }\n            }\n        }\n        return [\n            ...prependFakeMarkers,\n            ...foundFakeMarkers,\n            ...appendFakeMarkers\n        ];\n    }\n    /**\n     * When copy of markers occurs we have to make sure that pasted markers have different names\n     * than source markers. This functions helps with assigning unique part to marker name to\n     * prevent duplicated markers error.\n     *\n     * @param name Name of marker\n     */\n    _getUniqueMarkerName(name) {\n        const parts = name.split(':');\n        const newId = uid().substring(1, 6);\n        // It looks like the marker already is UID marker so in this scenario just swap\n        // last part of marker name and assign new UID.\n        //\n        // example: comment:{ threadId }:{ id } => comment:{ threadId }:{ newId }\n        if (parts.length === 3) {\n            return `${parts.slice(0, 2).join(':')}:${newId}`;\n        }\n        // Assign new segment to marker name with id.\n        //\n        // example: comment => comment:{ newId }\n        return `${parts.join(':')}:${newId}`;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboardpipeline\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { EventInfo } from '@ckeditor/ckeditor5-utils';\nimport ClipboardObserver from './clipboardobserver.js';\nimport plainTextToHtml from './utils/plaintexttohtml.js';\nimport normalizeClipboardHtml from './utils/normalizeclipboarddata.js';\nimport viewToPlainText from './utils/viewtoplaintext.js';\nimport ClipboardMarkersUtils from './clipboardmarkersutils.js';\n// Input pipeline events overview:\n//\n//              ┌──────────────────────┐          ┌──────────────────────┐\n//              │     view.Document    │          │     view.Document    │\n//              │         paste        │          │         drop         │\n//              └───────────┬──────────┘          └───────────┬──────────┘\n//                          │                                 │\n//                          └────────────────┌────────────────┘\n//                                           │\n//                                 ┌─────────V────────┐\n//                                 │   view.Document  │   Retrieves text/html or text/plain from data.dataTransfer\n//                                 │  clipboardInput  │   and processes it to view.DocumentFragment.\n//                                 └─────────┬────────┘\n//                                           │\n//                               ┌───────────V───────────┐\n//                               │   ClipboardPipeline   │   Converts view.DocumentFragment to model.DocumentFragment.\n//                               │  inputTransformation  │\n//                               └───────────┬───────────┘\n//                                           │\n//                                ┌──────────V──────────┐\n//                                │  ClipboardPipeline  │   Calls model.insertContent().\n//                                │   contentInsertion  │\n//                                └─────────────────────┘\n//\n//\n// Output pipeline events overview:\n//\n//              ┌──────────────────────┐          ┌──────────────────────┐\n//              │     view.Document    │          │     view.Document    │   Retrieves the selected model.DocumentFragment\n//              │         copy         │          │          cut         │   and fires the `outputTransformation` event.\n//              └───────────┬──────────┘          └───────────┬──────────┘\n//                          │                                 │\n//                          └────────────────┌────────────────┘\n//                                           │\n//                               ┌───────────V───────────┐\n//                               │   ClipboardPipeline   │   Processes model.DocumentFragment and converts it to\n//                               │  outputTransformation │   view.DocumentFragment.\n//                               └───────────┬───────────┘\n//                                           │\n//                                 ┌─────────V────────┐\n//                                 │   view.Document  │   Processes view.DocumentFragment to text/html and text/plain\n//                                 │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                                 └──────────────────┘\n//\n/**\n * The clipboard pipeline feature. It is responsible for intercepting the `paste` and `drop` events and\n * passing the pasted content through a series of events in order to insert it into the editor's content.\n * It also handles the `cut` and `copy` events to fill the native clipboard with the serialized editor's data.\n *\n * # Input pipeline\n *\n * The behavior of the default handlers (all at a `low` priority):\n *\n * ## Event: `paste` or `drop`\n *\n * 1. Translates the event data.\n * 2. Fires the {@link module:engine/view/document~Document#event:clipboardInput `view.Document#clipboardInput`} event.\n *\n * ## Event: `view.Document#clipboardInput`\n *\n * 1. If the `data.content` event field is already set (by some listener on a higher priority), it takes this content and fires the event\n *    from the last point.\n * 2. Otherwise, it retrieves `text/html` or `text/plain` from `data.dataTransfer`.\n * 3. Normalizes the raw data by applying simple filters on string data.\n * 4. Processes the raw data to {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`} with the\n *    {@link module:engine/controller/datacontroller~DataController#htmlProcessor `DataController#htmlProcessor`}.\n * 5. Fires the {@link module:clipboard/clipboardpipeline~ClipboardPipeline#event:inputTransformation\n *   `ClipboardPipeline#inputTransformation`} event with the view document fragment in the `data.content` event field.\n *\n * ## Event: `ClipboardPipeline#inputTransformation`\n *\n * 1. Converts {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`} from the `data.content` field to\n *    {@link module:engine/model/documentfragment~DocumentFragment `model.DocumentFragment`}.\n * 2. Fires the {@link module:clipboard/clipboardpipeline~ClipboardPipeline#event:contentInsertion `ClipboardPipeline#contentInsertion`}\n *    event with the model document fragment in the `data.content` event field.\n *    **Note**: The `ClipboardPipeline#contentInsertion` event is fired within a model change block to allow other handlers\n *    to run in the same block without post-fixers called in between (i.e., the selection post-fixer).\n *\n * ## Event: `ClipboardPipeline#contentInsertion`\n *\n * 1. Calls {@link module:engine/model/model~Model#insertContent `model.insertContent()`} to insert `data.content`\n *    at the current selection position.\n *\n * # Output pipeline\n *\n * The behavior of the default handlers (all at a `low` priority):\n *\n * ## Event: `copy`, `cut` or `dragstart`\n *\n * 1. Retrieves the selected {@link module:engine/model/documentfragment~DocumentFragment `model.DocumentFragment`} by calling\n *    {@link module:engine/model/model~Model#getSelectedContent `model#getSelectedContent()`}.\n * 2. Converts the model document fragment to {@link module:engine/view/documentfragment~DocumentFragment `view.DocumentFragment`}.\n * 3. Fires the {@link module:engine/view/document~Document#event:clipboardOutput `view.Document#clipboardOutput`} event\n *    with the view document fragment in the `data.content` event field.\n *\n * ## Event: `view.Document#clipboardOutput`\n *\n * 1. Processes `data.content` to HTML and plain text with the\n *    {@link module:engine/controller/datacontroller~DataController#htmlProcessor `DataController#htmlProcessor`}.\n * 2. Updates the `data.dataTransfer` data for `text/html` and `text/plain` with the processed data.\n * 3. For the `cut` method, calls {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n *    on the current selection.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n */\nexport default class ClipboardPipeline extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ClipboardPipeline';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardMarkersUtils];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        view.addObserver(ClipboardObserver);\n        this._setupPasteDrop();\n        this._setupCopyCut();\n    }\n    /**\n     * Fires Clipboard `'outputTransformation'` event for given parameters.\n     *\n     * @internal\n     */\n    _fireOutputTransformationEvent(dataTransfer, selection, method) {\n        const clipboardMarkersUtils = this.editor.plugins.get('ClipboardMarkersUtils');\n        this.editor.model.enqueueChange({ isUndoable: method === 'cut' }, () => {\n            const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(method, selection);\n            this.fire('outputTransformation', {\n                dataTransfer,\n                content: documentFragment,\n                method\n            });\n        });\n    }\n    /**\n     * The clipboard paste pipeline.\n     */\n    _setupPasteDrop() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const clipboardMarkersUtils = this.editor.plugins.get('ClipboardMarkersUtils');\n        // Pasting is disabled when selection is in non-editable place.\n        // Dropping is disabled in drag and drop handler.\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            if (data.method == 'paste' && !editor.model.canEditAt(editor.model.document.selection)) {\n                evt.stop();\n            }\n        }, { priority: 'highest' });\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            const dataTransfer = data.dataTransfer;\n            let content;\n            // Some feature could already inject content in the higher priority event handler (i.e., codeBlock).\n            if (data.content) {\n                content = data.content;\n            }\n            else {\n                let contentData = '';\n                if (dataTransfer.getData('text/html')) {\n                    contentData = normalizeClipboardHtml(dataTransfer.getData('text/html'));\n                }\n                else if (dataTransfer.getData('text/plain')) {\n                    contentData = plainTextToHtml(dataTransfer.getData('text/plain'));\n                }\n                content = this.editor.data.htmlProcessor.toView(contentData);\n            }\n            const eventInfo = new EventInfo(this, 'inputTransformation');\n            this.fire(eventInfo, {\n                content,\n                dataTransfer,\n                targetRanges: data.targetRanges,\n                method: data.method\n            });\n            // If CKEditor handled the input, do not bubble the original event any further.\n            // This helps external integrations recognize this fact and act accordingly.\n            // https://github.com/ckeditor/ckeditor5-upload/issues/92\n            if (eventInfo.stop.called) {\n                evt.stop();\n            }\n            view.scrollToTheSelection();\n        }, { priority: 'low' });\n        this.listenTo(this, 'inputTransformation', (evt, data) => {\n            if (data.content.isEmpty) {\n                return;\n            }\n            const dataController = this.editor.data;\n            // Convert the pasted content into a model document fragment.\n            // The conversion is contextual, but in this case an \"all allowed\" context is needed\n            // and for that we use the $clipboardHolder item.\n            const modelFragment = dataController.toModel(data.content, '$clipboardHolder');\n            if (modelFragment.childCount == 0) {\n                return;\n            }\n            evt.stop();\n            // Fire content insertion event in a single change block to allow other handlers to run in the same block\n            // without post-fixers called in between (i.e., the selection post-fixer).\n            model.change(() => {\n                this.fire('contentInsertion', {\n                    content: modelFragment,\n                    method: data.method,\n                    dataTransfer: data.dataTransfer,\n                    targetRanges: data.targetRanges\n                });\n            });\n        }, { priority: 'low' });\n        this.listenTo(this, 'contentInsertion', (evt, data) => {\n            data.resultRange = clipboardMarkersUtils._pasteFragmentWithMarkers(data.content);\n        }, { priority: 'low' });\n    }\n    /**\n     * The clipboard copy/cut pipeline.\n     */\n    _setupCopyCut() {\n        const editor = this.editor;\n        const modelDocument = editor.model.document;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const onCopyCut = (evt, data) => {\n            const dataTransfer = data.dataTransfer;\n            data.preventDefault();\n            this._fireOutputTransformationEvent(dataTransfer, modelDocument.selection, evt.name);\n        };\n        this.listenTo(viewDocument, 'copy', onCopyCut, { priority: 'low' });\n        this.listenTo(viewDocument, 'cut', (evt, data) => {\n            // Cutting is disabled when selection is in non-editable place.\n            // See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.\n            if (!editor.model.canEditAt(editor.model.document.selection)) {\n                data.preventDefault();\n            }\n            else {\n                onCopyCut(evt, data);\n            }\n        }, { priority: 'low' });\n        this.listenTo(this, 'outputTransformation', (evt, data) => {\n            const content = editor.data.toView(data.content);\n            viewDocument.fire('clipboardOutput', {\n                dataTransfer: data.dataTransfer,\n                content,\n                method: data.method\n            });\n        }, { priority: 'low' });\n        this.listenTo(viewDocument, 'clipboardOutput', (evt, data) => {\n            if (!data.content.isEmpty) {\n                data.dataTransfer.setData('text/html', this.editor.data.htmlProcessor.toData(data.content));\n                data.dataTransfer.setData('text/plain', viewToPlainText(data.content));\n            }\n            if (data.method == 'cut') {\n                editor.model.deleteContent(modelDocument.selection);\n            }\n        }, { priority: 'low' });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Change buffer allows to group atomic changes (like characters that have been typed) into\n * {@link module:engine/model/batch~Batch batches}.\n *\n * Batches represent single undo steps, hence changes added to one single batch are undone together.\n *\n * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was\n * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.\n *\n * To use the change buffer you need to let it know about the number of changes that were added to the batch:\n *\n * ```ts\n * const buffer = new ChangeBuffer( model, LIMIT );\n *\n * // Later on in your feature:\n * buffer.batch.insert( pos, insertedCharacters );\n * buffer.input( insertedCharacters.length );\n * ```\n */\nexport default class ChangeBuffer {\n    /**\n     * Creates a new instance of the change buffer.\n     *\n     * @param limit The maximum number of atomic changes which can be contained in one batch.\n     */\n    constructor(model, limit = 20) {\n        /**\n         * The current batch instance.\n         */\n        this._batch = null;\n        this.model = model;\n        this._size = 0;\n        this.limit = limit;\n        this._isLocked = false;\n        // The function to be called in order to notify the buffer about batches which appeared in the document.\n        // The callback will check whether it is a new batch and in that case the buffer will be flushed.\n        //\n        // The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards\n        // should be added to a new batch. For instance, when the user types, then inserts an image, and then types again,\n        // the characters typed after inserting the image should be added to a different batch than the characters typed before.\n        this._changeCallback = (evt, batch) => {\n            if (batch.isLocal && batch.isUndoable && batch !== this._batch) {\n                this._reset(true);\n            }\n        };\n        this._selectionChangeCallback = () => {\n            this._reset();\n        };\n        this.model.document.on('change', this._changeCallback);\n        this.model.document.selection.on('change:range', this._selectionChangeCallback);\n        this.model.document.selection.on('change:attribute', this._selectionChangeCallback);\n    }\n    /**\n     * The current batch to which a feature should add its operations. Once the {@link #size}\n     * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n     */\n    get batch() {\n        if (!this._batch) {\n            this._batch = this.model.createBatch({ isTyping: true });\n        }\n        return this._batch;\n    }\n    /**\n     * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},\n     * the {@link #batch batch} is set to a new one.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * The input number of changes into the buffer. Once the {@link #size} is\n     * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.\n     *\n     * @param changeCount The number of atomic changes to input.\n     */\n    input(changeCount) {\n        this._size += changeCount;\n        if (this._size >= this.limit) {\n            this._reset(true);\n        }\n    }\n    /**\n     * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.\n     */\n    get isLocked() {\n        return this._isLocked;\n    }\n    /**\n     * Locks the buffer.\n     */\n    lock() {\n        this._isLocked = true;\n    }\n    /**\n     * Unlocks the buffer.\n     */\n    unlock() {\n        this._isLocked = false;\n    }\n    /**\n     * Destroys the buffer.\n     */\n    destroy() {\n        this.model.document.off('change', this._changeCallback);\n        this.model.document.selection.off('change:range', this._selectionChangeCallback);\n        this.model.document.selection.off('change:attribute', this._selectionChangeCallback);\n    }\n    /**\n     * Resets the change buffer.\n     *\n     * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.\n     */\n    _reset(ignoreLock = false) {\n        if (!this.isLocked || ignoreLock) {\n            this._batch = null;\n            this._size = 0;\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/inserttextcommand\n */\nimport { Command } from '@ckeditor/ckeditor5-core';\nimport ChangeBuffer from './utils/changebuffer.js';\n/**\n * The insert text command. Used by the {@link module:typing/input~Input input feature} to handle typing.\n */\nexport default class InsertTextCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param undoStepSize The maximum number of atomic changes\n     * which can be contained in one batch in the command buffer.\n     */\n    constructor(editor, undoStepSize) {\n        super(editor);\n        this._buffer = new ChangeBuffer(editor.model, undoStepSize);\n        // Since this command may execute on different selectable than selection, it should be checked directly in execute block.\n        this._isEnabledBasedOnSelection = false;\n    }\n    /**\n     * The current change buffer.\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this._buffer.destroy();\n    }\n    /**\n     * Executes the input command. It replaces the content within the given range with the given text.\n     * Replacing is a two step process, first the content within the range is removed and then the new text is inserted\n     * at the beginning of the range (which after the removal is a collapsed range).\n     *\n     * @fires execute\n     * @param options The command options.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const doc = model.document;\n        const text = options.text || '';\n        const textInsertions = text.length;\n        let selection = doc.selection;\n        if (options.selection) {\n            selection = options.selection;\n        }\n        else if (options.range) {\n            selection = model.createSelection(options.range);\n        }\n        // Stop executing if selectable is in non-editable place.\n        if (!model.canEditAt(selection)) {\n            return;\n        }\n        const resultRange = options.resultRange;\n        model.enqueueChange(this._buffer.batch, writer => {\n            this._buffer.lock();\n            // Store selection attributes before deleting old content to preserve formatting and link.\n            // This unifies the behavior between DocumentSelection and Selection provided as input option.\n            const selectionAttributes = Array.from(doc.selection.getAttributes());\n            model.deleteContent(selection);\n            if (text) {\n                model.insertContent(writer.createText(text, selectionAttributes), selection);\n            }\n            if (resultRange) {\n                writer.setSelection(resultRange);\n            }\n            else if (!selection.is('documentSelection')) {\n                writer.setSelection(selection);\n            }\n            this._buffer.unlock();\n            this._buffer.input(textInsertions);\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/inserttextobserver\n */\nimport { env, EventInfo } from '@ckeditor/ckeditor5-utils';\nimport { DomEventData, Observer, FocusObserver } from '@ckeditor/ckeditor5-engine';\nconst TYPING_INPUT_TYPES = [\n    // For collapsed range:\n    //\t- This one is a regular typing (all browsers, all systems).\n    //\t- This one is used by Chrome when typing accented letter – 2nd step when the user selects the accent (Mac).\n    // For non-collapsed range:\n    //\t- This one is used by Chrome when typing accented letter – when the selection box first appears (Mac).\n    //\t- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).\n    'insertText',\n    // This one is used by Safari when typing accented letter (Mac).\n    // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).\n    'insertReplacementText'\n];\nconst TYPING_INPUT_TYPES_ANDROID = [\n    ...TYPING_INPUT_TYPES,\n    'insertCompositionText'\n];\n/**\n * Text insertion observer introduces the {@link module:engine/view/document~Document#event:insertText} event.\n */\nexport default class InsertTextObserver extends Observer {\n    /**\n     * @inheritDoc\n     */\n    constructor(view) {\n        super(view);\n        this.focusObserver = view.getObserver(FocusObserver);\n        // On Android composition events should immediately be applied to the model. Rendering is not disabled.\n        // On non-Android the model is updated only on composition end.\n        // On Android we can't rely on composition start/end to update model.\n        const typingInputTypes = env.isAndroid ? TYPING_INPUT_TYPES_ANDROID : TYPING_INPUT_TYPES;\n        const viewDocument = view.document;\n        viewDocument.on('beforeinput', (evt, data) => {\n            if (!this.isEnabled) {\n                return;\n            }\n            const { data: text, targetRanges, inputType, domEvent } = data;\n            if (!typingInputTypes.includes(inputType)) {\n                return;\n            }\n            // Mark the latest focus change as complete (we are typing in editable after the focus\n            // so the selection is in the focused element).\n            this.focusObserver.flush();\n            const eventInfo = new EventInfo(viewDocument, 'insertText');\n            viewDocument.fire(eventInfo, new DomEventData(view, domEvent, {\n                text,\n                selection: view.createSelection(targetRanges)\n            }));\n            // Stop the beforeinput event if `delete` event was stopped.\n            // https://github.com/ckeditor/ckeditor5/issues/753\n            if (eventInfo.stop.called) {\n                evt.stop();\n            }\n        });\n        // On Android composition events are immediately applied to the model.\n        // On non-Android the model is updated only on composition end.\n        // On Android we can't rely on composition start/end to update model.\n        if (!env.isAndroid) {\n            // Note: The priority must be lower than the CompositionObserver handler to call it after the renderer is unblocked.\n            // This is important for view to DOM position mapping.\n            // This causes the effect of first remove composed DOM and then reapply it after model modification.\n            viewDocument.on('compositionend', (evt, { data, domEvent }) => {\n                if (!this.isEnabled) {\n                    return;\n                }\n                // In case of aborted composition.\n                if (!data) {\n                    return;\n                }\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconsole.log( `%c[InsertTextObserver]%c Fire insertText event, %c${ JSON.stringify( data ) }`,\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-weight: bold', 'color: blue'\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                // How do we know where to insert the composed text?\n                // 1. The SelectionObserver is blocked and the view is not updated with the composition changes.\n                // 2. The last moment before it's locked is the `compositionstart` event.\n                // 3. The `SelectionObserver` is listening for `compositionstart` event and immediately converts\n                //    the selection. Handles this at the lowest priority so after the rendering is blocked.\n                viewDocument.fire('insertText', new DomEventData(view, domEvent, {\n                    text: data\n                }));\n            }, { priority: 'lowest' });\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    observe() { }\n    /**\n     * @inheritDoc\n     */\n    stopObserving() { }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/input\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { env } from '@ckeditor/ckeditor5-utils';\nimport InsertTextCommand from './inserttextcommand.js';\nimport InsertTextObserver from './inserttextobserver.js';\nimport { LiveRange } from '@ckeditor/ckeditor5-engine';\nimport { debounce } from 'lodash-es';\n/**\n * Handles text input coming from the keyboard or other input methods.\n */\nexport default class Input extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Input';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const mapper = editor.editing.mapper;\n        const modelSelection = model.document.selection;\n        this._compositionQueue = new CompositionQueue(editor);\n        view.addObserver(InsertTextObserver);\n        // TODO The above default configuration value should be defined using editor.config.define() once it's fixed.\n        const insertTextCommand = new InsertTextCommand(editor, editor.config.get('typing.undoStep') || 20);\n        // Register `insertText` command and add `input` command as an alias for backward compatibility.\n        editor.commands.add('insertText', insertTextCommand);\n        editor.commands.add('input', insertTextCommand);\n        this.listenTo(view.document, 'insertText', (evt, data) => {\n            // Rendering is disabled while composing so prevent events that will be rendered by the engine\n            // and should not be applied by the browser.\n            if (!view.document.isComposing) {\n                data.preventDefault();\n            }\n            // Flush queue on the next beforeinput event because it could happen\n            // that the mutation observer does not notice the DOM change in time.\n            if (env.isAndroid && view.document.isComposing) {\n                this._compositionQueue.flush('next beforeinput');\n            }\n            const { text, selection: viewSelection } = data;\n            let modelRanges;\n            // If view selection was specified, translate it to model selection.\n            if (viewSelection) {\n                modelRanges = Array.from(viewSelection.getRanges()).map(viewRange => mapper.toModelRange(viewRange));\n            }\n            else {\n                modelRanges = Array.from(modelSelection.getRanges());\n            }\n            let insertText = text;\n            // Typing in English on Android is firing composition events for the whole typed word.\n            // We need to check the target range text to only apply the difference.\n            if (env.isAndroid) {\n                const selectedText = Array.from(modelRanges[0].getItems()).reduce((rangeText, node) => {\n                    return rangeText + (node.is('$textProxy') ? node.data : '');\n                }, '');\n                if (selectedText) {\n                    if (selectedText.length <= insertText.length) {\n                        if (insertText.startsWith(selectedText)) {\n                            insertText = insertText.substring(selectedText.length);\n                            modelRanges[0].start = modelRanges[0].start.getShiftedBy(selectedText.length);\n                        }\n                    }\n                    else {\n                        if (selectedText.startsWith(insertText)) {\n                            // TODO this should be mapped as delete?\n                            modelRanges[0].start = modelRanges[0].start.getShiftedBy(insertText.length);\n                            insertText = '';\n                        }\n                    }\n                }\n                if (insertText.length == 0 && modelRanges[0].isCollapsed) {\n                    // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                    // @if CK_DEBUG_TYPING // \tconsole.log( '%c[Input]%c Ignore insertion of an empty data to the collapsed range.',\n                    // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-style: italic'\n                    // @if CK_DEBUG_TYPING // \t);\n                    // @if CK_DEBUG_TYPING // }\n                    return;\n                }\n            }\n            const commandData = {\n                text: insertText,\n                selection: model.createSelection(modelRanges)\n            };\n            // This is a composition event and those are not cancellable, so we need to wait until browser updates the DOM\n            // and we could apply changes to the model and verify if the DOM is valid.\n            // The browser applies changes to the DOM not immediately on beforeinput event.\n            // We just wait for mutation observer to notice changes or as a fallback a timeout.\n            if (env.isAndroid && view.document.isComposing) {\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconsole.log( `%c[Input]%c Queue insertText:%c \"${ commandData.text }\"%c ` +\n                // @if CK_DEBUG_TYPING // \t\t`[${ commandData.selection.getFirstPosition().path }]-` +\n                // @if CK_DEBUG_TYPING // \t\t`[${ commandData.selection.getLastPosition().path }]` +\n                // @if CK_DEBUG_TYPING // \t\t` queue size: ${ this._compositionQueue.length + 1 }`,\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-weight: bold', 'color: blue', ''\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                this._compositionQueue.push(commandData);\n            }\n            else {\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconsole.log( `%c[Input]%c Execute insertText:%c \"${ commandData.text }\"%c ` +\n                // @if CK_DEBUG_TYPING // \t\t`[${ commandData.selection.getFirstPosition().path }]-` +\n                // @if CK_DEBUG_TYPING // \t\t`[${ commandData.selection.getLastPosition().path }]`,\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-weight: bold', 'color: blue', ''\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                editor.execute('insertText', commandData);\n                view.scrollToTheSelection();\n            }\n        });\n        // Delete selected content on composition start.\n        if (env.isAndroid) {\n            // On Android with English keyboard, the composition starts just by putting caret\n            // at the word end or by selecting a table column. This is not a real composition started.\n            // Trigger delete content on first composition key pressed.\n            this.listenTo(view.document, 'keydown', (evt, data) => {\n                if (modelSelection.isCollapsed || data.keyCode != 229 || !view.document.isComposing) {\n                    return;\n                }\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconst firstPositionPath = modelSelection.getFirstPosition()!.path;\n                // @if CK_DEBUG_TYPING // \tconst lastPositionPath = modelSelection.getLastPosition()!.path;\n                // @if CK_DEBUG_TYPING // \tconsole.log( '%c[Input]%c KeyDown 229%c -> model.deleteContent() ' +\n                // @if CK_DEBUG_TYPING // \t\t`[${ firstPositionPath }]-[${ lastPositionPath }]`,\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-weight: bold', '',\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                deleteSelectionContent(model, insertTextCommand);\n            });\n        }\n        else {\n            // Note: The priority must precede the CompositionObserver handler to call it before\n            // the renderer is blocked, because we want to render this change.\n            this.listenTo(view.document, 'compositionstart', () => {\n                if (modelSelection.isCollapsed) {\n                    return;\n                }\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconst firstPositionPath = modelSelection.getFirstPosition()!.path;\n                // @if CK_DEBUG_TYPING // \tconst lastPositionPath = modelSelection.getLastPosition()!.path;\n                // @if CK_DEBUG_TYPING // \tconsole.log( '%c[Input]%c Composition start%c -> model.deleteContent() ' +\n                // @if CK_DEBUG_TYPING // \t\t`[${ firstPositionPath }]-[${ lastPositionPath }]`,\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-weight: bold', '',\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                deleteSelectionContent(model, insertTextCommand);\n            });\n        }\n        // Apply composed changes to the model.\n        if (env.isAndroid) {\n            // Apply changes to the model as they are applied to the DOM by the browser.\n            // On beforeinput event, the DOM is not yet modified. We wait for detected mutations to apply model changes.\n            this.listenTo(view.document, 'mutations', (evt, { mutations }) => {\n                if (!view.document.isComposing) {\n                    return;\n                }\n                // Check if mutations are relevant for queued changes.\n                for (const { node } of mutations) {\n                    const viewElement = findMappedViewAncestor(node, mapper);\n                    const modelElement = mapper.toModelElement(viewElement);\n                    if (this._compositionQueue.isComposedElement(modelElement)) {\n                        this._compositionQueue.flush('mutations');\n                        return;\n                    }\n                }\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconsole.log( '%c[Input]%c Mutations not related to the composition.',\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-style: italic'\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n            });\n            // Make sure that all changes are applied to the model before the end of composition.\n            this.listenTo(view.document, 'compositionend', () => {\n                this._compositionQueue.flush('composition end');\n            });\n            // Trigger mutations check after the composition completes to fix all DOM changes that got ignored during composition.\n            // On Android the Renderer is not disabled while composing. While updating DOM nodes we ignore some changes\n            // that are not that important (like NBSP vs plain space character) and could break the composition flow.\n            // After composition is completed we trigger additional `mutations` event for elements affected by the composition\n            // so the Renderer can adjust the DOM to the expected structure without breaking the composition.\n            this.listenTo(view.document, 'compositionend', () => {\n                const mutations = [];\n                for (const element of this._compositionQueue.flushComposedElements()) {\n                    const viewElement = mapper.toViewElement(element);\n                    if (!viewElement) {\n                        continue;\n                    }\n                    mutations.push({ type: 'children', node: viewElement });\n                }\n                if (mutations.length) {\n                    // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                    // @if CK_DEBUG_TYPING // \tconsole.group( '%c[Input]%c Fire post-composition mutation fixes.',\n                    // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green', 'font-weight: bold', ''\n                    // @if CK_DEBUG_TYPING // \t);\n                    // @if CK_DEBUG_TYPING // }\n                    view.document.fire('mutations', { mutations });\n                    // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                    // @if CK_DEBUG_TYPING // \tconsole.groupEnd();\n                    // @if CK_DEBUG_TYPING // }\n                }\n            }, { priority: 'lowest' });\n        }\n        else {\n            // After composition end we need to verify if there are no left-overs.\n            // Listening at the lowest priority so after the `InsertTextObserver` added above (all composed text\n            // should already be applied to the model, view, and DOM).\n            // On non-Android the `Renderer` is blocked while user is composing but the `MutationObserver` still collects\n            // mutated nodes and fires `mutations` events.\n            // Those events are recorded by the `Renderer` but not applied to the DOM while composing.\n            // We need to trigger those checks (and fixes) once again but this time without specifying the exact mutations\n            // since they are already recorded by the `Renderer`.\n            // It in the most cases just clears the internal record of mutated text nodes\n            // since all changes should already be applied to the DOM.\n            // This is especially needed when user cancels composition, so we can clear nodes marked to sync.\n            this.listenTo(view.document, 'compositionend', () => {\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconsole.group( '%c[Input]%c Force render after composition end.',\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green', 'font-weight: bold', ''\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                view.document.fire('mutations', { mutations: [] });\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconsole.groupEnd();\n                // @if CK_DEBUG_TYPING // }\n            }, { priority: 'lowest' });\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this._compositionQueue.destroy();\n    }\n}\n/**\n * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.\n */\nclass CompositionQueue {\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        /**\n         * Debounced queue flush as a safety mechanism for cases of mutation observer not triggering.\n         */\n        this.flushDebounced = debounce(() => this.flush('timeout'), 50);\n        /**\n         * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.\n         */\n        this._queue = [];\n        /**\n         * A set of model elements. The composition happened in those elements. It's used for mutations check.\n         */\n        this._compositionElements = new Set();\n        this.editor = editor;\n    }\n    /**\n     * Destroys the helper object.\n     */\n    destroy() {\n        this.flushDebounced.cancel();\n        this._compositionElements.clear();\n        while (this._queue.length) {\n            this.shift();\n        }\n    }\n    /**\n     * Returns the size of the queue.\n     */\n    get length() {\n        return this._queue.length;\n    }\n    /**\n     * Push next insertText command data to the queue.\n     */\n    push(commandData) {\n        const commandLiveData = {\n            text: commandData.text\n        };\n        if (commandData.selection) {\n            commandLiveData.selectionRanges = [];\n            for (const range of commandData.selection.getRanges()) {\n                commandLiveData.selectionRanges.push(LiveRange.fromRange(range));\n                // Keep reference to the model element for later mutation checks.\n                this._compositionElements.add(range.start.parent);\n            }\n        }\n        this._queue.push(commandLiveData);\n        this.flushDebounced();\n    }\n    /**\n     * Shift the first item from the insertText command data queue.\n     */\n    shift() {\n        const commandLiveData = this._queue.shift();\n        const commandData = {\n            text: commandLiveData.text\n        };\n        if (commandLiveData.selectionRanges) {\n            const ranges = commandLiveData.selectionRanges\n                .map(liveRange => detachLiveRange(liveRange))\n                .filter((range) => !!range);\n            if (ranges.length) {\n                commandData.selection = this.editor.model.createSelection(ranges);\n            }\n        }\n        return commandData;\n    }\n    /**\n     * Applies all queued insertText command executions.\n     *\n     * @param reason Used only for debugging.\n     */\n    flush(reason) {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        this.flushDebounced.cancel();\n        if (!this._queue.length) {\n            return;\n        }\n        // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n        // @if CK_DEBUG_TYPING // \tconsole.group( `%c[Input]%c Flush insertText queue on ${ reason }.`,\n        // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-weight: bold'\n        // @if CK_DEBUG_TYPING // \t);\n        // @if CK_DEBUG_TYPING // }\n        const insertTextCommand = editor.commands.get('insertText');\n        const buffer = insertTextCommand.buffer;\n        model.enqueueChange(buffer.batch, () => {\n            buffer.lock();\n            while (this._queue.length) {\n                const commandData = this.shift();\n                // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n                // @if CK_DEBUG_TYPING // \tconsole.log( '%c[Input]%c Execute queued insertText:%c ' +\n                // @if CK_DEBUG_TYPING // \t\t`\"${ commandData.text }\"%c ` +\n                // @if CK_DEBUG_TYPING // \t\t`[${ commandData.selection.getFirstPosition().path }]-` +\n                // @if CK_DEBUG_TYPING // \t\t`[${ commandData.selection.getLastPosition().path }]`,\n                // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', 'font-weight: bold', 'color: blue', ''\n                // @if CK_DEBUG_TYPING // \t);\n                // @if CK_DEBUG_TYPING // }\n                editor.execute('insertText', commandData);\n            }\n            buffer.unlock();\n        });\n        view.scrollToTheSelection();\n        // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n        // @if CK_DEBUG_TYPING // \tconsole.groupEnd();\n        // @if CK_DEBUG_TYPING // }\n    }\n    /**\n     * Returns `true` if the given model element is related to recent composition.\n     */\n    isComposedElement(element) {\n        return this._compositionElements.has(element);\n    }\n    /**\n     * Returns an array of composition-related elements and clears the internal list.\n     */\n    flushComposedElements() {\n        const result = Array.from(this._compositionElements);\n        this._compositionElements.clear();\n        return result;\n    }\n}\n/**\n * Deletes the content selected by the document selection at the start of composition.\n */\nfunction deleteSelectionContent(model, insertTextCommand) {\n    // By relying on the state of the input command we allow disabling the entire input easily\n    // by just disabling the input command. We could’ve used here the delete command but that\n    // would mean requiring the delete feature which would block loading one without the other.\n    // We could also check the editor.isReadOnly property, but that wouldn't allow to block\n    // the input without blocking other features.\n    if (!insertTextCommand.isEnabled) {\n        return;\n    }\n    const buffer = insertTextCommand.buffer;\n    buffer.lock();\n    model.enqueueChange(buffer.batch, () => {\n        model.deleteContent(model.document.selection);\n    });\n    buffer.unlock();\n}\n/**\n * Detaches a LiveRange and returns the static range from it.\n */\nfunction detachLiveRange(liveRange) {\n    const range = liveRange.toRange();\n    liveRange.detach();\n    if (range.root.rootName == '$graveyard') {\n        return null;\n    }\n    return range;\n}\n/**\n * For the given `viewNode`, finds and returns the closest ancestor of this node that has a mapping to the model.\n */\nfunction findMappedViewAncestor(viewNode, mapper) {\n    let node = (viewNode.is('$text') ? viewNode.parent : viewNode);\n    while (!mapper.toModelElement(node)) {\n        node = node.parent;\n    }\n    return node;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/deletecommand\n */\nimport { Command } from '@ckeditor/ckeditor5-core';\nimport { count } from '@ckeditor/ckeditor5-utils';\nimport ChangeBuffer from './utils/changebuffer.js';\n/**\n * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and\n * <kbd>Backspace</kbd> keys.\n */\nexport default class DeleteCommand extends Command {\n    /**\n     * Creates an instance of the command.\n     *\n     * @param direction The directionality of the delete describing in what direction it\n     * should consume the content when the selection is collapsed.\n     */\n    constructor(editor, direction) {\n        super(editor);\n        this.direction = direction;\n        this._buffer = new ChangeBuffer(editor.model, editor.config.get('typing.undoStep'));\n        // Since this command may execute on different selectable than selection, it should be checked directly in execute block.\n        this._isEnabledBasedOnSelection = false;\n    }\n    /**\n     * The current change buffer.\n     */\n    get buffer() {\n        return this._buffer;\n    }\n    /**\n     * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content\n     * or a piece of content in the {@link #direction defined direction}.\n     *\n     * @fires execute\n     * @param options The command options.\n     * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.\n     * @param options.sequence A number describing which subsequent delete event it is without the key being released.\n     * See the {@link module:engine/view/document~Document#event:delete} event data.\n     * @param options.selection Selection to remove. If not set, current model selection will be used.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const doc = model.document;\n        model.enqueueChange(this._buffer.batch, writer => {\n            this._buffer.lock();\n            const selection = writer.createSelection(options.selection || doc.selection);\n            // Don't execute command when selection is in non-editable place.\n            if (!model.canEditAt(selection)) {\n                return;\n            }\n            const sequence = options.sequence || 1;\n            // Do not replace the whole selected content if selection was collapsed.\n            // This prevents such situation:\n            //\n            // <h1></h1><p>[]</p>\t-->  <h1>[</h1><p>]</p> \t\t-->  <p></p>\n            // starting content\t\t-->   after `modifySelection`\t-->  after `deleteContent`.\n            const doNotResetEntireContent = selection.isCollapsed;\n            // Try to extend the selection in the specified direction.\n            if (selection.isCollapsed) {\n                model.modifySelection(selection, {\n                    direction: this.direction,\n                    unit: options.unit,\n                    treatEmojiAsSingleUnit: true\n                });\n            }\n            // Check if deleting in an empty editor. See #61.\n            if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {\n                this._replaceEntireContentWithParagraph(writer);\n                return;\n            }\n            // Check if deleting in the first empty block.\n            // See https://github.com/ckeditor/ckeditor5/issues/8137.\n            if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {\n                this.editor.execute('paragraph', { selection });\n                return;\n            }\n            // If selection is still collapsed, then there's nothing to delete.\n            if (selection.isCollapsed) {\n                return;\n            }\n            let changeCount = 0;\n            selection.getFirstRange().getMinimalFlatRanges().forEach(range => {\n                changeCount += count(range.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));\n            });\n            // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n            // @if CK_DEBUG_TYPING // \tconsole.log( '%c[DeleteCommand]%c Delete content',\n            // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green;', '',\n            // @if CK_DEBUG_TYPING // \t\t`[${ selection.getFirstPosition()!.path }]-[${ selection.getLastPosition()!.path }]`, options\n            // @if CK_DEBUG_TYPING // \t);\n            // @if CK_DEBUG_TYPING // }\n            model.deleteContent(selection, {\n                doNotResetEntireContent,\n                direction: this.direction\n            });\n            this._buffer.input(changeCount);\n            writer.setSelection(selection);\n            this._buffer.unlock();\n        });\n    }\n    /**\n     * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current\n     * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph\n     * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).\n     *\n     * But, if the user pressed the key in an empty editable for the first time,\n     * we want to replace the entire content with a paragraph if:\n     *\n     * * the current limit element is empty,\n     * * the paragraph is allowed in the limit element,\n     * * the limit doesn't already have a paragraph inside.\n     *\n     * See https://github.com/ckeditor/ckeditor5-typing/issues/61.\n     *\n     * @param sequence A number describing which subsequent delete event it is without the key being released.\n     */\n    _shouldEntireContentBeReplacedWithParagraph(sequence) {\n        // Does nothing if user pressed and held the \"Backspace\" or \"Delete\" key.\n        if (sequence > 1) {\n            return false;\n        }\n        const model = this.editor.model;\n        const doc = model.document;\n        const selection = doc.selection;\n        const limitElement = model.schema.getLimitElement(selection);\n        // If a collapsed selection contains the whole content it means that the content is empty\n        // (from the user perspective).\n        const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);\n        if (!limitElementIsEmpty) {\n            return false;\n        }\n        if (!model.schema.checkChild(limitElement, 'paragraph')) {\n            return false;\n        }\n        const limitElementFirstChild = limitElement.getChild(0);\n        // Does nothing if the limit element already contains only a paragraph.\n        // We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)\n        // because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.\n        if (limitElementFirstChild && limitElementFirstChild.is('element', 'paragraph')) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.\n     *\n     * @param writer The model writer.\n     */\n    _replaceEntireContentWithParagraph(writer) {\n        const model = this.editor.model;\n        const doc = model.document;\n        const selection = doc.selection;\n        const limitElement = model.schema.getLimitElement(selection);\n        const paragraph = writer.createElement('paragraph');\n        writer.remove(writer.createRangeIn(limitElement));\n        writer.insert(paragraph, limitElement);\n        writer.setSelection(paragraph, 0);\n    }\n    /**\n     * Checks if the selection is inside an empty element that is the first child of the limit element\n     * and should be replaced with a paragraph.\n     *\n     * @param selection The selection.\n     * @param sequence A number describing which subsequent delete event it is without the key being released.\n     */\n    _shouldReplaceFirstBlockWithParagraph(selection, sequence) {\n        const model = this.editor.model;\n        // Does nothing if user pressed and held the \"Backspace\" key or it was a \"Delete\" button.\n        if (sequence > 1 || this.direction != 'backward') {\n            return false;\n        }\n        if (!selection.isCollapsed) {\n            return false;\n        }\n        const position = selection.getFirstPosition();\n        const limitElement = model.schema.getLimitElement(position);\n        const limitElementFirstChild = limitElement.getChild(0);\n        // Only elements that are direct children of the limit element can be replaced.\n        // Unwrapping from a block quote should be handled in a dedicated feature.\n        if (position.parent != limitElementFirstChild) {\n            return false;\n        }\n        // A block should be replaced only if it was empty.\n        if (!selection.containsEntireContent(limitElementFirstChild)) {\n            return false;\n        }\n        // Replace with a paragraph only if it's allowed there.\n        if (!model.schema.checkChild(limitElement, 'paragraph')) {\n            return false;\n        }\n        // Does nothing if the limit element already contains only a paragraph.\n        if (limitElementFirstChild.name == 'paragraph') {\n            return false;\n        }\n        return true;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/deleteobserver\n */\nimport { env, keyCodes, isInsideCombinedSymbol, isInsideEmojiSequence, isInsideSurrogatePair } from '@ckeditor/ckeditor5-utils';\nimport { BubblingEventInfo, DomEventData, Observer } from '@ckeditor/ckeditor5-engine';\nconst DELETE_CHARACTER = 'character';\nconst DELETE_WORD = 'word';\nconst DELETE_CODE_POINT = 'codePoint';\nconst DELETE_SELECTION = 'selection';\nconst DELETE_BACKWARD = 'backward';\nconst DELETE_FORWARD = 'forward';\nconst DELETE_EVENT_TYPES = {\n    // --------------------------------------- Backward delete types -----------------------------------------------------\n    // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.\n    deleteContent: {\n        unit: DELETE_SELECTION,\n        // According to the Input Events Level 2 spec, this delete type has no direction\n        // but to keep things simple, let's default to backward.\n        direction: DELETE_BACKWARD\n    },\n    // Chrome and Safari on Mac: Backspace or Ctrl + H\n    deleteContentBackward: {\n        // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.\n        // Take for instance \"👨‍👩‍👧‍👧\", it equals:\n        //\n        //\t* [ \"👨\", \"ZERO WIDTH JOINER\", \"👩\", \"ZERO WIDTH JOINER\", \"👧\", \"ZERO WIDTH JOINER\", \"👧\" ]\n        //\t* or simply \"\\u{1F468}\\u200D\\u{1F469}\\u200D\\u{1F467}\\u200D\\u{1F467}\"\n        //\n        // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user\n        // intention when deleting backwards (\"👨‍👩‍👧‍👧[]\", then backspace) is gradual \"decomposition\" (first to \"👨‍👩‍👧‍[]\",\n        // then to \"👨‍👩‍[]\", etc.).\n        //\n        //\t* \"👨‍👩‍👧‍👧[]\" + backward delete (by code point)  -> results in \"👨‍👩‍👧[]\", removed the last \"👧\" 👍\n        //\t* \"👨‍👩‍👧‍👧[]\" + backward delete (by character)  -> results in \"[]\", removed the whole grapheme 👎\n        //\n        // Deleting by code-point is simply a better UX. See \"deleteContentForward\" to learn more.\n        unit: DELETE_CODE_POINT,\n        direction: DELETE_BACKWARD\n    },\n    // On Mac: Option + Backspace.\n    // On iOS: Hold the backspace for a while and the whole words will start to disappear.\n    deleteWordBackward: {\n        unit: DELETE_WORD,\n        direction: DELETE_BACKWARD\n    },\n    // Safari on Mac: Cmd + Backspace\n    deleteHardLineBackward: {\n        unit: DELETE_SELECTION,\n        direction: DELETE_BACKWARD\n    },\n    // Chrome on Mac: Cmd + Backspace.\n    deleteSoftLineBackward: {\n        unit: DELETE_SELECTION,\n        direction: DELETE_BACKWARD\n    },\n    // --------------------------------------- Forward delete types -----------------------------------------------------\n    // Chrome on Mac: Fn + Backspace or Ctrl + D\n    // Safari on Mac: Ctrl + K or Ctrl + D\n    deleteContentForward: {\n        // Unlike backward delete, this delete must be performed by character instead of by code point, which\n        // provides the best UX for working with accented letters.\n        // Take, for example \"b̂\" (\"\\u0062\\u0302\", or [ \"LATIN SMALL LETTER B\", \"COMBINING CIRCUMFLEX ACCENT\" ]):\n        //\n        //\t* \"b̂[]\" + backward delete (by code point)  -> results in \"b[]\", removed the combining mark 👍\n        //\t* \"[]b̂\" + forward delete (by code point)   -> results in \"[]^\", a bare combining mark does that not make sense when alone 👎\n        //\t* \"[]b̂\" + forward delete (by character)    -> results in \"[]\", removed both \"b\" and the combining mark 👍\n        //\n        // See: \"deleteContentBackward\" to learn more.\n        unit: DELETE_CHARACTER,\n        direction: DELETE_FORWARD\n    },\n    // On Mac: Fn + Option + Backspace.\n    deleteWordForward: {\n        unit: DELETE_WORD,\n        direction: DELETE_FORWARD\n    },\n    // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)\n    // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing\n    // on Apple's webpage.\n    deleteHardLineForward: {\n        unit: DELETE_SELECTION,\n        direction: DELETE_FORWARD\n    },\n    // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with\n    // deleteSoftLineBackward.\n    deleteSoftLineForward: {\n        unit: DELETE_SELECTION,\n        direction: DELETE_FORWARD\n    }\n};\n/**\n * Delete observer introduces the {@link module:engine/view/document~Document#event:delete} event.\n */\nexport default class DeleteObserver extends Observer {\n    /**\n     * @inheritDoc\n     */\n    constructor(view) {\n        super(view);\n        const document = view.document;\n        // It matters how many subsequent deletions were made, e.g. when the backspace key was pressed and held\n        // by the user for some time. For instance, if such scenario ocurred and the heading the selection was\n        // anchored to was the only content of the editor, it will not be converted into a paragraph (the user\n        // wanted to clean it up, not remove it, it's about UX). Check out the DeleteCommand implementation to learn more.\n        //\n        // Fun fact: Safari on Mac won't fire beforeinput for backspace in an empty heading (only content).\n        let sequence = 0;\n        document.on('keydown', () => {\n            sequence++;\n        });\n        document.on('keyup', () => {\n            sequence = 0;\n        });\n        document.on('beforeinput', (evt, data) => {\n            if (!this.isEnabled) {\n                return;\n            }\n            const { targetRanges, domEvent, inputType } = data;\n            const deleteEventSpec = DELETE_EVENT_TYPES[inputType];\n            if (!deleteEventSpec) {\n                return;\n            }\n            const deleteData = {\n                direction: deleteEventSpec.direction,\n                unit: deleteEventSpec.unit,\n                sequence\n            };\n            if (deleteData.unit == DELETE_SELECTION) {\n                deleteData.selectionToRemove = view.createSelection(targetRanges[0]);\n            }\n            // The default deletion unit for deleteContentBackward is a single code point\n            // but if the browser provides a wider target range then we should use it.\n            if (inputType === 'deleteContentBackward') {\n                // On Android, deleteContentBackward has sequence 1 by default.\n                if (env.isAndroid) {\n                    deleteData.sequence = 1;\n                }\n                // The beforeInput event wants more than a single character to be removed.\n                if (shouldUseTargetRanges(targetRanges)) {\n                    deleteData.unit = DELETE_SELECTION;\n                    deleteData.selectionToRemove = view.createSelection(targetRanges);\n                }\n            }\n            const eventInfo = new BubblingEventInfo(document, 'delete', targetRanges[0]);\n            document.fire(eventInfo, new DomEventData(view, domEvent, deleteData));\n            // Stop the beforeinput event if `delete` event was stopped.\n            // https://github.com/ckeditor/ckeditor5/issues/753\n            if (eventInfo.stop.called) {\n                evt.stop();\n            }\n        });\n        // TODO: to be removed when https://bugs.chromium.org/p/chromium/issues/detail?id=1365311 is solved.\n        if (env.isBlink) {\n            enableChromeWorkaround(this);\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    observe() { }\n    /**\n     * @inheritDoc\n     */\n    stopObserving() { }\n}\n/**\n * Enables workaround for the issue https://github.com/ckeditor/ckeditor5/issues/11904.\n */\nfunction enableChromeWorkaround(observer) {\n    const view = observer.view;\n    const document = view.document;\n    let pressedKeyCode = null;\n    let beforeInputReceived = false;\n    document.on('keydown', (evt, { keyCode }) => {\n        pressedKeyCode = keyCode;\n        beforeInputReceived = false;\n    });\n    document.on('keyup', (evt, { keyCode, domEvent }) => {\n        const selection = document.selection;\n        const shouldFireDeleteEvent = observer.isEnabled &&\n            keyCode == pressedKeyCode &&\n            isDeleteKeyCode(keyCode) &&\n            !selection.isCollapsed &&\n            !beforeInputReceived;\n        pressedKeyCode = null;\n        if (shouldFireDeleteEvent) {\n            const targetRange = selection.getFirstRange();\n            const eventInfo = new BubblingEventInfo(document, 'delete', targetRange);\n            const deleteData = {\n                unit: DELETE_SELECTION,\n                direction: getDeleteDirection(keyCode),\n                selectionToRemove: selection\n            };\n            document.fire(eventInfo, new DomEventData(view, domEvent, deleteData));\n        }\n    });\n    document.on('beforeinput', (evt, { inputType }) => {\n        const deleteEventSpec = DELETE_EVENT_TYPES[inputType];\n        const isMatchingBeforeInput = isDeleteKeyCode(pressedKeyCode) &&\n            deleteEventSpec &&\n            deleteEventSpec.direction == getDeleteDirection(pressedKeyCode);\n        if (isMatchingBeforeInput) {\n            beforeInputReceived = true;\n        }\n    }, { priority: 'high' });\n    document.on('beforeinput', (evt, { inputType, data }) => {\n        const shouldIgnoreBeforeInput = pressedKeyCode == keyCodes.delete &&\n            inputType == 'insertText' &&\n            data == '\\x7f'; // Delete character :P\n        if (shouldIgnoreBeforeInput) {\n            evt.stop();\n        }\n    }, { priority: 'high' });\n    function isDeleteKeyCode(keyCode) {\n        return keyCode == keyCodes.backspace || keyCode == keyCodes.delete;\n    }\n    function getDeleteDirection(keyCode) {\n        return keyCode == keyCodes.backspace ? DELETE_BACKWARD : DELETE_FORWARD;\n    }\n}\n/**\n * Verifies whether the given target ranges cover more than a single character and should be used instead of a single code-point deletion.\n */\nfunction shouldUseTargetRanges(targetRanges) {\n    // The collapsed target range could happen for example while deleting inside an inline filler\n    // (it's mapped to collapsed position before an inline filler).\n    if (targetRanges.length != 1 || targetRanges[0].isCollapsed) {\n        return false;\n    }\n    const walker = targetRanges[0].getWalker({\n        direction: 'backward',\n        singleCharacters: true,\n        ignoreElementEnd: true\n    });\n    let count = 0;\n    for (const { nextPosition, item } of walker) {\n        if (nextPosition.parent.is('$text')) {\n            const data = nextPosition.parent.data;\n            const offset = nextPosition.offset;\n            // Count combined symbols and emoji sequences as a single character.\n            if (isInsideSurrogatePair(data, offset) ||\n                isInsideCombinedSymbol(data, offset) ||\n                isInsideEmojiSequence(data, offset)) {\n                continue;\n            }\n            count++;\n        }\n        else if (item.is('containerElement') || item.is('emptyElement')) {\n            count++;\n        }\n        if (count > 1) {\n            return true;\n        }\n    }\n    return false;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/delete\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport DeleteCommand from './deletecommand.js';\nimport DeleteObserver from './deleteobserver.js';\n/**\n * The delete and backspace feature. Handles keys such as <kbd>Delete</kbd> and <kbd>Backspace</kbd>, other\n * keystrokes and user actions that result in deleting content in the editor.\n */\nexport default class Delete extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Delete';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const modelDocument = editor.model.document;\n        view.addObserver(DeleteObserver);\n        this._undoOnBackspace = false;\n        const deleteForwardCommand = new DeleteCommand(editor, 'forward');\n        // Register `deleteForward` command and add `forwardDelete` command as an alias for backward compatibility.\n        editor.commands.add('deleteForward', deleteForwardCommand);\n        editor.commands.add('forwardDelete', deleteForwardCommand);\n        editor.commands.add('delete', new DeleteCommand(editor, 'backward'));\n        this.listenTo(viewDocument, 'delete', (evt, data) => {\n            // When not in composition, we handle the action, so prevent the default one.\n            // When in composition, it's the browser who modify the DOM (renderer is disabled).\n            if (!viewDocument.isComposing) {\n                data.preventDefault();\n            }\n            const { direction, sequence, selectionToRemove, unit } = data;\n            const commandName = direction === 'forward' ? 'deleteForward' : 'delete';\n            const commandData = { sequence };\n            if (unit == 'selection') {\n                const modelRanges = Array.from(selectionToRemove.getRanges()).map(viewRange => {\n                    return editor.editing.mapper.toModelRange(viewRange);\n                });\n                commandData.selection = editor.model.createSelection(modelRanges);\n            }\n            else {\n                commandData.unit = unit;\n            }\n            editor.execute(commandName, commandData);\n            view.scrollToTheSelection();\n        }, { priority: 'low' });\n        if (this.editor.plugins.has('UndoEditing')) {\n            this.listenTo(viewDocument, 'delete', (evt, data) => {\n                if (this._undoOnBackspace && data.direction == 'backward' && data.sequence == 1 && data.unit == 'codePoint') {\n                    this._undoOnBackspace = false;\n                    editor.execute('undo');\n                    data.preventDefault();\n                    evt.stop();\n                }\n            }, { context: '$capture' });\n            this.listenTo(modelDocument, 'change', () => {\n                this._undoOnBackspace = false;\n            });\n        }\n    }\n    /**\n     * If the next user action after calling this method is pressing backspace, it would undo the last change.\n     *\n     * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.\n     */\n    requestUndoOnBackspace() {\n        if (this.editor.plugins.has('UndoEditing')) {\n            this._undoOnBackspace = true;\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/typing\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport Input from './input.js';\nimport Delete from './delete.js';\n/**\n * The typing feature. It handles typing.\n *\n * This is a \"glue\" plugin which loads the {@link module:typing/input~Input} and {@link module:typing/delete~Delete}\n * plugins.\n */\nexport default class Typing extends Plugin {\n    static get requires() {\n        return [Input, Delete];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Typing';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Returns the last text line from the given range.\n *\n * \"The last text line\" is understood as text (from one or more text nodes) which is limited either by a parent block\n * or by inline elements (e.g. `<softBreak>`).\n *\n * ```ts\n * const rangeToCheck = model.createRange(\n * \tmodel.createPositionAt( paragraph, 0 ),\n * \tmodel.createPositionAt( paragraph, 'end' )\n * );\n *\n * const { text, range } = getLastTextLine( rangeToCheck, model );\n * ```\n *\n * For model below, the returned `text` will be \"Foo bar baz\" and `range` will be set on whole `<paragraph>` content:\n *\n * ```xml\n * <paragraph>Foo bar baz<paragraph>\n * ```\n *\n * However, in below case, `text` will be set to \"baz\" and `range` will be set only on \"baz\".\n *\n * ```xml\n * <paragraph>Foo<softBreak></softBreak>bar<softBreak></softBreak>baz<paragraph>\n * ```\n */\nexport default function getLastTextLine(range, model) {\n    let start = range.start;\n    const text = Array.from(range.getWalker({ ignoreElementEnd: false })).reduce((rangeText, { item }) => {\n        // Trim text to a last occurrence of an inline element and update range start.\n        if (!(item.is('$text') || item.is('$textProxy'))) {\n            start = model.createPositionAfter(item);\n            return '';\n        }\n        return rangeText + item.data;\n    }, '');\n    return { text, range: model.createRange(start, range.end) };\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/textwatcher\n */\nimport { ObservableMixin } from '@ckeditor/ckeditor5-utils';\nimport getLastTextLine from './utils/getlasttextline.js';\n/**\n * The text watcher feature.\n *\n * Fires the {@link module:typing/textwatcher~TextWatcher#event:matched:data `matched:data`},\n * {@link module:typing/textwatcher~TextWatcher#event:matched:selection `matched:selection`} and\n * {@link module:typing/textwatcher~TextWatcher#event:unmatched `unmatched`} events on typing or selection changes.\n */\nexport default class TextWatcher extends /* #__PURE__ */ ObservableMixin() {\n    /**\n     * Creates a text watcher instance.\n     *\n     * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.\n     */\n    constructor(model, testCallback) {\n        super();\n        this.model = model;\n        this.testCallback = testCallback;\n        this._hasMatch = false;\n        this.set('isEnabled', true);\n        // Toggle text watching on isEnabled state change.\n        this.on('change:isEnabled', () => {\n            if (this.isEnabled) {\n                this._startListening();\n            }\n            else {\n                this.stopListening(model.document.selection);\n                this.stopListening(model.document);\n            }\n        });\n        this._startListening();\n    }\n    /**\n     * Flag indicating whether there is a match currently.\n     */\n    get hasMatch() {\n        return this._hasMatch;\n    }\n    /**\n     * Starts listening to the editor for typing and selection events.\n     */\n    _startListening() {\n        const model = this.model;\n        const document = model.document;\n        this.listenTo(document.selection, 'change:range', (evt, { directChange }) => {\n            // Indirect changes (i.e. when the user types or external changes are applied) are handled in the document's change event.\n            if (!directChange) {\n                return;\n            }\n            // Act only on collapsed selection.\n            if (!document.selection.isCollapsed) {\n                if (this.hasMatch) {\n                    this.fire('unmatched');\n                    this._hasMatch = false;\n                }\n                return;\n            }\n            this._evaluateTextBeforeSelection('selection');\n        });\n        this.listenTo(document, 'change:data', (evt, batch) => {\n            if (batch.isUndo || !batch.isLocal) {\n                return;\n            }\n            this._evaluateTextBeforeSelection('data', { batch });\n        });\n    }\n    /**\n     * Checks the editor content for matched text.\n     *\n     * @fires matched:data\n     * @fires matched:selection\n     * @fires unmatched\n     *\n     * @param suffix A suffix used for generating the event name.\n     * @param data Data object for event.\n     */\n    _evaluateTextBeforeSelection(suffix, data = {}) {\n        const model = this.model;\n        const document = model.document;\n        const selection = document.selection;\n        const rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);\n        const { text, range } = getLastTextLine(rangeBeforeSelection, model);\n        const testResult = this.testCallback(text);\n        if (!testResult && this.hasMatch) {\n            this.fire('unmatched');\n        }\n        this._hasMatch = !!testResult;\n        if (testResult) {\n            const eventData = Object.assign(data, { text, range });\n            // If the test callback returns an object with additional data, assign the data as well.\n            if (typeof testResult == 'object') {\n                Object.assign(eventData, testResult);\n            }\n            this.fire(`matched:${suffix}`, eventData);\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module typing/texttransformation\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport TextWatcher from './textwatcher.js';\nimport { escapeRegExp } from 'lodash-es';\n// All named transformations.\nconst TRANSFORMATIONS = {\n    // Common symbols:\n    copyright: { from: '(c)', to: '©' },\n    registeredTrademark: { from: '(r)', to: '®' },\n    trademark: { from: '(tm)', to: '™' },\n    // Mathematical:\n    oneHalf: { from: /(^|[^/a-z0-9])(1\\/2)([^/a-z0-9])$/i, to: [null, '½', null] },\n    oneThird: { from: /(^|[^/a-z0-9])(1\\/3)([^/a-z0-9])$/i, to: [null, '⅓', null] },\n    twoThirds: { from: /(^|[^/a-z0-9])(2\\/3)([^/a-z0-9])$/i, to: [null, '⅔', null] },\n    oneForth: { from: /(^|[^/a-z0-9])(1\\/4)([^/a-z0-9])$/i, to: [null, '¼', null] },\n    threeQuarters: { from: /(^|[^/a-z0-9])(3\\/4)([^/a-z0-9])$/i, to: [null, '¾', null] },\n    lessThanOrEqual: { from: '<=', to: '≤' },\n    greaterThanOrEqual: { from: '>=', to: '≥' },\n    notEqual: { from: '!=', to: '≠' },\n    arrowLeft: { from: '<-', to: '←' },\n    arrowRight: { from: '->', to: '→' },\n    // Typography:\n    horizontalEllipsis: { from: '...', to: '…' },\n    enDash: { from: /(^| )(--)( )$/, to: [null, '–', null] },\n    emDash: { from: /(^| )(---)( )$/, to: [null, '—', null] },\n    // Quotations:\n    // English, US\n    quotesPrimary: { from: buildQuotesRegExp('\"'), to: [null, '“', null, '”'] },\n    quotesSecondary: { from: buildQuotesRegExp('\\''), to: [null, '‘', null, '’'] },\n    // English, UK\n    quotesPrimaryEnGb: { from: buildQuotesRegExp('\\''), to: [null, '‘', null, '’'] },\n    quotesSecondaryEnGb: { from: buildQuotesRegExp('\"'), to: [null, '“', null, '”'] },\n    // Polish\n    quotesPrimaryPl: { from: buildQuotesRegExp('\"'), to: [null, '„', null, '”'] },\n    quotesSecondaryPl: { from: buildQuotesRegExp('\\''), to: [null, '‚', null, '’'] }\n};\n// Transformation groups.\nconst TRANSFORMATION_GROUPS = {\n    symbols: ['copyright', 'registeredTrademark', 'trademark'],\n    mathematical: [\n        'oneHalf', 'oneThird', 'twoThirds', 'oneForth', 'threeQuarters',\n        'lessThanOrEqual', 'greaterThanOrEqual', 'notEqual',\n        'arrowLeft', 'arrowRight'\n    ],\n    typography: ['horizontalEllipsis', 'enDash', 'emDash'],\n    quotes: ['quotesPrimary', 'quotesSecondary']\n};\n// A set of default transformations provided by the feature.\nconst DEFAULT_TRANSFORMATIONS = [\n    'symbols',\n    'mathematical',\n    'typography',\n    'quotes'\n];\n/**\n * The text transformation plugin.\n */\nexport default class TextTransformation extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return ['Delete', 'Input'];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'TextTransformation';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        super(editor);\n        editor.config.define('typing', {\n            transformations: {\n                include: DEFAULT_TRANSFORMATIONS\n            }\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const model = this.editor.model;\n        const modelSelection = model.document.selection;\n        modelSelection.on('change:range', () => {\n            // Disable plugin when selection is inside a code block.\n            this.isEnabled = !modelSelection.anchor.parent.is('element', 'codeBlock');\n        });\n        this._enableTransformationWatchers();\n    }\n    /**\n     * Create new TextWatcher listening to the editor for typing and selection events.\n     */\n    _enableTransformationWatchers() {\n        const editor = this.editor;\n        const model = editor.model;\n        const deletePlugin = editor.plugins.get('Delete');\n        const normalizedTransformations = normalizeTransformations(editor.config.get('typing.transformations'));\n        const testCallback = (text) => {\n            for (const normalizedTransformation of normalizedTransformations) {\n                const from = normalizedTransformation.from;\n                const match = from.test(text);\n                if (match) {\n                    return { normalizedTransformation };\n                }\n            }\n        };\n        const watcher = new TextWatcher(editor.model, testCallback);\n        watcher.on('matched:data', (evt, data) => {\n            if (!data.batch.isTyping) {\n                return;\n            }\n            const { from, to } = data.normalizedTransformation;\n            const matches = from.exec(data.text);\n            const replaces = to(matches.slice(1));\n            const matchedRange = data.range;\n            let changeIndex = matches.index;\n            model.enqueueChange(writer => {\n                for (let i = 1; i < matches.length; i++) {\n                    const match = matches[i];\n                    const replaceWith = replaces[i - 1];\n                    if (replaceWith == null) {\n                        changeIndex += match.length;\n                        continue;\n                    }\n                    const replacePosition = matchedRange.start.getShiftedBy(changeIndex);\n                    const replaceRange = model.createRange(replacePosition, replacePosition.getShiftedBy(match.length));\n                    const attributes = getTextAttributesAfterPosition(replacePosition);\n                    model.insertContent(writer.createText(replaceWith, attributes), replaceRange);\n                    changeIndex += replaceWith.length;\n                }\n                model.enqueueChange(() => {\n                    deletePlugin.requestUndoOnBackspace();\n                });\n            });\n        });\n        watcher.bind('isEnabled').to(this);\n    }\n}\n/**\n * Normalizes the configuration `from` parameter value.\n * The normalized value for the `from` parameter is a RegExp instance. If the passed `from` is already a RegExp instance,\n * it is returned unchanged.\n */\nfunction normalizeFrom(from) {\n    if (typeof from == 'string') {\n        return new RegExp(`(${escapeRegExp(from)})$`);\n    }\n    // `from` is already a regular expression.\n    return from;\n}\n/**\n * Normalizes the configuration `to` parameter value.\n * The normalized value for the `to` parameter is a function that takes an array and returns an array. See more in the\n * configuration description. If the passed `to` is already a function, it is returned unchanged.\n */\nfunction normalizeTo(to) {\n    if (typeof to == 'string') {\n        return () => [to];\n    }\n    else if (to instanceof Array) {\n        return () => to;\n    }\n    // `to` is already a function.\n    return to;\n}\n/**\n * For given `position` returns attributes for the text that is after that position.\n * The text can be in the same text node as the position (`foo[]bar`) or in the next text node (`foo[]<$text bold=\"true\">bar</$text>`).\n */\nfunction getTextAttributesAfterPosition(position) {\n    const textNode = position.textNode ? position.textNode : position.nodeAfter;\n    return textNode.getAttributes();\n}\n/**\n * Returns a RegExp pattern string that detects a sentence inside a quote.\n *\n * @param quoteCharacter The character to create a pattern for.\n */\nfunction buildQuotesRegExp(quoteCharacter) {\n    return new RegExp(`(^|\\\\s)(${quoteCharacter})([^${quoteCharacter}]*)(${quoteCharacter})$`);\n}\n/**\n * Reads text transformation config and returns normalized array of transformations objects.\n */\nfunction normalizeTransformations(config) {\n    const extra = config.extra || [];\n    const remove = config.remove || [];\n    const isNotRemoved = (transformation) => !remove.includes(transformation);\n    const configured = config.include.concat(extra).filter(isNotRemoved);\n    return expandGroupsAndRemoveDuplicates(configured)\n        .filter(isNotRemoved) // Filter out 'remove' transformations as they might be set in group.\n        .map(transformation => (typeof transformation == 'string' && TRANSFORMATIONS[transformation] ? TRANSFORMATIONS[transformation] : transformation))\n        // Filter out transformations set as string that has not been found.\n        .filter((transformation) => typeof transformation === 'object')\n        .map(transformation => ({\n        from: normalizeFrom(transformation.from),\n        to: normalizeTo(transformation.to)\n    }));\n}\n/**\n * Reads definitions and expands named groups if needed to transformation names.\n * This method also removes duplicated named transformations if any.\n */\nfunction expandGroupsAndRemoveDuplicates(definitions) {\n    // Set is using to make sure that transformation names are not duplicated.\n    const definedTransformations = new Set();\n    for (const transformationOrGroup of definitions) {\n        if (typeof transformationOrGroup == 'string' && TRANSFORMATION_GROUPS[transformationOrGroup]) {\n            for (const transformation of TRANSFORMATION_GROUPS[transformationOrGroup]) {\n                definedTransformations.add(transformation);\n            }\n        }\n        else {\n            definedTransformations.add(transformationOrGroup);\n        }\n    }\n    return Array.from(definedTransformations);\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * Returns attributes that should be preserved on the enter keystroke.\n *\n * Filtering is realized based on `copyOnEnter` attribute property. Read more about attribute properties\n * {@link module:engine/model/schema~Schema#setAttributeProperties here}.\n *\n * @param schema Model's schema.\n * @param allAttributes Attributes to filter.\n */\nexport function* getCopyOnEnterAttributes(schema, allAttributes) {\n    for (const attribute of allAttributes) {\n        if (attribute && schema.getAttributeProperties(attribute[0]).copyOnEnter) {\n            yield attribute;\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module enter/entercommand\n */\nimport { Command } from '@ckeditor/ckeditor5-core';\nimport { getCopyOnEnterAttributes } from './utils.js';\n/**\n * Enter command used by the {@link module:enter/enter~Enter Enter feature} to handle the <kbd>Enter</kbd> keystroke.\n */\nexport default class EnterCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    execute() {\n        this.editor.model.change(writer => {\n            this.enterBlock(writer);\n            this.fire('afterExecute', { writer });\n        });\n    }\n    /**\n     * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:\n     *\n     * ```\n     * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>\n     * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>\n     * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>\n     * ```\n     *\n     * In some cases, the split will not happen:\n     *\n     * ```\n     * // The selection parent is a limit element:\n     * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>\n     *\n     * // The selection spans over multiple elements:\n     * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>\n     * ```\n     *\n     * @param writer Writer to use when performing the enter action.\n     * @returns Boolean indicating if the block was split.\n     */\n    enterBlock(writer) {\n        const model = this.editor.model;\n        const selection = model.document.selection;\n        const schema = model.schema;\n        const isSelectionEmpty = selection.isCollapsed;\n        const range = selection.getFirstRange();\n        const startElement = range.start.parent;\n        const endElement = range.end.parent;\n        // Don't touch the roots and other limit elements.\n        if (schema.isLimit(startElement) || schema.isLimit(endElement)) {\n            // Delete the selected content but only if inside a single limit element.\n            // Abort, when crossing limit elements boundary (e.g. <limit1>x[x</limit1>donttouchme<limit2>y]y</limit2>).\n            // This is an edge case and it's hard to tell what should actually happen because such a selection\n            // is not entirely valid.\n            if (!isSelectionEmpty && startElement == endElement) {\n                model.deleteContent(selection);\n            }\n            return false;\n        }\n        if (isSelectionEmpty) {\n            const attributesToCopy = getCopyOnEnterAttributes(writer.model.schema, selection.getAttributes());\n            splitBlock(writer, range.start);\n            writer.setSelectionAttribute(attributesToCopy);\n            return true;\n        }\n        else {\n            const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);\n            const isContainedWithinOneElement = (startElement == endElement);\n            model.deleteContent(selection, { leaveUnmerged });\n            if (leaveUnmerged) {\n                // Partially selected elements.\n                //\n                // <h>x[xx]x</h>\t\t-> <h>x^x</h>\t\t\t-> <h>x</h><h>^x</h>\n                if (isContainedWithinOneElement) {\n                    splitBlock(writer, selection.focus);\n                    return true;\n                }\n                // Selection over multiple elements.\n                //\n                // <h>x[x</h><p>y]y<p>\t-> <h>x^</h><p>y</p>\t-> <h>x</h><p>^y</p>\n                else {\n                    writer.setSelection(endElement, 0);\n                }\n            }\n        }\n        return false;\n    }\n}\nfunction splitBlock(writer, splitPos) {\n    writer.split(splitPos);\n    writer.setSelection(splitPos.parent.nextSibling, 0);\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module enter/enterobserver\n */\nimport { Observer, DomEventData, BubblingEventInfo } from '@ckeditor/ckeditor5-engine';\nimport { env } from '@ckeditor/ckeditor5-utils';\nconst ENTER_EVENT_TYPES = {\n    insertParagraph: { isSoft: false },\n    insertLineBreak: { isSoft: true }\n};\n/**\n * Enter observer introduces the {@link module:engine/view/document~Document#event:enter `Document#enter`} event.\n */\nexport default class EnterObserver extends Observer {\n    /**\n     * @inheritDoc\n     */\n    constructor(view) {\n        super(view);\n        const doc = this.document;\n        let shiftPressed = false;\n        doc.on('keydown', (evt, data) => {\n            shiftPressed = data.shiftKey;\n        });\n        doc.on('beforeinput', (evt, data) => {\n            if (!this.isEnabled) {\n                return;\n            }\n            let inputType = data.inputType;\n            // See https://github.com/ckeditor/ckeditor5/issues/13321.\n            if (env.isSafari && shiftPressed && inputType == 'insertParagraph') {\n                inputType = 'insertLineBreak';\n            }\n            const domEvent = data.domEvent;\n            const enterEventSpec = ENTER_EVENT_TYPES[inputType];\n            if (!enterEventSpec) {\n                return;\n            }\n            const event = new BubblingEventInfo(doc, 'enter', data.targetRanges[0]);\n            doc.fire(event, new DomEventData(view, domEvent, {\n                isSoft: enterEventSpec.isSoft\n            }));\n            // Stop `beforeinput` event if `enter` event was stopped.\n            // https://github.com/ckeditor/ckeditor5/issues/753\n            if (event.stop.called) {\n                evt.stop();\n            }\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    observe() { }\n    /**\n     * @inheritDoc\n     */\n    stopObserving() { }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module enter/enter\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport EnterCommand from './entercommand.js';\nimport EnterObserver from './enterobserver.js';\n/**\n * This plugin handles the <kbd>Enter</kbd> keystroke (hard line break) in the editor.\n *\n * See also the {@link module:enter/shiftenter~ShiftEnter} plugin.\n *\n * For more information about this feature see the {@glink api/enter package page}.\n */\nexport default class Enter extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Enter';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const t = this.editor.t;\n        view.addObserver(EnterObserver);\n        editor.commands.add('enter', new EnterCommand(editor));\n        this.listenTo(viewDocument, 'enter', (evt, data) => {\n            // When not in composition, we handle the action, so prevent the default one.\n            // When in composition, it's the browser who modify the DOM (renderer is disabled).\n            if (!viewDocument.isComposing) {\n                data.preventDefault();\n            }\n            // The soft enter key is handled by the ShiftEnter plugin.\n            if (data.isSoft) {\n                return;\n            }\n            editor.execute('enter');\n            view.scrollToTheSelection();\n        }, { priority: 'low' });\n        // Add the information about the keystroke to the accessibility database.\n        editor.accessibility.addKeystrokeInfos({\n            keystrokes: [\n                {\n                    label: t('Insert a hard break (a new paragraph)'),\n                    keystroke: 'Enter'\n                }\n            ]\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module enter/shiftentercommand\n */\nimport { Command } from '@ckeditor/ckeditor5-core';\nimport { getCopyOnEnterAttributes } from './utils.js';\n/**\n * ShiftEnter command. It is used by the {@link module:enter/shiftenter~ShiftEnter ShiftEnter feature} to handle\n * the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke.\n */\nexport default class ShiftEnterCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    execute() {\n        const model = this.editor.model;\n        const doc = model.document;\n        model.change(writer => {\n            softBreakAction(model, writer, doc.selection);\n            this.fire('afterExecute', { writer });\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        const model = this.editor.model;\n        const doc = model.document;\n        this.isEnabled = isEnabled(model.schema, doc.selection);\n    }\n}\n/**\n * Checks whether the ShiftEnter command should be enabled in the specified selection.\n */\nfunction isEnabled(schema, selection) {\n    // At this moment it is okay to support single range selections only.\n    // But in the future we may need to change that.\n    if (selection.rangeCount > 1) {\n        return false;\n    }\n    const anchorPos = selection.anchor;\n    // Check whether the break element can be inserted in the current selection anchor.\n    if (!anchorPos || !schema.checkChild(anchorPos, 'softBreak')) {\n        return false;\n    }\n    const range = selection.getFirstRange();\n    const startElement = range.start.parent;\n    const endElement = range.end.parent;\n    // Do not modify the content if selection is cross-limit elements.\n    if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {\n        return false;\n    }\n    return true;\n}\n/**\n * Creates a break in the way that the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke is expected to work.\n */\nfunction softBreakAction(model, writer, selection) {\n    const isSelectionEmpty = selection.isCollapsed;\n    const range = selection.getFirstRange();\n    const startElement = range.start.parent;\n    const endElement = range.end.parent;\n    const isContainedWithinOneElement = (startElement == endElement);\n    if (isSelectionEmpty) {\n        const attributesToCopy = getCopyOnEnterAttributes(model.schema, selection.getAttributes());\n        insertBreak(model, writer, range.end);\n        writer.removeSelectionAttribute(selection.getAttributeKeys());\n        writer.setSelectionAttribute(attributesToCopy);\n    }\n    else {\n        const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);\n        model.deleteContent(selection, { leaveUnmerged });\n        // Selection within one element:\n        //\n        // <h>x[xx]x</h>\t\t-> <h>x^x</h>\t\t\t-> <h>x<br>^x</h>\n        if (isContainedWithinOneElement) {\n            insertBreak(model, writer, selection.focus);\n        }\n        // Selection over multiple elements.\n        //\n        // <h>x[x</h><p>y]y<p>\t-> <h>x^</h><p>y</p>\t-> <h>x</h><p>^y</p>\n        //\n        // We chose not to insert a line break in this case because:\n        //\n        // * it's not a very common scenario,\n        // * it actually surprised me when I saw the \"expected behavior\" in real life.\n        //\n        // It's ok if the user will need to be more specific where they want the <br> to be inserted.\n        else {\n            // Move the selection to the 2nd element (last step of the example above).\n            if (leaveUnmerged) {\n                writer.setSelection(endElement, 0);\n            }\n        }\n    }\n}\nfunction insertBreak(model, writer, position) {\n    const breakLineElement = writer.createElement('softBreak');\n    model.insertContent(breakLineElement, position);\n    writer.setSelection(breakLineElement, 'after');\n}\n/**\n * Checks whether the specified `element` is a child of the limit element.\n *\n * Checking whether the `<p>` element is inside a limit element:\n *   - `<$root><p>Text.</p></$root> => false`\n *   - `<$root><limitElement><p>Text</p></limitElement></$root> => true`\n */\nfunction isInsideLimitElement(element, schema) {\n    // `$root` is a limit element but in this case is an invalid element.\n    if (element.is('rootElement')) {\n        return false;\n    }\n    return schema.isLimit(element) || isInsideLimitElement(element.parent, schema);\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module enter/shiftenter\n */\nimport ShiftEnterCommand from './shiftentercommand.js';\nimport EnterObserver from './enterobserver.js';\nimport { Plugin } from '@ckeditor/ckeditor5-core';\n/**\n * This plugin handles the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke (soft line break) in the editor.\n *\n * See also the {@link module:enter/enter~Enter} plugin.\n *\n * For more information about this feature see the {@glink api/enter package page}.\n */\nexport default class ShiftEnter extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'ShiftEnter';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    init() {\n        const editor = this.editor;\n        const schema = editor.model.schema;\n        const conversion = editor.conversion;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const t = this.editor.t;\n        // Configure the schema.\n        schema.register('softBreak', {\n            allowWhere: '$text',\n            isInline: true\n        });\n        // Configure converters.\n        conversion.for('upcast')\n            .elementToElement({\n            model: 'softBreak',\n            view: 'br'\n        });\n        conversion.for('downcast')\n            .elementToElement({\n            model: 'softBreak',\n            view: (modelElement, { writer }) => writer.createEmptyElement('br')\n        });\n        view.addObserver(EnterObserver);\n        editor.commands.add('shiftEnter', new ShiftEnterCommand(editor));\n        this.listenTo(viewDocument, 'enter', (evt, data) => {\n            // When not in composition, we handle the action, so prevent the default one.\n            // When in composition, it's the browser who modify the DOM (renderer is disabled).\n            if (!viewDocument.isComposing) {\n                data.preventDefault();\n            }\n            // The hard enter key is handled by the Enter plugin.\n            if (!data.isSoft) {\n                return;\n            }\n            editor.execute('shiftEnter');\n            view.scrollToTheSelection();\n        }, { priority: 'low' });\n        // Add the information about the keystroke to the accessibility database.\n        editor.accessibility.addKeystrokeInfos({\n            keystrokes: [\n                {\n                    label: t('Insert a soft break (a <code>&lt;br&gt;</code> element)'),\n                    keystroke: 'Shift+Enter'\n                }\n            ]\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/highlightstack\n */\nimport { EmitterMixin } from '@ckeditor/ckeditor5-utils';\n/**\n * Class used to handle the correct order of highlights on elements.\n *\n * When different highlights are applied to same element the correct order should be preserved:\n *\n * * highlight with highest priority should be applied,\n * * if two highlights have same priority - sort by CSS class provided in\n * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n *\n * This way, highlight will be applied with the same rules it is applied on texts.\n */\nexport default class HighlightStack extends /* #__PURE__ */ EmitterMixin() {\n    constructor() {\n        super(...arguments);\n        this._stack = [];\n    }\n    /**\n     * Adds highlight descriptor to the stack.\n     *\n     * @fires change:top\n     */\n    add(descriptor, writer) {\n        const stack = this._stack;\n        // Save top descriptor and insert new one. If top is changed - fire event.\n        const oldTop = stack[0];\n        this._insertDescriptor(descriptor);\n        const newTop = stack[0];\n        // When new object is at the top and stores different information.\n        if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {\n            this.fire('change:top', {\n                oldDescriptor: oldTop,\n                newDescriptor: newTop,\n                writer\n            });\n        }\n    }\n    /**\n     * Removes highlight descriptor from the stack.\n     *\n     * @fires change:top\n     * @param id Id of the descriptor to remove.\n     */\n    remove(id, writer) {\n        const stack = this._stack;\n        const oldTop = stack[0];\n        this._removeDescriptor(id);\n        const newTop = stack[0];\n        // When new object is at the top and stores different information.\n        if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {\n            this.fire('change:top', {\n                oldDescriptor: oldTop,\n                newDescriptor: newTop,\n                writer\n            });\n        }\n    }\n    /**\n     * Inserts a given descriptor in correct place in the stack. It also takes care about updating information\n     * when descriptor with same id is already present.\n     */\n    _insertDescriptor(descriptor) {\n        const stack = this._stack;\n        const index = stack.findIndex(item => item.id === descriptor.id);\n        // Inserting exact same descriptor - do nothing.\n        if (compareDescriptors(descriptor, stack[index])) {\n            return;\n        }\n        // If descriptor with same id but with different information is on the stack - remove it.\n        if (index > -1) {\n            stack.splice(index, 1);\n        }\n        // Find correct place to insert descriptor in the stack.\n        // It has different information (for example priority) so it must be re-inserted in correct place.\n        let i = 0;\n        while (stack[i] && shouldABeBeforeB(stack[i], descriptor)) {\n            i++;\n        }\n        stack.splice(i, 0, descriptor);\n    }\n    /**\n     * Removes descriptor with given id from the stack.\n     *\n     * @param id Descriptor's id.\n     */\n    _removeDescriptor(id) {\n        const stack = this._stack;\n        const index = stack.findIndex(item => item.id === id);\n        // If descriptor with same id is on the list - remove it.\n        if (index > -1) {\n            stack.splice(index, 1);\n        }\n    }\n}\n/**\n * Compares two descriptors by checking their priority and class list.\n *\n * @returns Returns true if both descriptors are defined and have same priority and classes.\n */\nfunction compareDescriptors(a, b) {\n    return a && b && a.priority == b.priority && classesToString(a.classes) == classesToString(b.classes);\n}\n/**\n * Checks whenever first descriptor should be placed in the stack before second one.\n */\nfunction shouldABeBeforeB(a, b) {\n    if (a.priority > b.priority) {\n        return true;\n    }\n    else if (a.priority < b.priority) {\n        return false;\n    }\n    // When priorities are equal and names are different - use classes to compare.\n    return classesToString(a.classes) > classesToString(b.classes);\n}\n/**\n * Converts CSS classes passed with {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} to\n * sorted string.\n */\nfunction classesToString(classes) {\n    return Array.isArray(classes) ? classes.sort().join(',') : classes;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/utils\n */\nimport { Rect, CKEditorError, toArray } from '@ckeditor/ckeditor5-utils';\nimport { IconView } from '@ckeditor/ckeditor5-ui';\nimport HighlightStack from './highlightstack.js';\nimport { getTypeAroundFakeCaretPosition } from './widgettypearound/utils.js';\nimport dragHandleIcon from '../theme/icons/drag-handle.svg';\n/**\n * CSS class added to each widget element.\n */\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n/**\n * CSS class added to currently selected widget element.\n */\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n */\nexport function isWidget(node) {\n    if (!node.is('element')) {\n        return false;\n    }\n    return !!node.getCustomProperty('widget');\n}\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"false\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n * ```ts\n * editor.conversion.for( 'editingDowncast' )\n * \t.elementToElement( {\n * \t\tmodel: 'widget',\n * \t\tview: ( modelItem, { writer } ) => {\n * \t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n * \t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n * \t\t}\n * \t} );\n *\n * editor.conversion.for( 'dataDowncast' )\n * \t.elementToElement( {\n * \t\tmodel: 'widget',\n * \t\tview: ( modelItem, { writer } ) => {\n * \t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n * \t\t}\n * \t} );\n * ```\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param options Additional options.\n * @param options.label Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param options.hasSelectionHandle If `true`, the widget will have a selection handle added.\n * @returns Returns the same element.\n */\nexport function toWidget(element, writer, options = {}) {\n    if (!element.is('containerElement')) {\n        /**\n         * The element passed to `toWidget()` must be a {@link module:engine/view/containerelement~ContainerElement}\n         * instance.\n         *\n         * @error widget-to-widget-wrong-element-type\n         * @param element The view element passed to `toWidget()`.\n         */\n        throw new CKEditorError('widget-to-widget-wrong-element-type', null, { element });\n    }\n    writer.setAttribute('contenteditable', 'false', element);\n    writer.addClass(WIDGET_CLASS_NAME, element);\n    writer.setCustomProperty('widget', true, element);\n    element.getFillerOffset = getFillerOffset;\n    writer.setCustomProperty('widgetLabel', [], element);\n    if (options.label) {\n        setLabel(element, options.label);\n    }\n    if (options.hasSelectionHandle) {\n        addSelectionHandle(element, writer);\n    }\n    setHighlightHandling(element, writer);\n    return element;\n}\n/**\n * Default handler for adding a highlight on a widget.\n * It adds CSS class and attributes basing on the given highlight descriptor.\n */\nfunction addHighlight(element, descriptor, writer) {\n    if (descriptor.classes) {\n        writer.addClass(toArray(descriptor.classes), element);\n    }\n    if (descriptor.attributes) {\n        for (const key in descriptor.attributes) {\n            writer.setAttribute(key, descriptor.attributes[key], element);\n        }\n    }\n}\n/**\n * Default handler for removing a highlight from a widget.\n * It removes CSS class and attributes basing on the given highlight descriptor.\n */\nfunction removeHighlight(element, descriptor, writer) {\n    if (descriptor.classes) {\n        writer.removeClass(toArray(descriptor.classes), element);\n    }\n    if (descriptor.attributes) {\n        for (const key in descriptor.attributes) {\n            writer.removeAttribute(key, element);\n        }\n    }\n}\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n */\nexport function setHighlightHandling(element, writer, add = addHighlight, remove = removeHighlight) {\n    const stack = new HighlightStack();\n    stack.on('change:top', (evt, data) => {\n        if (data.oldDescriptor) {\n            remove(element, data.oldDescriptor, data.writer);\n        }\n        if (data.newDescriptor) {\n            add(element, data.newDescriptor, data.writer);\n        }\n    });\n    const addHighlightCallback = (element, descriptor, writer) => stack.add(descriptor, writer);\n    const removeHighlightCallback = (element, id, writer) => stack.remove(id, writer);\n    writer.setCustomProperty('addHighlight', addHighlightCallback, element);\n    writer.setCustomProperty('removeHighlight', removeHighlightCallback, element);\n}\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n */\nexport function setLabel(element, labelOrCreator) {\n    const widgetLabel = element.getCustomProperty('widgetLabel');\n    widgetLabel.push(labelOrCreator);\n}\n/**\n * Returns the label of the provided element.\n */\nexport function getLabel(element) {\n    const widgetLabel = element.getCustomProperty('widgetLabel');\n    return widgetLabel.reduce((prev, current) => {\n        if (typeof current === 'function') {\n            return prev ? prev + '. ' + current() : current();\n        }\n        else {\n            return prev ? prev + '. ' + current : current;\n        }\n    }, '');\n}\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n * * implements the {@link ~setHighlightHandling view highlight on widget's editable}.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `editingDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n * ```ts\n * editor.conversion.for( 'editingDowncast' )\n * \t.elementToElement( {\n * \t\tmodel: 'nested',\n * \t\tview: ( modelItem, { writer } ) => {\n * \t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n * \t\t\treturn toWidgetEditable( nested, writer, { label: 'label for editable' } );\n * \t\t}\n * \t} );\n *\n * editor.conversion.for( 'dataDowncast' )\n * \t.elementToElement( {\n * \t\tmodel: 'nested',\n * \t\tview: ( modelItem, { writer } ) => {\n * \t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n * \t\t}\n * \t} );\n * ```\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param options Additional options.\n * @param options.label Editable's label used by assistive technologies (e.g. screen readers).\n * @returns Returns the same element that was provided in the `editable` parameter\n */\nexport function toWidgetEditable(editable, writer, options = {}) {\n    writer.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], editable);\n    writer.setAttribute('role', 'textbox', editable);\n    writer.setAttribute('tabindex', '-1', editable);\n    if (options.label) {\n        writer.setAttribute('aria-label', options.label, editable);\n    }\n    // Set initial contenteditable value.\n    writer.setAttribute('contenteditable', editable.isReadOnly ? 'false' : 'true', editable);\n    // Bind the contenteditable property to element#isReadOnly.\n    editable.on('change:isReadOnly', (evt, property, is) => {\n        writer.setAttribute('contenteditable', is ? 'false' : 'true', editable);\n    });\n    editable.on('change:isFocused', (evt, property, is) => {\n        if (is) {\n            writer.addClass('ck-editor__nested-editable_focused', editable);\n        }\n        else {\n            writer.removeClass('ck-editor__nested-editable_focused', editable);\n        }\n    });\n    setHighlightHandling(editable, writer);\n    return editable;\n}\n/**\n * Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the collapsed range after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n * by the inserted widget block.\n *\n * @param selection The selection based on which the insertion position should be calculated.\n * @param model Model instance.\n * @returns The optimal range.\n */\nexport function findOptimalInsertionRange(selection, model) {\n    const selectedElement = selection.getSelectedElement();\n    if (selectedElement) {\n        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection);\n        // If the WidgetTypeAround \"fake caret\" is displayed, use its position for the insertion\n        // to provide the most predictable UX (https://github.com/ckeditor/ckeditor5/issues/7438).\n        if (typeAroundFakeCaretPosition) {\n            return model.createRange(model.createPositionAt(selectedElement, typeAroundFakeCaretPosition));\n        }\n    }\n    return model.schema.findOptimalInsertionRange(selection);\n}\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n * ```\n * // Model:\n * <placeholder type=\"name\"></placeholder>\n *\n * // View:\n * <span class=\"placeholder\">name</span>\n * ```\n *\n * In such case, view positions inside `<span>` cannot be correctly mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n * ```ts\n * editor.editing.mapper.on(\n * \t'viewToModelPosition',\n * \tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n * );\n * ```\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n * ```\n * // View:\n * <p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n * // Model:\n * <paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n * ```\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n * ```\n * // View:\n * <p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n * // Model:\n * <paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n * ```\n *\n * @param model Model instance on which the callback operates.\n * @param viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n */\nexport function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {\n    return (evt, data) => {\n        const { mapper, viewPosition } = data;\n        const viewParent = mapper.findMappedViewAncestor(viewPosition);\n        if (!viewElementMatcher(viewParent)) {\n            return;\n        }\n        const modelParent = mapper.toModelElement(viewParent);\n        data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? 'before' : 'after');\n    };\n}\n/**\n * Default filler offset function applied to all widget elements.\n */\nfunction getFillerOffset() {\n    return null;\n}\n/**\n * Adds a drag handle to the widget.\n */\nfunction addSelectionHandle(widgetElement, writer) {\n    const selectionHandle = writer.createUIElement('div', { class: 'ck ck-widget__selection-handle' }, function (domDocument) {\n        const domElement = this.toDomElement(domDocument);\n        // Use the IconView from the ui library.\n        const icon = new IconView();\n        icon.set('content', dragHandleIcon);\n        // Render the icon view right away to append its #element to the selectionHandle DOM element.\n        icon.render();\n        domElement.appendChild(icon.element);\n        return domElement;\n    });\n    // Append the selection handle into the widget wrapper.\n    writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);\n    writer.addClass(['ck-widget_with-selection-handle'], widgetElement);\n}\n/**\n * Starting from a DOM resize host element (an element that receives dimensions as a result of resizing),\n * this helper returns the width of the found ancestor element.\n *\n *\t* It searches up to 5 levels of ancestors only.\n *\n * @param domResizeHost Resize host DOM element that receives dimensions as a result of resizing.\n * @returns Width of ancestor element in pixels or 0 if no ancestor with a computed width has been found.\n */\nexport function calculateResizeHostAncestorWidth(domResizeHost) {\n    const getElementComputedWidth = (element) => {\n        const { width, paddingLeft, paddingRight } = element.ownerDocument.defaultView.getComputedStyle(element);\n        return parseFloat(width) - (parseFloat(paddingLeft) || 0) - (parseFloat(paddingRight) || 0);\n    };\n    const domResizeHostParent = domResizeHost.parentElement;\n    if (!domResizeHostParent) {\n        return 0;\n    }\n    // Need to use computed style as it properly excludes parent's paddings from the returned value.\n    let parentWidth = getElementComputedWidth(domResizeHostParent);\n    // Sometimes parent width cannot be accessed. If that happens we should go up in the elements tree\n    // and try to get width from next ancestor.\n    // https://github.com/ckeditor/ckeditor5/issues/10776\n    const ancestorLevelLimit = 5;\n    let currentLevel = 0;\n    let checkedElement = domResizeHostParent;\n    while (isNaN(parentWidth)) {\n        checkedElement = checkedElement.parentElement;\n        if (++currentLevel > ancestorLevelLimit) {\n            return 0;\n        }\n        parentWidth = getElementComputedWidth(checkedElement);\n    }\n    return parentWidth;\n}\n/**\n * Calculates a relative width of a `domResizeHost` compared to its ancestor in percents.\n *\n * @param domResizeHost Resize host DOM element.\n * @returns Percentage value between 0 and 100.\n */\nexport function calculateResizeHostPercentageWidth(domResizeHost, resizeHostRect = new Rect(domResizeHost)) {\n    const parentWidth = calculateResizeHostAncestorWidth(domResizeHost);\n    if (!parentWidth) {\n        return 0;\n    }\n    return resizeHostRect.width / parentWidth * 100;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgettypearound/utils\n */\nimport { isWidget } from '../utils.js';\n/**\n * The name of the type around model selection attribute responsible for\n * displaying a fake caret next to a selected widget.\n */\nexport const TYPE_AROUND_SELECTION_ATTRIBUTE = 'widget-type-around';\n/**\n * Checks if an element is a widget that qualifies to get the widget type around UI.\n */\nexport function isTypeAroundWidget(viewElement, modelElement, schema) {\n    return !!viewElement && isWidget(viewElement) && !schema.isInline(modelElement);\n}\n/**\n * For the passed HTML element, this helper finds the closest widget type around button ancestor.\n */\nexport function getClosestTypeAroundDomButton(domElement) {\n    return domElement.closest('.ck-widget__type-around__button');\n}\n/**\n * For the passed widget type around button element, this helper determines at which position\n * the paragraph would be inserted into the content if, for instance, the button was\n * clicked by the user.\n *\n * @returns The position of the button.\n */\nexport function getTypeAroundButtonPosition(domElement) {\n    return domElement.classList.contains('ck-widget__type-around__button_before') ? 'before' : 'after';\n}\n/**\n * For the passed HTML element, this helper returns the closest view widget ancestor.\n */\nexport function getClosestWidgetViewElement(domElement, domConverter) {\n    const widgetDomElement = domElement.closest('.ck-widget');\n    return domConverter.mapDomToView(widgetDomElement);\n}\n/**\n * For the passed selection instance, it returns the position of the fake caret displayed next to a widget.\n *\n * **Note**: If the fake caret is not currently displayed, `null` is returned.\n *\n * @returns The position of the fake caret or `null` when none is present.\n */\nexport function getTypeAroundFakeCaretPosition(selection) {\n    return selection.getAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/* global DOMParser */\n/**\n * @module widget/widgettypearound/widgettypearound\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { Template } from '@ckeditor/ckeditor5-ui';\nimport { Enter } from '@ckeditor/ckeditor5-enter';\nimport { Delete } from '@ckeditor/ckeditor5-typing';\nimport { env, isForwardArrowKeyCode } from '@ckeditor/ckeditor5-utils';\nimport { isTypeAroundWidget, getClosestTypeAroundDomButton, getTypeAroundButtonPosition, getClosestWidgetViewElement, getTypeAroundFakeCaretPosition, TYPE_AROUND_SELECTION_ATTRIBUTE } from './utils.js';\nimport { isWidget } from '../utils.js';\nimport returnIcon from '../../theme/icons/return-arrow.svg';\nimport '../../theme/widgettypearound.css';\nconst POSSIBLE_INSERTION_POSITIONS = ['before', 'after'];\n// Do the SVG parsing once and then clone the result <svg> DOM element for each new button.\nconst RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, 'image/svg+xml').firstChild;\nconst PLUGIN_DISABLED_EDITING_ROOT_CLASS = 'ck-widget__type-around_disabled';\n/**\n * A plugin that allows users to type around widgets where normally it is impossible to place the caret due\n * to limitations of web browsers. These \"tight spots\" occur, for instance, before (or after) a widget being\n * the first (or last) child of its parent or between two block widgets.\n *\n * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects the user interface\n * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the\n * user if the widget is next to the \"tight spot\". Once clicked, a paragraph is created with the selection anchored\n * in it so that users can type (or insert content, paste, etc.) straight away.\n */\nexport default class WidgetTypeAround extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A reference to the model widget element that has the fake caret active\n         * on either side of it. It is later used to remove CSS classes associated with the fake caret\n         * when the widget no longer needs it.\n         */\n        this._currentFakeCaretModelElement = null;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'WidgetTypeAround';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [Enter, Delete];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const editingView = editor.editing.view;\n        // Set a CSS class on the view editing root when the plugin is disabled so all the buttons\n        // and lines visually disappear. All the interactions are disabled in individual plugin methods.\n        this.on('change:isEnabled', (evt, data, isEnabled) => {\n            editingView.change(writer => {\n                for (const root of editingView.document.roots) {\n                    if (isEnabled) {\n                        writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n                    }\n                    else {\n                        writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root);\n                    }\n                }\n            });\n            if (!isEnabled) {\n                editor.model.change(writer => {\n                    writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n                });\n            }\n        });\n        this._enableTypeAroundUIInjection();\n        this._enableInsertingParagraphsOnButtonClick();\n        this._enableInsertingParagraphsOnEnterKeypress();\n        this._enableInsertingParagraphsOnTypingKeystroke();\n        this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();\n        this._enableDeleteIntegration();\n        this._enableInsertContentIntegration();\n        this._enableInsertObjectIntegration();\n        this._enableDeleteContentIntegration();\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this._currentFakeCaretModelElement = null;\n    }\n    /**\n     * Inserts a new paragraph next to a widget element with the selection anchored in it.\n     *\n     * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll\n     * the viewport to the selection in the inserted paragraph.\n     *\n     * @param widgetModelElement The model widget element next to which a paragraph is inserted.\n     * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.\n     */\n    _insertParagraph(widgetModelElement, position) {\n        const editor = this.editor;\n        const editingView = editor.editing.view;\n        const attributesToCopy = editor.model.schema.getAttributesWithProperty(widgetModelElement, 'copyOnReplace', true);\n        editor.execute('insertParagraph', {\n            position: editor.model.createPositionAt(widgetModelElement, position),\n            attributes: attributesToCopy\n        });\n        editingView.focus();\n        editingView.scrollToTheSelection();\n    }\n    /**\n     * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only\n     * when the plugin {@link #isEnabled is enabled}.\n     *\n     * @param emitter The object that fires the event.\n     * @param event The name of the event.\n     * @param callback The function to be called on event.\n     * @param options Additional options.\n     * @param options.priority The priority of this event callback. The higher the priority value the sooner\n     * the callback will be fired. Events having the same priority are called in the order they were added.\n     */\n    _listenToIfEnabled(emitter, event, callback, options) {\n        this.listenTo(emitter, event, (...args) => {\n            // Do not respond if the plugin is disabled.\n            if (this.isEnabled) {\n                callback(...args);\n            }\n        }, options);\n    }\n    /**\n     * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it\n     * does not expect a position. Instead, it performs the insertion next to a selected widget\n     * according to the `widget-type-around` model selection attribute value (fake caret position).\n     *\n     * Because this method requires the `widget-type-around` attribute to be set,\n     * the insertion can only happen when the widget's fake caret is active (e.g. activated\n     * using the keyboard).\n     *\n     * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.\n     */\n    _insertParagraphAccordingToFakeCaretPosition() {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelSelection = model.document.selection;\n        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n        if (!typeAroundFakeCaretPosition) {\n            return false;\n        }\n        // @if CK_DEBUG_TYPING // if ( ( window as any ).logCKETyping ) {\n        // @if CK_DEBUG_TYPING // \tconsole.info( '%c[WidgetTypeAround]%c Fake caret -> insert paragraph',\n        // @if CK_DEBUG_TYPING // \t\t'font-weight: bold; color: green', ''\n        // @if CK_DEBUG_TYPING // \t);\n        // @if CK_DEBUG_TYPING // }\n        const selectedModelElement = modelSelection.getSelectedElement();\n        this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);\n        return true;\n    }\n    /**\n     * Creates a listener in the editing conversion pipeline that injects the widget type around\n     * UI into every single widget instance created in the editor.\n     *\n     * The UI is delivered as a {@link module:engine/view/uielement~UIElement}\n     * wrapper which renders DOM buttons that users can use to insert paragraphs.\n     */\n    _enableTypeAroundUIInjection() {\n        const editor = this.editor;\n        const schema = editor.model.schema;\n        const t = editor.locale.t;\n        const buttonTitles = {\n            before: t('Insert paragraph before block'),\n            after: t('Insert paragraph after block')\n        };\n        editor.editing.downcastDispatcher.on('insert', (evt, data, conversionApi) => {\n            const viewElement = conversionApi.mapper.toViewElement(data.item);\n            if (!viewElement) {\n                return;\n            }\n            // Filter out non-widgets and inline widgets.\n            if (isTypeAroundWidget(viewElement, data.item, schema)) {\n                injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);\n                const widgetLabel = viewElement.getCustomProperty('widgetLabel');\n                widgetLabel.push(() => {\n                    return this.isEnabled ? t('Press Enter to type after or press Shift + Enter to type before the widget') : '';\n                });\n            }\n        }, { priority: 'low' });\n    }\n    /**\n     * Brings support for the fake caret that appears when either:\n     *\n     * * the selection moves to a widget from a position next to it using arrow keys,\n     * * the arrow key is pressed when the widget is already selected.\n     *\n     * The fake caret lets the user know that they can start typing or just press\n     * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.\n     *\n     * The fake caret disappears when the user changes the selection or the editor\n     * gets blurred.\n     *\n     * The whole idea is as follows:\n     *\n     * 1. A user does one of the 2 scenarios described at the beginning.\n     * 2. The \"keydown\" listener is executed and the decision is made whether to show or hide the fake caret.\n     * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating\n     *    on which side of the widget it should appear.\n     * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the\n     *    fake caret on the view widget.\n     * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher\n     *    does the CSS class clean-up in the view.\n     * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection\n     *    attribute (the former also removes widget CSS classes).\n     */\n    _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelSelection = model.document.selection;\n        const schema = model.schema;\n        const editingView = editor.editing.view;\n        // This is the main listener responsible for the fake caret.\n        // Note: The priority must precede the default Widget class keydown handler (\"high\").\n        this._listenToIfEnabled(editingView.document, 'arrowKey', (evt, domEventData) => {\n            this._handleArrowKeyPress(evt, domEventData);\n        }, { context: [isWidget, '$text'], priority: 'high' });\n        // This listener makes sure the widget type around selection attribute will be gone from the model\n        // selection as soon as the model range changes. This attribute only makes sense when a widget is selected\n        // (and the \"fake horizontal caret\" is visible) so whenever the range changes (e.g. selection moved somewhere else),\n        // let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.\n        this._listenToIfEnabled(modelSelection, 'change:range', (evt, data) => {\n            // Do not reset the selection attribute when the change was indirect.\n            if (!data.directChange) {\n                return;\n            }\n            // Get rid of the widget type around attribute of the selection on every change:range.\n            // If the range changes, it means for sure, the user is no longer in the active (\"fake horizontal caret\") mode.\n            editor.model.change(writer => {\n                writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n            });\n        });\n        // Get rid of the widget type around attribute of the selection on every document change\n        // that makes widget not selected any more (i.e. widget was removed).\n        this._listenToIfEnabled(model.document, 'change:data', () => {\n            const selectedModelElement = modelSelection.getSelectedElement();\n            if (selectedModelElement) {\n                const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n                if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n                    return;\n                }\n            }\n            editor.model.change(writer => {\n                writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n            });\n        });\n        // React to changes of the model selection attribute made by the arrow keys listener.\n        // If the block widget is selected and the attribute changes, downcast the attribute to special\n        // CSS classes associated with the active (\"fake horizontal caret\") mode of the widget.\n        this._listenToIfEnabled(editor.editing.downcastDispatcher, 'selection', (evt, data, conversionApi) => {\n            const writer = conversionApi.writer;\n            if (this._currentFakeCaretModelElement) {\n                const selectedViewElement = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);\n                if (selectedViewElement) {\n                    // Get rid of CSS classes associated with the active (\"fake horizontal caret\") mode from the view widget.\n                    writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement);\n                    this._currentFakeCaretModelElement = null;\n                }\n            }\n            const selectedModelElement = data.selection.getSelectedElement();\n            if (!selectedModelElement) {\n                return;\n            }\n            const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);\n            if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);\n            if (!typeAroundFakeCaretPosition) {\n                return;\n            }\n            writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement);\n            // Remember the view widget that got the \"fake-caret\" CSS class. This class should be removed ASAP when the\n            // selection changes\n            this._currentFakeCaretModelElement = selectedModelElement;\n        });\n        this._listenToIfEnabled(editor.ui.focusTracker, 'change:isFocused', (evt, name, isFocused) => {\n            if (!isFocused) {\n                editor.model.change(writer => {\n                    writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n                });\n            }\n        });\n        function positionToWidgetCssClass(position) {\n            return `ck-widget_type-around_show-fake-caret_${position}`;\n        }\n    }\n    /**\n     * A listener executed on each \"keydown\" in the view document, a part of\n     * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.\n     *\n     * It decides whether the arrow keypress should activate the fake caret or not (also whether it should\n     * be deactivated).\n     *\n     * The fake caret activation is done by setting the `widget-type-around` model selection attribute\n     * in this listener, and stopping and preventing the event that would normally be handled by the widget\n     * plugin that is responsible for the regular keyboard navigation near/across all widgets (that\n     * includes inline widgets, which are ignored by the widget type around plugin).\n     */\n    _handleArrowKeyPress(evt, domEventData) {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelSelection = model.document.selection;\n        const schema = model.schema;\n        const editingView = editor.editing.view;\n        const keyCode = domEventData.keyCode;\n        const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);\n        const selectedViewElement = editingView.document.selection.getSelectedElement();\n        const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);\n        let shouldStopAndPreventDefault;\n        // Handle keyboard navigation when a type-around-compatible widget is currently selected.\n        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n            shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);\n        }\n        // Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget\n        // and the widget is about to be selected.\n        else if (modelSelection.isCollapsed) {\n            shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);\n        }\n        // Handle collapsing a non-collapsed selection that is wider than on a single widget.\n        else if (!domEventData.shiftKey) {\n            shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);\n        }\n        if (shouldStopAndPreventDefault) {\n            domEventData.preventDefault();\n            evt.stop();\n        }\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when a widget is currently selected and activates or deactivates\n     * the fake caret for that widget, depending on the current value of the `widget-type-around` model\n     * selection attribute and the direction of the pressed arrow key.\n     *\n     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n    _handleArrowKeyPressOnSelectedWidget(isForward) {\n        const editor = this.editor;\n        const model = editor.model;\n        const modelSelection = model.document.selection;\n        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);\n        return model.change(writer => {\n            // If the fake caret is displayed...\n            if (typeAroundFakeCaretPosition) {\n                const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? 'after' : 'before');\n                // If the keyboard arrow works against the value of the selection attribute...\n                // then remove the selection attribute but prevent default DOM actions\n                // and do not let the Widget plugin listener move the selection. This brings\n                // the widget back to the state, for instance, like if was selected using the mouse.\n                //\n                // **Note**: If leaving the widget when the fake caret is active, then the default\n                // Widget handler will change the selection and, in turn, this will automatically discard\n                // the selection attribute.\n                if (!isLeavingWidget) {\n                    writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);\n                    return true;\n                }\n            }\n            // If the fake caret wasn't displayed, let's set it now according to the direction of the arrow\n            // key press. This also means we cannot let the Widget plugin listener move the selection.\n            else {\n                writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n                return true;\n            }\n            return false;\n        });\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when **no** widget is selected but the selection is **directly** next\n     * to one and upon the fake caret should become active for this widget upon arrow keypress\n     * (AKA entering/selecting the widget).\n     *\n     * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.\n     * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the\n     * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.\n     *\n     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n    _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {\n        const editor = this.editor;\n        const model = editor.model;\n        const schema = model.schema;\n        const widgetPlugin = editor.plugins.get('Widget');\n        // This is the widget the selection is about to be set on.\n        const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);\n        const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);\n        if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {\n            model.change(writer => {\n                widgetPlugin._setSelectionOverElement(modelElementNextToSelection);\n                writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after');\n            });\n            // The change() block above does the same job as the Widget plugin. The event can\n            // be safely canceled.\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Handles the keyboard navigation on \"keydown\" when a widget is currently selected (together with some other content)\n     * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.\n     *\n     * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement\n     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.\n     * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should\n     * process the event any further. Returns `false` otherwise.\n     */\n    _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {\n        const editor = this.editor;\n        const model = editor.model;\n        const schema = model.schema;\n        const mapper = editor.editing.mapper;\n        const modelSelection = model.document.selection;\n        const selectedModelNode = isForward ?\n            modelSelection.getLastPosition().nodeBefore :\n            modelSelection.getFirstPosition().nodeAfter;\n        const selectedViewNode = mapper.toViewElement(selectedModelNode);\n        // There is a widget at the collapse position so collapse the selection to the fake caret on it.\n        if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {\n            model.change(writer => {\n                writer.setSelection(selectedModelNode, 'on');\n                writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');\n            });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Registers a `mousedown` listener for the view document which intercepts events\n     * coming from the widget type around UI, which happens when a user clicks one of the buttons\n     * that insert a paragraph next to a widget.\n     */\n    _enableInsertingParagraphsOnButtonClick() {\n        const editor = this.editor;\n        const editingView = editor.editing.view;\n        this._listenToIfEnabled(editingView.document, 'mousedown', (evt, domEventData) => {\n            const button = getClosestTypeAroundDomButton(domEventData.domTarget);\n            if (!button) {\n                return;\n            }\n            const buttonPosition = getTypeAroundButtonPosition(button);\n            const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);\n            const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);\n            this._insertParagraph(widgetModelElement, buttonPosition);\n            domEventData.preventDefault();\n            evt.stop();\n        });\n    }\n    /**\n     * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph\n     * near the widget when either:\n     *\n     * * The fake caret was first activated using the arrow keys,\n     * * The entire widget is selected in the model.\n     *\n     * In the first case, the new paragraph is inserted according to the `widget-type-around` selection\n     * attribute (see {@link #_handleArrowKeyPress}).\n     *\n     * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke\n     * was pressed or not.\n     */\n    _enableInsertingParagraphsOnEnterKeypress() {\n        const editor = this.editor;\n        const selection = editor.model.document.selection;\n        const editingView = editor.editing.view;\n        this._listenToIfEnabled(editingView.document, 'enter', (evt, domEventData) => {\n            // This event could be triggered from inside the widget but we are interested\n            // only when the widget is selected itself.\n            if (evt.eventPhase != 'atTarget') {\n                return;\n            }\n            const selectedModelElement = selection.getSelectedElement();\n            const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n            const schema = editor.model.schema;\n            let wasHandled;\n            // First check if the widget is selected and there's a type around selection attribute associated\n            // with the fake caret that would tell where to insert a new paragraph.\n            if (this._insertParagraphAccordingToFakeCaretPosition()) {\n                wasHandled = true;\n            }\n            // Then, if there is no selection attribute associated with the fake caret, check if the widget\n            // simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.\n            else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {\n                this._insertParagraph(selectedModelElement, domEventData.isSoft ? 'before' : 'after');\n                wasHandled = true;\n            }\n            if (wasHandled) {\n                domEventData.preventDefault();\n                evt.stop();\n            }\n        }, { context: isWidget });\n    }\n    /**\n     * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user\n     * to insert a paragraph next to a widget when the fake caret was activated using arrow\n     * keys but it responds to typing instead of <kbd>Enter</kbd>.\n     *\n     * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`\n     * model selection attribute as the user simply starts typing, which creates the impression that the fake caret\n     * behaves like a real one rendered by the browser (AKA your text appears where the caret was).\n     *\n     * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command\n     * and another one for actual typing. It is not a disaster but this may need to be fixed\n     * sooner or later.\n     */\n    _enableInsertingParagraphsOnTypingKeystroke() {\n        const editor = this.editor;\n        const viewDocument = editor.editing.view.document;\n        // Note: The priority must precede the default Input plugin insertText handler.\n        this._listenToIfEnabled(viewDocument, 'insertText', (evt, data) => {\n            if (this._insertParagraphAccordingToFakeCaretPosition()) {\n                // The view selection in the event data contains the widget. If the new paragraph\n                // was inserted, modify the view selection passed along with the insertText event\n                // so the default event handler in the Input plugin starts typing inside the paragraph.\n                // Otherwise, the typing would be over the widget.\n                data.selection = viewDocument.selection;\n            }\n        }, { priority: 'high' });\n        if (env.isAndroid) {\n            // On Android with English keyboard, the composition starts just by putting caret\n            // at the word end or by selecting a table column. This is not a real composition started.\n            // Trigger delete content on first composition key pressed.\n            this._listenToIfEnabled(viewDocument, 'keydown', (evt, data) => {\n                if (data.keyCode == 229) {\n                    this._insertParagraphAccordingToFakeCaretPosition();\n                }\n            });\n        }\n        else {\n            // Note: The priority must precede the default Input plugin compositionstart handler (to call it before delete content).\n            this._listenToIfEnabled(viewDocument, 'compositionstart', () => {\n                this._insertParagraphAccordingToFakeCaretPosition();\n            }, { priority: 'high' });\n        }\n    }\n    /**\n     * It creates a \"delete\" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>\n     * is pressed and the fake caret is currently active.\n     *\n     * The fake caret should create an illusion of a real browser caret so that when it appears before or after\n     * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content\n     * before or after a widget (depending on the content surrounding the widget).\n     */\n    _enableDeleteIntegration() {\n        const editor = this.editor;\n        const editingView = editor.editing.view;\n        const model = editor.model;\n        const schema = model.schema;\n        this._listenToIfEnabled(editingView.document, 'delete', (evt, domEventData) => {\n            // This event could be triggered from inside the widget but we are interested\n            // only when the widget is selected itself.\n            if (evt.eventPhase != 'atTarget') {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection);\n            // This listener handles only these cases when the fake caret is active.\n            if (!typeAroundFakeCaretPosition) {\n                return;\n            }\n            const direction = domEventData.direction;\n            const selectedModelWidget = model.document.selection.getSelectedElement();\n            const isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';\n            const isDeleteForward = direction == 'forward';\n            const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;\n            if (shouldDeleteEntireWidget) {\n                editor.execute('delete', {\n                    selection: model.createSelection(selectedModelWidget, 'on')\n                });\n            }\n            else {\n                const range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction);\n                // If there is somewhere to move selection to, then there will be something to delete.\n                if (range) {\n                    // If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).\n                    if (!range.isCollapsed) {\n                        model.change(writer => {\n                            writer.setSelection(range);\n                            editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n                        });\n                    }\n                    else {\n                        const probe = model.createSelection(range.start);\n                        model.modifySelection(probe, { direction });\n                        // If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.\n                        // If such range exists, use the editor command because it it safe for collaboration (it merges where it can).\n                        if (!probe.focus.isEqual(range.start)) {\n                            model.change(writer => {\n                                writer.setSelection(range);\n                                editor.execute(isDeleteForward ? 'deleteForward' : 'delete');\n                            });\n                        }\n                        // If there is no non-collapsed range to be deleted then we are sure that there is an empty element\n                        // next to a widget that should be removed. \"delete\" and \"deleteForward\" commands cannot get rid of it\n                        // so calling Model#deleteContent here manually.\n                        else {\n                            const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);\n                            model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, 'on'), {\n                                doNotAutoparagraph: true\n                            });\n                        }\n                    }\n                }\n            }\n            // If some content was deleted, don't let the handler from the Widget plugin kick in.\n            // If nothing was deleted, then the default handler will have nothing to do anyway.\n            domEventData.preventDefault();\n            evt.stop();\n        }, { context: isWidget });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste\n     * content near a widget when the fake caret is first activated using the arrow keys.\n     *\n     * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n     */\n    _enableInsertContentIntegration() {\n        const editor = this.editor;\n        const model = this.editor.model;\n        const documentSelection = model.document.selection;\n        this._listenToIfEnabled(editor.model, 'insertContent', (evt, [content, selectable]) => {\n            if (selectable && !selectable.is('documentSelection')) {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n            if (!typeAroundFakeCaretPosition) {\n                return;\n            }\n            evt.stop();\n            return model.change(writer => {\n                const selectedElement = documentSelection.getSelectedElement();\n                const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);\n                const selection = writer.createSelection(position);\n                const result = model.insertContent(content, selection);\n                writer.setSelection(selection);\n                return result;\n            });\n        }, { priority: 'high' });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the\n     * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element\n     * to reflect user's intent of desired insertion position.\n     *\n     * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).\n     */\n    _enableInsertObjectIntegration() {\n        const editor = this.editor;\n        const model = this.editor.model;\n        const documentSelection = model.document.selection;\n        this._listenToIfEnabled(editor.model, 'insertObject', (evt, args) => {\n            const [, selectable, options = {}] = args;\n            if (selectable && !selectable.is('documentSelection')) {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n            if (!typeAroundFakeCaretPosition) {\n                return;\n            }\n            options.findOptimalPosition = typeAroundFakeCaretPosition;\n            args[3] = options;\n        }, { priority: 'high' });\n    }\n    /**\n     * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake\n     * caret is active.\n     *\n     * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}\n     * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,\n     * plain text pasting.\n     */\n    _enableDeleteContentIntegration() {\n        const editor = this.editor;\n        const model = this.editor.model;\n        const documentSelection = model.document.selection;\n        this._listenToIfEnabled(editor.model, 'deleteContent', (evt, [selection]) => {\n            if (selection && !selection.is('documentSelection')) {\n                return;\n            }\n            const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);\n            // Disable removing the selection content while pasting plain text.\n            if (typeAroundFakeCaretPosition) {\n                evt.stop();\n            }\n        }, { priority: 'high' });\n    }\n}\n/**\n * Injects the type around UI into a view widget instance.\n */\nfunction injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {\n    const typeAroundWrapper = viewWriter.createUIElement('div', {\n        class: 'ck ck-reset_all ck-widget__type-around'\n    }, function (domDocument) {\n        const wrapperDomElement = this.toDomElement(domDocument);\n        injectButtons(wrapperDomElement, buttonTitles);\n        injectFakeCaret(wrapperDomElement);\n        return wrapperDomElement;\n    });\n    // Inject the type around wrapper into the widget's wrapper.\n    viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, 'end'), typeAroundWrapper);\n}\n/**\n * FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks\n * and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw\n * <svg> here.\n */\nfunction injectButtons(wrapperDomElement, buttonTitles) {\n    for (const position of POSSIBLE_INSERTION_POSITIONS) {\n        const buttonTemplate = new Template({\n            tag: 'div',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-widget__type-around__button',\n                    `ck-widget__type-around__button_${position}`\n                ],\n                title: buttonTitles[position],\n                'aria-hidden': 'true'\n            },\n            children: [\n                wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)\n            ]\n        });\n        wrapperDomElement.appendChild(buttonTemplate.render());\n    }\n}\nfunction injectFakeCaret(wrapperDomElement) {\n    const caretTemplate = new Template({\n        tag: 'div',\n        attributes: {\n            class: [\n                'ck',\n                'ck-widget__type-around__fake-caret'\n            ]\n        }\n    });\n    wrapperDomElement.appendChild(caretTemplate.render());\n}\n/**\n * Returns the ancestor of an element closest to the root which is empty. For instance,\n * for `<baz>`:\n *\n * ```\n * <foo>abc<bar><baz></baz></bar></foo>\n * ```\n *\n * it returns `<bar>`.\n */\nfunction getDeepestEmptyElementAncestor(schema, element) {\n    let deepestEmptyAncestor = element;\n    for (const ancestor of element.getAncestors({ parentFirst: true })) {\n        if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {\n            break;\n        }\n        deepestEmptyAncestor = ancestor;\n    }\n    return deepestEmptyAncestor;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/verticalnavigation\n */\nimport { keyCodes, Rect } from '@ckeditor/ckeditor5-utils';\n/**\n * Returns 'keydown' handler for up/down arrow keys that modifies the caret movement if it's in a text line next to an object.\n *\n * @param editing The editing controller.\n */\nexport default function verticalNavigationHandler(editing) {\n    const model = editing.model;\n    return (evt, data) => {\n        const arrowUpPressed = data.keyCode == keyCodes.arrowup;\n        const arrowDownPressed = data.keyCode == keyCodes.arrowdown;\n        const expandSelection = data.shiftKey;\n        const selection = model.document.selection;\n        if (!arrowUpPressed && !arrowDownPressed) {\n            return;\n        }\n        const isForward = arrowDownPressed;\n        // Navigation is in the opposite direction than the selection direction so this is shrinking of the selection.\n        // Selection for sure will not approach any object.\n        if (expandSelection && selectionWillShrink(selection, isForward)) {\n            return;\n        }\n        // Find a range between selection and closest limit element.\n        const range = findTextRangeFromSelection(editing, selection, isForward);\n        // There is no selection position inside the limit element.\n        if (!range) {\n            return;\n        }\n        // If already at the edge of a limit element.\n        if (range.isCollapsed) {\n            // A collapsed selection at limit edge - nothing more to do.\n            if (selection.isCollapsed) {\n                return;\n            }\n            // A non collapsed selection is at the limit edge while expanding the selection - let others do their stuff.\n            else if (expandSelection) {\n                return;\n            }\n        }\n        // If the range is a single line (there is no word wrapping) then move the selection to the position closest to the limit element.\n        //\n        // We can't move the selection directly to the isObject element (eg. table cell) because of dual position at the end/beginning\n        // of wrapped line (it's at the same time at the end of one line and at the start of the next line).\n        if (range.isCollapsed || isSingleLineRange(editing, range, isForward)) {\n            model.change(writer => {\n                const newPosition = isForward ? range.end : range.start;\n                if (expandSelection) {\n                    const newSelection = model.createSelection(selection.anchor);\n                    newSelection.setFocus(newPosition);\n                    writer.setSelection(newSelection);\n                }\n                else {\n                    writer.setSelection(newPosition);\n                }\n            });\n            evt.stop();\n            data.preventDefault();\n            data.stopPropagation();\n        }\n    };\n}\n/**\n * Finds the range between selection and closest limit element (in the direction of navigation).\n * The position next to limit element is adjusted to the closest allowed `$text` position.\n *\n * Returns `null` if, according to the schema, the resulting range cannot contain a `$text` element.\n *\n * @param editing The editing controller.\n * @param selection The current selection.\n * @param isForward The expected navigation direction.\n */\nfunction findTextRangeFromSelection(editing, selection, isForward) {\n    const model = editing.model;\n    if (isForward) {\n        const startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();\n        const endPosition = getNearestNonInlineLimit(model, startPosition, 'forward');\n        // There is no limit element, browser should handle this.\n        if (!endPosition) {\n            return null;\n        }\n        const range = model.createRange(startPosition, endPosition);\n        const lastRangePosition = getNearestTextPosition(model.schema, range, 'backward');\n        if (lastRangePosition) {\n            return model.createRange(startPosition, lastRangePosition);\n        }\n        return null;\n    }\n    else {\n        const endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();\n        const startPosition = getNearestNonInlineLimit(model, endPosition, 'backward');\n        // There is no limit element, browser should handle this.\n        if (!startPosition) {\n            return null;\n        }\n        const range = model.createRange(startPosition, endPosition);\n        const firstRangePosition = getNearestTextPosition(model.schema, range, 'forward');\n        if (firstRangePosition) {\n            return model.createRange(firstRangePosition, endPosition);\n        }\n        return null;\n    }\n}\n/**\n * Finds the limit element position that is closest to startPosition.\n *\n * @param direction Search direction.\n */\nfunction getNearestNonInlineLimit(model, startPosition, direction) {\n    const schema = model.schema;\n    const range = model.createRangeIn(startPosition.root);\n    const walkerValueType = direction == 'forward' ? 'elementStart' : 'elementEnd';\n    for (const { previousPosition, item, type } of range.getWalker({ startPosition, direction })) {\n        if (schema.isLimit(item) && !schema.isInline(item)) {\n            return previousPosition;\n        }\n        // Stop looking for isLimit element if the next element is a block element (it is for sure not single line).\n        if (type == walkerValueType && schema.isBlock(item)) {\n            return null;\n        }\n    }\n    return null;\n}\n/**\n * Basing on the provided range, finds the first or last (depending on `direction`) position inside the range\n * that can contain `$text` (according to schema).\n *\n * @param schema The schema.\n * @param range The range to find the position in.\n * @param direction Search direction.\n * @returns The nearest selection position.\n *\n */\nfunction getNearestTextPosition(schema, range, direction) {\n    const position = direction == 'backward' ? range.end : range.start;\n    if (schema.checkChild(position, '$text')) {\n        return position;\n    }\n    for (const { nextPosition } of range.getWalker({ direction })) {\n        if (schema.checkChild(nextPosition, '$text')) {\n            return nextPosition;\n        }\n    }\n    return null;\n}\n/**\n * Checks if the DOM range corresponding to the provided model range renders as a single line by analyzing DOMRects\n * (verifying if they visually wrap content to the next line).\n *\n * @param editing The editing controller.\n * @param modelRange The current table cell content range.\n * @param isForward The expected navigation direction.\n */\nfunction isSingleLineRange(editing, modelRange, isForward) {\n    const model = editing.model;\n    const domConverter = editing.view.domConverter;\n    // Wrapped lines contain exactly the same position at the end of current line\n    // and at the beginning of next line. That position's client rect is at the end\n    // of current line. In case of caret at first position of the last line that 'dual'\n    // position would be detected as it's not the last line.\n    if (isForward) {\n        const probe = model.createSelection(modelRange.start);\n        model.modifySelection(probe);\n        // If the new position is at the end of the container then we can't use this position\n        // because it would provide incorrect result for eg caption of image and selection\n        // just before end of it. Also in this case there is no \"dual\" position.\n        if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {\n            modelRange = model.createRange(probe.focus, modelRange.end);\n        }\n    }\n    const viewRange = editing.mapper.toViewRange(modelRange);\n    const domRange = domConverter.viewRangeToDom(viewRange);\n    const rects = Rect.getDomRangeRects(domRange);\n    let boundaryVerticalPosition;\n    for (const rect of rects) {\n        if (boundaryVerticalPosition === undefined) {\n            boundaryVerticalPosition = Math.round(rect.bottom);\n            continue;\n        }\n        // Let's check if this rect is in new line.\n        if (Math.round(rect.top) >= boundaryVerticalPosition) {\n            return false;\n        }\n        boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));\n    }\n    return true;\n}\nfunction selectionWillShrink(selection, isForward) {\n    return !selection.isCollapsed && selection.isBackward == isForward;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widget\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { MouseObserver, TreeWalker } from '@ckeditor/ckeditor5-engine';\nimport { Delete } from '@ckeditor/ckeditor5-typing';\nimport { env, keyCodes, getLocalizedArrowKeyCodeDirection, getRangeFromMouseEvent } from '@ckeditor/ckeditor5-utils';\nimport WidgetTypeAround from './widgettypearound/widgettypearound.js';\nimport verticalNavigationHandler from './verticalnavigation.js';\nimport { getLabel, isWidget, WIDGET_SELECTED_CLASS_NAME } from './utils.js';\nimport '../theme/widget.css';\n/**\n * The widget plugin. It enables base support for widgets.\n *\n * See {@glink api/widget package page} for more details and documentation.\n *\n * This plugin enables multiple behaviors required by widgets:\n *\n * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).\n * If a converted selection wraps around a widget element, that selection is marked as\n * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class\n * is added to indicate that widget has been selected.\n * * The mouse and keyboard events handling on and around widget elements.\n */\nexport default class Widget extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * Holds previously selected widgets.\n         */\n        this._previouslySelected = new Set();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Widget';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [WidgetTypeAround, Delete];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const t = editor.t;\n        // Model to view selection converter.\n        // Converts selection placed over widget element to fake selection.\n        //\n        // By default, the selection is downcasted by the engine to surround the attribute element, even though its only\n        // child is an inline widget. A similar thing also happens when a collapsed marker is rendered as a UI element\n        // next to an inline widget: the view selection contains both the widget and the marker.\n        //\n        // This prevents creating a correct fake selection when this inline widget is selected. Normalize the selection\n        // in these cases based on the model:\n        //\n        //\t\t[<attributeElement><inlineWidget /></attributeElement>] -> <attributeElement>[<inlineWidget />]</attributeElement>\n        //\t\t[<uiElement></uiElement><inlineWidget />] -> <uiElement></uiElement>[<inlineWidget />]\n        //\n        // Thanks to this:\n        //\n        // * fake selection can be set correctly,\n        // * any logic depending on (View)Selection#getSelectedElement() also works OK.\n        //\n        // See https://github.com/ckeditor/ckeditor5/issues/9524.\n        this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n            const viewWriter = conversionApi.writer;\n            const modelSelection = data.selection;\n            // The collapsed selection can't contain any widget.\n            if (modelSelection.isCollapsed) {\n                return;\n            }\n            const selectedModelElement = modelSelection.getSelectedElement();\n            if (!selectedModelElement) {\n                return;\n            }\n            const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);\n            if (!isWidget(selectedViewElement)) {\n                return;\n            }\n            if (!conversionApi.consumable.consume(modelSelection, 'selection')) {\n                return;\n            }\n            viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {\n                fake: true,\n                label: getLabel(selectedViewElement)\n            });\n        });\n        // Mark all widgets inside the selection with the css class.\n        // This handler is registered at the 'low' priority so it's triggered after the real selection conversion.\n        this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n            // Remove selected class from previously selected widgets.\n            this._clearPreviouslySelectedWidgets(conversionApi.writer);\n            const viewWriter = conversionApi.writer;\n            const viewSelection = viewWriter.document.selection;\n            let lastMarked = null;\n            for (const range of viewSelection.getRanges()) {\n                // Note: There could be multiple selected widgets in a range but no fake selection.\n                // All of them must be marked as selected, for instance [<widget></widget><widget></widget>]\n                for (const value of range) {\n                    const node = value.item;\n                    // Do not mark nested widgets in selected one. See: #4594\n                    if (isWidget(node) && !isChild(node, lastMarked)) {\n                        viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);\n                        this._previouslySelected.add(node);\n                        lastMarked = node;\n                    }\n                }\n            }\n        }, { priority: 'low' });\n        // If mouse down is pressed on widget - create selection over whole widget.\n        view.addObserver(MouseObserver);\n        this.listenTo(viewDocument, 'mousedown', (...args) => this._onMousedown(...args));\n        // There are two keydown listeners working on different priorities. This allows other\n        // features such as WidgetTypeAround or TableKeyboard to attach their listeners in between\n        // and customize the behavior even further in different content/selection scenarios.\n        //\n        // * The first listener handles changing the selection on arrow key press\n        // if the widget is selected or if the selection is next to a widget and the widget\n        // should become selected upon the arrow key press.\n        //\n        // * The second (late) listener makes sure the default browser action on arrow key press is\n        // prevented when a widget is selected. This prevents the selection from being moved\n        // from a fake selection container.\n        this.listenTo(viewDocument, 'arrowKey', (...args) => {\n            this._handleSelectionChangeOnArrowKeyPress(...args);\n        }, { context: [isWidget, '$text'] });\n        this.listenTo(viewDocument, 'arrowKey', (...args) => {\n            this._preventDefaultOnArrowKeyPress(...args);\n        }, { context: '$root' });\n        this.listenTo(viewDocument, 'arrowKey', verticalNavigationHandler(this.editor.editing), { context: '$text' });\n        // Handle custom delete behaviour.\n        this.listenTo(viewDocument, 'delete', (evt, data) => {\n            if (this._handleDelete(data.direction == 'forward')) {\n                data.preventDefault();\n                evt.stop();\n            }\n        }, { context: '$root' });\n        // Handle Tab key while a widget is selected.\n        this.listenTo(viewDocument, 'tab', (evt, data) => {\n            // This event could be triggered from inside the widget, but we are interested\n            // only when the widget is selected itself.\n            if (evt.eventPhase != 'atTarget') {\n                return;\n            }\n            if (data.shiftKey) {\n                return;\n            }\n            if (this._selectFirstNestedEditable()) {\n                data.preventDefault();\n                evt.stop();\n            }\n        }, { context: isWidget, priority: 'low' });\n        // Handle Shift+Tab key while caret inside a widget editable.\n        this.listenTo(viewDocument, 'tab', (evt, data) => {\n            if (!data.shiftKey) {\n                return;\n            }\n            if (this._selectAncestorWidget()) {\n                data.preventDefault();\n                evt.stop();\n            }\n        }, { priority: 'low' });\n        // Handle Esc key while inside a nested editable.\n        this.listenTo(viewDocument, 'keydown', (evt, data) => {\n            if (data.keystroke != keyCodes.esc) {\n                return;\n            }\n            if (this._selectAncestorWidget()) {\n                data.preventDefault();\n                evt.stop();\n            }\n        }, { priority: 'low' });\n        // Add the information about the keystrokes to the accessibility database.\n        editor.accessibility.addKeystrokeInfoGroup({\n            id: 'widget',\n            label: t('Keystrokes that can be used when a widget is selected (for example: image, table, etc.)'),\n            keystrokes: [\n                {\n                    label: t('Move focus from an editable area back to the parent widget'),\n                    keystroke: 'Esc'\n                },\n                {\n                    label: t('Insert a new paragraph directly after a widget'),\n                    keystroke: 'Enter'\n                },\n                {\n                    label: t('Insert a new paragraph directly before a widget'),\n                    keystroke: 'Shift+Enter'\n                },\n                {\n                    label: t('Move the caret to allow typing directly before a widget'),\n                    keystroke: [['arrowup'], ['arrowleft']]\n                },\n                {\n                    label: t('Move the caret to allow typing directly after a widget'),\n                    keystroke: [['arrowdown'], ['arrowright']]\n                }\n            ]\n        });\n    }\n    /**\n     * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n     */\n    _onMousedown(eventInfo, domEventData) {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        let element = domEventData.target;\n        // Some of DOM elements have no view element representation so it may be null.\n        if (!element) {\n            return;\n        }\n        // If triple click should select entire paragraph.\n        if (domEventData.domEvent.detail >= 3) {\n            if (this._selectBlockContent(element)) {\n                domEventData.preventDefault();\n            }\n            return;\n        }\n        // If target is not a widget element - check if one of the ancestors is.\n        if (!isWidget(element)) {\n            const editableOrWidgetElement = findClosestEditableOrWidgetAncestor(element);\n            if (!editableOrWidgetElement) {\n                return;\n            }\n            if (isWidget(editableOrWidgetElement)) {\n                element = editableOrWidgetElement;\n            }\n            else {\n                // Pick view range from the point where the mouse was clicked.\n                const clickTargetFromPoint = getElementFromMouseEvent(view, domEventData);\n                if (clickTargetFromPoint && isWidget(clickTargetFromPoint)) {\n                    element = clickTargetFromPoint;\n                }\n                else {\n                    return;\n                }\n            }\n        }\n        // On Android selection would jump to the first table cell, on other devices\n        // we can't block it (and don't need to) because of drag and drop support.\n        if (env.isAndroid) {\n            domEventData.preventDefault();\n        }\n        // Focus editor if is not focused already.\n        if (!viewDocument.isFocused) {\n            view.focus();\n        }\n        // Create model selection over widget.\n        const modelElement = editor.editing.mapper.toModelElement(element);\n        this._setSelectionOverElement(modelElement);\n    }\n    /**\n     * Selects entire block content, e.g. on triple click it selects entire paragraph.\n     */\n    _selectBlockContent(element) {\n        const editor = this.editor;\n        const model = editor.model;\n        const mapper = editor.editing.mapper;\n        const schema = model.schema;\n        const viewElement = mapper.findMappedViewAncestor(this.editor.editing.view.createPositionAt(element, 0));\n        const modelElement = findTextBlockAncestor(mapper.toModelElement(viewElement), model.schema);\n        if (!modelElement) {\n            return false;\n        }\n        model.change(writer => {\n            const nextTextBlock = !schema.isLimit(modelElement) ?\n                findNextTextBlock(writer.createPositionAfter(modelElement), schema) :\n                null;\n            const start = writer.createPositionAt(modelElement, 0);\n            const end = nextTextBlock ?\n                writer.createPositionAt(nextTextBlock, 0) :\n                writer.createPositionAt(modelElement, 'end');\n            writer.setSelection(writer.createRange(start, end));\n        });\n        return true;\n    }\n    /**\n     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes\n     * the model selection when:\n     *\n     * * arrow key is pressed when the widget is selected,\n     * * the selection is next to a widget and the widget should become selected upon the arrow key press.\n     *\n     * See {@link #_preventDefaultOnArrowKeyPress}.\n     */\n    _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {\n        const keyCode = domEventData.keyCode;\n        const model = this.editor.model;\n        const schema = model.schema;\n        const modelSelection = model.document.selection;\n        const objectElement = modelSelection.getSelectedElement();\n        const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);\n        const isForward = direction == 'down' || direction == 'right';\n        const isVerticalNavigation = direction == 'up' || direction == 'down';\n        // If object element is selected.\n        if (objectElement && schema.isObject(objectElement)) {\n            const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n            const newRange = schema.getNearestSelectionRange(position, isForward ? 'forward' : 'backward');\n            if (newRange) {\n                model.change(writer => {\n                    writer.setSelection(newRange);\n                });\n                domEventData.preventDefault();\n                eventInfo.stop();\n            }\n            return;\n        }\n        // Handle collapsing of the selection when there is any widget on the edge of selection.\n        // This is needed because browsers have problems with collapsing such selection.\n        if (!modelSelection.isCollapsed && !domEventData.shiftKey) {\n            const firstPosition = modelSelection.getFirstPosition();\n            const lastPosition = modelSelection.getLastPosition();\n            const firstSelectedNode = firstPosition.nodeAfter;\n            const lastSelectedNode = lastPosition.nodeBefore;\n            if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {\n                model.change(writer => {\n                    writer.setSelection(isForward ? lastPosition : firstPosition);\n                });\n                domEventData.preventDefault();\n                eventInfo.stop();\n            }\n            return;\n        }\n        // Return if not collapsed.\n        if (!modelSelection.isCollapsed) {\n            return;\n        }\n        // If selection is next to object element.\n        const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);\n        if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {\n            // Do not select an inline widget while handling up/down arrow.\n            if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {\n                return;\n            }\n            this._setSelectionOverElement(objectElementNextToSelection);\n            domEventData.preventDefault();\n            eventInfo.stop();\n        }\n    }\n    /**\n     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents\n     * the default browser behavior to make sure the fake selection is not being moved from a fake selection\n     * container.\n     *\n     * See {@link #_handleSelectionChangeOnArrowKeyPress}.\n     */\n    _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {\n        const model = this.editor.model;\n        const schema = model.schema;\n        const objectElement = model.document.selection.getSelectedElement();\n        // If object element is selected.\n        if (objectElement && schema.isObject(objectElement)) {\n            domEventData.preventDefault();\n            eventInfo.stop();\n        }\n    }\n    /**\n     * Handles delete keys: backspace and delete.\n     *\n     * @param isForward Set to true if delete was performed in forward direction.\n     * @returns Returns `true` if keys were handled correctly.\n     */\n    _handleDelete(isForward) {\n        const modelDocument = this.editor.model.document;\n        const modelSelection = modelDocument.selection;\n        // Do nothing when the read only mode is enabled.\n        if (!this.editor.model.canEditAt(modelSelection)) {\n            return;\n        }\n        // Do nothing on non-collapsed selection.\n        if (!modelSelection.isCollapsed) {\n            return;\n        }\n        const objectElement = this._getObjectElementNextToSelection(isForward);\n        if (objectElement) {\n            this.editor.model.change(writer => {\n                let previousNode = modelSelection.anchor.parent;\n                // Remove previous element if empty.\n                while (previousNode.isEmpty) {\n                    const nodeToRemove = previousNode;\n                    previousNode = nodeToRemove.parent;\n                    writer.remove(nodeToRemove);\n                }\n                this._setSelectionOverElement(objectElement);\n            });\n            return true;\n        }\n    }\n    /**\n     * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n     *\n     * @internal\n     */\n    _setSelectionOverElement(element) {\n        this.editor.model.change(writer => {\n            writer.setSelection(writer.createRangeOn(element));\n        });\n    }\n    /**\n     * Checks if {@link module:engine/model/element~Element element} placed next to the current\n     * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n     * {@link module:engine/model/schema~Schema schema} as `object`.\n     *\n     * @internal\n     * @param forward Direction of checking.\n     */\n    _getObjectElementNextToSelection(forward) {\n        const model = this.editor.model;\n        const schema = model.schema;\n        const modelSelection = model.document.selection;\n        // Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n        // to its current state after undo.\n        const probe = model.createSelection(modelSelection);\n        model.modifySelection(probe, { direction: forward ? 'forward' : 'backward' });\n        // The selection didn't change so there is nothing there.\n        if (probe.isEqual(modelSelection)) {\n            return null;\n        }\n        const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n        if (!!objectElement && schema.isObject(objectElement)) {\n            return objectElement;\n        }\n        return null;\n    }\n    /**\n     * Removes CSS class from previously selected widgets.\n     */\n    _clearPreviouslySelectedWidgets(writer) {\n        for (const widget of this._previouslySelected) {\n            writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);\n        }\n        this._previouslySelected.clear();\n    }\n    /**\n     * Moves the document selection into the first nested editable.\n     */\n    _selectFirstNestedEditable() {\n        const editor = this.editor;\n        const view = this.editor.editing.view;\n        const viewDocument = view.document;\n        for (const item of viewDocument.selection.getFirstRange().getItems()) {\n            if (item.is('editableElement')) {\n                const modelElement = editor.editing.mapper.toModelElement(item);\n                /* istanbul ignore next -- @preserve */\n                if (!modelElement) {\n                    continue;\n                }\n                const position = editor.model.createPositionAt(modelElement, 0);\n                const newRange = editor.model.schema.getNearestSelectionRange(position, 'forward');\n                editor.model.change(writer => {\n                    writer.setSelection(newRange);\n                });\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Updates the document selection so that it selects first ancestor widget.\n     */\n    _selectAncestorWidget() {\n        const editor = this.editor;\n        const mapper = editor.editing.mapper;\n        const selection = editor.editing.view.document.selection;\n        const positionParent = selection.getFirstPosition().parent;\n        const positionParentElement = positionParent.is('$text') ?\n            positionParent.parent :\n            positionParent;\n        const viewElement = positionParentElement.findAncestor(isWidget);\n        if (!viewElement) {\n            return false;\n        }\n        const modelElement = mapper.toModelElement(viewElement);\n        /* istanbul ignore next -- @preserve */\n        if (!modelElement) {\n            return false;\n        }\n        editor.model.change(writer => {\n            writer.setSelection(modelElement, 'on');\n        });\n        return true;\n    }\n}\n/**\n * Finds the closest ancestor element that is either an editable element or a widget.\n *\n * @param element The element from which to start searching.\n * @returns The closest ancestor element that is either an editable element or a widget, or null if none is found.\n */\nfunction findClosestEditableOrWidgetAncestor(element) {\n    let currentElement = element;\n    while (currentElement) {\n        if (currentElement.is('editableElement') || isWidget(currentElement)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parent;\n    }\n    return null;\n}\n/**\n * Retrieves the ViewElement associated with a mouse event in the editing view.\n *\n * @param view The editing view.\n * @param domEventData The DOM event data containing the mouse event.\n * @returns The ViewElement associated with the mouse event, or null if not found.\n */\nfunction getElementFromMouseEvent(view, domEventData) {\n    const domRange = getRangeFromMouseEvent(domEventData.domEvent);\n    let viewRange = null;\n    if (domRange) {\n        viewRange = view.domConverter.domRangeToView(domRange);\n    }\n    else {\n        // Fallback to create range in target element. It happens frequently on Safari browser.\n        // See more: https://github.com/ckeditor/ckeditor5/issues/16978\n        viewRange = view.createRange(view.createPositionAt(domEventData.target, 0));\n    }\n    if (!viewRange) {\n        return null;\n    }\n    const viewPosition = viewRange.start;\n    if (!viewPosition.parent) {\n        return null;\n    }\n    let viewNode = viewPosition.parent;\n    if (viewPosition.parent.is('editableElement')) {\n        if (viewPosition.isAtEnd && viewPosition.nodeBefore) {\n            // Click after a widget tend to return position at the end of the editable element\n            // so use the node before it if range is at the end of a parent.\n            viewNode = viewPosition.nodeBefore;\n        }\n        else if (viewPosition.isAtStart && viewPosition.nodeAfter) {\n            // Click before a widget tend to return position at the start of the editable element\n            // so use the node after it if range is at the start of a parent.\n            // See more: https://github.com/ckeditor/ckeditor5/issues/16992\n            viewNode = viewPosition.nodeAfter;\n        }\n    }\n    if (viewNode.is('$text')) {\n        return viewNode.parent;\n    }\n    return viewNode;\n}\n/**\n * Checks whether the specified `element` is a child of the `parent` element.\n *\n * @param element An element to check.\n * @param parent A parent for the element.\n */\nfunction isChild(element, parent) {\n    if (!parent) {\n        return false;\n    }\n    return Array.from(element.getAncestors()).includes(parent);\n}\n/**\n * Returns nearest text block ancestor.\n */\nfunction findTextBlockAncestor(modelElement, schema) {\n    for (const element of modelElement.getAncestors({ includeSelf: true, parentFirst: true })) {\n        if (schema.checkChild(element, '$text')) {\n            return element;\n        }\n        // Do not go beyond nested editable.\n        if (schema.isLimit(element) && !schema.isObject(element)) {\n            break;\n        }\n    }\n    return null;\n}\n/**\n * Returns next text block where could put selection.\n */\nfunction findNextTextBlock(position, schema) {\n    const treeWalker = new TreeWalker({ startPosition: position });\n    for (const { item } of treeWalker) {\n        if (schema.isLimit(item) || !item.is('element')) {\n            return null;\n        }\n        if (schema.checkChild(item, '$text')) {\n            return item;\n        }\n    }\n    return null;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgetresize/resizerstate\n */\nimport { ObservableMixin, Rect } from '@ckeditor/ckeditor5-utils';\nimport { calculateResizeHostPercentageWidth } from '../utils.js';\n/**\n * Stores the internal state of a single resizable object.\n */\nexport default class ResizeState extends /* #__PURE__ */ ObservableMixin() {\n    /**\n     * @param options Resizer options.\n     */\n    constructor(options) {\n        super();\n        this.set('activeHandlePosition', null);\n        this.set('proposedWidthPercents', null);\n        this.set('proposedWidth', null);\n        this.set('proposedHeight', null);\n        this.set('proposedHandleHostWidth', null);\n        this.set('proposedHandleHostHeight', null);\n        this._options = options;\n        this._referenceCoordinates = null;\n    }\n    /**\n     * The original width (pixels) of the resized object when the resize process was started.\n     */\n    get originalWidth() {\n        return this._originalWidth;\n    }\n    /**\n     * The original height (pixels) of the resized object when the resize process was started.\n     */\n    get originalHeight() {\n        return this._originalHeight;\n    }\n    /**\n     * The original width (percents) of the resized object when the resize process was started.\n     */\n    get originalWidthPercents() {\n        return this._originalWidthPercents;\n    }\n    /**\n     * A width to height ratio of the resized image.\n     */\n    get aspectRatio() {\n        return this._aspectRatio;\n    }\n    /**\n     *\n     * @param domResizeHandle The handle used to calculate the reference point.\n     */\n    begin(domResizeHandle, domHandleHost, domResizeHost) {\n        const clientRect = new Rect(domHandleHost);\n        this.activeHandlePosition = getHandlePosition(domResizeHandle);\n        this._referenceCoordinates = getAbsoluteBoundaryPoint(domHandleHost, getOppositePosition(this.activeHandlePosition));\n        this._originalWidth = clientRect.width;\n        this._originalHeight = clientRect.height;\n        this._aspectRatio = clientRect.width / clientRect.height;\n        const widthStyle = domResizeHost.style.width;\n        if (widthStyle && widthStyle.match(/^\\d+(\\.\\d*)?%$/)) {\n            this._originalWidthPercents = parseFloat(widthStyle);\n        }\n        else {\n            this._originalWidthPercents = calculateResizeHostPercentageWidth(domResizeHost, clientRect);\n        }\n    }\n    update(newSize) {\n        this.proposedWidth = newSize.width;\n        this.proposedHeight = newSize.height;\n        this.proposedWidthPercents = newSize.widthPercents;\n        this.proposedHandleHostWidth = newSize.handleHostWidth;\n        this.proposedHandleHostHeight = newSize.handleHostHeight;\n    }\n}\n/**\n * Returns coordinates of the top-left corner of an element, relative to the document's top-left corner.\n *\n * @param resizerPosition The position of the resize handle, e.g. `\"top-left\"`, `\"bottom-right\"`.\n */\nfunction getAbsoluteBoundaryPoint(element, resizerPosition) {\n    const elementRect = new Rect(element);\n    const positionParts = resizerPosition.split('-');\n    const ret = {\n        x: positionParts[1] == 'right' ? elementRect.right : elementRect.left,\n        y: positionParts[0] == 'bottom' ? elementRect.bottom : elementRect.top\n    };\n    ret.x += element.ownerDocument.defaultView.scrollX;\n    ret.y += element.ownerDocument.defaultView.scrollY;\n    return ret;\n}\n/**\n * @param resizerPosition The expected resizer position, like `\"top-left\"`, `\"bottom-right\"`.\n * @returns A prefixed HTML class name for the resizer element.\n */\nfunction getResizerHandleClass(resizerPosition) {\n    return `ck-widget__resizer__handle-${resizerPosition}`;\n}\n/**\n * Determines the position of a given resize handle.\n *\n * @param domHandle Handle used to calculate the reference point.\n * @returns Returns a string like `\"top-left\"` or `undefined` if not matched.\n */\nfunction getHandlePosition(domHandle) {\n    const resizerPositions = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];\n    for (const position of resizerPositions) {\n        if (domHandle.classList.contains(getResizerHandleClass(position))) {\n            return position;\n        }\n    }\n}\n/**\n * @param position Like `\"top-left\"`.\n * @returns Inverted `position`, e.g. it returns `\"bottom-right\"` if `\"top-left\"` was given as `position`.\n */\nfunction getOppositePosition(position) {\n    const parts = position.split('-');\n    const replacements = {\n        top: 'bottom',\n        bottom: 'top',\n        left: 'right',\n        right: 'left'\n    };\n    return `${replacements[parts[0]]}-${replacements[parts[1]]}`;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgetresize/sizeview\n */\nimport { View } from '@ckeditor/ckeditor5-ui';\n/**\n * A view displaying the proposed new element size during the resizing.\n */\nexport default class SizeView extends View {\n    constructor() {\n        super();\n        const bind = this.bindTemplate;\n        this.setTemplate({\n            tag: 'div',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-size-view',\n                    bind.to('_viewPosition', value => value ? `ck-orientation-${value}` : '')\n                ],\n                style: {\n                    display: bind.if('_isVisible', 'none', visible => !visible)\n                }\n            },\n            children: [{\n                    text: bind.to('_label')\n                }]\n        });\n    }\n    /**\n     * A method used for binding the `SizeView` instance properties to the `ResizeState` instance observable properties.\n     *\n     * @internal\n     * @param options An object defining the resizer options, used for setting the proper size label.\n     * @param resizeState The `ResizeState` class instance, used for keeping the `SizeView` state up to date.\n     */\n    _bindToState(options, resizeState) {\n        this.bind('_isVisible').to(resizeState, 'proposedWidth', resizeState, 'proposedHeight', (width, height) => width !== null && height !== null);\n        this.bind('_label').to(resizeState, 'proposedHandleHostWidth', resizeState, 'proposedHandleHostHeight', resizeState, 'proposedWidthPercents', (width, height, widthPercents) => {\n            if (options.unit === 'px') {\n                return `${width}×${height}`;\n            }\n            else {\n                return `${widthPercents}%`;\n            }\n        });\n        this.bind('_viewPosition').to(resizeState, 'activeHandlePosition', resizeState, 'proposedHandleHostWidth', resizeState, 'proposedHandleHostHeight', \n        // If the widget is too small to contain the size label, display the label above.\n        (position, width, height) => width < 50 || height < 50 ? 'above-center' : position);\n    }\n    /**\n     * A method used for cleaning up. It removes the bindings and hides the view.\n     *\n     * @internal\n     */\n    _dismiss() {\n        this.unbind();\n        this._isVisible = false;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgetresize/resizer\n */\nimport { Template } from '@ckeditor/ckeditor5-ui';\nimport { Rect, ObservableMixin, compareArrays } from '@ckeditor/ckeditor5-utils';\nimport ResizeState from './resizerstate.js';\nimport SizeView from './sizeview.js';\n/**\n * Represents a resizer for a single resizable object.\n */\nexport default class Resizer extends /* #__PURE__ */ ObservableMixin() {\n    /**\n     * @param options Resizer options.\n     */\n    constructor(options) {\n        super();\n        /**\n         * A wrapper that is controlled by the resizer. This is usually a widget element.\n         */\n        this._viewResizerWrapper = null;\n        this._options = options;\n        this.set('isEnabled', true);\n        this.set('isSelected', false);\n        this.bind('isVisible').to(this, 'isEnabled', this, 'isSelected', (isEnabled, isSelected) => isEnabled && isSelected);\n        this.decorate('begin');\n        this.decorate('cancel');\n        this.decorate('commit');\n        this.decorate('updateSize');\n        this.on('commit', event => {\n            // State might not be initialized yet. In this case, prevent further handling and make sure that the resizer is\n            // cleaned up (#5195).\n            if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {\n                this._cleanup();\n                event.stop();\n            }\n        }, { priority: 'high' });\n    }\n    /**\n     * Stores the state of the resizable host geometry, such as the original width, the currently proposed height, etc.\n     *\n     * Note that a new state is created for each resize transaction.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Makes resizer visible in the UI.\n     */\n    show() {\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            writer.removeClass('ck-hidden', this._viewResizerWrapper);\n        });\n    }\n    /**\n     * Hides resizer in the UI.\n     */\n    hide() {\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            writer.addClass('ck-hidden', this._viewResizerWrapper);\n        });\n    }\n    /**\n     * Attaches the resizer to the DOM.\n     */\n    attach() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const that = this;\n        const widgetElement = this._options.viewElement;\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            const viewResizerWrapper = writer.createUIElement('div', {\n                class: 'ck ck-reset_all ck-widget__resizer'\n            }, function (domDocument) {\n                const domElement = this.toDomElement(domDocument);\n                that._appendHandles(domElement);\n                that._appendSizeUI(domElement);\n                return domElement;\n            });\n            // Append the resizer wrapper to the widget's wrapper.\n            writer.insert(writer.createPositionAt(widgetElement, 'end'), viewResizerWrapper);\n            writer.addClass('ck-widget_with-resizer', widgetElement);\n            this._viewResizerWrapper = viewResizerWrapper;\n            if (!this.isVisible) {\n                this.hide();\n            }\n        });\n        this.on('change:isVisible', () => {\n            if (this.isVisible) {\n                this.show();\n                this.redraw();\n            }\n            else {\n                this.hide();\n            }\n        });\n    }\n    /**\n     * Starts the resizing process.\n     *\n     * Creates a new {@link #state} for the current process.\n     *\n     * @fires begin\n     * @param domResizeHandle Clicked handle.\n     */\n    begin(domResizeHandle) {\n        this._state = new ResizeState(this._options);\n        this._sizeView._bindToState(this._options, this.state);\n        this._initialViewWidth = this._options.viewElement.getStyle('width');\n        this.state.begin(domResizeHandle, this._getHandleHost(), this._getResizeHost());\n    }\n    /**\n     * Updates the proposed size based on `domEventData`.\n     *\n     * @fires updateSize\n     */\n    updateSize(domEventData) {\n        const newSize = this._proposeNewSize(domEventData);\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            const unit = this._options.unit || '%';\n            const newWidth = (unit === '%' ? newSize.widthPercents : newSize.width) + unit;\n            writer.setStyle('width', newWidth, this._options.viewElement);\n        });\n        // Get an actual image width, and:\n        // * reflect this size to the resize wrapper\n        // * apply this **real** size to the state\n        const domHandleHost = this._getHandleHost();\n        const domHandleHostRect = new Rect(domHandleHost);\n        const handleHostWidth = Math.round(domHandleHostRect.width);\n        const handleHostHeight = Math.round(domHandleHostRect.height);\n        // Handle max-width limitation.\n        const domResizeHostRect = new Rect(domHandleHost);\n        newSize.width = Math.round(domResizeHostRect.width);\n        newSize.height = Math.round(domResizeHostRect.height);\n        this.redraw(domHandleHostRect);\n        this.state.update({\n            ...newSize,\n            handleHostWidth,\n            handleHostHeight\n        });\n    }\n    /**\n     * Applies the geometry proposed with the resizer.\n     *\n     * @fires commit\n     */\n    commit() {\n        const unit = this._options.unit || '%';\n        const newValue = (unit === '%' ? this.state.proposedWidthPercents : this.state.proposedWidth) + unit;\n        // Both cleanup and onCommit callback are very likely to make view changes. Ensure that it is made in a single step.\n        this._options.editor.editing.view.change(() => {\n            this._cleanup();\n            this._options.onCommit(newValue);\n        });\n    }\n    /**\n     * Cancels and rejects the proposed resize dimensions, hiding the UI.\n     *\n     * @fires cancel\n     */\n    cancel() {\n        this._cleanup();\n    }\n    /**\n     * Destroys the resizer.\n     */\n    destroy() {\n        this.cancel();\n    }\n    /**\n     * Redraws the resizer.\n     *\n     * @param handleHostRect Handle host rectangle might be given to improve performance.\n     */\n    redraw(handleHostRect) {\n        const domWrapper = this._domResizerWrapper;\n        // Refresh only if resizer exists in the DOM.\n        if (!existsInDom(domWrapper)) {\n            return;\n        }\n        const widgetWrapper = domWrapper.parentElement;\n        const handleHost = this._getHandleHost();\n        const resizerWrapper = this._viewResizerWrapper;\n        const currentDimensions = [\n            resizerWrapper.getStyle('width'),\n            resizerWrapper.getStyle('height'),\n            resizerWrapper.getStyle('left'),\n            resizerWrapper.getStyle('top')\n        ];\n        let newDimensions;\n        if (widgetWrapper.isSameNode(handleHost)) {\n            const clientRect = handleHostRect || new Rect(handleHost);\n            newDimensions = [\n                clientRect.width + 'px',\n                clientRect.height + 'px',\n                undefined,\n                undefined\n            ];\n        }\n        // In case a resizing host is not a widget wrapper, we need to compensate\n        // for any additional offsets the resize host might have. E.g. wrapper padding\n        // or simply another editable. By doing that the border and resizers are shown\n        // only around the resize host.\n        else {\n            newDimensions = [\n                handleHost.offsetWidth + 'px',\n                handleHost.offsetHeight + 'px',\n                handleHost.offsetLeft + 'px',\n                handleHost.offsetTop + 'px'\n            ];\n        }\n        // Make changes to the view only if the resizer should actually get new dimensions.\n        // Otherwise, if View#change() was always called, this would cause EditorUI#update\n        // loops because the WidgetResize plugin listens to EditorUI#update and updates\n        // the resizer.\n        // https://github.com/ckeditor/ckeditor5/issues/7633\n        if (compareArrays(currentDimensions, newDimensions) !== 'same') {\n            this._options.editor.editing.view.change(writer => {\n                writer.setStyle({\n                    width: newDimensions[0],\n                    height: newDimensions[1],\n                    left: newDimensions[2],\n                    top: newDimensions[3]\n                }, resizerWrapper);\n            });\n        }\n    }\n    containsHandle(domElement) {\n        return this._domResizerWrapper.contains(domElement);\n    }\n    static isResizeHandle(domElement) {\n        return domElement.classList.contains('ck-widget__resizer__handle');\n    }\n    /**\n     * Cleans up the context state.\n     */\n    _cleanup() {\n        this._sizeView._dismiss();\n        const editingView = this._options.editor.editing.view;\n        editingView.change(writer => {\n            writer.setStyle('width', this._initialViewWidth, this._options.viewElement);\n        });\n    }\n    /**\n     * Calculates the proposed size as the resize handles are dragged.\n     *\n     * @param domEventData Event data that caused the size update request. It should be used to calculate the proposed size.\n     */\n    _proposeNewSize(domEventData) {\n        const state = this.state;\n        const currentCoordinates = extractCoordinates(domEventData);\n        const isCentered = this._options.isCentered ? this._options.isCentered(this) : true;\n        // Enlargement defines how much the resize host has changed in a given axis. Naturally it could be a negative number\n        // meaning that it has been shrunk.\n        //\n        // +----------------+--+\n        // |                |  |\n        // |       img      |  |\n        // |  /handle host  |  |\n        // +----------------+  | ^\n        // |                   | | - enlarge y\n        // +-------------------+ v\n        // \t\t\t\t\t<-->\n        // \t\t\t\t\t enlarge x\n        const enlargement = {\n            x: state._referenceCoordinates.x - (currentCoordinates.x + state.originalWidth),\n            y: (currentCoordinates.y - state.originalHeight) - state._referenceCoordinates.y\n        };\n        if (isCentered && state.activeHandlePosition.endsWith('-right')) {\n            enlargement.x = currentCoordinates.x - (state._referenceCoordinates.x + state.originalWidth);\n        }\n        // Objects needs to be resized twice as much in horizontal axis if centered, since enlargement is counted from\n        // one resized corner to your cursor. It needs to be duplicated to compensate for the other side too.\n        if (isCentered) {\n            enlargement.x *= 2;\n        }\n        // const resizeHost = this._getResizeHost();\n        // The size proposed by the user. It does not consider the aspect ratio.\n        let width = Math.abs(state.originalWidth + enlargement.x);\n        let height = Math.abs(state.originalHeight + enlargement.y);\n        // Dominant determination must take the ratio into account.\n        const dominant = width / state.aspectRatio > height ? 'width' : 'height';\n        if (dominant == 'width') {\n            height = width / state.aspectRatio;\n        }\n        else {\n            width = height * state.aspectRatio;\n        }\n        return {\n            width: Math.round(width),\n            height: Math.round(height),\n            widthPercents: Math.min(Math.round(state.originalWidthPercents / state.originalWidth * width * 100) / 100, 100)\n        };\n    }\n    /**\n     * Obtains the resize host.\n     *\n     * Resize host is an object that receives dimensions which are the result of resizing.\n     */\n    _getResizeHost() {\n        const widgetWrapper = this._domResizerWrapper.parentElement;\n        return this._options.getResizeHost(widgetWrapper);\n    }\n    /**\n     * Obtains the handle host.\n     *\n     * Handle host is an object that the handles are aligned to.\n     *\n     * Handle host will not always be an entire widget itself. Take an image as an example. The image widget\n     * contains an image and a caption. Only the image should be surrounded with handles.\n     */\n    _getHandleHost() {\n        const widgetWrapper = this._domResizerWrapper.parentElement;\n        return this._options.getHandleHost(widgetWrapper);\n    }\n    /**\n     * DOM container of the entire resize UI.\n     *\n     * Note that this property will have a value only after the element bound with the resizer is rendered\n     * (otherwise `null`).\n     */\n    get _domResizerWrapper() {\n        return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);\n    }\n    /**\n     * Renders the resize handles in the DOM.\n     *\n     * @param domElement The resizer wrapper.\n     */\n    _appendHandles(domElement) {\n        const resizerPositions = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];\n        for (const currentPosition of resizerPositions) {\n            domElement.appendChild((new Template({\n                tag: 'div',\n                attributes: {\n                    class: `ck-widget__resizer__handle ${getResizerClass(currentPosition)}`\n                }\n            }).render()));\n        }\n    }\n    /**\n     * Sets up the {@link #_sizeView} property and adds it to the passed `domElement`.\n     */\n    _appendSizeUI(domElement) {\n        this._sizeView = new SizeView();\n        // Make sure icon#element is rendered before passing to appendChild().\n        this._sizeView.render();\n        domElement.appendChild(this._sizeView.element);\n    }\n}\n/**\n * @param resizerPosition Expected resizer position like `\"top-left\"`, `\"bottom-right\"`.\n * @returns A prefixed HTML class name for the resizer element\n */\nfunction getResizerClass(resizerPosition) {\n    return `ck-widget__resizer__handle-${resizerPosition}`;\n}\nfunction extractCoordinates(event) {\n    return {\n        x: event.pageX,\n        y: event.pageY\n    };\n}\nfunction existsInDom(element) {\n    return element && element.ownerDocument && element.ownerDocument.contains(element);\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module widget/widgetresize\n */\nimport Resizer from './widgetresize/resizer.js';\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { MouseObserver } from '@ckeditor/ckeditor5-engine';\nimport { DomEmitterMixin, global } from '@ckeditor/ckeditor5-utils';\nimport { throttle } from 'lodash-es';\nimport '../theme/widgetresize.css';\n/**\n * The widget resize feature plugin.\n *\n * Use the {@link module:widget/widgetresize~WidgetResize#attachTo} method to create a resizer for the specified widget.\n */\nexport default class WidgetResize extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A map of resizers created using this plugin instance.\n         */\n        this._resizers = new Map();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'WidgetResize';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editing = this.editor.editing;\n        const domDocument = global.window.document;\n        this.set('selectedResizer', null);\n        this.set('_activeResizer', null);\n        editing.view.addObserver(MouseObserver);\n        this._observer = new (DomEmitterMixin())();\n        this.listenTo(editing.view.document, 'mousedown', this._mouseDownListener.bind(this), { priority: 'high' });\n        this._observer.listenTo(domDocument, 'mousemove', this._mouseMoveListener.bind(this));\n        this._observer.listenTo(domDocument, 'mouseup', this._mouseUpListener.bind(this));\n        this._redrawSelectedResizerThrottled = throttle(() => this.redrawSelectedResizer(), 200);\n        // Redrawing on any change of the UI of the editor (including content changes).\n        this.editor.ui.on('update', this._redrawSelectedResizerThrottled);\n        // Remove view widget-resizer mappings for widgets that have been removed from the document.\n        // https://github.com/ckeditor/ckeditor5/issues/10156\n        // https://github.com/ckeditor/ckeditor5/issues/10266\n        this.editor.model.document.on('change', () => {\n            for (const [viewElement, resizer] of this._resizers) {\n                if (!viewElement.isAttached()) {\n                    this._resizers.delete(viewElement);\n                    resizer.destroy();\n                }\n            }\n        }, { priority: 'lowest' });\n        // Resizers need to be redrawn upon window resize, because new window might shrink resize host.\n        this._observer.listenTo(global.window, 'resize', this._redrawSelectedResizerThrottled);\n        const viewSelection = this.editor.editing.view.document.selection;\n        viewSelection.on('change', () => {\n            const selectedElement = viewSelection.getSelectedElement();\n            const resizer = this.getResizerByViewElement(selectedElement) || null;\n            if (resizer) {\n                this.select(resizer);\n            }\n            else {\n                this.deselect();\n            }\n        });\n    }\n    /**\n     * Redraws the selected resizer if there is any selected resizer and if it is visible.\n     */\n    redrawSelectedResizer() {\n        if (this.selectedResizer && this.selectedResizer.isVisible) {\n            this.selectedResizer.redraw();\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        super.destroy();\n        this._observer.stopListening();\n        for (const resizer of this._resizers.values()) {\n            resizer.destroy();\n        }\n        this._redrawSelectedResizerThrottled.cancel();\n    }\n    /**\n     * Marks resizer as selected.\n     */\n    select(resizer) {\n        this.deselect();\n        this.selectedResizer = resizer;\n        this.selectedResizer.isSelected = true;\n    }\n    /**\n     * Deselects currently set resizer.\n     */\n    deselect() {\n        if (this.selectedResizer) {\n            this.selectedResizer.isSelected = false;\n        }\n        this.selectedResizer = null;\n    }\n    /**\n     * @param options Resizer options.\n     */\n    attachTo(options) {\n        const resizer = new Resizer(options);\n        const plugins = this.editor.plugins;\n        resizer.attach();\n        if (plugins.has('WidgetToolbarRepository')) {\n            // Hiding widget toolbar to improve the performance\n            // (https://github.com/ckeditor/ckeditor5-widget/pull/112#issuecomment-564528765).\n            const widgetToolbarRepository = plugins.get('WidgetToolbarRepository');\n            resizer.on('begin', () => {\n                widgetToolbarRepository.forceDisabled('resize');\n            }, { priority: 'lowest' });\n            resizer.on('cancel', () => {\n                widgetToolbarRepository.clearForceDisabled('resize');\n            }, { priority: 'highest' });\n            resizer.on('commit', () => {\n                widgetToolbarRepository.clearForceDisabled('resize');\n            }, { priority: 'highest' });\n        }\n        this._resizers.set(options.viewElement, resizer);\n        const viewSelection = this.editor.editing.view.document.selection;\n        const selectedElement = viewSelection.getSelectedElement();\n        // If the element the resizer is created for is currently focused, it should become visible.\n        if (this.getResizerByViewElement(selectedElement) == resizer) {\n            this.select(resizer);\n        }\n        return resizer;\n    }\n    /**\n     * Returns a resizer created for a given view element (widget element).\n     *\n     * @param viewElement View element associated with the resizer.\n     */\n    getResizerByViewElement(viewElement) {\n        return this._resizers.get(viewElement);\n    }\n    /**\n     * Returns a resizer that contains a given resize handle.\n     */\n    _getResizerByHandle(domResizeHandle) {\n        for (const resizer of this._resizers.values()) {\n            if (resizer.containsHandle(domResizeHandle)) {\n                return resizer;\n            }\n        }\n    }\n    /**\n     * @param domEventData Native DOM event.\n     */\n    _mouseDownListener(event, domEventData) {\n        const resizeHandle = domEventData.domTarget;\n        if (!Resizer.isResizeHandle(resizeHandle)) {\n            return;\n        }\n        this._activeResizer = this._getResizerByHandle(resizeHandle) || null;\n        if (this._activeResizer) {\n            this._activeResizer.begin(resizeHandle);\n            // Do not call other events when resizing. See: #6755.\n            event.stop();\n            domEventData.preventDefault();\n        }\n    }\n    /**\n     * @param domEventData Native DOM event.\n     */\n    _mouseMoveListener(event, domEventData) {\n        if (this._activeResizer) {\n            this._activeResizer.updateSize(domEventData);\n        }\n    }\n    _mouseUpListener() {\n        if (this._activeResizer) {\n            this._activeResizer.commit();\n            this._activeResizer = null;\n        }\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/lineview\n */\n/* istanbul ignore file -- @preserve */\nimport { View } from '@ckeditor/ckeditor5-ui';\nimport { toUnit } from '@ckeditor/ckeditor5-utils';\nconst toPx = /* #__PURE__ */ toUnit('px');\n/**\n * The horizontal drop target line view.\n */\nexport default class LineView extends View {\n    /**\n     * @inheritDoc\n     */\n    constructor() {\n        super();\n        const bind = this.bindTemplate;\n        this.set({\n            isVisible: false,\n            left: null,\n            top: null,\n            width: null\n        });\n        this.setTemplate({\n            tag: 'div',\n            attributes: {\n                class: [\n                    'ck',\n                    'ck-clipboard-drop-target-line',\n                    bind.if('isVisible', 'ck-hidden', value => !value)\n                ],\n                style: {\n                    left: bind.to('left', left => toPx(left)),\n                    top: bind.to('top', top => toPx(top)),\n                    width: bind.to('width', width => toPx(width))\n                }\n            }\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/dragdroptarget\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { global, Rect, DomEmitterMixin, delay, ResizeObserver } from '@ckeditor/ckeditor5-utils';\nimport LineView from './lineview.js';\nimport { throttle } from 'lodash-es';\n/**\n * Part of the Drag and Drop handling. Responsible for finding and displaying the drop target.\n *\n * @internal\n */\nexport default class DragDropTarget extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A delayed callback removing the drop marker.\n         *\n         * @internal\n         */\n        this.removeDropMarkerDelayed = delay(() => this.removeDropMarker(), 40);\n        /**\n         * A throttled callback updating the drop marker.\n         */\n        this._updateDropMarkerThrottled = throttle(targetRange => this._updateDropMarker(targetRange), 40);\n        /**\n         * A throttled callback reconverting the drop parker.\n         */\n        this._reconvertMarkerThrottled = throttle(() => {\n            if (this.editor.model.markers.has('drop-target')) {\n                this.editor.editing.reconvertMarker('drop-target');\n            }\n        }, 0);\n        /**\n         * The horizontal drop target line view.\n         */\n        this._dropTargetLineView = new LineView();\n        /**\n         * DOM Emitter.\n         */\n        this._domEmitter = new (DomEmitterMixin())();\n        /**\n         * Map of document scrollable elements.\n         */\n        this._scrollables = new Map();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DragDropTarget';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        this._setupDropMarker();\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        this._domEmitter.stopListening();\n        for (const { resizeObserver } of this._scrollables.values()) {\n            resizeObserver.destroy();\n        }\n        this._updateDropMarkerThrottled.cancel();\n        this.removeDropMarkerDelayed.cancel();\n        this._reconvertMarkerThrottled.cancel();\n        return super.destroy();\n    }\n    /**\n     * Finds the drop target range and updates the drop marker.\n     *\n     * @internal\n     */\n    updateDropMarker(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {\n        this.removeDropMarkerDelayed.cancel();\n        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);\n        /* istanbul ignore next -- @preserve */\n        if (!targetRange) {\n            return;\n        }\n        if (draggedRange && draggedRange.containsRange(targetRange)) {\n            // Target range is inside the dragged range.\n            return this.removeDropMarker();\n        }\n        this._updateDropMarkerThrottled(targetRange);\n    }\n    /**\n     * Finds the final drop target range.\n     *\n     * @internal\n     */\n    getFinalDropRange(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {\n        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);\n        // The dragging markers must be removed after searching for the target range because sometimes\n        // the target lands on the marker itself.\n        this.removeDropMarker();\n        return targetRange;\n    }\n    /**\n     * Removes the drop target marker.\n     *\n     * @internal\n     */\n    removeDropMarker() {\n        const model = this.editor.model;\n        this.removeDropMarkerDelayed.cancel();\n        this._updateDropMarkerThrottled.cancel();\n        this._dropTargetLineView.isVisible = false;\n        if (model.markers.has('drop-target')) {\n            model.change(writer => {\n                writer.removeMarker('drop-target');\n            });\n        }\n    }\n    /**\n     * Creates downcast conversion for the drop target marker.\n     */\n    _setupDropMarker() {\n        const editor = this.editor;\n        editor.ui.view.body.add(this._dropTargetLineView);\n        // Drop marker conversion for hovering over widgets.\n        editor.conversion.for('editingDowncast').markerToHighlight({\n            model: 'drop-target',\n            view: {\n                classes: ['ck-clipboard-drop-target-range']\n            }\n        });\n        // Drop marker conversion for in text and block drop target.\n        editor.conversion.for('editingDowncast').markerToElement({\n            model: 'drop-target',\n            view: (data, { writer }) => {\n                // Inline drop.\n                if (editor.model.schema.checkChild(data.markerRange.start, '$text')) {\n                    this._dropTargetLineView.isVisible = false;\n                    return this._createDropTargetPosition(writer);\n                }\n                // Block drop.\n                else {\n                    if (data.markerRange.isCollapsed) {\n                        this._updateDropTargetLine(data.markerRange);\n                    }\n                    else {\n                        this._dropTargetLineView.isVisible = false;\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Updates the drop target marker to the provided range.\n     *\n     * @param targetRange The range to set the marker to.\n     */\n    _updateDropMarker(targetRange) {\n        const editor = this.editor;\n        const markers = editor.model.markers;\n        editor.model.change(writer => {\n            if (markers.has('drop-target')) {\n                if (!markers.get('drop-target').getRange().isEqual(targetRange)) {\n                    writer.updateMarker('drop-target', { range: targetRange });\n                }\n            }\n            else {\n                writer.addMarker('drop-target', {\n                    range: targetRange,\n                    usingOperation: false,\n                    affectsData: false\n                });\n            }\n        });\n    }\n    /**\n     * Creates the UI element for vertical (in-line) drop target.\n     */\n    _createDropTargetPosition(writer) {\n        return writer.createUIElement('span', { class: 'ck ck-clipboard-drop-target-position' }, function (domDocument) {\n            const domElement = this.toDomElement(domDocument);\n            // Using word joiner to make this marker as high as text and also making text not break on marker.\n            domElement.append('\\u2060', domDocument.createElement('span'), '\\u2060');\n            return domElement;\n        });\n    }\n    /**\n     * Updates the horizontal drop target line.\n     */\n    _updateDropTargetLine(range) {\n        const editing = this.editor.editing;\n        const nodeBefore = range.start.nodeBefore;\n        const nodeAfter = range.start.nodeAfter;\n        const nodeParent = range.start.parent;\n        const viewElementBefore = nodeBefore ? editing.mapper.toViewElement(nodeBefore) : null;\n        const domElementBefore = viewElementBefore ? editing.view.domConverter.mapViewToDom(viewElementBefore) : null;\n        const viewElementAfter = nodeAfter ? editing.mapper.toViewElement(nodeAfter) : null;\n        const domElementAfter = viewElementAfter ? editing.view.domConverter.mapViewToDom(viewElementAfter) : null;\n        const viewElementParent = editing.mapper.toViewElement(nodeParent);\n        if (!viewElementParent) {\n            return;\n        }\n        const domElementParent = editing.view.domConverter.mapViewToDom(viewElementParent);\n        const domScrollableRect = this._getScrollableRect(viewElementParent);\n        const { scrollX, scrollY } = global.window;\n        const rectBefore = domElementBefore ? new Rect(domElementBefore) : null;\n        const rectAfter = domElementAfter ? new Rect(domElementAfter) : null;\n        const rectParent = new Rect(domElementParent).excludeScrollbarsAndBorders();\n        const above = rectBefore ? rectBefore.bottom : rectParent.top;\n        const below = rectAfter ? rectAfter.top : rectParent.bottom;\n        const parentStyle = global.window.getComputedStyle(domElementParent);\n        const top = (above <= below ? (above + below) / 2 : below);\n        if (domScrollableRect.top < top && top < domScrollableRect.bottom) {\n            const left = rectParent.left + parseFloat(parentStyle.paddingLeft);\n            const right = rectParent.right - parseFloat(parentStyle.paddingRight);\n            const leftClamped = Math.max(left + scrollX, domScrollableRect.left);\n            const rightClamped = Math.min(right + scrollX, domScrollableRect.right);\n            this._dropTargetLineView.set({\n                isVisible: true,\n                left: leftClamped,\n                top: top + scrollY,\n                width: rightClamped - leftClamped\n            });\n        }\n        else {\n            this._dropTargetLineView.isVisible = false;\n        }\n    }\n    /**\n     * Finds the closest scrollable element rect for the given view element.\n     */\n    _getScrollableRect(viewElement) {\n        const rootName = viewElement.root.rootName;\n        let domScrollable;\n        if (this._scrollables.has(rootName)) {\n            domScrollable = this._scrollables.get(rootName).domElement;\n        }\n        else {\n            const domElement = this.editor.editing.view.domConverter.mapViewToDom(viewElement);\n            domScrollable = findScrollableElement(domElement);\n            this._domEmitter.listenTo(domScrollable, 'scroll', this._reconvertMarkerThrottled, { usePassive: true });\n            const resizeObserver = new ResizeObserver(domScrollable, this._reconvertMarkerThrottled);\n            this._scrollables.set(rootName, {\n                domElement: domScrollable,\n                resizeObserver\n            });\n        }\n        return new Rect(domScrollable).excludeScrollbarsAndBorders();\n    }\n}\n/**\n * Returns fixed selection range for given position and target element.\n */\nfunction findDropTargetRange(editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {\n    const model = editor.model;\n    const mapper = editor.editing.mapper;\n    const targetModelElement = getClosestMappedModelElement(editor, targetViewElement);\n    let modelElement = targetModelElement;\n    while (modelElement) {\n        if (!blockMode) {\n            if (model.schema.checkChild(modelElement, '$text')) {\n                if (targetViewRanges) {\n                    const targetViewPosition = targetViewRanges[0].start;\n                    const targetModelPosition = mapper.toModelPosition(targetViewPosition);\n                    const canDropOnPosition = !draggedRange || Array\n                        .from(draggedRange.getItems({ shallow: true }))\n                        .every(item => model.schema.checkChild(targetModelPosition, item));\n                    if (canDropOnPosition) {\n                        if (model.schema.checkChild(targetModelPosition, '$text')) {\n                            return model.createRange(targetModelPosition);\n                        }\n                        else if (targetViewPosition) {\n                            // This is the case of dropping inside a span wrapper of an inline image.\n                            return findDropTargetRangeForElement(editor, getClosestMappedModelElement(editor, targetViewPosition.parent), clientX, clientY);\n                        }\n                    }\n                }\n            }\n            else if (model.schema.isInline(modelElement)) {\n                return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);\n            }\n        }\n        if (model.schema.isBlock(modelElement)) {\n            return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);\n        }\n        else if (model.schema.checkChild(modelElement, '$block')) {\n            const childNodes = Array.from(modelElement.getChildren())\n                .filter((node) => node.is('element') && !shouldIgnoreElement(editor, node));\n            let startIndex = 0;\n            let endIndex = childNodes.length;\n            if (endIndex == 0) {\n                return model.createRange(model.createPositionAt(modelElement, 'end'));\n            }\n            while (startIndex < endIndex - 1) {\n                const middleIndex = Math.floor((startIndex + endIndex) / 2);\n                const side = findElementSide(editor, childNodes[middleIndex], clientX, clientY);\n                if (side == 'before') {\n                    endIndex = middleIndex;\n                }\n                else {\n                    startIndex = middleIndex;\n                }\n            }\n            return findDropTargetRangeForElement(editor, childNodes[startIndex], clientX, clientY);\n        }\n        modelElement = modelElement.parent;\n    }\n    return null;\n}\n/**\n * Returns true for elements which should be ignored.\n */\nfunction shouldIgnoreElement(editor, modelElement) {\n    const mapper = editor.editing.mapper;\n    const domConverter = editor.editing.view.domConverter;\n    const viewElement = mapper.toViewElement(modelElement);\n    if (!viewElement) {\n        return true;\n    }\n    const domElement = domConverter.mapViewToDom(viewElement);\n    return global.window.getComputedStyle(domElement).float != 'none';\n}\n/**\n * Returns target range relative to the given element.\n */\nfunction findDropTargetRangeForElement(editor, modelElement, clientX, clientY) {\n    const model = editor.model;\n    return model.createRange(model.createPositionAt(modelElement, findElementSide(editor, modelElement, clientX, clientY)));\n}\n/**\n * Resolves whether drop marker should be before or after the given element.\n */\nfunction findElementSide(editor, modelElement, clientX, clientY) {\n    const mapper = editor.editing.mapper;\n    const domConverter = editor.editing.view.domConverter;\n    const viewElement = mapper.toViewElement(modelElement);\n    const domElement = domConverter.mapViewToDom(viewElement);\n    const rect = new Rect(domElement);\n    if (editor.model.schema.isInline(modelElement)) {\n        return clientX < (rect.left + rect.right) / 2 ? 'before' : 'after';\n    }\n    else {\n        return clientY < (rect.top + rect.bottom) / 2 ? 'before' : 'after';\n    }\n}\n/**\n * Returns the closest model element for the specified view element.\n */\nfunction getClosestMappedModelElement(editor, element) {\n    const mapper = editor.editing.mapper;\n    const view = editor.editing.view;\n    const targetModelElement = mapper.toModelElement(element);\n    if (targetModelElement) {\n        return targetModelElement;\n    }\n    // Find mapped ancestor if the target is inside not mapped element (for example inline code element).\n    const viewPosition = view.createPositionBefore(element);\n    const viewElement = mapper.findMappedViewAncestor(viewPosition);\n    return mapper.toModelElement(viewElement);\n}\n/**\n * Returns the closest scrollable ancestor DOM element.\n *\n * It is assumed that `domNode` is attached to the document.\n */\nfunction findScrollableElement(domNode) {\n    let domElement = domNode;\n    do {\n        domElement = domElement.parentElement;\n        const overflow = global.window.getComputedStyle(domElement).overflowY;\n        if (overflow == 'auto' || overflow == 'scroll') {\n            break;\n        }\n    } while (domElement.tagName != 'BODY');\n    return domElement;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/dragdropblocktoolbar\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { env, global, DomEmitterMixin } from '@ckeditor/ckeditor5-utils';\nimport ClipboardObserver from './clipboardobserver.js';\n/**\n * Integration of a block Drag and Drop support with the block toolbar.\n *\n * @internal\n */\nexport default class DragDropBlockToolbar extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * Whether current dragging is started by block toolbar button dragging.\n         */\n        this._isBlockDragging = false;\n        /**\n         * DOM Emitter.\n         */\n        this._domEmitter = new (DomEmitterMixin())();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DragDropBlockToolbar';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly) => {\n            if (isReadOnly) {\n                this.forceDisabled('readOnlyMode');\n                this._isBlockDragging = false;\n            }\n            else {\n                this.clearForceDisabled('readOnlyMode');\n            }\n        });\n        if (env.isAndroid) {\n            this.forceDisabled('noAndroidSupport');\n        }\n        if (editor.plugins.has('BlockToolbar')) {\n            const blockToolbar = editor.plugins.get('BlockToolbar');\n            const element = blockToolbar.buttonView.element;\n            this._domEmitter.listenTo(element, 'dragstart', (evt, data) => this._handleBlockDragStart(data));\n            this._domEmitter.listenTo(global.document, 'dragover', (evt, data) => this._handleBlockDragging(data));\n            this._domEmitter.listenTo(global.document, 'drop', (evt, data) => this._handleBlockDragging(data));\n            this._domEmitter.listenTo(global.document, 'dragend', () => this._handleBlockDragEnd(), { useCapture: true });\n            if (this.isEnabled) {\n                element.setAttribute('draggable', 'true');\n            }\n            this.on('change:isEnabled', (evt, name, isEnabled) => {\n                element.setAttribute('draggable', isEnabled ? 'true' : 'false');\n            });\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        this._domEmitter.stopListening();\n        return super.destroy();\n    }\n    /**\n     * The `dragstart` event handler.\n     */\n    _handleBlockDragStart(domEvent) {\n        if (!this.isEnabled) {\n            return;\n        }\n        const model = this.editor.model;\n        const selection = model.document.selection;\n        const view = this.editor.editing.view;\n        const blocks = Array.from(selection.getSelectedBlocks());\n        const draggedRange = model.createRange(model.createPositionBefore(blocks[0]), model.createPositionAfter(blocks[blocks.length - 1]));\n        model.change(writer => writer.setSelection(draggedRange));\n        this._isBlockDragging = true;\n        view.focus();\n        view.getObserver(ClipboardObserver).onDomEvent(domEvent);\n    }\n    /**\n     * The `dragover` and `drop` event handler.\n     */\n    _handleBlockDragging(domEvent) {\n        if (!this.isEnabled || !this._isBlockDragging) {\n            return;\n        }\n        const clientX = domEvent.clientX + (this.editor.locale.contentLanguageDirection == 'ltr' ? 100 : -100);\n        const clientY = domEvent.clientY;\n        const target = document.elementFromPoint(clientX, clientY);\n        const view = this.editor.editing.view;\n        if (!target || !target.closest('.ck-editor__editable')) {\n            return;\n        }\n        view.getObserver(ClipboardObserver).onDomEvent({\n            ...domEvent,\n            type: domEvent.type,\n            dataTransfer: domEvent.dataTransfer,\n            target,\n            clientX,\n            clientY,\n            preventDefault: () => domEvent.preventDefault(),\n            stopPropagation: () => domEvent.stopPropagation()\n        });\n    }\n    /**\n     * The `dragend` event handler.\n     */\n    _handleBlockDragEnd() {\n        this._isBlockDragging = false;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/dragdrop\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { LiveRange, MouseObserver } from '@ckeditor/ckeditor5-engine';\nimport { Widget, isWidget } from '@ckeditor/ckeditor5-widget';\nimport { env, uid, global, createElement, DomEmitterMixin, delay, Rect } from '@ckeditor/ckeditor5-utils';\nimport ClipboardPipeline from './clipboardpipeline.js';\nimport ClipboardObserver from './clipboardobserver.js';\nimport DragDropTarget from './dragdroptarget.js';\nimport DragDropBlockToolbar from './dragdropblocktoolbar.js';\nimport '../theme/clipboard.css';\n// Drag and drop events overview:\n//\n//                ┌──────────────────┐\n//                │     mousedown    │   Sets the draggable attribute.\n//                └─────────┬────────┘\n//                          │\n//                          └─────────────────────┐\n//                          │                     │\n//                          │           ┌─────────V────────┐\n//                          │           │      mouseup     │   Dragging did not start, removes the draggable attribute.\n//                          │           └──────────────────┘\n//                          │\n//                ┌─────────V────────┐   Retrieves the selected model.DocumentFragment\n//                │     dragstart    │   and converts it to view.DocumentFragment.\n//                └─────────┬────────┘\n//                          │\n//                ┌─────────V────────┐   Processes view.DocumentFragment to text/html and text/plain\n//                │  clipboardOutput │   and stores the results in data.dataTransfer.\n//                └─────────┬────────┘\n//                          │\n//                          │   DOM dragover\n//                          ┌────────────┐\n//                          │            │\n//                ┌─────────V────────┐   │\n//                │     dragging     │   │   Updates the drop target marker.\n//                └─────────┬────────┘   │\n//                          │            │\n//            ┌─────────────└────────────┘\n//            │             │            │\n//            │   ┌─────────V────────┐   │\n//            │   │     dragleave    │   │   Removes the drop target marker.\n//            │   └─────────┬────────┘   │\n//            │             │            │\n//        ┌───│─────────────┘            │\n//        │   │             │            │\n//        │   │   ┌─────────V────────┐   │\n//        │   │   │     dragenter    │   │   Focuses the editor view.\n//        │   │   └─────────┬────────┘   │\n//        │   │             │            │\n//        │   │             └────────────┘\n//        │   │\n//        │   └─────────────┐\n//        │   │             │\n//        │   │   ┌─────────V────────┐\n//        └───┐   │       drop       │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐   Resolves the final data.targetRanges.\n//            │   │  clipboardInput  │   Aborts if dropping on dragged content.\n//            │   └─────────┬────────┘\n//            │             │\n//            │   ┌─────────V────────┐\n//            │   │  clipboardInput  │   (The default handler of the clipboard pipeline).\n//            │   └─────────┬────────┘\n//            │             │\n//            │ ┌───────────V───────────┐\n//            │ │  inputTransformation  │   (The default handler of the clipboard pipeline).\n//            │ └───────────┬───────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Updates the document selection to drop range.\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   (The default handler of the clipboard pipeline).\n//            │  └──────────┬──────────┘\n//            │             │\n//            │  ┌──────────V──────────┐\n//            │  │   contentInsertion  │   Removes the content from the original range if the insertion was successful.\n//            │  └──────────┬──────────┘\n//            │             │\n//            └─────────────┐\n//                          │\n//                ┌─────────V────────┐\n//                │      dragend     │   Removes the drop marker and cleans the state.\n//                └──────────────────┘\n//\n/**\n * The drag and drop feature. It works on top of the {@link module:clipboard/clipboardpipeline~ClipboardPipeline}.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n *\n * @internal\n */\nexport default class DragDrop extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * A delayed callback removing draggable attributes.\n         */\n        this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40);\n        /**\n         * Whether the dragged content can be dropped only in block context.\n         */\n        // TODO handle drag from other editor instance\n        // TODO configure to use block, inline or both\n        this._blockMode = false;\n        /**\n         * DOM Emitter.\n         */\n        this._domEmitter = new (DomEmitterMixin())();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'DragDrop';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline, Widget, DragDropTarget, DragDropBlockToolbar];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        this._draggedRange = null;\n        this._draggingUid = '';\n        this._draggableElement = null;\n        view.addObserver(ClipboardObserver);\n        view.addObserver(MouseObserver);\n        this._setupDragging();\n        this._setupContentInsertionIntegration();\n        this._setupClipboardInputIntegration();\n        this._setupDraggableAttributeHandling();\n        this.listenTo(editor, 'change:isReadOnly', (evt, name, isReadOnly) => {\n            if (isReadOnly) {\n                this.forceDisabled('readOnlyMode');\n            }\n            else {\n                this.clearForceDisabled('readOnlyMode');\n            }\n        });\n        this.on('change:isEnabled', (evt, name, isEnabled) => {\n            if (!isEnabled) {\n                this._finalizeDragging(false);\n            }\n        });\n        if (env.isAndroid) {\n            this.forceDisabled('noAndroidSupport');\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    destroy() {\n        if (this._draggedRange) {\n            this._draggedRange.detach();\n            this._draggedRange = null;\n        }\n        if (this._previewContainer) {\n            this._previewContainer.remove();\n        }\n        this._domEmitter.stopListening();\n        this._clearDraggableAttributesDelayed.cancel();\n        return super.destroy();\n    }\n    /**\n     * Drag and drop events handling.\n     */\n    _setupDragging() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        // The handler for the drag start; it is responsible for setting data transfer object.\n        this.listenTo(viewDocument, 'dragstart', (evt, data) => {\n            // Don't drag the editable element itself.\n            if (data.target && data.target.is('editableElement')) {\n                data.preventDefault();\n                return;\n            }\n            this._prepareDraggedRange(data.target);\n            if (!this._draggedRange) {\n                data.preventDefault();\n                return;\n            }\n            this._draggingUid = uid();\n            data.dataTransfer.effectAllowed = this.isEnabled ? 'copyMove' : 'copy';\n            data.dataTransfer.setData('application/ckeditor5-dragging-uid', this._draggingUid);\n            const draggedSelection = model.createSelection(this._draggedRange.toRange());\n            const clipboardPipeline = this.editor.plugins.get('ClipboardPipeline');\n            clipboardPipeline._fireOutputTransformationEvent(data.dataTransfer, draggedSelection, 'dragstart');\n            const { dataTransfer, domTarget, domEvent } = data;\n            const { clientX } = domEvent;\n            this._updatePreview({ dataTransfer, domTarget, clientX });\n            data.stopPropagation();\n            if (!this.isEnabled) {\n                this._draggedRange.detach();\n                this._draggedRange = null;\n                this._draggingUid = '';\n            }\n        }, { priority: 'low' });\n        // The handler for finalizing drag and drop. It should always be triggered after dragging completes\n        // even if it was completed in a different application.\n        // Note: This is not fired if source text node got removed while downcasting a marker.\n        this.listenTo(viewDocument, 'dragend', (evt, data) => {\n            this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == 'move');\n        }, { priority: 'low' });\n        // Reset block dragging mode even if dropped outside the editable.\n        this._domEmitter.listenTo(global.document, 'dragend', () => {\n            this._blockMode = false;\n        }, { useCapture: true });\n        // Dragging over the editable.\n        this.listenTo(viewDocument, 'dragenter', () => {\n            if (!this.isEnabled) {\n                return;\n            }\n            view.focus();\n        });\n        // Dragging out of the editable.\n        this.listenTo(viewDocument, 'dragleave', () => {\n            // We do not know if the mouse left the editor or just some element in it, so let us wait a few milliseconds\n            // to check if 'dragover' is not fired.\n            dragDropTarget.removeDropMarkerDelayed();\n        });\n        // Handler for moving dragged content over the target area.\n        this.listenTo(viewDocument, 'dragging', (evt, data) => {\n            if (!this.isEnabled) {\n                data.dataTransfer.dropEffect = 'none';\n                return;\n            }\n            const { clientX, clientY } = data.domEvent;\n            dragDropTarget.updateDropMarker(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);\n            // If this is content being dragged from another editor, moving out of current editor instance\n            // is not possible until 'dragend' event case will be fixed.\n            if (!this._draggedRange) {\n                data.dataTransfer.dropEffect = 'copy';\n            }\n            // In Firefox it is already set and effect allowed remains the same as originally set.\n            if (!env.isGecko) {\n                if (data.dataTransfer.effectAllowed == 'copy') {\n                    data.dataTransfer.dropEffect = 'copy';\n                }\n                else if (['all', 'copyMove'].includes(data.dataTransfer.effectAllowed)) {\n                    data.dataTransfer.dropEffect = 'move';\n                }\n            }\n            evt.stop();\n        }, { priority: 'low' });\n    }\n    /**\n     * Integration with the `clipboardInput` event.\n     */\n    _setupClipboardInputIntegration() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        // Update the event target ranges and abort dropping if dropping over itself.\n        this.listenTo(viewDocument, 'clipboardInput', (evt, data) => {\n            if (data.method != 'drop') {\n                return;\n            }\n            const { clientX, clientY } = data.domEvent;\n            const targetRange = dragDropTarget.getFinalDropRange(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);\n            if (!targetRange) {\n                this._finalizeDragging(false);\n                evt.stop();\n                return;\n            }\n            // Since we cannot rely on the drag end event, we must check if the local drag range is from the current drag and drop\n            // or it is from some previous not cleared one.\n            if (this._draggedRange && this._draggingUid != data.dataTransfer.getData('application/ckeditor5-dragging-uid')) {\n                this._draggedRange.detach();\n                this._draggedRange = null;\n                this._draggingUid = '';\n            }\n            // Do not do anything if some content was dragged within the same document to the same position.\n            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n            if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {\n                this._finalizeDragging(false);\n                evt.stop();\n                return;\n            }\n            // Override the target ranges with the one adjusted to the best one for a drop.\n            data.targetRanges = [editor.editing.mapper.toViewRange(targetRange)];\n        }, { priority: 'high' });\n    }\n    /**\n     * Integration with the `contentInsertion` event of the clipboard pipeline.\n     */\n    _setupContentInsertionIntegration() {\n        const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);\n        clipboardPipeline.on('contentInsertion', (evt, data) => {\n            if (!this.isEnabled || data.method !== 'drop') {\n                return;\n            }\n            // Update the selection to the target range in the same change block to avoid selection post-fixing\n            // and to be able to clone text attributes for plain text dropping.\n            const ranges = data.targetRanges.map(viewRange => this.editor.editing.mapper.toModelRange(viewRange));\n            this.editor.model.change(writer => writer.setSelection(ranges));\n        }, { priority: 'high' });\n        clipboardPipeline.on('contentInsertion', (evt, data) => {\n            if (!this.isEnabled || data.method !== 'drop') {\n                return;\n            }\n            // Remove dragged range content, remove markers, clean after dragging.\n            const isMove = getFinalDropEffect(data.dataTransfer) == 'move';\n            // Whether any content was inserted (insertion might fail if the schema is disallowing some elements\n            // (for example an image caption allows only the content of a block but not blocks themselves.\n            // Some integrations might not return valid range (i.e., table pasting).\n            const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;\n            this._finalizeDragging(isSuccess && isMove);\n        }, { priority: 'lowest' });\n    }\n    /**\n     * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.\n     */\n    _setupDraggableAttributeHandling() {\n        const editor = this.editor;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        // Add the 'draggable' attribute to the widget while pressing the selection handle.\n        // This is required for widgets to be draggable. In Chrome it will enable dragging text nodes.\n        this.listenTo(viewDocument, 'mousedown', (evt, data) => {\n            // The lack of data can be caused by editor tests firing fake mouse events. This should not occur\n            // in real-life scenarios but this greatly simplifies editor tests that would otherwise fail a lot.\n            if (env.isAndroid || !data) {\n                return;\n            }\n            this._clearDraggableAttributesDelayed.cancel();\n            // Check if this is a mousedown over the widget (but not a nested editable).\n            let draggableElement = findDraggableWidget(data.target);\n            // Note: There is a limitation that if more than a widget is selected (a widget and some text)\n            // and dragging starts on the widget, then only the widget is dragged.\n            // If this was not a widget then we should check if we need to drag some text content.\n            // In Chrome set a 'draggable' attribute on closest editable to allow immediate dragging of the selected text range.\n            // In Firefox this is not needed. In Safari it makes the whole editable draggable (not just textual content).\n            // Disabled in read-only mode because draggable=\"true\" + contenteditable=\"false\" results\n            // in not firing selectionchange event ever, which makes the selection stuck in read-only mode.\n            if (env.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {\n                const selectedElement = viewDocument.selection.getSelectedElement();\n                if (!selectedElement || !isWidget(selectedElement)) {\n                    draggableElement = viewDocument.selection.editableElement;\n                }\n            }\n            if (draggableElement) {\n                view.change(writer => {\n                    writer.setAttribute('draggable', 'true', draggableElement);\n                });\n                // Keep the reference to the model element in case the view element gets removed while dragging.\n                this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);\n            }\n        });\n        // Remove the draggable attribute in case no dragging started (only mousedown + mouseup).\n        this.listenTo(viewDocument, 'mouseup', () => {\n            if (!env.isAndroid) {\n                this._clearDraggableAttributesDelayed();\n            }\n        });\n    }\n    /**\n     * Removes the `draggable` attribute from the element that was used for dragging.\n     */\n    _clearDraggableAttributes() {\n        const editing = this.editor.editing;\n        editing.view.change(writer => {\n            // Remove 'draggable' attribute.\n            if (this._draggableElement && this._draggableElement.root.rootName != '$graveyard') {\n                writer.removeAttribute('draggable', editing.mapper.toViewElement(this._draggableElement));\n            }\n            this._draggableElement = null;\n        });\n    }\n    /**\n     * Deletes the dragged content from its original range and clears the dragging state.\n     *\n     * @param moved Whether the move succeeded.\n     */\n    _finalizeDragging(moved) {\n        const editor = this.editor;\n        const model = editor.model;\n        const dragDropTarget = editor.plugins.get(DragDropTarget);\n        dragDropTarget.removeDropMarker();\n        this._clearDraggableAttributes();\n        if (editor.plugins.has('WidgetToolbarRepository')) {\n            const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');\n            widgetToolbarRepository.clearForceDisabled('dragDrop');\n        }\n        this._draggingUid = '';\n        if (this._previewContainer) {\n            this._previewContainer.remove();\n            this._previewContainer = undefined;\n        }\n        if (!this._draggedRange) {\n            return;\n        }\n        // Delete moved content.\n        if (moved && this.isEnabled) {\n            model.change(writer => {\n                const selection = model.createSelection(this._draggedRange);\n                model.deleteContent(selection, { doNotAutoparagraph: true });\n                // Check result selection if it does not require auto-paragraphing of empty container.\n                const selectionParent = selection.getFirstPosition().parent;\n                if (selectionParent.isEmpty &&\n                    !model.schema.checkChild(selectionParent, '$text') &&\n                    model.schema.checkChild(selectionParent, 'paragraph')) {\n                    writer.insertElement('paragraph', selectionParent, 0);\n                }\n            });\n        }\n        this._draggedRange.detach();\n        this._draggedRange = null;\n    }\n    /**\n     * Sets the dragged source range based on event target and document selection.\n     */\n    _prepareDraggedRange(target) {\n        const editor = this.editor;\n        const model = editor.model;\n        const selection = model.document.selection;\n        // Check if this is dragstart over the widget (but not a nested editable).\n        const draggableWidget = target ? findDraggableWidget(target) : null;\n        if (draggableWidget) {\n            const modelElement = editor.editing.mapper.toModelElement(draggableWidget);\n            this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement));\n            this._blockMode = model.schema.isBlock(modelElement);\n            // Disable toolbars so they won't obscure the drop area.\n            if (editor.plugins.has('WidgetToolbarRepository')) {\n                const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository');\n                widgetToolbarRepository.forceDisabled('dragDrop');\n            }\n            return;\n        }\n        // If this was not a widget we should check if we need to drag some text content.\n        if (selection.isCollapsed && !selection.getFirstPosition().parent.isEmpty) {\n            return;\n        }\n        const blocks = Array.from(selection.getSelectedBlocks());\n        const draggedRange = selection.getFirstRange();\n        if (blocks.length == 0) {\n            this._draggedRange = LiveRange.fromRange(draggedRange);\n            return;\n        }\n        const blockRange = getRangeIncludingFullySelectedParents(model, blocks);\n        if (blocks.length > 1) {\n            this._draggedRange = LiveRange.fromRange(blockRange);\n            this._blockMode = true;\n            // TODO block mode for dragging from outside editor? or inline? or both?\n        }\n        else if (blocks.length == 1) {\n            const touchesBlockEdges = draggedRange.start.isTouching(blockRange.start) &&\n                draggedRange.end.isTouching(blockRange.end);\n            this._draggedRange = LiveRange.fromRange(touchesBlockEdges ? blockRange : draggedRange);\n            this._blockMode = touchesBlockEdges;\n        }\n        model.change(writer => writer.setSelection(this._draggedRange.toRange()));\n    }\n    /**\n     * Updates the dragged preview image.\n     */\n    _updatePreview({ dataTransfer, domTarget, clientX }) {\n        const view = this.editor.editing.view;\n        const editable = view.document.selection.editableElement;\n        const domEditable = view.domConverter.mapViewToDom(editable);\n        const computedStyle = global.window.getComputedStyle(domEditable);\n        if (!this._previewContainer) {\n            this._previewContainer = createElement(global.document, 'div', {\n                style: 'position: fixed; left: -999999px;'\n            });\n            global.document.body.appendChild(this._previewContainer);\n        }\n        else if (this._previewContainer.firstElementChild) {\n            this._previewContainer.removeChild(this._previewContainer.firstElementChild);\n        }\n        const domRect = new Rect(domEditable);\n        // If domTarget is inside the editable root, browsers will display the preview correctly by themselves.\n        if (domEditable.contains(domTarget)) {\n            return;\n        }\n        const domEditablePaddingLeft = parseFloat(computedStyle.paddingLeft);\n        const preview = createElement(global.document, 'div');\n        preview.className = 'ck ck-content';\n        preview.style.width = computedStyle.width;\n        preview.style.paddingLeft = `${domRect.left - clientX + domEditablePaddingLeft}px`;\n        /**\n         * Set white background in drag and drop preview if iOS.\n         * Check: https://github.com/ckeditor/ckeditor5/issues/15085\n         */\n        if (env.isiOS) {\n            preview.style.backgroundColor = 'white';\n        }\n        view.domConverter.setContentOf(preview, dataTransfer.getData('text/html'));\n        dataTransfer.setDragImage(preview, 0, 0);\n        this._previewContainer.appendChild(preview);\n    }\n}\n/**\n * Returns the drop effect that should be a result of dragging the content.\n * This function is handling a quirk when checking the effect in the 'drop' DOM event.\n */\nfunction getFinalDropEffect(dataTransfer) {\n    if (env.isGecko) {\n        return dataTransfer.dropEffect;\n    }\n    return ['all', 'copyMove'].includes(dataTransfer.effectAllowed) ? 'move' : 'copy';\n}\n/**\n * Returns a widget element that should be dragged.\n */\nfunction findDraggableWidget(target) {\n    // This is directly an editable so not a widget for sure.\n    if (target.is('editableElement')) {\n        return null;\n    }\n    // TODO: Let's have a isWidgetSelectionHandleDomElement() helper in ckeditor5-widget utils.\n    if (target.hasClass('ck-widget__selection-handle')) {\n        return target.findAncestor(isWidget);\n    }\n    // Direct hit on a widget.\n    if (isWidget(target)) {\n        return target;\n    }\n    // Find closest ancestor that is either a widget or an editable element...\n    const ancestor = target.findAncestor(node => isWidget(node) || node.is('editableElement'));\n    // ...and if closer was the widget then enable dragging it.\n    if (isWidget(ancestor)) {\n        return ancestor;\n    }\n    return null;\n}\n/**\n * Recursively checks if common parent of provided elements doesn't have any other children. If that's the case,\n * it returns range including this parent. Otherwise, it returns only the range from first to last element.\n *\n * Example:\n *\n * <blockQuote>\n *   <paragraph>[Test 1</paragraph>\n *   <paragraph>Test 2</paragraph>\n *   <paragraph>Test 3]</paragraph>\n * <blockQuote>\n *\n * Because all elements inside the `blockQuote` are selected, the range is extended to include the `blockQuote` too.\n * If only first and second paragraphs would be selected, the range would not include it.\n */\nfunction getRangeIncludingFullySelectedParents(model, elements) {\n    const firstElement = elements[0];\n    const lastElement = elements[elements.length - 1];\n    const parent = firstElement.getCommonAncestor(lastElement);\n    const startPosition = model.createPositionBefore(firstElement);\n    const endPosition = model.createPositionAfter(lastElement);\n    if (parent &&\n        parent.is('element') &&\n        !model.schema.isLimit(parent)) {\n        const parentRange = model.createRangeOn(parent);\n        const touchesStart = startPosition.isTouching(parentRange.start);\n        const touchesEnd = endPosition.isTouching(parentRange.end);\n        if (touchesStart && touchesEnd) {\n            // Selection includes all elements in the parent.\n            return getRangeIncludingFullySelectedParents(model, [parent]);\n        }\n    }\n    return model.createRange(startPosition, endPosition);\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/pasteplaintext\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport ClipboardObserver from './clipboardobserver.js';\nimport ClipboardPipeline from './clipboardpipeline.js';\n/**\n * The plugin detects the user's intention to paste plain text.\n *\n * For example, it detects the <kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd> keystroke.\n */\nexport default class PastePlainText extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'PastePlainText';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardPipeline];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const model = editor.model;\n        const view = editor.editing.view;\n        const selection = model.document.selection;\n        view.addObserver(ClipboardObserver);\n        editor.plugins.get(ClipboardPipeline).on('contentInsertion', (evt, data) => {\n            if (!isUnformattedInlineContent(data.content, model)) {\n                return;\n            }\n            model.change(writer => {\n                // Formatting attributes should be preserved.\n                const textAttributes = Array.from(selection.getAttributes())\n                    .filter(([key]) => model.schema.getAttributeProperties(key).isFormatting);\n                if (!selection.isCollapsed) {\n                    model.deleteContent(selection, { doNotAutoparagraph: true });\n                }\n                // Also preserve other attributes if they survived the content deletion (because they were not fully selected).\n                // For example linkHref is not a formatting attribute but it should be preserved if pasted text was in the middle\n                // of a link.\n                textAttributes.push(...selection.getAttributes());\n                const range = writer.createRangeIn(data.content);\n                for (const item of range.getItems()) {\n                    for (const attribute of textAttributes) {\n                        if (model.schema.checkAttribute(item, attribute[0])) {\n                            writer.setAttribute(attribute[0], attribute[1], item);\n                        }\n                    }\n                }\n            });\n        });\n    }\n}\n/**\n * Returns true if specified `documentFragment` represents the unformatted inline content.\n */\nfunction isUnformattedInlineContent(documentFragment, model) {\n    let range = model.createRangeIn(documentFragment);\n    // We consider three scenarios here. The document fragment may include:\n    //\n    // 1. Only text and inline objects. Then it could be unformatted inline content.\n    // 2. Exactly one block element on top-level, eg. <p>Foobar</p> or <h2>Title</h2>.\n    //    In this case, check this element content, it could be treated as unformatted inline content.\n    // 3. More block elements or block objects, then it is not unformatted inline content.\n    //\n    // We will check for scenario 2. specifically, and if it happens, we will unwrap it and follow with the regular algorithm.\n    //\n    if (documentFragment.childCount == 1) {\n        const child = documentFragment.getChild(0);\n        if (child.is('element') && model.schema.isBlock(child) && !model.schema.isObject(child) && !model.schema.isLimit(child)) {\n            // Scenario 2. as described above.\n            range = model.createRangeIn(child);\n        }\n    }\n    for (const child of range.getItems()) {\n        if (!model.schema.isInline(child)) {\n            return false;\n        }\n        const attributeKeys = Array.from(child.getAttributeKeys());\n        if (attributeKeys.find(key => model.schema.getAttributeProperties(key).isFormatting)) {\n            return false;\n        }\n    }\n    return true;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module clipboard/clipboard\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport ClipboardPipeline from './clipboardpipeline.js';\nimport DragDrop from './dragdrop.js';\nimport PastePlainText from './pasteplaintext.js';\nimport ClipboardMarkersUtils from './clipboardmarkersutils.js';\n/**\n * The clipboard feature.\n *\n * Read more about the clipboard integration in the {@glink framework/deep-dive/clipboard clipboard deep-dive} guide.\n *\n * This is a \"glue\" plugin which loads the following plugins:\n * * {@link module:clipboard/clipboardpipeline~ClipboardPipeline}\n * * {@link module:clipboard/dragdrop~DragDrop}\n * * {@link module:clipboard/pasteplaintext~PastePlainText}\n */\nexport default class Clipboard extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Clipboard';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [ClipboardMarkersUtils, ClipboardPipeline, DragDrop, PastePlainText];\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const t = this.editor.t;\n        // Add the information about the keystrokes to the accessibility database.\n        editor.accessibility.addKeystrokeInfos({\n            keystrokes: [\n                {\n                    label: t('Copy selected content'),\n                    keystroke: 'CTRL+C'\n                },\n                {\n                    label: t('Paste content'),\n                    keystroke: 'CTRL+V'\n                },\n                {\n                    label: t('Paste content as plain text'),\n                    keystroke: 'CTRL+SHIFT+V'\n                }\n            ]\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module select-all/selectallcommand\n */\nimport { Command } from '@ckeditor/ckeditor5-core';\n/**\n * The select all command.\n *\n * It is used by the {@link module:select-all/selectallediting~SelectAllEditing select all editing feature} to handle\n * the <kbd>Ctrl/⌘</kbd>+<kbd>A</kbd> keystroke.\n *\n * Executing this command changes the {@glink framework/architecture/editing-engine#model model}\n * selection so it contains the entire content of the editable root of the editor the selection is\n * {@link module:engine/model/selection~Selection#anchor anchored} in.\n *\n * If the selection was anchored in a {@glink framework/tutorials/widgets/implementing-a-block-widget nested editable}\n * (e.g. a caption of an image), the new selection will contain its entire content. Successive executions of this command\n * will expand the selection to encompass more and more content up to the entire editable root of the editor.\n */\nexport default class SelectAllCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        super(editor);\n        // It does not affect data so should be enabled in read-only mode.\n        this.affectsData = false;\n    }\n    /**\n     * @inheritDoc\n     */\n    execute() {\n        const model = this.editor.model;\n        const selection = model.document.selection;\n        let scopeElement = model.schema.getLimitElement(selection);\n        // If an entire scope is selected, or the selection's ancestor is not a scope yet,\n        // browse through ancestors to find the enclosing parent scope.\n        if (selection.containsEntireContent(scopeElement) || !isSelectAllScope(model.schema, scopeElement)) {\n            do {\n                scopeElement = scopeElement.parent;\n                // Do nothing, if the entire `root` is already selected.\n                if (!scopeElement) {\n                    return;\n                }\n            } while (!isSelectAllScope(model.schema, scopeElement));\n        }\n        model.change(writer => {\n            writer.setSelection(scopeElement, 'in');\n        });\n    }\n}\n/**\n * Checks whether the element is a valid select-all scope. Returns true, if the element is a\n * {@link module:engine/model/schema~Schema#isLimit limit}, and can contain any text or paragraph.\n *\n * @param schema Schema to check against.\n * @param element Model element.\n */\nfunction isSelectAllScope(schema, element) {\n    return schema.isLimit(element) && (schema.checkChild(element, '$text') || schema.checkChild(element, 'paragraph'));\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module select-all/selectallediting\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { getCode, parseKeystroke } from '@ckeditor/ckeditor5-utils';\nimport SelectAllCommand from './selectallcommand.js';\nconst SELECT_ALL_KEYSTROKE = /* #__PURE__ */ parseKeystroke('Ctrl+A');\n/**\n * The select all editing feature.\n *\n * It registers the `'selectAll'` {@link module:select-all/selectallcommand~SelectAllCommand command}\n * and the <kbd>Ctrl/⌘</kbd>+<kbd>A</kbd> keystroke listener which executes it.\n */\nexport default class SelectAllEditing extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'SelectAllEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const t = editor.t;\n        const view = editor.editing.view;\n        const viewDocument = view.document;\n        editor.commands.add('selectAll', new SelectAllCommand(editor));\n        this.listenTo(viewDocument, 'keydown', (eventInfo, domEventData) => {\n            if (getCode(domEventData) === SELECT_ALL_KEYSTROKE) {\n                editor.execute('selectAll');\n                domEventData.preventDefault();\n            }\n        });\n        // Add the information about the keystroke to the accessibility database.\n        editor.accessibility.addKeystrokeInfos({\n            keystrokes: [\n                {\n                    label: t('Select all'),\n                    keystroke: 'CTRL+A'\n                }\n            ]\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module select-all/selectallui\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport { ButtonView, MenuBarMenuListItemButtonView } from '@ckeditor/ckeditor5-ui';\nimport selectAllIcon from '../theme/icons/select-all.svg';\n/**\n * The select all UI feature.\n *\n * It registers the `'selectAll'` UI button in the editor's\n * {@link module:ui/componentfactory~ComponentFactory component factory}. When clicked, the button\n * executes the {@link module:select-all/selectallcommand~SelectAllCommand select all command}.\n */\nexport default class SelectAllUI extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'SelectAllUI';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        editor.ui.componentFactory.add('selectAll', () => {\n            const buttonView = this._createButton(ButtonView);\n            buttonView.set({\n                tooltip: true\n            });\n            return buttonView;\n        });\n        editor.ui.componentFactory.add('menuBar:selectAll', () => {\n            return this._createButton(MenuBarMenuListItemButtonView);\n        });\n    }\n    /**\n     * Creates a button for select all command to use either in toolbar or in menu bar.\n     */\n    _createButton(ButtonClass) {\n        const editor = this.editor;\n        const locale = editor.locale;\n        const command = editor.commands.get('selectAll');\n        const view = new ButtonClass(editor.locale);\n        const t = locale.t;\n        view.set({\n            label: t('Select all'),\n            icon: selectAllIcon,\n            keystroke: 'Ctrl+A'\n        });\n        view.bind('isEnabled').to(command, 'isEnabled');\n        // Execute the command.\n        this.listenTo(view, 'execute', () => {\n            editor.execute('selectAll');\n            editor.editing.view.focus();\n        });\n        return view;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module select-all/selectall\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport SelectAllEditing from './selectallediting.js';\nimport SelectAllUI from './selectallui.js';\n/**\n * The select all feature.\n *\n * This is a \"glue\" plugin which loads the {@link module:select-all/selectallediting~SelectAllEditing select all editing feature}\n * and the {@link module:select-all/selectallui~SelectAllUI select all UI feature}.\n *\n * Please refer to the documentation of individual features to learn more.\n */\nexport default class SelectAll extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [SelectAllEditing, SelectAllUI];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'SelectAll';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module undo/basecommand\n */\nimport { Command } from '@ckeditor/ckeditor5-core';\nimport { transformSets, NoOperation } from '@ckeditor/ckeditor5-engine';\n/**\n * Base class for the undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.\n */\nexport default class BaseCommand extends Command {\n    /**\n     * @inheritDoc\n     */\n    constructor(editor) {\n        super(editor);\n        /**\n         * Stack of items stored by the command. These are pairs of:\n         *\n         * * {@link module:engine/model/batch~Batch batch} saved by the command,\n         * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.\n         */\n        this._stack = [];\n        /**\n         * Stores all batches that were created by this command.\n         *\n         * @internal\n         */\n        this._createdBatches = new WeakSet();\n        // Refresh state, so the command is inactive right after initialization.\n        this.refresh();\n        // This command should not depend on selection change.\n        this._isEnabledBasedOnSelection = false;\n        // Set the transparent batch for the `editor.data.set()` call if the\n        // batch type is not set already.\n        this.listenTo(editor.data, 'set', (evt, data) => {\n            // Create a shallow copy of the options to not change the original args.\n            // And make sure that an object is assigned to data[ 1 ].\n            data[1] = { ...data[1] };\n            const options = data[1];\n            // If batch type is not set, default to non-undoable batch.\n            if (!options.batchType) {\n                options.batchType = { isUndoable: false };\n            }\n        }, { priority: 'high' });\n        // Clear the stack for the `transparent` batches.\n        this.listenTo(editor.data, 'set', (evt, data) => {\n            // We can assume that the object exists and it has a `batchType` property.\n            // It was ensured with a higher priority listener before.\n            const options = data[1];\n            if (!options.batchType.isUndoable) {\n                this.clearStack();\n            }\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    refresh() {\n        this.isEnabled = this._stack.length > 0;\n    }\n    /**\n     * Returns all batches created by this command.\n     */\n    get createdBatches() {\n        return this._createdBatches;\n    }\n    /**\n     * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}\n     * created by the editor which this command is registered to.\n     *\n     * @param batch The batch to add.\n     */\n    addBatch(batch) {\n        const docSelection = this.editor.model.document.selection;\n        const selection = {\n            ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],\n            isBackward: docSelection.isBackward\n        };\n        this._stack.push({ batch, selection });\n        this.refresh();\n    }\n    /**\n     * Removes all items from the stack.\n     */\n    clearStack() {\n        this._stack = [];\n        this.refresh();\n    }\n    /**\n     * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.\n     *\n     * @param ranges Ranges to be restored.\n     * @param isBackward A flag describing whether the restored range was selected forward or backward.\n     * @param operations Operations which has been applied since selection has been stored.\n     */\n    _restoreSelection(ranges, isBackward, operations) {\n        const model = this.editor.model;\n        const document = model.document;\n        // This will keep the transformed selection ranges.\n        const selectionRanges = [];\n        // Transform all ranges from the restored selection.\n        const transformedRangeGroups = ranges.map(range => range.getTransformedByOperations(operations));\n        const allRanges = transformedRangeGroups.flat();\n        for (const rangeGroup of transformedRangeGroups) {\n            // While transforming there could appear ranges that are contained by other ranges, we shall ignore them.\n            const transformed = rangeGroup\n                .filter(range => range.root != document.graveyard)\n                .filter(range => !isRangeContainedByAnyOtherRange(range, allRanges));\n            // All the transformed ranges ended up in graveyard.\n            if (!transformed.length) {\n                continue;\n            }\n            // After the range got transformed, we have an array of ranges. Some of those\n            // ranges may be \"touching\" -- they can be next to each other and could be merged.\n            normalizeRanges(transformed);\n            // For each `range` from `ranges`, we take only one transformed range.\n            // This is because we want to prevent situation where single-range selection\n            // got transformed to multi-range selection.\n            selectionRanges.push(transformed[0]);\n        }\n        // @if CK_DEBUG_ENGINE // console.log( `Restored selection by undo: ${ selectionRanges.join( ', ' ) }` );\n        // `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.\n        if (selectionRanges.length) {\n            model.change(writer => {\n                writer.setSelection(selectionRanges, { backward: isBackward });\n            });\n        }\n    }\n    /**\n     * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.\n     * This is a helper method for {@link #execute}.\n     *\n     * @param batchToUndo The batch to be undone.\n     * @param undoingBatch The batch that will contain undoing changes.\n     */\n    _undo(batchToUndo, undoingBatch) {\n        const model = this.editor.model;\n        const document = model.document;\n        // All changes done by the command execution will be saved as one batch.\n        this._createdBatches.add(undoingBatch);\n        const operationsToUndo = batchToUndo.operations.slice().filter(operation => operation.isDocumentOperation);\n        operationsToUndo.reverse();\n        // We will process each operation from `batchToUndo`, in reverse order. If there were operations A, B and C in undone batch,\n        // we need to revert them in reverse order, so first C' (reversed C), then B', then A'.\n        for (const operationToUndo of operationsToUndo) {\n            const nextBaseVersion = operationToUndo.baseVersion + 1;\n            const historyOperations = Array.from(document.history.getOperations(nextBaseVersion));\n            const transformedSets = transformSets([operationToUndo.getReversed()], historyOperations, {\n                useRelations: true,\n                document: this.editor.model.document,\n                padWithNoOps: false,\n                forceWeakRemove: true\n            });\n            const reversedOperations = transformedSets.operationsA;\n            // After reversed operation has been transformed by all history operations, apply it.\n            for (let operation of reversedOperations) {\n                // Do not apply any operation on non-editable space.\n                const affectedSelectable = operation.affectedSelectable;\n                if (affectedSelectable && !model.canEditAt(affectedSelectable)) {\n                    operation = new NoOperation(operation.baseVersion);\n                }\n                // Before applying, add the operation to the `undoingBatch`.\n                undoingBatch.addOperation(operation);\n                model.applyOperation(operation);\n                document.history.setOperationAsUndone(operationToUndo, operation);\n            }\n        }\n    }\n}\n/**\n * Normalizes list of ranges by joining intersecting or \"touching\" ranges.\n *\n * @param ranges Ranges to be normalized.\n */\nfunction normalizeRanges(ranges) {\n    ranges.sort((a, b) => a.start.isBefore(b.start) ? -1 : 1);\n    for (let i = 1; i < ranges.length; i++) {\n        const previousRange = ranges[i - 1];\n        const joinedRange = previousRange.getJoined(ranges[i], true);\n        if (joinedRange) {\n            // Replace the ranges on the list with the new joined range.\n            i--;\n            ranges.splice(i, 2, joinedRange);\n        }\n    }\n}\nfunction isRangeContainedByAnyOtherRange(range, ranges) {\n    return ranges.some(otherRange => otherRange !== range && otherRange.containsRange(range, true));\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module undo/undocommand\n */\nimport BaseCommand from './basecommand.js';\n/**\n * The undo command stores {@link module:engine/model/batch~Batch batches} applied to the\n * {@link module:engine/model/document~Document document} and is able to undo a batch by reversing it and transforming by\n * batches from {@link module:engine/model/document~Document#history history} that happened after the reversed batch.\n *\n * The undo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.\n */\nexport default class UndoCommand extends BaseCommand {\n    /**\n     * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms\n     * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.\n     * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.\n     *\n     * @fires execute\n     * @fires revert\n     * @param batch A batch that should be undone. If not set, the last added batch will be undone.\n     */\n    execute(batch = null) {\n        // If batch is not given, set `batchIndex` to the last index in command stack.\n        const batchIndex = batch ? this._stack.findIndex(a => a.batch == batch) : this._stack.length - 1;\n        const item = this._stack.splice(batchIndex, 1)[0];\n        const undoingBatch = this.editor.model.createBatch({ isUndo: true });\n        // All changes have to be done in one `enqueueChange` callback so other listeners will not\n        // step between consecutive operations, or won't do changes to the document before selection is properly restored.\n        this.editor.model.enqueueChange(undoingBatch, () => {\n            this._undo(item.batch, undoingBatch);\n            const operations = this.editor.model.document.history.getOperations(item.batch.baseVersion);\n            this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);\n        });\n        // Firing `revert` event after the change block to make sure that it includes all changes from post-fixers\n        // and make sure that the selection is \"stabilized\" (the selection range is saved after undo is executed and then\n        // restored on redo, so it is important that the selection range is saved after post-fixers are done).\n        this.fire('revert', item.batch, undoingBatch);\n        this.refresh();\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module undo/redocommand\n */\nimport BaseCommand from './basecommand.js';\n/**\n * The redo command stores {@link module:engine/model/batch~Batch batches} that were used to undo a batch by\n * {@link module:undo/undocommand~UndoCommand}. It is able to redo a previously undone batch by reversing the undoing\n * batches created by `UndoCommand`. The reversed batch is transformed by all the batches from\n * {@link module:engine/model/document~Document#history history} that happened after the reversed undo batch.\n *\n * The redo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.\n */\nexport default class RedoCommand extends BaseCommand {\n    /**\n     * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to\n     * the command's stack, applies the reverted and transformed version on the\n     * {@link module:engine/model/document~Document document} and removes the batch from the stack.\n     * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.\n     *\n     * @fires execute\n     */\n    execute() {\n        const item = this._stack.pop();\n        const redoingBatch = this.editor.model.createBatch({ isUndo: true });\n        // All changes have to be done in one `enqueueChange` callback so other listeners will not step between consecutive\n        // operations, or won't do changes to the document before selection is properly restored.\n        this.editor.model.enqueueChange(redoingBatch, () => {\n            const lastOperation = item.batch.operations[item.batch.operations.length - 1];\n            const nextBaseVersion = lastOperation.baseVersion + 1;\n            const operations = this.editor.model.document.history.getOperations(nextBaseVersion);\n            this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);\n            this._undo(item.batch, redoingBatch);\n        });\n        this.refresh();\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module undo/undoediting\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport UndoCommand from './undocommand.js';\nimport RedoCommand from './redocommand.js';\n/**\n * The undo engine feature.\n *\n * It introduces the `'undo'` and `'redo'` commands to the editor.\n */\nexport default class UndoEditing extends Plugin {\n    constructor() {\n        super(...arguments);\n        /**\n         * Keeps track of which batches were registered in undo.\n         */\n        this._batchRegistry = new WeakSet();\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'UndoEditing';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const t = editor.t;\n        // Create commands.\n        this._undoCommand = new UndoCommand(editor);\n        this._redoCommand = new RedoCommand(editor);\n        // Register command to the editor.\n        editor.commands.add('undo', this._undoCommand);\n        editor.commands.add('redo', this._redoCommand);\n        this.listenTo(editor.model, 'applyOperation', (evt, args) => {\n            const operation = args[0];\n            // Do not register batch if the operation is not a document operation.\n            // This prevents from creating empty undo steps, where all operations where non-document operations.\n            // Non-document operations creates and alters content in detached tree fragments (for example, document fragments).\n            // Most of time this is preparing data before it is inserted into actual tree (for example during copy & paste).\n            // Such operations should not be reversed.\n            if (!operation.isDocumentOperation) {\n                return;\n            }\n            const batch = operation.batch;\n            const isRedoBatch = this._redoCommand.createdBatches.has(batch);\n            const isUndoBatch = this._undoCommand.createdBatches.has(batch);\n            const wasProcessed = this._batchRegistry.has(batch);\n            // Skip the batch if it was already processed.\n            if (wasProcessed) {\n                return;\n            }\n            // Add the batch to the registry so it will not be processed again.\n            this._batchRegistry.add(batch);\n            if (!batch.isUndoable) {\n                return;\n            }\n            if (isRedoBatch) {\n                // If this batch comes from `redoCommand`, add it to the `undoCommand` stack.\n                this._undoCommand.addBatch(batch);\n            }\n            else if (!isUndoBatch) {\n                // If the batch comes neither  from `redoCommand` nor from `undoCommand` then it is a new, regular batch.\n                // Add the batch to the `undoCommand` stack and clear the `redoCommand` stack.\n                this._undoCommand.addBatch(batch);\n                this._redoCommand.clearStack();\n            }\n        }, { priority: 'highest' });\n        this.listenTo(this._undoCommand, 'revert', (evt, undoneBatch, undoingBatch) => {\n            this._redoCommand.addBatch(undoingBatch);\n        });\n        editor.keystrokes.set('CTRL+Z', 'undo');\n        editor.keystrokes.set('CTRL+Y', 'redo');\n        editor.keystrokes.set('CTRL+SHIFT+Z', 'redo');\n        // Add the information about the keystrokes to the accessibility database.\n        editor.accessibility.addKeystrokeInfos({\n            keystrokes: [\n                {\n                    label: t('Undo'),\n                    keystroke: 'CTRL+Z'\n                },\n                {\n                    label: t('Redo'),\n                    keystroke: [['CTRL+Y'], ['CTRL+SHIFT+Z']]\n                }\n            ]\n        });\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module undo/undoui\n */\nimport { icons, Plugin } from '@ckeditor/ckeditor5-core';\nimport { ButtonView, MenuBarMenuListItemButtonView } from '@ckeditor/ckeditor5-ui';\n/**\n * The undo UI feature. It introduces the `'undo'` and `'redo'` buttons to the editor.\n */\nexport default class UndoUI extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'UndoUI';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n    /**\n     * @inheritDoc\n     */\n    init() {\n        const editor = this.editor;\n        const locale = editor.locale;\n        const t = editor.t;\n        const localizedUndoIcon = locale.uiLanguageDirection == 'ltr' ? icons.undo : icons.redo;\n        const localizedRedoIcon = locale.uiLanguageDirection == 'ltr' ? icons.redo : icons.undo;\n        this._addButtonsToFactory('undo', t('Undo'), 'CTRL+Z', localizedUndoIcon);\n        this._addButtonsToFactory('redo', t('Redo'), 'CTRL+Y', localizedRedoIcon);\n    }\n    /**\n     * Creates a button for the specified command.\n     *\n     * @param name Command name.\n     * @param label Button label.\n     * @param keystroke Command keystroke.\n     * @param Icon Source of the icon.\n     */\n    _addButtonsToFactory(name, label, keystroke, Icon) {\n        const editor = this.editor;\n        editor.ui.componentFactory.add(name, () => {\n            const buttonView = this._createButton(ButtonView, name, label, keystroke, Icon);\n            buttonView.set({\n                tooltip: true\n            });\n            return buttonView;\n        });\n        editor.ui.componentFactory.add('menuBar:' + name, () => {\n            return this._createButton(MenuBarMenuListItemButtonView, name, label, keystroke, Icon);\n        });\n    }\n    /**\n     * TODO\n     */\n    _createButton(ButtonClass, name, label, keystroke, Icon) {\n        const editor = this.editor;\n        const locale = editor.locale;\n        const command = editor.commands.get(name);\n        const view = new ButtonClass(locale);\n        view.set({\n            label,\n            icon: Icon,\n            keystroke\n        });\n        view.bind('isEnabled').to(command, 'isEnabled');\n        this.listenTo(view, 'execute', () => {\n            editor.execute(name);\n            editor.editing.view.focus();\n        });\n        return view;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module undo/undo\n */\nimport { Plugin } from '@ckeditor/ckeditor5-core';\nimport UndoEditing from './undoediting.js';\nimport UndoUI from './undoui.js';\n/**\n * The undo feature.\n *\n * This is a \"glue\" plugin which loads the {@link module:undo/undoediting~UndoEditing undo editing feature}\n * and the {@link module:undo/undoui~UndoUI undo UI feature}.\n *\n * Below is an explanation of the undo mechanism working together with {@link module:engine/model/history~History History}:\n *\n * Whenever an {@link module:engine/model/operation/operation~Operation operation} is applied to the\n * {@link module:engine/model/document~Document document}, it is saved to `History` as is.\n * The {@link module:engine/model/batch~Batch batch} that owns that operation is also saved, in\n * {@link module:undo/undocommand~UndoCommand}, together with the selection that was present in the document before the\n * operation was applied. A batch is saved instead of the operation because changes are undone batch-by-batch, not operation-by-operation\n * and a batch is seen as one undo step.\n *\n * After changes happen to the document, the `History` and `UndoCommand` stack can be represented as follows:\n *\n * ```\n *    History                            Undo stack\n * ==============             ==================================\n * [operation A1]                      [  batch A  ]\n * [operation B1]                      [  batch B  ]\n * [operation B2]                      [  batch C  ]\n * [operation C1]\n * [operation C2]\n * [operation B3]\n * [operation C3]\n * ```\n *\n * Where operations starting with the same letter are from same batch.\n *\n * Undoing a batch means that a set of operations which will reverse the effects of that batch needs to be generated.\n * For example, if a batch added several letters, undoing the batch should remove them. It is important to apply undoing\n * operations in the reversed order, so if a batch has operation `X`, `Y`, `Z`, reversed operations `Zr`, `Yr` and `Xr`\n * need to be applied. Otherwise reversed operation `Xr` would operate on a wrong document state, because operation `X`\n * does not know that operations `Y` and `Z` happened.\n *\n * After operations from an undone batch got {@link module:engine/model/operation/operation~Operation#getReversed reversed},\n * one needs to make sure if they are ready to be applied. In the scenario above, operation `C3` is the last operation and `C3r`\n * bases on up-to-date document state, so it can be applied to the document.\n *\n * ```\n *      History                             Undo stack\n * =================             ==================================\n * [ operation A1  ]                      [  batch A  ]\n * [ operation B1  ]                      [  batch B  ]\n * [ operation B2  ]             [   processing undoing batch C   ]\n * [ operation C1  ]\n * [ operation C2  ]\n * [ operation B3  ]\n * [ operation C3  ]\n * [ operation C3r ]\n * ```\n *\n * Next is operation `C2`, reversed to `C2r`. `C2r` bases on `C2`, so it bases on the wrong document state. It needs to be\n * transformed by operations from history that happened after it, so it \"knows\" about them. Let us assume that `C2' = C2r * B3 * C3 * C3r`,\n * where `*` means \"transformed by\". Rest of operations from that batch are processed in the same fashion.\n *\n * ```\n *      History                             Undo stack                                      Redo stack\n * =================             ==================================             ==================================\n * [ operation A1  ]                      [  batch A  ]                                    [ batch Cr ]\n * [ operation B1  ]                      [  batch B  ]\n * [ operation B2  ]\n * [ operation C1  ]\n * [ operation C2  ]\n * [ operation B3  ]\n * [ operation C3  ]\n * [ operation C3r ]\n * [ operation C2' ]\n * [ operation C1' ]\n * ```\n *\n * Selective undo works on the same basis, however, instead of undoing the last batch in the undo stack, any batch can be undone.\n * The same algorithm applies: operations from a batch (i.e. `A1`) are reversed and then transformed by operations stored in history.\n *\n * Redo also is very similar to undo. It has its own stack that is filled with undoing (reversed batches). Operations from\n * the batch that is re-done are reversed-back, transformed in proper order and applied to the document.\n *\n * ```\n *      History                             Undo stack                                      Redo stack\n * =================             ==================================             ==================================\n * [ operation A1  ]                      [  batch A  ]\n * [ operation B1  ]                      [  batch B  ]\n * [ operation B2  ]                      [ batch Crr ]\n * [ operation C1  ]\n * [ operation C2  ]\n * [ operation B3  ]\n * [ operation C3  ]\n * [ operation C3r ]\n * [ operation C2' ]\n * [ operation C1' ]\n * [ operation C1'r]\n * [ operation C2'r]\n * [ operation C3rr]\n * ```\n */\nexport default class Undo extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [UndoEditing, UndoUI];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Undo';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module essentials/essentials\n */\nimport { Plugin } from 'ckeditor5/src/core.js';\nimport { Clipboard } from 'ckeditor5/src/clipboard.js';\nimport { Enter, ShiftEnter } from 'ckeditor5/src/enter.js';\nimport { SelectAll } from 'ckeditor5/src/select-all.js';\nimport { Typing } from 'ckeditor5/src/typing.js';\nimport { Undo } from 'ckeditor5/src/undo.js';\nimport { AccessibilityHelp } from 'ckeditor5/src/ui.js';\n/**\n * A plugin including all essential editing features. It represents a set of features that enables similar functionalities\n * to a `<textarea>` element.\n *\n * It includes:\n *\n * * {@link module:ui/editorui/accessibilityhelp/accessibilityhelp~AccessibilityHelp},\n * * {@link module:clipboard/clipboard~Clipboard},\n * * {@link module:enter/enter~Enter},\n * * {@link module:select-all/selectall~SelectAll},\n * * {@link module:enter/shiftenter~ShiftEnter},\n * * {@link module:typing/typing~Typing},\n * * {@link module:undo/undo~Undo}.\n *\n * This plugin set does not define any block-level containers (such as {@link module:paragraph/paragraph~Paragraph}).\n * If your editor is supposed to handle block content, make sure to include it.\n */\nexport default class Essentials extends Plugin {\n    /**\n     * @inheritDoc\n     */\n    static get requires() {\n        return [AccessibilityHelp, Clipboard, Enter, SelectAll, ShiftEnter, Typing, Undo];\n    }\n    /**\n     * @inheritDoc\n     */\n    static get pluginName() {\n        return 'Essentials';\n    }\n    /**\n     * @inheritDoc\n     */\n    static get isOfficialPlugin() {\n        return true;\n    }\n}\n"],
  "mappings": "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",
  "names": ["document", "count", "document", "isEnabled", "selectedViewElement", "isEnabled", "isEnabled", "isEnabled", "document"]
}
