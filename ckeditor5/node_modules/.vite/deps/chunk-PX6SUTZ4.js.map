{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-basic-styles/src/attributecommand.js", "../../@ckeditor/ckeditor5-basic-styles/src/utils.js"],
  "sourcesContent": ["/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n/**\n * @module basic-styles/attributecommand\n */\nimport { Command } from 'ckeditor5/src/core.js';\n/**\n * An extension of the base {@link module:core/command~Command} class, which provides utilities for a command\n * that toggles a single attribute on a text or an element.\n *\n * `AttributeCommand` uses {@link module:engine/model/document~Document#selection}\n * to decide which nodes (if any) should be changed, and applies or removes the attribute from them.\n *\n * The command checks the {@link module:engine/model/model~Model#schema} to decide if it can be enabled\n * for the current selection and to which nodes the attribute can be applied.\n */\nexport default class AttributeCommand extends Command {\n    /**\n     * @param attributeKey Attribute that will be set by the command.\n     */\n    constructor(editor, attributeKey) {\n        super(editor);\n        this.attributeKey = attributeKey;\n    }\n    /**\n     * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.\n     */\n    refresh() {\n        const model = this.editor.model;\n        const doc = model.document;\n        this.value = this._getValueFromFirstAllowedNode();\n        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);\n    }\n    /**\n     * Executes the command &ndash; applies the attribute to the selection or removes it from the selection.\n     *\n     * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.\n     *\n     * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:\n     *\n     * * If the selection is on a range, the command applies the attribute to all nodes in that range\n     * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).\n     * * If the selection is collapsed in a non-empty node, the command applies the attribute to the\n     * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).\n     * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note\n     * that the selection inherits all attributes from a node if it is in an empty node).\n     *\n     * @fires execute\n     * @param options Command options.\n     * @param options.forceValue If set, it will force the command behavior. If `true`,\n     * the command will apply the attribute, otherwise the command will remove the attribute.\n     * If not set, the command will look for its current value to decide what it should do.\n     */\n    execute(options = {}) {\n        const model = this.editor.model;\n        const doc = model.document;\n        const selection = doc.selection;\n        const value = (options.forceValue === undefined) ? !this.value : options.forceValue;\n        model.change(writer => {\n            if (selection.isCollapsed) {\n                if (value) {\n                    writer.setSelectionAttribute(this.attributeKey, true);\n                }\n                else {\n                    writer.removeSelectionAttribute(this.attributeKey);\n                }\n            }\n            else {\n                const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);\n                for (const range of ranges) {\n                    if (value) {\n                        writer.setAttribute(this.attributeKey, value, range);\n                    }\n                    else {\n                        writer.removeAttribute(this.attributeKey, range);\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Checks the attribute value of the first node in the selection that allows the attribute.\n     * For the collapsed selection returns the selection attribute.\n     *\n     * @returns The attribute value.\n     */\n    _getValueFromFirstAllowedNode() {\n        const model = this.editor.model;\n        const schema = model.schema;\n        const selection = model.document.selection;\n        if (selection.isCollapsed) {\n            return selection.hasAttribute(this.attributeKey);\n        }\n        for (const range of selection.getRanges()) {\n            for (const item of range.getItems()) {\n                if (schema.checkAttribute(item, this.attributeKey)) {\n                    return item.hasAttribute(this.attributeKey);\n                }\n            }\n        }\n        return false;\n    }\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport { MenuBarMenuListItemButtonView } from 'ckeditor5/src/ui.js';\n/**\n * Returns a function that creates a (toolbar or menu bar) button for a basic style feature.\n */\nexport function getButtonCreator({ editor, commandName, plugin, icon, label, keystroke }) {\n    return (ButtonClass) => {\n        const command = editor.commands.get(commandName);\n        const view = new ButtonClass(editor.locale);\n        view.set({\n            label,\n            icon,\n            keystroke,\n            isToggleable: true\n        });\n        view.bind('isEnabled').to(command, 'isEnabled');\n        view.bind('isOn').to(command, 'value');\n        if (view instanceof MenuBarMenuListItemButtonView) {\n            view.set({\n                role: 'menuitemcheckbox'\n            });\n        }\n        else {\n            view.set({\n                tooltip: true\n            });\n        }\n        // Execute the command.\n        plugin.listenTo(view, 'execute', () => {\n            editor.execute(commandName);\n            editor.editing.view.focus();\n        });\n        return view;\n    };\n}\n"],
  "mappings": ";;;;;;AAkBA,IAAqB,mBAArB,cAA8C,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIlD,YAAY,QAAQ,cAAc;AAC9B,UAAM,MAAM;AACZ,SAAK,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACN,UAAM,QAAQ,KAAK,OAAO;AAC1B,UAAM,MAAM,MAAM;AAClB,SAAK,QAAQ,KAAK,8BAA8B;AAChD,SAAK,YAAY,MAAM,OAAO,0BAA0B,IAAI,WAAW,KAAK,YAAY;AAAA,EAC5F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,QAAQ,UAAU,CAAC,GAAG;AAClB,UAAM,QAAQ,KAAK,OAAO;AAC1B,UAAM,MAAM,MAAM;AAClB,UAAM,YAAY,IAAI;AACtB,UAAM,QAAS,QAAQ,eAAe,SAAa,CAAC,KAAK,QAAQ,QAAQ;AACzE,UAAM,OAAO,YAAU;AACnB,UAAI,UAAU,aAAa;AACvB,YAAI,OAAO;AACP,iBAAO,sBAAsB,KAAK,cAAc,IAAI;AAAA,QACxD,OACK;AACD,iBAAO,yBAAyB,KAAK,YAAY;AAAA,QACrD;AAAA,MACJ,OACK;AACD,cAAM,SAAS,MAAM,OAAO,eAAe,UAAU,UAAU,GAAG,KAAK,YAAY;AACnF,mBAAW,SAAS,QAAQ;AACxB,cAAI,OAAO;AACP,mBAAO,aAAa,KAAK,cAAc,OAAO,KAAK;AAAA,UACvD,OACK;AACD,mBAAO,gBAAgB,KAAK,cAAc,KAAK;AAAA,UACnD;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gCAAgC;AAC5B,UAAM,QAAQ,KAAK,OAAO;AAC1B,UAAM,SAAS,MAAM;AACrB,UAAM,YAAY,MAAM,SAAS;AACjC,QAAI,UAAU,aAAa;AACvB,aAAO,UAAU,aAAa,KAAK,YAAY;AAAA,IACnD;AACA,eAAW,SAAS,UAAU,UAAU,GAAG;AACvC,iBAAW,QAAQ,MAAM,SAAS,GAAG;AACjC,YAAI,OAAO,eAAe,MAAM,KAAK,YAAY,GAAG;AAChD,iBAAO,KAAK,aAAa,KAAK,YAAY;AAAA,QAC9C;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;;;AChGO,SAAS,iBAAiB,EAAE,QAAQ,aAAa,QAAQ,MAAM,OAAO,UAAU,GAAG;AACtF,SAAO,CAAC,gBAAgB;AACpB,UAAM,UAAU,OAAO,SAAS,IAAI,WAAW;AAC/C,UAAM,OAAO,IAAI,YAAY,OAAO,MAAM;AAC1C,SAAK,IAAI;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc;AAAA,IAClB,CAAC;AACD,SAAK,KAAK,WAAW,EAAE,GAAG,SAAS,WAAW;AAC9C,SAAK,KAAK,MAAM,EAAE,GAAG,SAAS,OAAO;AACrC,QAAI,gBAAgB,+BAA+B;AAC/C,WAAK,IAAI;AAAA,QACL,MAAM;AAAA,MACV,CAAC;AAAA,IACL,OACK;AACD,WAAK,IAAI;AAAA,QACL,SAAS;AAAA,MACb,CAAC;AAAA,IACL;AAEA,WAAO,SAAS,MAAM,WAAW,MAAM;AACnC,aAAO,QAAQ,WAAW;AAC1B,aAAO,QAAQ,KAAK,MAAM;AAAA,IAC9B,CAAC;AACD,WAAO;AAAA,EACX;AACJ;",
  "names": []
}
