import {
  CKEditorError,
  Collection,
  DomEmitterMixin,
  EmitterMixin,
  ObservableMixin,
  delay,
  env_default,
  getEnvKeystrokeText,
  isIterable,
  isNode,
  toArray,
  uid
} from "./chunk-3X5M7Q3U.js";
import {
  cloneDeepWith_default,
  isObject_default
} from "./chunk-K6UGUURS.js";

// node_modules/@ckeditor/ckeditor5-ui/src/viewcollection.js
var ViewCollection = class extends Collection {
  /**
   * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
   *
   * @param initialItems The initial items of the collection.
   */
  constructor(initialItems = []) {
    super(initialItems, {
      // An #id Number attribute should be legal and not break the `ViewCollection` instance.
      // https://github.com/ckeditor/ckeditor5-ui/issues/93
      idProperty: "viewUid"
    });
    this.on("add", (evt, view, index) => {
      this._renderViewIntoCollectionParent(view, index);
    });
    this.on("remove", (evt, view) => {
      if (view.element && this._parentElement) {
        view.element.remove();
      }
    });
    this._parentElement = null;
  }
  /**
   * Destroys the view collection along with child views.
   * See the view {@link module:ui/view~View#destroy} method.
   */
  destroy() {
    this.map((view) => view.destroy());
  }
  /**
   * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
   * {@link #remove removing} views in the collection synchronizes their
   * {@link module:ui/view~View#element elements} in the parent element.
   *
   * @param element A new parent element.
   */
  setParent(elementOrDocFragment) {
    this._parentElement = elementOrDocFragment;
    for (const view of this) {
      this._renderViewIntoCollectionParent(view);
    }
  }
  /**
   * Delegates selected events coming from within views in the collection to any
   * {@link module:utils/emittermixin~Emitter}.
   *
   * For the following views and collection:
   *
   * ```ts
   * const viewA = new View();
   * const viewB = new View();
   * const viewC = new View();
   *
   * const views = parentView.createCollection();
   *
   * views.delegate( 'eventX' ).to( viewB );
   * views.delegate( 'eventX', 'eventY' ).to( viewC );
   *
   * views.add( viewA );
   * ```
   *
   * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventX', customData );
   * ```
   *
   * and `eventY` is delegated (fired by) `viewC` along with `customData`:
   *
   * ```ts
   * viewA.fire( 'eventY', customData );
   * ```
   *
   * See {@link module:utils/emittermixin~Emitter#delegate}.
   *
   * @param events {@link module:ui/view~View} event names to be delegated to another
   * {@link module:utils/emittermixin~Emitter}.
   * @returns Object with `to` property, a function which accepts the destination
   * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
   */
  delegate(...events) {
    if (!events.length || !isStringArray(events)) {
      throw new CKEditorError("ui-viewcollection-delegate-wrong-events", this);
    }
    return {
      to: (dest) => {
        for (const view of this) {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        }
        this.on("add", (evt, view) => {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        });
        this.on("remove", (evt, view) => {
          for (const evtName of events) {
            view.stopDelegating(evtName, dest);
          }
        });
      }
    };
  }
  /**
   * This method {@link module:ui/view~View#render renders} a new view added to the collection.
   *
   * If the {@link #_parentElement parent element} of the collection is set, this method also adds
   * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
   *
   * **Note**: If index is not specified, the view's element is pushed as the last child
   * of the parent element.
   *
   * @param view A new view added to the collection.
   * @param index An index the view holds in the collection. When not specified,
   * the view is added at the end.
   */
  _renderViewIntoCollectionParent(view, index) {
    if (!view.isRendered) {
      view.render();
    }
    if (view.element && this._parentElement) {
      this._parentElement.insertBefore(view.element, this._parentElement.children[index]);
    }
  }
  /**
   * Removes a child view from the collection. If the {@link #setParent parent element} of the
   * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
   * in DOM, reflecting the order of the collection.
   *
   * See the {@link #add} method.
   *
   * @param subject The view to remove, its id or index in the collection.
   * @returns The removed view.
   */
  remove(subject) {
    return super.remove(subject);
  }
};
function isStringArray(arr) {
  return arr.every((a) => typeof a == "string");
}

// node_modules/@ckeditor/ckeditor5-ui/src/template.js
var xhtmlNs = "http://www.w3.org/1999/xhtml";
var Template = class extends EmitterMixin() {
  /**
   * Creates an instance of the {@link ~Template} class.
   *
   * @param def The definition of the template.
   */
  constructor(def) {
    super();
    Object.assign(this, normalize(clone(def)));
    this._isRendered = false;
    this._revertData = null;
  }
  /**
   * Renders a DOM Node (an HTML element or text) out of the template.
   *
   * ```ts
   * const domNode = new Template( { ... } ).render();
   * ```
   *
   * See: {@link #apply}.
   */
  render() {
    const node = this._renderNode({
      intoFragment: true
    });
    this._isRendered = true;
    return node;
  }
  /**
   * Applies the template to an existing DOM Node, either HTML element or text.
   *
   * **Note:** No new DOM nodes will be created. Applying extends:
   *
   * {@link module:ui/template~TemplateDefinition attributes},
   * {@link module:ui/template~TemplateDefinition event listeners}, and
   * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
   *
   * **Note:** Existing `class` and `style` attributes are extended when a template
   * is applied to an HTML element, while other attributes and `textContent` are overridden.
   *
   * **Note:** The process of applying a template can be easily reverted using the
   * {@link module:ui/template~Template#revert} method.
   *
   * ```ts
   * const element = document.createElement( 'div' );
   * const observable = new Model( { divClass: 'my-div' } );
   * const emitter = Object.create( EmitterMixin );
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		id: 'first-div',
   * 		class: bind.to( 'divClass' )
   * 	},
   * 	on: {
   * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
   * 	},
   * 	children: [
   * 		'Div text.'
   * 	]
   * } ).apply( element );
   *
   * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
   * ```
   *
   * @see module:ui/template~Template#render
   * @see module:ui/template~Template#revert
   * @param node Root node for the template to apply.
   */
  apply(node) {
    this._revertData = getEmptyRevertData();
    this._renderNode({
      node,
      intoFragment: false,
      isApplying: true,
      revertData: this._revertData
    });
    return node;
  }
  /**
   * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
   *
   * @param node The root node for the template to revert. In most of the cases, it is the
   * same node used by {@link module:ui/template~Template#apply}.
   */
  revert(node) {
    if (!this._revertData) {
      throw new CKEditorError("ui-template-revert-not-applied", [this, node]);
    }
    this._revertTemplateFromNode(node, this._revertData);
  }
  /**
   * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
   * instances and returns them one by one.
   *
   * ```ts
   * const viewFoo = new View();
   * const viewBar = new View();
   * const viewBaz = new View();
   * const template = new Template( {
   * 	tag: 'div',
   * 	children: [
   * 		viewFoo,
   * 		{
   * 			tag: 'div',
   * 			children: [
   * 				viewBar
   * 			]
   * 		},
   * 		viewBaz
   * 	]
   * } );
   *
   * // Logs: viewFoo, viewBar, viewBaz
   * for ( const view of template.getViews() ) {
   * 	console.log( view );
   * }
   * ```
   */
  *getViews() {
    function* search(def) {
      if (def.children) {
        for (const child of def.children) {
          if (isView(child)) {
            yield child;
          } else if (isTemplate(child)) {
            yield* search(child);
          }
        }
      }
    }
    yield* search(this);
  }
  /**
   * An entry point to the interface which binds DOM nodes to
   * {@link module:utils/observablemixin~Observable observables}.
   * There are two types of bindings:
   *
   * * HTML element attributes or text `textContent` synchronized with attributes of an
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
   * and {@link module:ui/template~BindChain#if}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	attributes: {
   * 		// Binds the element "class" attribute to observable#classAttribute.
   * 		class: bind.to( 'classAttribute' )
   * 	}
   * } ).render();
   * ```
   *
   * * DOM events fired on HTML element propagated through
   * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * new Template( {
   * 	on: {
   * 		// Will be fired by the observable.
   * 		click: bind( 'elementClicked' )
   * 	}
   * } ).render();
   * ```
   *
   * Also see {@link module:ui/view~View#bindTemplate}.
   *
   * @param observable An observable which provides boundable attributes.
   * @param emitter An emitter that listens to observable attribute
   * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
   */
  static bind(observable, emitter) {
    return {
      to(eventNameOrFunctionOrAttribute, callback) {
        return new TemplateToBinding({
          eventNameOrFunction: eventNameOrFunctionOrAttribute,
          attribute: eventNameOrFunctionOrAttribute,
          observable,
          emitter,
          callback
        });
      },
      if(attribute, valueIfTrue, callback) {
        return new TemplateIfBinding({
          observable,
          emitter,
          attribute,
          valueIfTrue,
          callback
        });
      }
    };
  }
  /**
   * Extends an existing {@link module:ui/template~Template} instance with some additional content
   * from another {@link module:ui/template~TemplateDefinition}.
   *
   * ```ts
   * const bind = Template.bind( observable, emitter );
   *
   * const template = new Template( {
   * 	tag: 'p',
   * 	attributes: {
   * 		class: 'a',
   * 		data-x: bind.to( 'foo' )
   * 	},
   * 	children: [
   * 		{
   * 			tag: 'span',
   * 			attributes: {
   * 				class: 'b'
   * 			},
   * 			children: [
   * 				'Span'
   * 			]
   * 		}
   * 	]
   *  } );
   *
   * // Instance-level extension.
   * Template.extend( template, {
   * 	attributes: {
   * 		class: 'b',
   * 		data-x: bind.to( 'bar' )
   * 	},
   * 	children: [
   * 		{
   * 			attributes: {
   * 				class: 'c'
   * 			}
   * 		}
   * 	]
   * } );
   *
   * // Child extension.
   * Template.extend( template.children[ 0 ], {
   * 	attributes: {
   * 		class: 'd'
   * 	}
   * } );
   * ```
   *
   * the `outerHTML` of `template.render()` is:
   *
   * ```html
   * <p class="a b" data-x="{ observable.foo } { observable.bar }">
   * 	<span class="b c d">Span</span>
   * </p>
   * ```
   *
   * @param template An existing template instance to be extended.
   * @param def Additional definition to be applied to a template.
   */
  static extend(template, def) {
    if (template._isRendered) {
      throw new CKEditorError("template-extend-render", [this, template]);
    }
    extendTemplate(template, normalize(clone(def)));
  }
  /**
   * Renders a DOM Node (either an HTML element or text) out of the template.
   *
   * @param data Rendering data.
   */
  _renderNode(data) {
    let isInvalid;
    if (data.node) {
      isInvalid = this.tag && this.text;
    } else {
      isInvalid = this.tag ? this.text : !this.text;
    }
    if (isInvalid) {
      throw new CKEditorError("ui-template-wrong-syntax", this);
    }
    if (this.text) {
      return this._renderText(data);
    } else {
      return this._renderElement(data);
    }
  }
  /**
   * Renders an HTML element out of the template.
   *
   * @param data Rendering data.
   */
  _renderElement(data) {
    let node = data.node;
    if (!node) {
      node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
    }
    this._renderAttributes(data);
    this._renderElementChildren(data);
    this._setUpListeners(data);
    return node;
  }
  /**
   * Renders a text node out of {@link module:ui/template~Template#text}.
   *
   * @param data Rendering data.
   */
  _renderText(data) {
    let node = data.node;
    if (node) {
      data.revertData.text = node.textContent;
    } else {
      node = data.node = document.createTextNode("");
    }
    if (hasTemplateBinding(this.text)) {
      this._bindToObservable({
        schema: this.text,
        updater: getTextUpdater(node),
        data
      });
    } else {
      node.textContent = this.text.join("");
    }
    return node;
  }
  /**
   * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
   *
   * @param data Rendering data.
   */
  _renderAttributes(data) {
    if (!this.attributes) {
      return;
    }
    const node = data.node;
    const revertData = data.revertData;
    for (const attrName in this.attributes) {
      const domAttrValue = node.getAttribute(attrName);
      const attrValue = this.attributes[attrName];
      if (revertData) {
        revertData.attributes[attrName] = domAttrValue;
      }
      const attrNs = isNamespaced(attrValue) ? attrValue[0].ns : null;
      if (hasTemplateBinding(attrValue)) {
        const valueToBind = isNamespaced(attrValue) ? attrValue[0].value : attrValue;
        if (revertData && shouldExtend(attrName)) {
          valueToBind.unshift(domAttrValue);
        }
        this._bindToObservable({
          schema: valueToBind,
          updater: getAttributeUpdater(node, attrName, attrNs),
          data
        });
      } else if (attrName == "style" && typeof attrValue[0] !== "string") {
        this._renderStyleAttribute(attrValue[0], data);
      } else {
        if (revertData && domAttrValue && shouldExtend(attrName)) {
          attrValue.unshift(domAttrValue);
        }
        const value = attrValue.map((val) => val ? val.value || val : val).reduce((prev, next) => prev.concat(next), []).reduce(arrayValueReducer, "");
        if (!isFalsy(value)) {
          node.setAttributeNS(attrNs, attrName, value);
        }
      }
    }
  }
  /**
   * Renders the `style` attribute of an HTML element based on
   * {@link module:ui/template~Template#attributes}.
   *
   * A style attribute is an object with static values:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: 'red'
   * 	}
   * }
   * ```
   *
   * or values bound to {@link module:ui/model~Model} properties:
   *
   * ```ts
   * attributes: {
   * 	style: {
   * 		color: bind.to( ... )
   * 	}
   * }
   * ```
   *
   * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
   * needed.
   *
   * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
   * @param data Rendering data.
   */
  _renderStyleAttribute(styles, data) {
    const node = data.node;
    for (const styleName in styles) {
      const styleValue = styles[styleName];
      if (hasTemplateBinding(styleValue)) {
        this._bindToObservable({
          schema: [styleValue],
          updater: getStyleUpdater(node, styleName),
          data
        });
      } else {
        node.style[styleName] = styleValue;
      }
    }
  }
  /**
   * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
   *
   * @param data Rendering data.
   */
  _renderElementChildren(data) {
    const node = data.node;
    const container = data.intoFragment ? document.createDocumentFragment() : node;
    const isApplying = data.isApplying;
    let childIndex = 0;
    for (const child of this.children) {
      if (isViewCollection(child)) {
        if (!isApplying) {
          child.setParent(node);
          for (const view of child) {
            container.appendChild(view.element);
          }
        }
      } else if (isView(child)) {
        if (!isApplying) {
          if (!child.isRendered) {
            child.render();
          }
          container.appendChild(child.element);
        }
      } else if (isNode(child)) {
        container.appendChild(child);
      } else {
        if (isApplying) {
          const revertData = data.revertData;
          const childRevertData = getEmptyRevertData();
          revertData.children.push(childRevertData);
          child._renderNode({
            intoFragment: false,
            node: container.childNodes[childIndex++],
            isApplying: true,
            revertData: childRevertData
          });
        } else {
          container.appendChild(child.render());
        }
      }
    }
    if (data.intoFragment) {
      node.appendChild(container);
    }
  }
  /**
   * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
   * on an HTML element.
   *
   * @param data Rendering data.
   */
  _setUpListeners(data) {
    if (!this.eventListeners) {
      return;
    }
    for (const key in this.eventListeners) {
      const revertBindings = this.eventListeners[key].map((schemaItem) => {
        const [domEvtName, domSelector] = key.split("@");
        return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
      });
      if (data.revertData) {
        data.revertData.bindings.push(revertBindings);
      }
    }
  }
  /**
   * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
   * activates the binding and sets its initial value.
   *
   * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
   * text node `textContent`.
   *
   * @param options Binding options.
   * @param options.updater A function which updates the DOM (like attribute or text).
   * @param options.data Rendering data.
   */
  _bindToObservable({ schema, updater, data }) {
    const revertData = data.revertData;
    syncValueSchemaValue(schema, updater, data);
    const revertBindings = schema.filter((item) => !isFalsy(item)).filter((item) => item.observable).map((templateBinding) => templateBinding.activateAttributeListener(schema, updater, data));
    if (revertData) {
      revertData.bindings.push(revertBindings);
    }
  }
  /**
   * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
   * return it to the original state.
   *
   * @param node A node to be reverted.
   * @param revertData An object that stores information about what changes have been made by
   * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
   */
  _revertTemplateFromNode(node, revertData) {
    for (const binding of revertData.bindings) {
      for (const revertBinding of binding) {
        revertBinding();
      }
    }
    if (revertData.text) {
      node.textContent = revertData.text;
      return;
    }
    const element = node;
    for (const attrName in revertData.attributes) {
      const attrValue = revertData.attributes[attrName];
      if (attrValue === null) {
        element.removeAttribute(attrName);
      } else {
        element.setAttribute(attrName, attrValue);
      }
    }
    for (let i = 0; i < revertData.children.length; ++i) {
      this._revertTemplateFromNode(element.childNodes[i], revertData.children[i]);
    }
  }
};
var TemplateBinding = class {
  /**
   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
   *
   * @param def The definition of the binding.
   */
  constructor(def) {
    this.attribute = def.attribute;
    this.observable = def.observable;
    this.emitter = def.emitter;
    this.callback = def.callback;
  }
  /**
   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
   *
   * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
   * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}.
   */
  getValue(node) {
    const value = this.observable[this.attribute];
    return this.callback ? this.callback(value, node) : value;
  }
  /**
   * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
   * value of {@link module:ui/template~TemplateValueSchema}.
   *
   * @param schema A full schema to generate an attribute or text in the DOM.
   * @param updater A DOM updater function used to update the native DOM attribute or text.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateAttributeListener(schema, updater, data) {
    const callback = () => syncValueSchemaValue(schema, updater, data);
    this.emitter.listenTo(this.observable, `change:${this.attribute}`, callback);
    return () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, callback);
    };
  }
};
var TemplateToBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.eventNameOrFunction = def.eventNameOrFunction;
  }
  /**
   * Activates the listener for the native DOM event, which when fired, is propagated by
   * the {@link module:ui/template~TemplateBinding#emitter}.
   *
   * @param domEvtName The name of the native DOM event.
   * @param domSelector The selector in the DOM to filter delegated events.
   * @param data Rendering data.
   * @returns A function to sever the listener binding.
   */
  activateDomEventListener(domEvtName, domSelector, data) {
    const callback = (evt, domEvt) => {
      if (!domSelector || domEvt.target.matches(domSelector)) {
        if (typeof this.eventNameOrFunction == "function") {
          this.eventNameOrFunction(domEvt);
        } else {
          this.observable.fire(this.eventNameOrFunction, domEvt);
        }
      }
    };
    this.emitter.listenTo(data.node, domEvtName, callback);
    return () => {
      this.emitter.stopListening(data.node, domEvtName, callback);
    };
  }
};
var TemplateIfBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.valueIfTrue = def.valueIfTrue;
  }
  /**
   * @inheritDoc
   */
  getValue(node) {
    const value = super.getValue(node);
    return isFalsy(value) ? false : this.valueIfTrue || true;
  }
};
function hasTemplateBinding(schema) {
  if (!schema) {
    return false;
  }
  if (schema.value) {
    schema = schema.value;
  }
  if (Array.isArray(schema)) {
    return schema.some(hasTemplateBinding);
  } else if (schema instanceof TemplateBinding) {
    return true;
  }
  return false;
}
function getValueSchemaValue(schema, node) {
  return schema.map((schemaItem) => {
    if (schemaItem instanceof TemplateBinding) {
      return schemaItem.getValue(node);
    }
    return schemaItem;
  });
}
function syncValueSchemaValue(schema, updater, { node }) {
  const values = getValueSchemaValue(schema, node);
  let value;
  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {
    value = values[0];
  } else {
    value = values.reduce(arrayValueReducer, "");
  }
  if (isFalsy(value)) {
    updater.remove();
  } else {
    updater.set(value);
  }
}
function getTextUpdater(node) {
  return {
    set(value) {
      node.textContent = value;
    },
    remove() {
      node.textContent = "";
    }
  };
}
function getAttributeUpdater(el, attrName, ns) {
  return {
    set(value) {
      el.setAttributeNS(ns, attrName, value);
    },
    remove() {
      el.removeAttributeNS(ns, attrName);
    }
  };
}
function getStyleUpdater(el, styleName) {
  return {
    set(value) {
      el.style[styleName] = value;
    },
    remove() {
      el.style[styleName] = null;
    }
  };
}
function clone(def) {
  const clone2 = cloneDeepWith_default(def, (value) => {
    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
      return value;
    }
  });
  return clone2;
}
function normalize(def) {
  if (typeof def == "string") {
    def = normalizePlainTextDefinition(def);
  } else if (def.text) {
    normalizeTextDefinition(def);
  }
  if (def.on) {
    def.eventListeners = normalizeListeners(def.on);
    delete def.on;
  }
  if (!def.text) {
    if (def.attributes) {
      normalizeAttributes(def.attributes);
    }
    const children = [];
    if (def.children) {
      if (isViewCollection(def.children)) {
        children.push(def.children);
      } else {
        for (const child of def.children) {
          if (isTemplate(child) || isView(child) || isNode(child)) {
            children.push(child);
          } else {
            children.push(new Template(child));
          }
        }
      }
    }
    def.children = children;
  }
  return def;
}
function normalizeAttributes(attributes) {
  for (const a in attributes) {
    if (attributes[a].value) {
      attributes[a].value = toArray(attributes[a].value);
    }
    arrayify(attributes, a);
  }
}
function normalizeListeners(listeners) {
  for (const l in listeners) {
    arrayify(listeners, l);
  }
  return listeners;
}
function normalizePlainTextDefinition(def) {
  return {
    text: [def]
  };
}
function normalizeTextDefinition(def) {
  def.text = toArray(def.text);
}
function arrayify(obj, key) {
  obj[key] = toArray(obj[key]);
}
function arrayValueReducer(prev, cur) {
  if (isFalsy(cur)) {
    return prev;
  } else if (isFalsy(prev)) {
    return cur;
  } else {
    return `${prev} ${cur}`;
  }
}
function extendObjectValueArray(obj, ext) {
  for (const a in ext) {
    if (obj[a]) {
      obj[a].push(...ext[a]);
    } else {
      obj[a] = ext[a];
    }
  }
}
function extendTemplate(template, def) {
  if (def.attributes) {
    if (!template.attributes) {
      template.attributes = {};
    }
    extendObjectValueArray(template.attributes, def.attributes);
  }
  if (def.eventListeners) {
    if (!template.eventListeners) {
      template.eventListeners = {};
    }
    extendObjectValueArray(template.eventListeners, def.eventListeners);
  }
  if (def.text) {
    template.text.push(...def.text);
  }
  if (def.children && def.children.length) {
    if (template.children.length != def.children.length) {
      throw new CKEditorError("ui-template-extend-children-mismatch", template);
    }
    let childIndex = 0;
    for (const childDef of def.children) {
      extendTemplate(template.children[childIndex++], childDef);
    }
  }
}
function isFalsy(value) {
  return !value && value !== 0;
}
function isView(item) {
  return item instanceof View;
}
function isTemplate(item) {
  return item instanceof Template;
}
function isViewCollection(item) {
  return item instanceof ViewCollection;
}
function isNamespaced(attrValue) {
  return isObject_default(attrValue[0]) && attrValue[0].ns;
}
function getEmptyRevertData() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
}
function shouldExtend(attrName) {
  return attrName == "class" || attrName == "style";
}

// node_modules/@ckeditor/ckeditor5-ui/src/view.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/globals/globals.css";
var View = class extends DomEmitterMixin(ObservableMixin()) {
  /**
   * Creates an instance of the {@link module:ui/view~View} class.
   *
   * Also see {@link #render}.
   *
   * @param locale The localization services instance.
   */
  constructor(locale) {
    super();
    this.element = null;
    this.isRendered = false;
    this.locale = locale;
    this.t = locale && locale.t;
    this._viewCollections = new Collection();
    this._unboundChildren = this.createCollection();
    this._viewCollections.on("add", (evt, collection) => {
      collection.locale = locale;
      collection.t = locale && locale.t;
    });
    this.decorate("render");
  }
  /**
   * Shorthand for {@link module:ui/template~Template.bind}, a binding
   * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
   *
   * It provides {@link module:ui/template~BindChain#to `to()`} and
   * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
   * observable attributes and attach DOM listeners.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const bind = this.bindTemplate;
   *
   * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
   * 		// the state of the view in DOM.
   * 		this.set( {
   * 			elementClass: 'foo',
   * 		 	isEnabled: true
   * 		 } );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			attributes: {
   * 				// The class HTML attribute will follow elementClass
   * 				// and isEnabled view attributes.
   * 				class: [
   * 					bind.to( 'elementClass' )
   * 					bind.if( 'isEnabled', 'present-when-enabled' )
   * 				]
   * 			},
   *
   * 			on: {
   * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
   * 				click: bind.to( 'clicked' )
   * 			}
   * 		} );
   * 	}
   * }
   * ```
   */
  get bindTemplate() {
    if (this._bindTemplate) {
      return this._bindTemplate;
    }
    return this._bindTemplate = Template.bind(this, this);
  }
  /**
   * Creates a new collection of views, which can be used as
   * {@link module:ui/template~Template#children} of this view.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		const child = new ChildView( locale );
   * 		this.items = this.createCollection( [ child ] );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// `items` collection will render here.
   * 			children: this.items
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   * view.render();
   *
   * // It will append <p><child#element></p> to the <body>.
   * document.body.appendChild( view.element );
   * ```
   *
   * @param views Initial views of the collection.
   * @returns A new collection of view instances.
   */
  createCollection(views) {
    const collection = new ViewCollection(views);
    this._viewCollections.add(collection);
    return collection;
  }
  /**
   * Registers a new child view under the view instance. Once registered, a child
   * view is managed by its parent, including {@link #render rendering}
   * and {@link #destroy destruction}.
   *
   * To revert this, use {@link #deregisterChild}.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( { tag: 'p' } );
   *
   * 		// Register the children.
   * 		this.registerChild( [ this.childA, this.childB ] );
   * 	}
   *
   * 	render() {
   * 		super.render();
   *
   * 		this.element.appendChild( this.childA.element );
   * 		this.element.appendChild( this.childB.element );
   * 	}
   * }
   *
   * const view = new SampleView( locale );
   *
   * view.render();
   *
   * // Will append <p><childA#element><b></b><childB#element></p>.
   * document.body.appendChild( view.element );
   * ```
   *
   * **Note**: There's no need to add child views if they're already referenced in the
   * {@link #template}:
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor( locale ) {
   * 		super( locale );
   *
   * 		this.childA = new SomeChildView( locale );
   * 		this.childB = new SomeChildView( locale );
   *
   * 		this.setTemplate( {
   * 			tag: 'p',
   *
   * 			// These children will be added automatically. There's no
   * 			// need to call {@link #registerChild} for any of them.
   * 			children: [ this.childA, this.childB ]
   * 		} );
   * 	}
   *
   * 	// ...
   * }
   * ```
   *
   * @param children Children views to be registered.
   */
  registerChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.add(child);
    }
  }
  /**
   * The opposite of {@link #registerChild}. Removes a child view from this view instance.
   * Once removed, the child is no longer managed by its parent, e.g. it can safely
   * become a child of another parent view.
   *
   * @see #registerChild
   * @param children Child views to be removed.
   */
  deregisterChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.remove(child);
    }
  }
  /**
   * Sets the {@link #template} of the view with with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * view.setTemplate( definition );
   * ```
   *
   * @param definition Definition of view's template.
   */
  setTemplate(definition) {
    this.template = new Template(definition);
  }
  /**
   * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
   * with given definition.
   *
   * A shorthand for:
   *
   * ```ts
   * Template.extend( view.template, definition );
   * ```
   *
   * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
   *
   * @param definition Definition which extends the {@link #template}.
   */
  extendTemplate(definition) {
    Template.extend(this.template, definition);
  }
  /**
   * Recursively renders the view.
   *
   * Once the view is rendered:
   * * the {@link #element} becomes an HTML element out of {@link #template},
   * * the {@link #isRendered} flag is set `true`.
   *
   * **Note**: The children of the view:
   * * defined directly in the {@link #template}
   * * residing in collections created by the {@link #createCollection} method,
   * * and added by {@link #registerChild}
   * are also rendered in the process.
   *
   * In general, `render()` method is the right place to keep the code which refers to the
   * {@link #element} and should be executed at the very beginning of the view's life cycle.
   *
   * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
   * the view is rendered. To allow an early customization of the view (e.g. by its parent),
   * such references should be done in `render()`.
   *
   * ```ts
   * class SampleView extends View {
   * 	constructor() {
   * 		this.setTemplate( {
   * 			// ...
   * 		} );
   * 	},
   *
   * 	render() {
   * 		// View#element becomes available.
   * 		super.render();
   *
   * 		// The "scroll" listener depends on #element.
   * 		this.listenTo( window, 'scroll', () => {
   * 			// A reference to #element would render the #template and make it non-extendable.
   * 			if ( window.scrollY > 0 ) {
   * 				this.element.scrollLeft = 100;
   * 			} else {
   * 				this.element.scrollLeft = 0;
   * 			}
   * 		} );
   * 	}
   * }
   *
   * const view = new SampleView();
   *
   * // Let's customize the view before it gets rendered.
   * view.extendTemplate( {
   * 	attributes: {
   * 		class: [
   * 			'additional-class'
   * 		]
   * 	}
   * } );
   *
   * // Late rendering allows customization of the view.
   * view.render();
   * ```
   */
  render() {
    if (this.isRendered) {
      throw new CKEditorError("ui-view-render-already-rendered", this);
    }
    if (this.template) {
      this.element = this.template.render();
      this.registerChild(this.template.getViews());
    }
    this.isRendered = true;
  }
  /**
   * Recursively destroys the view instance and child views added by {@link #registerChild} and
   * residing in collections created by the {@link #createCollection}.
   *
   * Destruction disables all event listeners:
   * * created on the view, e.g. `view.on( 'event', () => {} )`,
   * * defined in the {@link #template} for DOM events.
   */
  destroy() {
    this.stopListening();
    this._viewCollections.map((c) => c.destroy());
    if (this.template && this.template._revertData) {
      this.template.revert(this.element);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/icon/iconview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css";
var IconView = class _IconView extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set("content", "");
    this.set("viewBox", "0 0 20 20");
    this.set("fillColor", "");
    this.set("isColorInherited", true);
    this.set("isVisible", true);
    this.setTemplate({
      tag: "svg",
      ns: "http://www.w3.org/2000/svg",
      attributes: {
        class: [
          "ck",
          "ck-icon",
          bind.if("isVisible", "ck-hidden", (value) => !value),
          // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          "ck-reset_all-excluded",
          // The class to remove the dynamic color inheritance is toggleable
          // (https://github.com/ckeditor/ckeditor5/issues/12599).
          bind.if("isColorInherited", "ck-icon_inherit-color")
        ],
        viewBox: bind.to("viewBox")
      }
    });
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    this._updateXMLContent();
    this._colorFillPaths();
    this.on("change:content", () => {
      this._updateXMLContent();
      this._colorFillPaths();
    });
    this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  /**
   * Updates the {@link #element} with the value of {@link #content}.
   */
  _updateXMLContent() {
    if (this.content) {
      const parsed = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
      const svg = parsed.querySelector("svg");
      const viewBox = svg.getAttribute("viewBox");
      if (viewBox) {
        this.viewBox = viewBox;
      }
      for (const { name, value } of Array.from(svg.attributes)) {
        if (_IconView.presentationalAttributeNames.includes(name)) {
          this.element.setAttribute(name, value);
        }
      }
      while (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
      while (svg.childNodes.length > 0) {
        this.element.appendChild(svg.childNodes[0]);
      }
    }
  }
  /**
   * Fills all child `path.ck-icon__fill` with the `#fillColor`.
   */
  _colorFillPaths() {
    if (this.fillColor) {
      this.element.querySelectorAll(".ck-icon__fill").forEach((path) => {
        path.style.fill = this.fillColor;
      });
    }
  }
};
IconView.presentationalAttributeNames = [
  "alignment-baseline",
  "baseline-shift",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-rendering",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "opacity",
  "overflow",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-overflow",
  "text-rendering",
  "transform",
  "unicode-bidi",
  "vector-effect",
  "visibility",
  "white-space",
  "word-spacing",
  "writing-mode"
];
var iconview_default = IconView;

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonlabelview.js
var ButtonLabelView = class extends View {
  /**
   * @inheritDoc
   */
  constructor() {
    super();
    this.set({
      style: void 0,
      text: void 0,
      id: void 0
    });
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__label"
        ],
        style: bind.to("style"),
        id: bind.to("id")
      },
      children: [
        {
          text: bind.to("text")
        }
      ]
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonview.js
import "/home/wsl/code/cash/drupal/ckeditor5/node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css";
var ButtonView = class extends View {
  /**
   * Creates an instance of the button view class.
   *
   * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param labelView The instance of the button's label. If not provided, an instance of
   * {@link module:ui/button/buttonlabelview~ButtonLabelView} is used.
   */
  constructor(locale, labelView = new ButtonLabelView()) {
    super(locale);
    this._focusDelayed = null;
    const bind = this.bindTemplate;
    const ariaLabelUid = uid();
    this.set("_ariaPressed", false);
    this.set("_ariaChecked", false);
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", `ck-editor__aria-label_${ariaLabelUid}`);
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isVisible", true);
    this.set("isToggleable", false);
    this.set("keystroke", void 0);
    this.set("label", void 0);
    this.set("role", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.set("withKeystroke", false);
    this.children = this.createCollection();
    this.labelView = this._setupLabelView(labelView);
    this.iconView = new iconview_default();
    this.iconView.extendTemplate({
      attributes: {
        class: "ck-button__icon"
      }
    });
    this.keystrokeView = this._createKeystrokeView();
    this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const template = {
      tag: "button",
      attributes: {
        class: [
          "ck",
          "ck-button",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isVisible", "ck-hidden", (value) => !value),
          bind.to("isOn", (value) => value ? "ck-on" : "ck-off"),
          bind.if("withText", "ck-button_with-text"),
          bind.if("withKeystroke", "ck-button_with-keystroke")
        ],
        role: bind.to("role"),
        type: bind.to("type", (value) => value ? value : "button"),
        tabindex: bind.to("tabindex"),
        "aria-checked": bind.to("_ariaChecked"),
        "aria-pressed": bind.to("_ariaPressed"),
        "aria-label": bind.to("ariaLabel"),
        "aria-labelledby": bind.to("ariaLabelledBy"),
        "aria-disabled": bind.if("isEnabled", true, (value) => !value),
        "data-cke-tooltip-text": bind.to("_tooltipString"),
        "data-cke-tooltip-position": bind.to("tooltipPosition")
      },
      children: this.children,
      on: {
        click: bind.to((evt) => {
          if (this.isEnabled) {
            this.fire("execute");
          } else {
            evt.preventDefault();
          }
        })
      }
    };
    this.bind("_ariaPressed").to(this, "isOn", this, "isToggleable", this, "role", (isOn, isToggleable, role) => {
      if (!isToggleable || isCheckableRole(role)) {
        return false;
      }
      return String(!!isOn);
    });
    this.bind("_ariaChecked").to(this, "isOn", this, "isToggleable", this, "role", (isOn, isToggleable, role) => {
      if (!isToggleable || !isCheckableRole(role)) {
        return false;
      }
      return String(!!isOn);
    });
    if (env_default.isSafari) {
      if (!this._focusDelayed) {
        this._focusDelayed = delay(() => this.focus(), 0);
      }
      template.on.mousedown = bind.to(() => {
        this._focusDelayed();
      });
      template.on.mouseup = bind.to(() => {
        this._focusDelayed.cancel();
      });
    }
    this.setTemplate(template);
  }
  /**
   * @inheritDoc
   */
  render() {
    super.render();
    if (this.icon) {
      this.iconView.bind("content").to(this, "icon");
      this.children.add(this.iconView);
    }
    this.children.add(this.labelView);
    if (this.withKeystroke && this.keystroke) {
      this.children.add(this.keystrokeView);
    }
  }
  /**
   * Focuses the {@link #element} of the button.
   */
  focus() {
    this.element.focus();
  }
  /**
   * @inheritDoc
   */
  destroy() {
    if (this._focusDelayed) {
      this._focusDelayed.cancel();
    }
    super.destroy();
  }
  /**
   * Binds the label view instance it with button attributes.
   */
  _setupLabelView(labelView) {
    labelView.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy");
    return labelView;
  }
  /**
   * Creates a view that displays a keystroke next to a {@link #labelView label }
   * and binds it with button attributes.
   */
  _createKeystrokeView() {
    const keystrokeView = new View();
    keystrokeView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__keystroke"
        ]
      },
      children: [
        {
          text: this.bindTemplate.to("keystroke", (text) => getEnvKeystrokeText(text))
        }
      ]
    });
    return keystrokeView;
  }
  /**
   * Gets the text for the tooltip from the combination of
   * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
   *
   * @see #tooltip
   * @see #_tooltipString
   * @param tooltip Button tooltip.
   * @param label Button label.
   * @param keystroke Button keystroke.
   */
  _getTooltipString(tooltip, label, keystroke) {
    if (tooltip) {
      if (typeof tooltip == "string") {
        return tooltip;
      } else {
        if (keystroke) {
          keystroke = getEnvKeystrokeText(keystroke);
        }
        if (tooltip instanceof Function) {
          return tooltip(label, keystroke);
        } else {
          return `${label}${keystroke ? ` (${keystroke})` : ""}`;
        }
      }
    }
    return "";
  }
};
function isCheckableRole(role) {
  switch (role) {
    case "radio":
    case "checkbox":
    case "option":
    case "switch":
    case "menuitemcheckbox":
    case "menuitemradio":
      return true;
    default:
      return false;
  }
}

export {
  ViewCollection,
  Template,
  View,
  iconview_default,
  ButtonLabelView,
  ButtonView
};
/*! Bundled license information:

@ckeditor/ckeditor5-ui/src/viewcollection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/template.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/view.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/icon/iconview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/buttonlabelview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-ui/src/button/buttonview.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-OWJNOFJW.js.map
