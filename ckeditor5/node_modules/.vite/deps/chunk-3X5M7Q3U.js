import {
  cloneDeepWith_default,
  isElement_default,
  isFunction_default,
  isObject_default,
  isPlainObject_default,
  isString_default,
  merge_default
} from "./chunk-K6UGUURS.js";

// node_modules/@ckeditor/ckeditor5-utils/src/dom/global.js
var globalVar;
try {
  globalVar = { window, document };
} catch (e) {
  globalVar = { window: {}, document: {} };
}
var global_default = globalVar;

// node_modules/@ckeditor/ckeditor5-utils/src/env.js
function getUserAgent() {
  try {
    return navigator.userAgent.toLowerCase();
  } catch (e) {
    return "";
  }
}
var userAgent = getUserAgent();
var env = {
  isMac: isMac(userAgent),
  isWindows: isWindows(userAgent),
  isGecko: isGecko(userAgent),
  isSafari: isSafari(userAgent),
  isiOS: isiOS(userAgent),
  isAndroid: isAndroid(userAgent),
  isBlink: isBlink(userAgent),
  get isMediaForcedColors() {
    return isMediaForcedColors();
  },
  get isMotionReduced() {
    return isMotionReduced();
  },
  features: {
    isRegExpUnicodePropertySupported: isRegExpUnicodePropertySupported()
  }
};
var env_default = env;
function isMac(userAgent2) {
  return userAgent2.indexOf("macintosh") > -1;
}
function isWindows(userAgent2) {
  return userAgent2.indexOf("windows") > -1;
}
function isGecko(userAgent2) {
  return !!userAgent2.match(/gecko\/\d+/);
}
function isSafari(userAgent2) {
  return userAgent2.indexOf(" applewebkit/") > -1 && userAgent2.indexOf("chrome") === -1;
}
function isiOS(userAgent2) {
  return !!userAgent2.match(/iphone|ipad/i) || isMac(userAgent2) && navigator.maxTouchPoints > 0;
}
function isAndroid(userAgent2) {
  return userAgent2.indexOf("android") > -1;
}
function isBlink(userAgent2) {
  return userAgent2.indexOf("chrome/") > -1 && userAgent2.indexOf("edge/") < 0;
}
function isRegExpUnicodePropertySupported() {
  let isSupported = false;
  try {
    isSupported = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
  } catch (error) {
  }
  return isSupported;
}
function isMediaForcedColors() {
  return global_default.window.matchMedia ? global_default.window.matchMedia("(forced-colors: active)").matches : false;
}
function isMotionReduced() {
  return global_default.window.matchMedia ? global_default.window.matchMedia("(prefers-reduced-motion)").matches : false;
}

// node_modules/@ckeditor/ckeditor5-utils/src/uid.js
var HEX_NUMBERS = new Array(256).fill("").map((_, index) => ("0" + index.toString(16)).slice(-2));
function uid() {
  const [r1, r2, r3, r4] = crypto.getRandomValues(new Uint32Array(4));
  return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
}

// node_modules/@ckeditor/ckeditor5-utils/src/ckeditorerror.js
var DOCUMENTATION_URL = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
var CKEditorError = class _CKEditorError extends Error {
  /**
   * Creates an instance of the CKEditorError class.
   *
   * @param errorName The error id in an `error-name` format. A link to this error documentation page will be added
   * to the thrown error's `message`.
   * @param context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
   * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
   * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
   * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
   * to check if the object works as the context.
   * @param data Additional data describing the error. A stringified version of this object
   * will be appended to the error message, so the data are quickly visible in the console. The original
   * data object will also be later available under the {@link #data} property.
   */
  constructor(errorName, context, data) {
    super(getErrorMessage(errorName, data));
    this.name = "CKEditorError";
    this.context = context;
    this.data = data;
  }
  /**
   * Checks if the error is of the `CKEditorError` type.
   */
  is(type) {
    return type === "CKEditorError";
  }
  /**
   * A utility that ensures that the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
   * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
   * of a {@link module:utils/ckeditorerror~CKEditorError} error.
   *
   * @param err The error to rethrow.
   * @param context An object connected through properties with the editor instance. This context will be used
   * by the watchdog to verify which editor should be restarted.
   */
  static rethrowUnexpectedError(err, context) {
    if (err.is && err.is("CKEditorError")) {
      throw err;
    }
    const error = new _CKEditorError(err.message, context);
    error.stack = err.stack;
    throw error;
  }
};
function logWarning(errorName, data) {
  console.warn(...formatConsoleArguments(errorName, data));
}
function logError(errorName, data) {
  console.error(...formatConsoleArguments(errorName, data));
}
function getLinkToDocumentationMessage(errorName) {
  return `
Read more: ${DOCUMENTATION_URL}#error-${errorName}`;
}
function getErrorMessage(errorName, data) {
  const processedObjects = /* @__PURE__ */ new WeakSet();
  const circularReferencesReplacer = (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (processedObjects.has(value)) {
        return `[object ${value.constructor.name}]`;
      }
      processedObjects.add(value);
    }
    return value;
  };
  const stringifiedData = data ? ` ${JSON.stringify(data, circularReferencesReplacer)}` : "";
  const documentationLink = getLinkToDocumentationMessage(errorName);
  return errorName + stringifiedData + documentationLink;
}
function formatConsoleArguments(errorName, data) {
  const documentationMessage = getLinkToDocumentationMessage(errorName);
  return data ? [errorName, data, documentationMessage] : [errorName, documentationMessage];
}

// node_modules/@ckeditor/ckeditor5-utils/src/spy.js
function spy() {
  return function spy2() {
    spy2.called = true;
  };
}
var spy_default = spy;

// node_modules/@ckeditor/ckeditor5-utils/src/eventinfo.js
var EventInfo = class {
  /**
   * @param source The emitter.
   * @param name The event name.
   */
  constructor(source, name) {
    this.source = source;
    this.name = name;
    this.path = [];
    this.stop = spy_default();
    this.off = spy_default();
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/priorities.js
var priorities = {
  get(priority = "normal") {
    if (typeof priority != "number") {
      return this[priority] || this.normal;
    } else {
      return priority;
    }
  },
  highest: 1e5,
  high: 1e3,
  normal: 0,
  low: -1e3,
  lowest: -1e5
};
var priorities_default = priorities;

// node_modules/@ckeditor/ckeditor5-utils/src/inserttopriorityarray.js
function insertToPriorityArray(objects, objectToInsert) {
  const priority = priorities_default.get(objectToInsert.priority);
  let left = 0;
  let right = objects.length;
  while (left < right) {
    const mid = left + right >> 1;
    const midPriority = priorities_default.get(objects[mid].priority);
    if (midPriority < priority) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }
  objects.splice(left, 0, objectToInsert);
}

// node_modules/@ckeditor/ckeditor5-utils/src/version.js
var version = "44.0.0";
var releaseDate = new Date(2024, 11, 2);
if (globalThis.CKEDITOR_VERSION) {
  throw new CKEditorError("ckeditor-duplicated-modules", null);
} else {
  globalThis.CKEDITOR_VERSION = version;
}

// node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js
var _listeningTo = Symbol("listeningTo");
var _emitterId = Symbol("emitterId");
var _delegations = Symbol("delegations");
var defaultEmitterClass = EmitterMixin(Object);
function EmitterMixin(base) {
  if (!base) {
    return defaultEmitterClass;
  }
  class Mixin extends base {
    on(event, callback, options) {
      this.listenTo(this, event, callback, options);
    }
    once(event, callback, options) {
      let wasFired = false;
      const onceCallback = (event2, ...args) => {
        if (!wasFired) {
          wasFired = true;
          event2.off();
          callback.call(this, event2, ...args);
        }
      };
      this.listenTo(this, event, onceCallback, options);
    }
    off(event, callback) {
      this.stopListening(this, event, callback);
    }
    listenTo(emitter, event, callback, options = {}) {
      let emitterInfo, eventCallbacks;
      if (!this[_listeningTo]) {
        this[_listeningTo] = {};
      }
      const emitters = this[_listeningTo];
      if (!_getEmitterId(emitter)) {
        _setEmitterId(emitter);
      }
      const emitterId = _getEmitterId(emitter);
      if (!(emitterInfo = emitters[emitterId])) {
        emitterInfo = emitters[emitterId] = {
          emitter,
          callbacks: {}
        };
      }
      if (!(eventCallbacks = emitterInfo.callbacks[event])) {
        eventCallbacks = emitterInfo.callbacks[event] = [];
      }
      eventCallbacks.push(callback);
      addEventListener(this, emitter, event, callback, options);
    }
    stopListening(emitter, event, callback) {
      const emitters = this[_listeningTo];
      let emitterId = emitter && _getEmitterId(emitter);
      const emitterInfo = emitters && emitterId ? emitters[emitterId] : void 0;
      const eventCallbacks = emitterInfo && event ? emitterInfo.callbacks[event] : void 0;
      if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
        return;
      }
      if (callback) {
        removeEventListener(this, emitter, event, callback);
        const index = eventCallbacks.indexOf(callback);
        if (index !== -1) {
          if (eventCallbacks.length === 1) {
            delete emitterInfo.callbacks[event];
          } else {
            removeEventListener(this, emitter, event, callback);
          }
        }
      } else if (eventCallbacks) {
        while (callback = eventCallbacks.pop()) {
          removeEventListener(this, emitter, event, callback);
        }
        delete emitterInfo.callbacks[event];
      } else if (emitterInfo) {
        for (event in emitterInfo.callbacks) {
          this.stopListening(emitter, event);
        }
        delete emitters[emitterId];
      } else {
        for (emitterId in emitters) {
          this.stopListening(emitters[emitterId].emitter);
        }
        delete this[_listeningTo];
      }
    }
    fire(eventOrInfo, ...args) {
      try {
        const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
        const event = eventInfo.name;
        let callbacks = getCallbacksForEvent(this, event);
        eventInfo.path.push(this);
        if (callbacks) {
          const callbackArgs = [eventInfo, ...args];
          callbacks = Array.from(callbacks);
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i].callback.apply(this, callbackArgs);
            if (eventInfo.off.called) {
              delete eventInfo.off.called;
              this._removeEventListener(event, callbacks[i].callback);
            }
            if (eventInfo.stop.called) {
              break;
            }
          }
        }
        const delegations = this[_delegations];
        if (delegations) {
          const destinations = delegations.get(event);
          const passAllDestinations = delegations.get("*");
          if (destinations) {
            fireDelegatedEvents(destinations, eventInfo, args);
          }
          if (passAllDestinations) {
            fireDelegatedEvents(passAllDestinations, eventInfo, args);
          }
        }
        return eventInfo.return;
      } catch (err) {
        CKEditorError.rethrowUnexpectedError(err, this);
      }
    }
    delegate(...events) {
      return {
        to: (emitter, nameOrFunction) => {
          if (!this[_delegations]) {
            this[_delegations] = /* @__PURE__ */ new Map();
          }
          events.forEach((eventName) => {
            const destinations = this[_delegations].get(eventName);
            if (!destinations) {
              this[_delegations].set(eventName, /* @__PURE__ */ new Map([[emitter, nameOrFunction]]));
            } else {
              destinations.set(emitter, nameOrFunction);
            }
          });
        }
      };
    }
    stopDelegating(event, emitter) {
      if (!this[_delegations]) {
        return;
      }
      if (!event) {
        this[_delegations].clear();
      } else if (!emitter) {
        this[_delegations].delete(event);
      } else {
        const destinations = this[_delegations].get(event);
        if (destinations) {
          destinations.delete(emitter);
        }
      }
    }
    _addEventListener(event, callback, options) {
      createEventNamespace(this, event);
      const lists = getCallbacksListsForNamespace(this, event);
      const priority = priorities_default.get(options.priority);
      const callbackDefinition = {
        callback,
        priority
      };
      for (const callbacks of lists) {
        insertToPriorityArray(callbacks, callbackDefinition);
      }
    }
    _removeEventListener(event, callback) {
      const lists = getCallbacksListsForNamespace(this, event);
      for (const callbacks of lists) {
        for (let i = 0; i < callbacks.length; i++) {
          if (callbacks[i].callback == callback) {
            callbacks.splice(i, 1);
            i--;
          }
        }
      }
    }
  }
  return Mixin;
}
[
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  EmitterMixin[key] = defaultEmitterClass.prototype[key];
});
function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {
  const listeningTo = listeningEmitter[_listeningTo];
  if (listeningTo && listeningTo[listenedToEmitterId]) {
    return listeningTo[listenedToEmitterId].emitter;
  }
  return null;
}
function _setEmitterId(emitter, id) {
  if (!emitter[_emitterId]) {
    emitter[_emitterId] = id || uid();
  }
}
function _getEmitterId(emitter) {
  return emitter[_emitterId];
}
function getEvents(source) {
  if (!source._events) {
    Object.defineProperty(source, "_events", {
      value: {}
    });
  }
  return source._events;
}
function makeEventNode() {
  return {
    callbacks: [],
    childEvents: []
  };
}
function createEventNamespace(source, eventName) {
  const events = getEvents(source);
  if (events[eventName]) {
    return;
  }
  let name = eventName;
  let childEventName = null;
  const newEventNodes = [];
  while (name !== "") {
    if (events[name]) {
      break;
    }
    events[name] = makeEventNode();
    newEventNodes.push(events[name]);
    if (childEventName) {
      events[name].childEvents.push(childEventName);
    }
    childEventName = name;
    name = name.substr(0, name.lastIndexOf(":"));
  }
  if (name !== "") {
    for (const node of newEventNodes) {
      node.callbacks = events[name].callbacks.slice();
    }
    events[name].childEvents.push(childEventName);
  }
}
function getCallbacksListsForNamespace(source, eventName) {
  const eventNode = getEvents(source)[eventName];
  if (!eventNode) {
    return [];
  }
  let callbacksLists = [eventNode.callbacks];
  for (let i = 0; i < eventNode.childEvents.length; i++) {
    const childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);
    callbacksLists = callbacksLists.concat(childCallbacksLists);
  }
  return callbacksLists;
}
function getCallbacksForEvent(source, eventName) {
  let event;
  if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {
    if (eventName.indexOf(":") > -1) {
      return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(":")));
    } else {
      return null;
    }
  }
  return event.callbacks;
}
function fireDelegatedEvents(destinations, eventInfo, fireArgs) {
  for (let [emitter, name] of destinations) {
    if (!name) {
      name = eventInfo.name;
    } else if (typeof name == "function") {
      name = name(eventInfo.name);
    }
    const delegatedInfo = new EventInfo(eventInfo.source, name);
    delegatedInfo.path = [...eventInfo.path];
    emitter.fire(delegatedInfo, ...fireArgs);
  }
}
function addEventListener(listener, emitter, event, callback, options) {
  if (emitter._addEventListener) {
    emitter._addEventListener(event, callback, options);
  } else {
    listener._addEventListener.call(emitter, event, callback, options);
  }
}
function removeEventListener(listener, emitter, event, callback) {
  if (emitter._removeEventListener) {
    emitter._removeEventListener(event, callback);
  } else {
    listener._removeEventListener.call(emitter, event, callback);
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/observablemixin.js
var observablePropertiesSymbol = Symbol("observableProperties");
var boundObservablesSymbol = Symbol("boundObservables");
var boundPropertiesSymbol = Symbol("boundProperties");
var decoratedMethods = Symbol("decoratedMethods");
var decoratedOriginal = Symbol("decoratedOriginal");
var defaultObservableClass = ObservableMixin(EmitterMixin());
function ObservableMixin(base) {
  if (!base) {
    return defaultObservableClass;
  }
  class Mixin extends base {
    set(name, value) {
      if (isObject_default(name)) {
        Object.keys(name).forEach((property) => {
          this.set(property, name[property]);
        }, this);
        return;
      }
      initObservable(this);
      const properties = this[observablePropertiesSymbol];
      if (name in this && !properties.has(name)) {
        throw new CKEditorError("observable-set-cannot-override", this);
      }
      Object.defineProperty(this, name, {
        enumerable: true,
        configurable: true,
        get() {
          return properties.get(name);
        },
        set(value2) {
          const oldValue = properties.get(name);
          let newValue = this.fire(`set:${name}`, name, value2, oldValue);
          if (newValue === void 0) {
            newValue = value2;
          }
          if (oldValue !== newValue || !properties.has(name)) {
            properties.set(name, newValue);
            this.fire(`change:${name}`, name, newValue, oldValue);
          }
        }
      });
      this[name] = value;
    }
    bind(...bindProperties) {
      if (!bindProperties.length || !isStringArray(bindProperties)) {
        throw new CKEditorError("observable-bind-wrong-properties", this);
      }
      if (new Set(bindProperties).size !== bindProperties.length) {
        throw new CKEditorError("observable-bind-duplicate-properties", this);
      }
      initObservable(this);
      const boundProperties = this[boundPropertiesSymbol];
      bindProperties.forEach((propertyName) => {
        if (boundProperties.has(propertyName)) {
          throw new CKEditorError("observable-bind-rebind", this);
        }
      });
      const bindings = /* @__PURE__ */ new Map();
      bindProperties.forEach((a) => {
        const binding = { property: a, to: [] };
        boundProperties.set(a, binding);
        bindings.set(a, binding);
      });
      return {
        to: bindTo,
        toMany: bindToMany,
        _observable: this,
        _bindProperties: bindProperties,
        _to: [],
        _bindings: bindings
      };
    }
    unbind(...unbindProperties) {
      if (!this[observablePropertiesSymbol]) {
        return;
      }
      const boundProperties = this[boundPropertiesSymbol];
      const boundObservables = this[boundObservablesSymbol];
      if (unbindProperties.length) {
        if (!isStringArray(unbindProperties)) {
          throw new CKEditorError("observable-unbind-wrong-properties", this);
        }
        unbindProperties.forEach((propertyName) => {
          const binding = boundProperties.get(propertyName);
          if (!binding) {
            return;
          }
          binding.to.forEach(([toObservable, toProperty]) => {
            const toProperties = boundObservables.get(toObservable);
            const toPropertyBindings = toProperties[toProperty];
            toPropertyBindings.delete(binding);
            if (!toPropertyBindings.size) {
              delete toProperties[toProperty];
            }
            if (!Object.keys(toProperties).length) {
              boundObservables.delete(toObservable);
              this.stopListening(toObservable, "change");
            }
          });
          boundProperties.delete(propertyName);
        });
      } else {
        boundObservables.forEach((bindings, boundObservable) => {
          this.stopListening(boundObservable, "change");
        });
        boundObservables.clear();
        boundProperties.clear();
      }
    }
    decorate(methodName) {
      initObservable(this);
      const originalMethod = this[methodName];
      if (!originalMethod) {
        throw new CKEditorError("observablemixin-cannot-decorate-undefined", this, { object: this, methodName });
      }
      this.on(methodName, (evt, args) => {
        evt.return = originalMethod.apply(this, args);
      });
      this[methodName] = function(...args) {
        return this.fire(methodName, args);
      };
      this[methodName][decoratedOriginal] = originalMethod;
      if (!this[decoratedMethods]) {
        this[decoratedMethods] = [];
      }
      this[decoratedMethods].push(methodName);
    }
    // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.
    // This is needed in case of:
    //  1. Have x.foo() decorated.
    //  2. Call x.stopListening()
    //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)
    stopListening(emitter, event, callback) {
      if (!emitter && this[decoratedMethods]) {
        for (const methodName of this[decoratedMethods]) {
          this[methodName] = this[methodName][decoratedOriginal];
        }
        delete this[decoratedMethods];
      }
      super.stopListening(emitter, event, callback);
    }
  }
  return Mixin;
}
[
  "set",
  "bind",
  "unbind",
  "decorate",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  ObservableMixin[key] = defaultObservableClass.prototype[key];
});
function initObservable(observable) {
  if (observable[observablePropertiesSymbol]) {
    return;
  }
  Object.defineProperty(observable, observablePropertiesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
  Object.defineProperty(observable, boundObservablesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
  Object.defineProperty(observable, boundPropertiesSymbol, {
    value: /* @__PURE__ */ new Map()
  });
}
function bindTo(...args) {
  const parsedArgs = parseBindToArgs(...args);
  const bindingsKeys = Array.from(this._bindings.keys());
  const numberOfBindings = bindingsKeys.length;
  if (!parsedArgs.callback && parsedArgs.to.length > 1) {
    throw new CKEditorError("observable-bind-to-no-callback", this);
  }
  if (numberOfBindings > 1 && parsedArgs.callback) {
    throw new CKEditorError("observable-bind-to-extra-callback", this);
  }
  parsedArgs.to.forEach((to) => {
    if (to.properties.length && to.properties.length !== numberOfBindings) {
      throw new CKEditorError("observable-bind-to-properties-length", this);
    }
    if (!to.properties.length) {
      to.properties = this._bindProperties;
    }
  });
  this._to = parsedArgs.to;
  if (parsedArgs.callback) {
    this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
  }
  attachBindToListeners(this._observable, this._to);
  updateBindToBound(this);
  this._bindProperties.forEach((propertyName) => {
    updateBoundObservableProperty(this._observable, propertyName);
  });
}
function bindToMany(observables, attribute, callback) {
  if (this._bindings.size > 1) {
    throw new CKEditorError("observable-bind-to-many-not-one-binding", this);
  }
  this.to(
    ...getBindingTargets(observables, attribute),
    // ...using given callback to parse attribute values.
    callback
  );
}
function getBindingTargets(observables, attribute) {
  const observableAndAttributePairs = observables.map((observable) => [observable, attribute]);
  return Array.prototype.concat.apply([], observableAndAttributePairs);
}
function isStringArray(arr) {
  return arr.every((a) => typeof a == "string");
}
function parseBindToArgs(...args) {
  if (!args.length) {
    throw new CKEditorError("observable-bind-to-parse-error", null);
  }
  const parsed = { to: [] };
  let lastObservable;
  if (typeof args[args.length - 1] == "function") {
    parsed.callback = args.pop();
  }
  args.forEach((a) => {
    if (typeof a == "string") {
      lastObservable.properties.push(a);
    } else if (typeof a == "object") {
      lastObservable = { observable: a, properties: [] };
      parsed.to.push(lastObservable);
    } else {
      throw new CKEditorError("observable-bind-to-parse-error", null);
    }
  });
  return parsed;
}
function updateBoundObservables(observable, binding, toObservable, toPropertyName) {
  const boundObservables = observable[boundObservablesSymbol];
  const bindingsToObservable = boundObservables.get(toObservable);
  const bindings = bindingsToObservable || {};
  if (!bindings[toPropertyName]) {
    bindings[toPropertyName] = /* @__PURE__ */ new Set();
  }
  bindings[toPropertyName].add(binding);
  if (!bindingsToObservable) {
    boundObservables.set(toObservable, bindings);
  }
}
function updateBindToBound(chain) {
  let toProperty;
  chain._bindings.forEach((binding, propertyName) => {
    chain._to.forEach((to) => {
      toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];
      binding.to.push([to.observable, toProperty]);
      updateBoundObservables(chain._observable, binding, to.observable, toProperty);
    });
  });
}
function updateBoundObservableProperty(observable, propertyName) {
  const boundProperties = observable[boundPropertiesSymbol];
  const binding = boundProperties.get(propertyName);
  let propertyValue;
  if (binding.callback) {
    propertyValue = binding.callback.apply(observable, binding.to.map((to) => to[0][to[1]]));
  } else {
    propertyValue = binding.to[0];
    propertyValue = propertyValue[0][propertyValue[1]];
  }
  if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {
    observable[propertyName] = propertyValue;
  } else {
    observable.set(propertyName, propertyValue);
  }
}
function attachBindToListeners(observable, toBindings) {
  toBindings.forEach((to) => {
    const boundObservables = observable[boundObservablesSymbol];
    let bindings;
    if (!boundObservables.get(to.observable)) {
      observable.listenTo(to.observable, "change", (evt, propertyName) => {
        bindings = boundObservables.get(to.observable)[propertyName];
        if (bindings) {
          bindings.forEach((binding) => {
            updateBoundObservableProperty(observable, binding.property);
          });
        }
      });
    }
  });
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getdatafromelement.js
function getDataFromElement(el) {
  if (el instanceof HTMLTextAreaElement) {
    return el.value;
  }
  return el.innerHTML;
}

// node_modules/@ckeditor/ckeditor5-utils/src/keyboard.js
var modifiersToGlyphsMac = {
  ctrl: "⌃",
  cmd: "⌘",
  alt: "⌥",
  shift: "⇧"
};
var modifiersToGlyphsNonMac = {
  ctrl: "Ctrl+",
  alt: "Alt+",
  shift: "Shift+"
};
var keyCodesToGlyphs = {
  37: "←",
  38: "↑",
  39: "→",
  40: "↓",
  9: "⇥",
  33: "Page Up",
  34: "Page Down"
};
var keyCodes = generateKnownKeyCodes();
var keyCodeNames = Object.fromEntries(
  Object.entries(keyCodes).map(([name, code]) => {
    let prettyKeyName;
    if (code in keyCodesToGlyphs) {
      prettyKeyName = keyCodesToGlyphs[code];
    } else {
      prettyKeyName = name.charAt(0).toUpperCase() + name.slice(1);
    }
    return [code, prettyKeyName];
  })
);
function getCode(key) {
  let keyCode;
  if (typeof key == "string") {
    keyCode = keyCodes[key.toLowerCase()];
    if (!keyCode) {
      throw new CKEditorError("keyboard-unknown-key", null, { key });
    }
  } else {
    keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0) + (key.metaKey ? keyCodes.cmd : 0);
  }
  return keyCode;
}
function parseKeystroke(keystroke) {
  if (typeof keystroke == "string") {
    keystroke = splitKeystrokeText(keystroke);
  }
  return keystroke.map((key) => typeof key == "string" ? getEnvKeyCode(key) : key).reduce((key, sum) => sum + key, 0);
}
function getEnvKeystrokeText(keystroke) {
  let keystrokeCode = parseKeystroke(keystroke);
  const modifiersToGlyphs = Object.entries(env_default.isMac || env_default.isiOS ? modifiersToGlyphsMac : modifiersToGlyphsNonMac);
  const modifiers = modifiersToGlyphs.reduce((modifiers2, [name, glyph]) => {
    if ((keystrokeCode & keyCodes[name]) != 0) {
      keystrokeCode &= ~keyCodes[name];
      modifiers2 += glyph;
    }
    return modifiers2;
  }, "");
  return modifiers + (keystrokeCode ? keyCodeNames[keystrokeCode] : "");
}
function isArrowKeyCode(keyCode) {
  return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;
}
function getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection) {
  const isLtrContent = contentLanguageDirection === "ltr";
  switch (keyCode) {
    case keyCodes.arrowleft:
      return isLtrContent ? "left" : "right";
    case keyCodes.arrowright:
      return isLtrContent ? "right" : "left";
    case keyCodes.arrowup:
      return "up";
    case keyCodes.arrowdown:
      return "down";
  }
}
function getEnvKeyCode(key) {
  if (key.endsWith("!")) {
    return getCode(key.slice(0, -1));
  }
  const code = getCode(key);
  return (env_default.isMac || env_default.isiOS) && code == keyCodes.ctrl ? keyCodes.cmd : code;
}
function isForwardArrowKeyCode(keyCode, contentLanguageDirection) {
  const localizedKeyCodeDirection = getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection);
  return localizedKeyCodeDirection === "down" || localizedKeyCodeDirection === "right";
}
function generateKnownKeyCodes() {
  const keyCodes2 = {
    pageup: 33,
    pagedown: 34,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    backspace: 8,
    delete: 46,
    enter: 13,
    space: 32,
    esc: 27,
    tab: 9,
    // The idea about these numbers is that they do not collide with any real key codes, so we can use them
    // like bit masks.
    ctrl: 1114112,
    shift: 2228224,
    alt: 4456448,
    cmd: 8912896
  };
  for (let code = 65; code <= 90; code++) {
    const letter = String.fromCharCode(code);
    keyCodes2[letter.toLowerCase()] = code;
  }
  for (let code = 48; code <= 57; code++) {
    keyCodes2[code - 48] = code;
  }
  for (let code = 112; code <= 123; code++) {
    keyCodes2["f" + (code - 111)] = code;
  }
  Object.assign(keyCodes2, {
    "'": 222,
    ",": 108,
    "-": 109,
    ".": 110,
    "/": 111,
    ";": 186,
    "=": 187,
    "[": 219,
    "\\": 220,
    "]": 221,
    "`": 223
  });
  return keyCodes2;
}
function splitKeystrokeText(keystroke) {
  return keystroke.split("+").map((key) => key.trim());
}

// node_modules/@ckeditor/ckeditor5-utils/src/delay.js
function delay(func, wait2) {
  let timer;
  function delayed(...args) {
    delayed.cancel();
    timer = setTimeout(() => func(...args), wait2);
  }
  delayed.cancel = () => {
    clearTimeout(timer);
  };
  return delayed;
}

// node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js
function fastDiff(a, b, cmp, atomicChanges) {
  cmp = cmp || function(a2, b2) {
    return a2 === b2;
  };
  const arrayA = Array.isArray(a) ? a : Array.prototype.slice.call(a);
  const arrayB = Array.isArray(b) ? b : Array.prototype.slice.call(b);
  const changeIndexes = findChangeBoundaryIndexes(arrayA, arrayB, cmp);
  const result = atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, arrayB.length) : changeIndexesToChanges(arrayB, changeIndexes);
  return result;
}
function findChangeBoundaryIndexes(arr1, arr2, cmp) {
  const firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp);
  if (firstIndex === -1) {
    return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
  }
  const oldArrayReversed = cutAndReverse(arr1, firstIndex);
  const newArrayReversed = cutAndReverse(arr2, firstIndex);
  const lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp);
  const lastIndexOld = arr1.length - lastIndex;
  const lastIndexNew = arr2.length - lastIndex;
  return { firstIndex, lastIndexOld, lastIndexNew };
}
function findFirstDifferenceIndex(arr1, arr2, cmp) {
  for (let i = 0; i < Math.max(arr1.length, arr2.length); i++) {
    if (arr1[i] === void 0 || arr2[i] === void 0 || !cmp(arr1[i], arr2[i])) {
      return i;
    }
  }
  return -1;
}
function cutAndReverse(arr, howMany) {
  return arr.slice(howMany).reverse();
}
function changeIndexesToChanges(newArray, changeIndexes) {
  const result = [];
  const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
  if (lastIndexNew - firstIndex > 0) {
    result.push({
      index: firstIndex,
      type: "insert",
      values: newArray.slice(firstIndex, lastIndexNew)
    });
  }
  if (lastIndexOld - firstIndex > 0) {
    result.push({
      index: firstIndex + (lastIndexNew - firstIndex),
      type: "delete",
      howMany: lastIndexOld - firstIndex
    });
  }
  return result;
}
function changeIndexesToAtomicChanges(changeIndexes, newLength) {
  const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
  if (firstIndex === -1) {
    return Array(newLength).fill("equal");
  }
  let result = [];
  if (firstIndex > 0) {
    result = result.concat(Array(firstIndex).fill("equal"));
  }
  if (lastIndexNew - firstIndex > 0) {
    result = result.concat(Array(lastIndexNew - firstIndex).fill("insert"));
  }
  if (lastIndexOld - firstIndex > 0) {
    result = result.concat(Array(lastIndexOld - firstIndex).fill("delete"));
  }
  if (lastIndexNew < newLength) {
    result = result.concat(Array(newLength - lastIndexNew).fill("equal"));
  }
  return result;
}

// node_modules/@ckeditor/ckeditor5-utils/src/diff.js
function diff(a, b, cmp) {
  cmp = cmp || function(a2, b2) {
    return a2 === b2;
  };
  const aLength = a.length;
  const bLength = b.length;
  if (aLength > 200 || bLength > 200 || aLength + bLength > 300) {
    return diff.fastDiff(a, b, cmp, true);
  }
  let _insert, _delete;
  if (bLength < aLength) {
    const tmp = a;
    a = b;
    b = tmp;
    _insert = "delete";
    _delete = "insert";
  } else {
    _insert = "insert";
    _delete = "delete";
  }
  const m = a.length;
  const n = b.length;
  const delta = n - m;
  const es = {};
  const fp = {};
  function snake(k2) {
    const y1 = (fp[k2 - 1] !== void 0 ? fp[k2 - 1] : -1) + 1;
    const y2 = fp[k2 + 1] !== void 0 ? fp[k2 + 1] : -1;
    const dir = y1 > y2 ? -1 : 1;
    if (es[k2 + dir]) {
      es[k2] = es[k2 + dir].slice(0);
    }
    if (!es[k2]) {
      es[k2] = [];
    }
    es[k2].push(y1 > y2 ? _insert : _delete);
    let y = Math.max(y1, y2);
    let x = y - k2;
    while (x < m && y < n && cmp(a[x], b[y])) {
      x++;
      y++;
      es[k2].push("equal");
    }
    return y;
  }
  let p = 0;
  let k;
  do {
    for (k = -p; k < delta; k++) {
      fp[k] = snake(k);
    }
    for (k = delta + p; k > delta; k--) {
      fp[k] = snake(k);
    }
    fp[delta] = snake(delta);
    p++;
  } while (fp[delta] !== n);
  return es[delta].slice(1);
}
diff.fastDiff = fastDiff;

// node_modules/@ckeditor/ckeditor5-utils/src/elementreplacer.js
var ElementReplacer = class {
  constructor() {
    this._replacedElements = [];
  }
  /**
   * Hides the `element` and, if specified, inserts the the given element next to it.
   *
   * The effect of this method can be reverted by {@link #restore}.
   *
   * @param element The element to replace.
   * @param newElement The replacement element. If not passed, then the `element` will just be hidden.
   */
  replace(element, newElement) {
    this._replacedElements.push({ element, newElement });
    element.style.display = "none";
    if (newElement) {
      element.parentNode.insertBefore(newElement, element.nextSibling);
    }
  }
  /**
   * Restores what {@link #replace} did.
   */
  restore() {
    this._replacedElements.forEach(({ element, newElement }) => {
      element.style.display = "";
      if (newElement) {
        newElement.remove();
      }
    });
    this._replacedElements = [];
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/count.js
function count(iterable) {
  let count2 = 0;
  for (const _ of iterable) {
    count2++;
  }
  return count2;
}

// node_modules/@ckeditor/ckeditor5-utils/src/comparearrays.js
function compareArrays(a, b) {
  const minLen = Math.min(a.length, b.length);
  for (let i = 0; i < minLen; i++) {
    if (a[i] != b[i]) {
      return i;
    }
  }
  if (a.length == b.length) {
    return "same";
  } else if (a.length < b.length) {
    return "prefix";
  } else {
    return "extension";
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/isiterable.js
function isIterable(value) {
  return !!(value && value[Symbol.iterator]);
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/createelement.js
function createElement(doc, name, attributes = {}, children = []) {
  const namespace = attributes && attributes.xmlns;
  const element = namespace ? doc.createElementNS(namespace, name) : doc.createElement(name);
  for (const key in attributes) {
    element.setAttribute(key, attributes[key]);
  }
  if (isString_default(children) || !isIterable(children)) {
    children = [children];
  }
  for (let child of children) {
    if (isString_default(child)) {
      child = doc.createTextNode(child);
    }
    element.appendChild(child);
  }
  return element;
}

// node_modules/@ckeditor/ckeditor5-utils/src/config.js
var Config = class {
  /**
   * Creates an instance of the {@link ~Config} class.
   *
   * @param configurations The initial configurations to be set. Usually, provided by the user.
   * @param defaultConfigurations The default configurations. Usually, provided by the system.
   */
  constructor(configurations, defaultConfigurations) {
    this._config = /* @__PURE__ */ Object.create(null);
    if (defaultConfigurations) {
      this.define(cloneConfig(defaultConfigurations));
    }
    if (configurations) {
      this._setObjectToTarget(this._config, configurations);
    }
  }
  set(name, value) {
    this._setToTarget(this._config, name, value);
  }
  define(name, value) {
    const isDefine = true;
    this._setToTarget(this._config, name, value, isDefine);
  }
  /**
   * Gets the value for a configuration entry.
   *
   * ```ts
   * config.get( 'name' );
   * ```
   *
   * Deep configurations can be retrieved by separating each part with a dot.
   *
   * ```ts
   * config.get( 'toolbar.collapsed' );
   * ```
   *
   * @param name The configuration name. Configuration names are case-sensitive.
   * @returns The configuration value or `undefined` if the configuration entry was not found.
   */
  get(name) {
    return this._getFromSource(this._config, name);
  }
  /**
   * Iterates over all top level configuration names.
   */
  *names() {
    for (const name of Object.keys(this._config)) {
      yield name;
    }
  }
  /**
   * Saves passed configuration to the specified target (nested object).
   *
   * @param target Nested config object.
   * @param name The configuration name or an object from which take properties as
   * configuration entries. Configuration names are case-sensitive.
   * @param value The configuration value. Used if a name is passed.
   * @param isDefine Define if passed configuration should overwrite existing one.
   */
  _setToTarget(target, name, value, isDefine = false) {
    if (isPlainObject_default(name)) {
      this._setObjectToTarget(target, name, isDefine);
      return;
    }
    const parts = name.split(".");
    name = parts.pop();
    for (const part of parts) {
      if (!isPlainObject_default(target[part])) {
        target[part] = /* @__PURE__ */ Object.create(null);
      }
      target = target[part];
    }
    if (isPlainObject_default(value)) {
      if (!isPlainObject_default(target[name])) {
        target[name] = /* @__PURE__ */ Object.create(null);
      }
      target = target[name];
      this._setObjectToTarget(target, value, isDefine);
      return;
    }
    if (isDefine && typeof target[name] != "undefined") {
      return;
    }
    target[name] = value;
  }
  /**
   * Get specified configuration from specified source (nested object).
   *
   * @param source level of nested object.
   * @param name The configuration name. Configuration names are case-sensitive.
   * @returns The configuration value or `undefined` if the configuration entry was not found.
   */
  _getFromSource(source, name) {
    const parts = name.split(".");
    name = parts.pop();
    for (const part of parts) {
      if (!isPlainObject_default(source[part])) {
        source = null;
        break;
      }
      source = source[part];
    }
    return source ? cloneConfig(source[name]) : void 0;
  }
  /**
   * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
   *
   * @param target Nested config object.
   * @param configuration Configuration data set
   * @param isDefine Defines if passed configuration is default configuration or not.
   */
  _setObjectToTarget(target, configuration, isDefine) {
    Object.keys(configuration).forEach((key) => {
      this._setToTarget(target, key, configuration[key], isDefine);
    });
  }
};
function cloneConfig(source) {
  return cloneDeepWith_default(source, leaveItemReferences);
}
function leaveItemReferences(value) {
  return isElement_default(value) || typeof value === "function" ? value : void 0;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isnode.js
function isNode(obj) {
  if (obj) {
    if (obj.defaultView) {
      return obj instanceof obj.defaultView.Document;
    } else if (obj.ownerDocument && obj.ownerDocument.defaultView) {
      return obj instanceof obj.ownerDocument.defaultView.Node;
    }
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/iswindow.js
function isWindow(obj) {
  const stringifiedObject = Object.prototype.toString.apply(obj);
  if (stringifiedObject == "[object Window]") {
    return true;
  }
  if (stringifiedObject == "[object global]") {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/emittermixin.js
var defaultEmitterClass2 = DomEmitterMixin(EmitterMixin());
function DomEmitterMixin(base) {
  if (!base) {
    return defaultEmitterClass2;
  }
  class Mixin extends base {
    listenTo(emitter, event, callback, options = {}) {
      if (isNode(emitter) || isWindow(emitter)) {
        const proxyOptions = {
          capture: !!options.useCapture,
          passive: !!options.usePassive
        };
        const proxyEmitter = this._getProxyEmitter(emitter, proxyOptions) || new ProxyEmitter(emitter, proxyOptions);
        this.listenTo(proxyEmitter, event, callback, options);
      } else {
        super.listenTo(emitter, event, callback, options);
      }
    }
    stopListening(emitter, event, callback) {
      if (isNode(emitter) || isWindow(emitter)) {
        const proxyEmitters = this._getAllProxyEmitters(emitter);
        for (const proxy of proxyEmitters) {
          this.stopListening(proxy, event, callback);
        }
      } else {
        super.stopListening(emitter, event, callback);
      }
    }
    /**
     * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.
     *
     * @param node DOM Node of the ProxyEmitter.
     * @param options Additional options.
     * @param options.useCapture Indicates that events of this type will be dispatched to the registered
     * listener before being dispatched to any EventTarget beneath it in the DOM tree.
     * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
     * and prevents blocking browser's main thread by this event handler.
     * @returns ProxyEmitter instance bound to the DOM Node.
     */
    _getProxyEmitter(node, options) {
      return _getEmitterListenedTo(this, getProxyEmitterId(node, options));
    }
    /**
     * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.
     *
     * @param node DOM Node of the ProxyEmitter.
     */
    _getAllProxyEmitters(node) {
      return [
        { capture: false, passive: false },
        { capture: false, passive: true },
        { capture: true, passive: false },
        { capture: true, passive: true }
      ].map((options) => this._getProxyEmitter(node, options)).filter((proxy) => !!proxy);
    }
  }
  return Mixin;
}
[
  "_getProxyEmitter",
  "_getAllProxyEmitters",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  DomEmitterMixin[key] = defaultEmitterClass2.prototype[key];
});
var ProxyEmitter = class extends EmitterMixin() {
  /**
   * @param node DOM Node that fires events.
   * @param options Additional options.
   * @param options.useCapture Indicates that events of this type will be dispatched to the registered
   * listener before being dispatched to any EventTarget beneath it in the DOM tree.
   * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
   * and prevents blocking browser's main thread by this event handler.
   */
  constructor(node, options) {
    super();
    _setEmitterId(this, getProxyEmitterId(node, options));
    this._domNode = node;
    this._options = options;
  }
  /**
   * Registers a callback function to be executed when an event is fired.
   *
   * It attaches a native DOM listener to the DOM Node. When fired,
   * a corresponding Emitter event will also fire with DOM Event object as an argument.
   *
   * **Note**: This is automatically called by the
   * {@link module:utils/emittermixin~Emitter#listenTo `Emitter#listenTo()`}.
   *
   * @param event The name of the event.
   */
  attach(event) {
    if (this._domListeners && this._domListeners[event]) {
      return;
    }
    const domListener = this._createDomListener(event);
    this._domNode.addEventListener(event, domListener, this._options);
    if (!this._domListeners) {
      this._domListeners = {};
    }
    this._domListeners[event] = domListener;
  }
  /**
   * Stops executing the callback on the given event.
   *
   * **Note**: This is automatically called by the
   * {@link module:utils/emittermixin~Emitter#stopListening `Emitter#stopListening()`}.
   *
   * @param event The name of the event.
   */
  detach(event) {
    let events;
    if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {
      this._domListeners[event].removeListener();
    }
  }
  /**
   * Adds callback to emitter for given event.
   *
   * @internal
   * @param event The name of the event.
   * @param callback The function to be called on event.
   * @param options Additional options.
   */
  _addEventListener(event, callback, options) {
    this.attach(event);
    EmitterMixin().prototype._addEventListener.call(this, event, callback, options);
  }
  /**
   * Removes callback from emitter for given event.
   *
   * @internal
   * @param event The name of the event.
   * @param callback The function to stop being called.
   */
  _removeEventListener(event, callback) {
    EmitterMixin().prototype._removeEventListener.call(this, event, callback);
    this.detach(event);
  }
  /**
   * Creates a native DOM listener callback. When the native DOM event
   * is fired it will fire corresponding event on this ProxyEmitter.
   * Note: A native DOM Event is passed as an argument.
   *
   * @param event The name of the event.
   * @returns The DOM listener callback.
   */
  _createDomListener(event) {
    const domListener = (domEvt) => {
      this.fire(event, domEvt);
    };
    domListener.removeListener = () => {
      this._domNode.removeEventListener(event, domListener, this._options);
      delete this._domListeners[event];
    };
    return domListener;
  }
};
function getNodeUID(node) {
  return node["data-ck-expando"] || (node["data-ck-expando"] = uid());
}
function getProxyEmitterId(node, options) {
  let id = getNodeUID(node);
  for (const option of Object.keys(options).sort()) {
    if (options[option]) {
      id += "-" + option;
    }
  }
  return id;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getancestors.js
function getAncestors(node) {
  const nodes = [];
  let currentNode = node;
  while (currentNode && currentNode.nodeType != Node.DOCUMENT_NODE) {
    nodes.unshift(currentNode);
    currentNode = currentNode.parentNode;
  }
  return nodes;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getborderwidths.js
function getBorderWidths(element) {
  const style = element.ownerDocument.defaultView.getComputedStyle(element);
  return {
    top: parseInt(style.borderTopWidth, 10),
    right: parseInt(style.borderRightWidth, 10),
    bottom: parseInt(style.borderBottomWidth, 10),
    left: parseInt(style.borderLeftWidth, 10)
  };
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getrangefrommouseevent.js
function getRangeFromMouseEvent(domEvent) {
  if (!domEvent.target) {
    return null;
  }
  const domDoc = domEvent.target.ownerDocument;
  const x = domEvent.clientX;
  const y = domEvent.clientY;
  let domRange = null;
  if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {
    domRange = domDoc.caretRangeFromPoint(x, y);
  } else if (domEvent.rangeParent) {
    domRange = domDoc.createRange();
    domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);
    domRange.collapse(true);
  }
  return domRange;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/istext.js
function isText(obj) {
  return Object.prototype.toString.call(obj) == "[object Text]";
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isrange.js
function isRange(obj) {
  return Object.prototype.toString.apply(obj) == "[object Range]";
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getpositionedancestor.js
function getPositionedAncestor(element) {
  if (!element || !element.parentNode) {
    return null;
  }
  if (element.offsetParent === global_default.document.body) {
    return null;
  }
  return element.offsetParent;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/rect.js
var rectProperties = ["top", "right", "bottom", "left", "width", "height"];
var Rect = class _Rect {
  /**
   * Creates an instance of rect.
   *
   * ```ts
   * // Rect of an HTMLElement.
   * const rectA = new Rect( document.body );
   *
   * // Rect of a DOM Range.
   * const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
   *
   * // Rect of a window (web browser viewport).
   * const rectC = new Rect( window );
   *
   * // Rect out of an object.
   * const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
   *
   * // Rect out of another Rect instance.
   * const rectE = new Rect( rectD );
   *
   * // Rect out of a ClientRect.
   * const rectF = new Rect( document.body.getClientRects().item( 0 ) );
   * ```
   *
   * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
   * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
   * to get the inner part of the rect.
   *
   * @param source A source object to create the rect.
   */
  constructor(source) {
    const isSourceRange = isRange(source);
    Object.defineProperty(this, "_source", {
      // If the source is a Rect instance, copy it's #_source.
      value: source._source || source,
      writable: true,
      enumerable: false
    });
    if (isDomElement(source) || isSourceRange) {
      if (isSourceRange) {
        const rangeRects = _Rect.getDomRangeRects(source);
        copyRectProperties(this, _Rect.getBoundingRect(rangeRects));
      } else {
        copyRectProperties(this, source.getBoundingClientRect());
      }
    } else if (isWindow(source)) {
      const { innerWidth, innerHeight } = source;
      copyRectProperties(this, {
        top: 0,
        right: innerWidth,
        bottom: innerHeight,
        left: 0,
        width: innerWidth,
        height: innerHeight
      });
    } else {
      copyRectProperties(this, source);
    }
  }
  /**
   * Returns a clone of the rect.
   *
   * @returns A cloned rect.
   */
  clone() {
    return new _Rect(this);
  }
  /**
   * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.
   *
   * @param x Desired horizontal location.
   * @param y Desired vertical location.
   * @returns A rect which has been moved.
   */
  moveTo(x, y) {
    this.top = y;
    this.right = x + this.width;
    this.bottom = y + this.height;
    this.left = x;
    return this;
  }
  /**
   * Moves the rect in–place by a dedicated offset.
   *
   * @param x A horizontal offset.
   * @param y A vertical offset
   * @returns A rect which has been moved.
   */
  moveBy(x, y) {
    this.top += y;
    this.right += x;
    this.left += x;
    this.bottom += y;
    return this;
  }
  /**
   * Returns a new rect a a result of intersection with another rect.
   */
  getIntersection(anotherRect) {
    const rect = {
      top: Math.max(this.top, anotherRect.top),
      right: Math.min(this.right, anotherRect.right),
      bottom: Math.min(this.bottom, anotherRect.bottom),
      left: Math.max(this.left, anotherRect.left),
      width: 0,
      height: 0
    };
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    if (rect.width < 0 || rect.height < 0) {
      return null;
    } else {
      const newRect = new _Rect(rect);
      newRect._source = this._source;
      return newRect;
    }
  }
  /**
   * Returns the area of intersection with another rect.
   *
   * @returns Area of intersection.
   */
  getIntersectionArea(anotherRect) {
    const rect = this.getIntersection(anotherRect);
    if (rect) {
      return rect.getArea();
    } else {
      return 0;
    }
  }
  /**
   * Returns the area of the rect.
   */
  getArea() {
    return this.width * this.height;
  }
  /**
   * Returns a new rect, a part of the original rect, which is actually visible to the user and is relative to the,`body`,
   * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
   * other than `"visible"`.
   *
   * If there's no such visible rect, which is when the rect is limited by one or many of
   * the ancestors, `null` is returned.
   *
   * **Note**: This method does not consider the boundaries of the viewport (window).
   * To get a rect cropped by all ancestors and the viewport, use an intersection such as:
   *
   * ```ts
   * const visibleInViewportRect = new Rect( window ).getIntersection( new Rect( source ).getVisible() );
   * ```
   *
   * @returns A visible rect instance or `null`, if there's none.
   */
  getVisible() {
    const source = this._source;
    let visibleRect = this.clone();
    if (isBody(source)) {
      return visibleRect;
    }
    let child = source;
    let parent = source.parentNode || source.commonAncestorContainer;
    let absolutelyPositionedChildElement;
    while (parent && !isBody(parent)) {
      const isParentOverflowVisible = getElementOverflow(parent) === "visible";
      if (child instanceof HTMLElement && getElementPosition(child) === "absolute") {
        absolutelyPositionedChildElement = child;
      }
      const parentElementPosition = getElementPosition(parent);
      if (isParentOverflowVisible || absolutelyPositionedChildElement && (parentElementPosition === "relative" && isParentOverflowVisible || parentElementPosition !== "relative")) {
        child = parent;
        parent = parent.parentNode;
        continue;
      }
      const parentRect = new _Rect(parent);
      const intersectionRect = visibleRect.getIntersection(parentRect);
      if (intersectionRect) {
        if (intersectionRect.getArea() < visibleRect.getArea()) {
          visibleRect = intersectionRect;
        }
      } else {
        return null;
      }
      child = parent;
      parent = parent.parentNode;
    }
    return visibleRect;
  }
  /**
   * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
   * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
   * instances.
   *
   * @param anotherRect A rect instance to compare with.
   * @returns `true` when Rects are equal. `false` otherwise.
   */
  isEqual(anotherRect) {
    for (const prop of rectProperties) {
      if (this[prop] !== anotherRect[prop]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks whether a rect fully contains another rect instance.
   *
   * @param anotherRect
   * @returns `true` if contains, `false` otherwise.
   */
  contains(anotherRect) {
    const intersectRect = this.getIntersection(anotherRect);
    return !!(intersectRect && intersectRect.isEqual(anotherRect));
  }
  /**
   * Recalculates screen coordinates to coordinates relative to the positioned ancestor offset.
   */
  toAbsoluteRect() {
    const { scrollX, scrollY } = global_default.window;
    const absoluteRect = this.clone().moveBy(scrollX, scrollY);
    if (isDomElement(absoluteRect._source)) {
      const positionedAncestor = getPositionedAncestor(absoluteRect._source);
      if (positionedAncestor) {
        shiftRectToCompensatePositionedAncestor(absoluteRect, positionedAncestor);
      }
    }
    return absoluteRect;
  }
  /**
   * Excludes scrollbars and CSS borders from the rect.
   *
   * * Borders are removed when {@link #_source} is an HTML element.
   * * Scrollbars are excluded from HTML elements and the `window`.
   *
   * @returns A rect which has been updated.
   */
  excludeScrollbarsAndBorders() {
    const source = this._source;
    let scrollBarWidth, scrollBarHeight, direction;
    if (isWindow(source)) {
      scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;
      scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;
      direction = source.getComputedStyle(source.document.documentElement).direction;
    } else {
      const borderWidths = getBorderWidths(source);
      scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;
      scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;
      direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;
      this.left += borderWidths.left;
      this.top += borderWidths.top;
      this.right -= borderWidths.right;
      this.bottom -= borderWidths.bottom;
      this.width = this.right - this.left;
      this.height = this.bottom - this.top;
    }
    this.width -= scrollBarWidth;
    if (direction === "ltr") {
      this.right -= scrollBarWidth;
    } else {
      this.left += scrollBarWidth;
    }
    this.height -= scrollBarHeight;
    this.bottom -= scrollBarHeight;
    return this;
  }
  /**
   * Returns an array of rects of the given native DOM Range.
   *
   * @param range A native DOM range.
   * @returns DOM Range rects.
   */
  static getDomRangeRects(range) {
    const rects = [];
    const clientRects = Array.from(range.getClientRects());
    if (clientRects.length) {
      for (const rect of clientRects) {
        rects.push(new _Rect(rect));
      }
    } else {
      let startContainer = range.startContainer;
      if (isText(startContainer)) {
        startContainer = startContainer.parentNode;
      }
      const rect = new _Rect(startContainer.getBoundingClientRect());
      rect.right = rect.left;
      rect.width = 0;
      rects.push(rect);
    }
    return rects;
  }
  /**
   * Returns a bounding rectangle that contains all the given `rects`.
   *
   * @param rects A list of rectangles that should be contained in the result rectangle.
   * @returns Bounding rectangle or `null` if no `rects` were given.
   */
  static getBoundingRect(rects) {
    const boundingRectData = {
      left: Number.POSITIVE_INFINITY,
      top: Number.POSITIVE_INFINITY,
      right: Number.NEGATIVE_INFINITY,
      bottom: Number.NEGATIVE_INFINITY,
      width: 0,
      height: 0
    };
    let rectangleCount = 0;
    for (const rect of rects) {
      rectangleCount++;
      boundingRectData.left = Math.min(boundingRectData.left, rect.left);
      boundingRectData.top = Math.min(boundingRectData.top, rect.top);
      boundingRectData.right = Math.max(boundingRectData.right, rect.right);
      boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);
    }
    if (rectangleCount == 0) {
      return null;
    }
    boundingRectData.width = boundingRectData.right - boundingRectData.left;
    boundingRectData.height = boundingRectData.bottom - boundingRectData.top;
    return new _Rect(boundingRectData);
  }
};
function copyRectProperties(rect, source) {
  for (const p of rectProperties) {
    rect[p] = source[p];
  }
}
function isBody(value) {
  if (!isDomElement(value)) {
    return false;
  }
  return value === value.ownerDocument.body;
}
function isDomElement(value) {
  return value !== null && typeof value === "object" && value.nodeType === 1 && typeof value.getBoundingClientRect === "function";
}
function getElementPosition(element) {
  return element instanceof HTMLElement ? element.ownerDocument.defaultView.getComputedStyle(element).position : "static";
}
function getElementOverflow(element) {
  return element instanceof HTMLElement ? element.ownerDocument.defaultView.getComputedStyle(element).overflow : "visible";
}
function shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {
  const ancestorPosition = new Rect(positionedElementAncestor);
  const ancestorBorderWidths = getBorderWidths(positionedElementAncestor);
  let moveX = 0;
  let moveY = 0;
  moveX -= ancestorPosition.left;
  moveY -= ancestorPosition.top;
  moveX += positionedElementAncestor.scrollLeft;
  moveY += positionedElementAncestor.scrollTop;
  moveX -= ancestorBorderWidths.left;
  moveY -= ancestorBorderWidths.top;
  rect.moveBy(moveX, moveY);
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/resizeobserver.js
var ResizeObserver = class _ResizeObserver {
  /**
   * Creates an instance of the `ResizeObserver` class.
   *
   * @param element A DOM element that is to be observed for resizing. Note that
   * the element must be visible (i.e. not detached from DOM) for the observer to work.
   * @param callback A function called when the observed element was resized. It passes
   * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
   * object with information about the resize event.
   */
  constructor(element, callback) {
    if (!_ResizeObserver._observerInstance) {
      _ResizeObserver._createObserver();
    }
    this._element = element;
    this._callback = callback;
    _ResizeObserver._addElementCallback(element, callback);
    _ResizeObserver._observerInstance.observe(element);
  }
  /**
   * The element observed by this observer.
   */
  get element() {
    return this._element;
  }
  /**
   * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
   */
  destroy() {
    _ResizeObserver._deleteElementCallback(this._element, this._callback);
  }
  /**
   * Registers a new resize callback for the DOM element.
   */
  static _addElementCallback(element, callback) {
    if (!_ResizeObserver._elementCallbacks) {
      _ResizeObserver._elementCallbacks = /* @__PURE__ */ new Map();
    }
    let callbacks = _ResizeObserver._elementCallbacks.get(element);
    if (!callbacks) {
      callbacks = /* @__PURE__ */ new Set();
      _ResizeObserver._elementCallbacks.set(element, callbacks);
    }
    callbacks.add(callback);
  }
  /**
   * Removes a resize callback from the DOM element. If no callbacks are left
   * for the element, it removes the element from the native observer.
   */
  static _deleteElementCallback(element, callback) {
    const callbacks = _ResizeObserver._getElementCallbacks(element);
    if (callbacks) {
      callbacks.delete(callback);
      if (!callbacks.size) {
        _ResizeObserver._elementCallbacks.delete(element);
        _ResizeObserver._observerInstance.unobserve(element);
      }
    }
    if (_ResizeObserver._elementCallbacks && !_ResizeObserver._elementCallbacks.size) {
      _ResizeObserver._observerInstance = null;
      _ResizeObserver._elementCallbacks = null;
    }
  }
  /**
   * Returns are registered resize callbacks for the DOM element.
   */
  static _getElementCallbacks(element) {
    if (!_ResizeObserver._elementCallbacks) {
      return null;
    }
    return _ResizeObserver._elementCallbacks.get(element);
  }
  /**
   * Creates the single native observer shared across all `ResizeObserver` instances.
   */
  static _createObserver() {
    _ResizeObserver._observerInstance = new global_default.window.ResizeObserver((entries) => {
      for (const entry of entries) {
        const callbacks = _ResizeObserver._getElementCallbacks(entry.target);
        if (callbacks) {
          for (const callback of callbacks) {
            callback(entry);
          }
        }
      }
    });
  }
};
ResizeObserver._observerInstance = null;
ResizeObserver._elementCallbacks = null;
var resizeobserver_default = ResizeObserver;

// node_modules/@ckeditor/ckeditor5-utils/src/dom/setdatainelement.js
function setDataInElement(el, data) {
  if (el instanceof HTMLTextAreaElement) {
    el.value = data;
  }
  el.innerHTML = data;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/tounit.js
function toUnit(unit) {
  return (value) => value + unit;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/indexof.js
function indexOf(node) {
  let index = 0;
  while (node.previousSibling) {
    node = node.previousSibling;
    index++;
  }
  return index;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/insertat.js
function insertAt(parentElement, index, nodeToInsert) {
  parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index] || null);
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/iscomment.js
function isComment(obj) {
  return obj && obj.nodeType === Node.COMMENT_NODE;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isvalidattributename.js
function isValidAttributeName(name) {
  try {
    global_default.document.createAttribute(name);
  } catch (error) {
    return false;
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isvisible.js
function isVisible(element) {
  if (!element) {
    return false;
  }
  if (isText(element)) {
    return isVisible(element.parentElement);
  }
  if (element.getClientRects) {
    return !!element.getClientRects().length;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/position.js
function getOptimalPosition({ element, target, positions, limiter, fitInViewport, viewportOffsetConfig }) {
  if (isFunction_default(target)) {
    target = target();
  }
  if (isFunction_default(limiter)) {
    limiter = limiter();
  }
  const positionedElementAncestor = getPositionedAncestor(element);
  const constrainedViewportRect = getConstrainedViewportRect(viewportOffsetConfig);
  const elementRect = new Rect(element);
  const visibleTargetRect = getVisibleViewportIntersectionRect(target, constrainedViewportRect);
  let bestPosition;
  if (!visibleTargetRect || !constrainedViewportRect.getIntersection(visibleTargetRect)) {
    return null;
  }
  const positionOptions = {
    targetRect: visibleTargetRect,
    elementRect,
    positionedElementAncestor,
    viewportRect: constrainedViewportRect
  };
  if (!limiter && !fitInViewport) {
    bestPosition = new PositionObject(positions[0], positionOptions);
  } else {
    if (limiter) {
      const visibleLimiterRect = getVisibleViewportIntersectionRect(limiter, constrainedViewportRect);
      if (visibleLimiterRect) {
        positionOptions.limiterRect = visibleLimiterRect;
      }
    }
    bestPosition = getBestPosition(positions, positionOptions);
  }
  return bestPosition;
}
function getVisibleViewportIntersectionRect(source, viewportRect) {
  const visibleSourceRect = new Rect(source).getVisible();
  if (!visibleSourceRect) {
    return null;
  }
  return visibleSourceRect.getIntersection(viewportRect);
}
function getConstrainedViewportRect(viewportOffsetConfig) {
  viewportOffsetConfig = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, viewportOffsetConfig);
  const viewportRect = new Rect(global_default.window);
  viewportRect.top += viewportOffsetConfig.top;
  viewportRect.height -= viewportOffsetConfig.top;
  viewportRect.bottom -= viewportOffsetConfig.bottom;
  viewportRect.height -= viewportOffsetConfig.bottom;
  return viewportRect;
}
function getBestPosition(positions, options) {
  const { elementRect } = options;
  const elementRectArea = elementRect.getArea();
  const positionInstances = positions.map((positioningFunction) => new PositionObject(positioningFunction, options)).filter((position) => !!position.name);
  let maxFitFactor = 0;
  let bestPosition = null;
  for (const position of positionInstances) {
    const { limiterIntersectionArea, viewportIntersectionArea } = position;
    if (limiterIntersectionArea === elementRectArea) {
      return position;
    }
    const fitFactor = viewportIntersectionArea ** 2 + limiterIntersectionArea ** 2;
    if (fitFactor > maxFitFactor) {
      maxFitFactor = fitFactor;
      bestPosition = position;
    }
  }
  return bestPosition;
}
var PositionObject = class {
  /**
   * Creates an instance of the {@link module:utils/dom/position~PositionObject} class.
   *
   * @param positioningFunction function The function that defines the expected
   * coordinates the positioned element should move to.
   * @param options options object.
   * @param options.elementRect The positioned element rect.
   * @param options.targetRect The target element rect.
   * @param options.viewportRect The viewport rect.
   * @param options.limiterRect The limiter rect.
   * @param options.positionedElementAncestor Nearest element ancestor element which CSS position is not "static".
   */
  constructor(positioningFunction, options) {
    const positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect, options.limiterRect);
    if (!positioningFunctionOutput) {
      return;
    }
    const { left, top, name, config } = positioningFunctionOutput;
    this.name = name;
    this.config = config;
    this._positioningFunctionCoordinates = { left, top };
    this._options = options;
  }
  /**
   * The left value in pixels in the CSS `position: absolute` coordinate system.
   * Set it on the positioned element in DOM to move it to the position.
   */
  get left() {
    return this._absoluteRect.left;
  }
  /**
   * The top value in pixels in the CSS `position: absolute` coordinate system.
   * Set it on the positioned element in DOM to move it to the position.
   */
  get top() {
    return this._absoluteRect.top;
  }
  /**
   * An intersection area between positioned element and limiter within viewport constraints.
   */
  get limiterIntersectionArea() {
    const limiterRect = this._options.limiterRect;
    if (limiterRect) {
      return limiterRect.getIntersectionArea(this._rect);
    }
    return 0;
  }
  /**
   * An intersection area between positioned element and viewport.
   */
  get viewportIntersectionArea() {
    const viewportRect = this._options.viewportRect;
    return viewportRect.getIntersectionArea(this._rect);
  }
  /**
   * An already positioned element rect. A clone of the element rect passed to the constructor
   * but placed in the viewport according to the positioning function.
   */
  get _rect() {
    if (this._cachedRect) {
      return this._cachedRect;
    }
    this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top);
    return this._cachedRect;
  }
  /**
   * An already absolutely positioned element rect. See ({@link #_rect}).
   */
  get _absoluteRect() {
    if (this._cachedAbsoluteRect) {
      return this._cachedAbsoluteRect;
    }
    this._cachedAbsoluteRect = this._rect.toAbsoluteRect();
    return this._cachedAbsoluteRect;
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/dom/remove.js
function remove(node) {
  const parent = node.parentNode;
  if (parent) {
    parent.removeChild(node);
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js
function scrollViewportToShowTarget({ target, viewportOffset = 0, ancestorOffset = 0, alignToTop, forceScroll }) {
  const targetWindow = getWindow(target);
  let currentWindow = targetWindow;
  let currentFrame = null;
  viewportOffset = normalizeViewportOffset(viewportOffset);
  while (currentWindow) {
    let firstAncestorToScroll;
    if (currentWindow == targetWindow) {
      firstAncestorToScroll = getParentElement(target);
    } else {
      firstAncestorToScroll = getParentElement(currentFrame);
    }
    scrollAncestorsToShowRect({
      parent: firstAncestorToScroll,
      getRect: () => {
        return getRectRelativeToWindow(target, currentWindow);
      },
      alignToTop,
      ancestorOffset,
      forceScroll
    });
    let targetRect = getRectRelativeToWindow(target, currentWindow);
    const ancestorWindowRelativeRect = getRectRelativeToWindow(firstAncestorToScroll, currentWindow);
    if (targetRect.height > ancestorWindowRelativeRect.height) {
      const ancestorTargetIntersection = targetRect.getIntersection(ancestorWindowRelativeRect);
      if (ancestorTargetIntersection) {
        targetRect = ancestorTargetIntersection;
      }
    }
    scrollWindowToShowRect({
      window: currentWindow,
      rect: targetRect,
      viewportOffset,
      alignToTop,
      forceScroll
    });
    if (currentWindow.parent != currentWindow) {
      currentFrame = currentWindow.frameElement;
      currentWindow = currentWindow.parent;
      if (!currentFrame) {
        return;
      }
    } else {
      currentWindow = null;
    }
  }
}
function scrollWindowToShowRect({ window: window2, rect, alignToTop, forceScroll, viewportOffset }) {
  const targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset.bottom);
  const targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset.top);
  const viewportRect = new Rect(window2).excludeScrollbarsAndBorders();
  const rects = [targetShiftedUpRect, targetShiftedDownRect];
  const forceScrollToTop = alignToTop && forceScroll;
  const allRectsFitInViewport = rects.every((rect2) => viewportRect.contains(rect2));
  let { scrollX, scrollY } = window2;
  const initialScrollX = scrollX;
  const initialScrollY = scrollY;
  if (forceScrollToTop) {
    scrollY -= viewportRect.top - rect.top + viewportOffset.top;
  } else if (!allRectsFitInViewport) {
    if (isAbove(targetShiftedUpRect, viewportRect)) {
      scrollY -= viewportRect.top - rect.top + viewportOffset.top;
    } else if (isBelow(targetShiftedDownRect, viewportRect)) {
      if (alignToTop) {
        scrollY += rect.top - viewportRect.top - viewportOffset.top;
      } else {
        scrollY += rect.bottom - viewportRect.bottom + viewportOffset.bottom;
      }
    }
  }
  if (!allRectsFitInViewport) {
    if (isLeftOf(rect, viewportRect)) {
      scrollX -= viewportRect.left - rect.left + viewportOffset.left;
    } else if (isRightOf(rect, viewportRect)) {
      scrollX += rect.right - viewportRect.right + viewportOffset.right;
    }
  }
  if (scrollX != initialScrollX || scrollY !== initialScrollY) {
    window2.scrollTo(scrollX, scrollY);
  }
}
function scrollAncestorsToShowRect({ parent, getRect, alignToTop, forceScroll, ancestorOffset = 0, limiterElement }) {
  const parentWindow = getWindow(parent);
  const forceScrollToTop = alignToTop && forceScroll;
  let parentRect, targetRect, targetFitsInTarget;
  const limiter = limiterElement || parentWindow.document.body;
  while (parent != limiter) {
    targetRect = getRect();
    parentRect = new Rect(parent).excludeScrollbarsAndBorders();
    targetFitsInTarget = parentRect.contains(targetRect);
    if (forceScrollToTop) {
      parent.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
    } else if (!targetFitsInTarget) {
      if (isAbove(targetRect, parentRect)) {
        parent.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
      } else if (isBelow(targetRect, parentRect)) {
        if (alignToTop) {
          parent.scrollTop += targetRect.top - parentRect.top - ancestorOffset;
        } else {
          parent.scrollTop += targetRect.bottom - parentRect.bottom + ancestorOffset;
        }
      }
    }
    if (!targetFitsInTarget) {
      if (isLeftOf(targetRect, parentRect)) {
        parent.scrollLeft -= parentRect.left - targetRect.left + ancestorOffset;
      } else if (isRightOf(targetRect, parentRect)) {
        parent.scrollLeft += targetRect.right - parentRect.right + ancestorOffset;
      }
    }
    parent = parent.parentNode;
  }
}
function isBelow(firstRect, secondRect) {
  return firstRect.bottom > secondRect.bottom;
}
function isAbove(firstRect, secondRect) {
  return firstRect.top < secondRect.top;
}
function isLeftOf(firstRect, secondRect) {
  return firstRect.left < secondRect.left;
}
function isRightOf(firstRect, secondRect) {
  return firstRect.right > secondRect.right;
}
function getWindow(elementOrRange) {
  if (isRange(elementOrRange)) {
    return elementOrRange.startContainer.ownerDocument.defaultView;
  } else {
    return elementOrRange.ownerDocument.defaultView;
  }
}
function getParentElement(elementOrRange) {
  if (isRange(elementOrRange)) {
    let parent = elementOrRange.commonAncestorContainer;
    if (isText(parent)) {
      parent = parent.parentNode;
    }
    return parent;
  } else {
    return elementOrRange.parentNode;
  }
}
function getRectRelativeToWindow(target, relativeWindow) {
  const targetWindow = getWindow(target);
  const rect = new Rect(target);
  if (targetWindow === relativeWindow) {
    return rect;
  } else {
    let currentWindow = targetWindow;
    while (currentWindow != relativeWindow) {
      const frame = currentWindow.frameElement;
      const frameRect = new Rect(frame).excludeScrollbarsAndBorders();
      rect.moveBy(frameRect.left, frameRect.top);
      currentWindow = currentWindow.parent;
    }
  }
  return rect;
}
function normalizeViewportOffset(viewportOffset) {
  if (typeof viewportOffset === "number") {
    return {
      top: viewportOffset,
      bottom: viewportOffset,
      left: viewportOffset,
      right: viewportOffset
    };
  }
  return viewportOffset;
}

// node_modules/@ckeditor/ckeditor5-utils/src/language.js
var RTL_LANGUAGE_CODES = [
  "ar",
  "ara",
  "dv",
  "div",
  "fa",
  "per",
  "fas",
  "he",
  "heb",
  "ku",
  "kur",
  "ug",
  "uig"
  // Uighur, Uyghur
];
function getLanguageDirection(languageCode) {
  return RTL_LANGUAGE_CODES.includes(languageCode) ? "rtl" : "ltr";
}

// node_modules/@ckeditor/ckeditor5-utils/src/toarray.js
function toArray(data) {
  return Array.isArray(data) ? data : [data];
}

// node_modules/@ckeditor/ckeditor5-utils/src/translation-service.js
if (!global_default.window.CKEDITOR_TRANSLATIONS) {
  global_default.window.CKEDITOR_TRANSLATIONS = {};
}
function _translate(language, message, quantity = 1, translations) {
  if (typeof quantity !== "number") {
    throw new CKEditorError("translation-service-quantity-not-a-number", null, { quantity });
  }
  const normalizedTranslations = translations || global_default.window.CKEDITOR_TRANSLATIONS;
  const numberOfLanguages = getNumberOfLanguages(normalizedTranslations);
  if (numberOfLanguages === 1) {
    language = Object.keys(normalizedTranslations)[0];
  }
  const messageId = message.id || message.string;
  if (numberOfLanguages === 0 || !hasTranslation(language, messageId, normalizedTranslations)) {
    if (quantity !== 1) {
      return message.plural;
    }
    return message.string;
  }
  const dictionary = normalizedTranslations[language].dictionary;
  const getPluralForm = normalizedTranslations[language].getPluralForm || ((n) => n === 1 ? 0 : 1);
  const translation = dictionary[messageId];
  if (typeof translation === "string") {
    return translation;
  }
  const pluralFormIndex = Number(getPluralForm(quantity));
  return translation[pluralFormIndex];
}
function _unifyTranslations(translations) {
  return Array.isArray(translations) ? translations.reduce((acc, translation) => merge_default(acc, translation)) : translations;
}
function hasTranslation(language, messageId, translations) {
  return !!translations[language] && !!translations[language].dictionary[messageId];
}
function getNumberOfLanguages(translations) {
  return Object.keys(translations).length;
}

// node_modules/@ckeditor/ckeditor5-utils/src/locale.js
var Locale = class {
  /**
   * Creates a new instance of the locale class. Learn more about
   * {@glink getting-started/setup/ui-language configuring the language of the editor}.
   *
   * @param options Locale configuration.
   * @param options.uiLanguage The editor UI language code in the
   * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. See {@link #uiLanguage}.
   * @param options.contentLanguage The editor content language code in the
   * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. If not specified, the same as `options.language`.
   * See {@link #contentLanguage}.
   * @param translations Translations passed as a editor config parameter.
   */
  constructor({ uiLanguage = "en", contentLanguage, translations } = {}) {
    this.uiLanguage = uiLanguage;
    this.contentLanguage = contentLanguage || this.uiLanguage;
    this.uiLanguageDirection = getLanguageDirection(this.uiLanguage);
    this.contentLanguageDirection = getLanguageDirection(this.contentLanguage);
    this.translations = _unifyTranslations(translations);
    this.t = (message, values) => this._t(message, values);
  }
  /**
   * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
   *
   * **Note**: This property was deprecated. Please use {@link #uiLanguage} and {@link #contentLanguage}
   * properties instead.
   *
   * @deprecated
   */
  get language() {
    console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead.");
    return this.uiLanguage;
  }
  /**
   * An unbound version of the {@link #t} method.
   */
  _t(message, values = []) {
    values = toArray(values);
    if (typeof message === "string") {
      message = { string: message };
    }
    const hasPluralForm = !!message.plural;
    const quantity = hasPluralForm ? values[0] : 1;
    const translatedString = _translate(this.uiLanguage, message, quantity, this.translations);
    return interpolateString(translatedString, values);
  }
};
function interpolateString(string, values) {
  return string.replace(/%(\d+)/g, (match, index) => {
    return index < values.length ? values[index] : match;
  });
}

// node_modules/@ckeditor/ckeditor5-utils/src/collection.js
var Collection = class extends EmitterMixin() {
  constructor(initialItemsOrOptions = {}, options = {}) {
    super();
    const hasInitialItems = isIterable(initialItemsOrOptions);
    if (!hasInitialItems) {
      options = initialItemsOrOptions;
    }
    this._items = [];
    this._itemMap = /* @__PURE__ */ new Map();
    this._idProperty = options.idProperty || "id";
    this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap();
    this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap();
    this._skippedIndexesFromExternal = [];
    if (hasInitialItems) {
      for (const item of initialItemsOrOptions) {
        this._items.push(item);
        this._itemMap.set(this._getItemIdBeforeAdding(item), item);
      }
    }
  }
  /**
   * The number of items available in the collection.
   */
  get length() {
    return this._items.length;
  }
  /**
   * Returns the first item from the collection or null when collection is empty.
   */
  get first() {
    return this._items[0] || null;
  }
  /**
   * Returns the last item from the collection or null when collection is empty.
   */
  get last() {
    return this._items[this.length - 1] || null;
  }
  /**
   * Adds an item into the collection.
   *
   * If the item does not have an id, then it will be automatically generated and set on the item.
   *
   * @param item
   * @param index The position of the item in the collection. The item
   * is pushed to the collection when `index` not specified.
   * @fires add
   * @fires change
   */
  add(item, index) {
    return this.addMany([item], index);
  }
  /**
   * Adds multiple items into the collection.
   *
   * Any item not containing an id will get an automatically generated one.
   *
   * @param items
   * @param index The position of the insertion. Items will be appended if no `index` is specified.
   * @fires add
   * @fires change
   */
  addMany(items, index) {
    if (index === void 0) {
      index = this._items.length;
    } else if (index > this._items.length || index < 0) {
      throw new CKEditorError("collection-add-item-invalid-index", this);
    }
    let offset = 0;
    for (const item of items) {
      const itemId = this._getItemIdBeforeAdding(item);
      const currentItemIndex = index + offset;
      this._items.splice(currentItemIndex, 0, item);
      this._itemMap.set(itemId, item);
      this.fire("add", item, currentItemIndex);
      offset++;
    }
    this.fire("change", {
      added: items,
      removed: [],
      index
    });
    return this;
  }
  /**
   * Gets an item by its ID or index.
   *
   * @param idOrIndex The item ID or index in the collection.
   * @returns The requested item or `null` if such item does not exist.
   */
  get(idOrIndex) {
    let item;
    if (typeof idOrIndex == "string") {
      item = this._itemMap.get(idOrIndex);
    } else if (typeof idOrIndex == "number") {
      item = this._items[idOrIndex];
    } else {
      throw new CKEditorError("collection-get-invalid-arg", this);
    }
    return item || null;
  }
  /**
   * Returns a Boolean indicating whether the collection contains an item.
   *
   * @param itemOrId The item or its ID in the collection.
   * @returns `true` if the collection contains the item, `false` otherwise.
   */
  has(itemOrId) {
    if (typeof itemOrId == "string") {
      return this._itemMap.has(itemOrId);
    } else {
      const idProperty = this._idProperty;
      const id = itemOrId[idProperty];
      return id && this._itemMap.has(id);
    }
  }
  /**
   * Gets an index of an item in the collection.
   * When an item is not defined in the collection, the index will equal -1.
   *
   * @param itemOrId The item or its ID in the collection.
   * @returns The index of a given item.
   */
  getIndex(itemOrId) {
    let item;
    if (typeof itemOrId == "string") {
      item = this._itemMap.get(itemOrId);
    } else {
      item = itemOrId;
    }
    return item ? this._items.indexOf(item) : -1;
  }
  /**
   * Removes an item from the collection.
   *
   * @param subject The item to remove, its ID or index in the collection.
   * @returns The removed item.
   * @fires remove
   * @fires change
   */
  remove(subject) {
    const [item, index] = this._remove(subject);
    this.fire("change", {
      added: [],
      removed: [item],
      index
    });
    return item;
  }
  /**
   * Executes the callback for each item in the collection and composes an array or values returned by this callback.
   *
   * @typeParam U The result type of the callback.
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The result of mapping.
   */
  map(callback, ctx) {
    return this._items.map(callback, ctx);
  }
  /**
   * Performs the specified action for each item in the collection.
   *
   * @param ctx Context in which the `callback` will be called.
   */
  forEach(callback, ctx) {
    this._items.forEach(callback, ctx);
  }
  /**
   * Finds the first item in the collection for which the `callback` returns a true value.
   *
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The item for which `callback` returned a true value.
   */
  find(callback, ctx) {
    return this._items.find(callback, ctx);
  }
  /**
   * Returns an array with items for which the `callback` returned a true value.
   *
   * @param callback
   * @param ctx Context in which the `callback` will be called.
   * @returns The array with matching items.
   */
  filter(callback, ctx) {
    return this._items.filter(callback, ctx);
  }
  /**
   * Removes all items from the collection and destroys the binding created using
   * {@link #bindTo}.
   *
   * @fires remove
   * @fires change
   */
  clear() {
    if (this._bindToCollection) {
      this.stopListening(this._bindToCollection);
      this._bindToCollection = null;
    }
    const removedItems = Array.from(this._items);
    while (this.length) {
      this._remove(0);
    }
    this.fire("change", {
      added: [],
      removed: removedItems,
      index: 0
    });
  }
  /**
   * Binds and synchronizes the collection with another one.
   *
   * The binding can be a simple factory:
   *
   * ```ts
   * class FactoryClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
   * const target = new Collection<FactoryClass>();
   *
   * target.bindTo( source ).as( FactoryClass );
   *
   * source.add( { label: 'foo' } );
   * source.add( { label: 'bar' } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 1 ).label ); // 'bar'
   *
   * source.remove( 0 );
   * console.log( target.length ); // 1
   * console.log( target.get( 0 ).label ); // 'bar'
   * ```
   *
   * or the factory driven by a custom callback:
   *
   * ```ts
   * class FooClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * class BarClass {
   * 	public label: string;
   *
   * 	constructor( data: { label: string } ) {
   * 		this.label = data.label;
   * 	}
   * }
   *
   * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
   * const target = new Collection<FooClass | BarClass>();
   *
   * target.bindTo( source ).using( ( item ) => {
   * 	if ( item.label == 'foo' ) {
   * 		return new FooClass( item );
   * 	} else {
   * 		return new BarClass( item );
   * 	}
   * } );
   *
   * source.add( { label: 'foo' } );
   * source.add( { label: 'bar' } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 0 ) instanceof FooClass ); // true
   * console.log( target.get( 1 ) instanceof BarClass ); // true
   * ```
   *
   * or the factory out of property name:
   *
   * ```ts
   * const source = new Collection<{ nested: { value: string } }>();
   * const target = new Collection<{ value: string }>();
   *
   * target.bindTo( source ).using( 'nested' );
   *
   * source.add( { nested: { value: 'foo' } } );
   * source.add( { nested: { value: 'bar' } } );
   *
   * console.log( target.length ); // 2
   * console.log( target.get( 0 ).value ); // 'foo'
   * console.log( target.get( 1 ).value ); // 'bar'
   * ```
   *
   * It's possible to skip specified items by returning null value:
   *
   * ```ts
   * const source = new Collection<{ hidden: boolean }>();
   * const target = new Collection<{ hidden: boolean }>();
   *
   * target.bindTo( source ).using( item => {
   * 	if ( item.hidden ) {
   * 		return null;
   * 	}
   *
   * 	return item;
   * } );
   *
   * source.add( { hidden: true } );
   * source.add( { hidden: false } );
   *
   * console.log( source.length ); // 2
   * console.log( target.length ); // 1
   * ```
   *
   * **Note**: {@link #clear} can be used to break the binding.
   *
   * @typeParam S The type of `externalCollection` element.
   * @param externalCollection A collection to be bound.
   * @returns The binding chain object.
   */
  bindTo(externalCollection) {
    if (this._bindToCollection) {
      throw new CKEditorError("collection-bind-to-rebind", this);
    }
    this._bindToCollection = externalCollection;
    return {
      as: (Class) => {
        this._setUpBindToBinding((item) => new Class(item));
      },
      using: (callbackOrProperty) => {
        if (typeof callbackOrProperty == "function") {
          this._setUpBindToBinding(callbackOrProperty);
        } else {
          this._setUpBindToBinding((item) => item[callbackOrProperty]);
        }
      }
    };
  }
  /**
   * Finalizes and activates a binding initiated by {@link #bindTo}.
   *
   * @param factory A function which produces collection items.
   */
  _setUpBindToBinding(factory) {
    const externalCollection = this._bindToCollection;
    const addItem = (evt, externalItem, index) => {
      const isExternalBoundToThis = externalCollection._bindToCollection == this;
      const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem);
      if (isExternalBoundToThis && externalItemBound) {
        this._bindToExternalToInternalMap.set(externalItem, externalItemBound);
        this._bindToInternalToExternalMap.set(externalItemBound, externalItem);
      } else {
        const item = factory(externalItem);
        if (!item) {
          this._skippedIndexesFromExternal.push(index);
          return;
        }
        let finalIndex = index;
        for (const skipped of this._skippedIndexesFromExternal) {
          if (index > skipped) {
            finalIndex--;
          }
        }
        for (const skipped of externalCollection._skippedIndexesFromExternal) {
          if (finalIndex >= skipped) {
            finalIndex++;
          }
        }
        this._bindToExternalToInternalMap.set(externalItem, item);
        this._bindToInternalToExternalMap.set(item, externalItem);
        this.add(item, finalIndex);
        for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {
          if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {
            externalCollection._skippedIndexesFromExternal[i]++;
          }
        }
      }
    };
    for (const externalItem of externalCollection) {
      addItem(null, externalItem, externalCollection.getIndex(externalItem));
    }
    this.listenTo(externalCollection, "add", addItem);
    this.listenTo(externalCollection, "remove", (evt, externalItem, index) => {
      const item = this._bindToExternalToInternalMap.get(externalItem);
      if (item) {
        this.remove(item);
      }
      this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {
        if (index < skipped) {
          result.push(skipped - 1);
        }
        if (index > skipped) {
          result.push(skipped);
        }
        return result;
      }, []);
    });
  }
  /**
   * Returns an unique id property for a given `item`.
   *
   * The method will generate new id and assign it to the `item` if it doesn't have any.
   *
   * @param item Item to be added.
   */
  _getItemIdBeforeAdding(item) {
    const idProperty = this._idProperty;
    let itemId;
    if (idProperty in item) {
      itemId = item[idProperty];
      if (typeof itemId != "string") {
        throw new CKEditorError("collection-add-invalid-id", this);
      }
      if (this.get(itemId)) {
        throw new CKEditorError("collection-add-item-already-exists", this);
      }
    } else {
      item[idProperty] = itemId = uid();
    }
    return itemId;
  }
  /**
   * Core {@link #remove} method implementation shared in other functions.
   *
   * In contrast this method **does not** fire the {@link #event:change} event.
   *
   * @param subject The item to remove, its id or index in the collection.
   * @returns Returns an array with the removed item and its index.
   * @fires remove
   */
  _remove(subject) {
    let index, id, item;
    let itemDoesNotExist = false;
    const idProperty = this._idProperty;
    if (typeof subject == "string") {
      id = subject;
      item = this._itemMap.get(id);
      itemDoesNotExist = !item;
      if (item) {
        index = this._items.indexOf(item);
      }
    } else if (typeof subject == "number") {
      index = subject;
      item = this._items[index];
      itemDoesNotExist = !item;
      if (item) {
        id = item[idProperty];
      }
    } else {
      item = subject;
      id = item[idProperty];
      index = this._items.indexOf(item);
      itemDoesNotExist = index == -1 || !this._itemMap.get(id);
    }
    if (itemDoesNotExist) {
      throw new CKEditorError("collection-remove-404", this);
    }
    this._items.splice(index, 1);
    this._itemMap.delete(id);
    const externalItem = this._bindToInternalToExternalMap.get(item);
    this._bindToInternalToExternalMap.delete(item);
    this._bindToExternalToInternalMap.delete(externalItem);
    this.fire("remove", item, index);
    return [item, index];
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/first.js
function first(iterator) {
  const iteratorItem = iterator.next();
  if (iteratorItem.done) {
    return null;
  }
  return iteratorItem.value;
}

// node_modules/@ckeditor/ckeditor5-utils/src/focustracker.js
var FocusTracker = class extends DomEmitterMixin(ObservableMixin()) {
  // @if CK_DEBUG_FOCUSTRACKER // public _label?: string;
  constructor() {
    super();
    this._elements = /* @__PURE__ */ new Set();
    this._externalViews = /* @__PURE__ */ new Set();
    this._blurTimeout = null;
    this.set("isFocused", false);
    this.set("focusedElement", null);
  }
  /**
   * List of registered DOM elements.
   *
   * **Note**: The list does do not include elements from {@link #externalViews}.
   */
  get elements() {
    return Array.from(this._elements.values());
  }
  /**
   * List of external focusable views that contribute to the state of this focus tracker. See {@link #add} to learn more.
   */
  get externalViews() {
    return Array.from(this._externalViews.values());
  }
  /**
   * Starts tracking a specified DOM element or a {@link module:ui/view~View} instance.
   *
   * * If a DOM element is passed, the focus tracker listens to the `focus` and `blur` events on this element.
   * Tracked elements are listed in {@link #elements}.
   * * If a {@link module:ui/view~View} instance is passed that has a `FocusTracker` instance ({@link ~ViewWithFocusTracker}),
   * the external focus tracker's state ({@link #isFocused}, {@link #focusedElement}) starts contributing to the current tracker instance.
   * This allows for increasing the "reach" of a focus tracker instance, by connecting two or more focus trackers together when DOM
   * elements they track are located in different subtrees in DOM. External focus trackers are listed in {@link #externalViews}.
   * * If a {@link module:ui/view~View} instance is passed that has no `FocusTracker` (**not** a {@link ~ViewWithFocusTracker}),
   * its {@link module:ui/view~View#element} is used to track focus like any other DOM element.
   */
  add(elementOrView) {
    if (isElement(elementOrView)) {
      this._addElement(elementOrView);
    } else {
      if (isViewWithFocusTracker(elementOrView)) {
        this._addView(elementOrView);
      } else {
        if (!elementOrView.element) {
          throw new CKEditorError("focustracker-add-view-missing-element", {
            focusTracker: this,
            view: elementOrView
          });
        }
        this._addElement(elementOrView.element);
      }
    }
  }
  /**
   * Stops tracking focus in the specified DOM element or a {@link module:ui/view~View view instance}. See {@link #add} to learn more.
   */
  remove(elementOrView) {
    if (isElement(elementOrView)) {
      this._removeElement(elementOrView);
    } else {
      if (isViewWithFocusTracker(elementOrView)) {
        this._removeView(elementOrView);
      } else {
        this._removeElement(elementOrView.element);
      }
    }
  }
  /**
   * Adds a DOM element to the focus tracker and starts listening to the `focus` and `blur` events on it.
   */
  _addElement(element) {
    if (this._elements.has(element)) {
      throw new CKEditorError("focustracker-add-element-already-exist", this);
    }
    this.listenTo(element, "focus", () => {
      const externalFocusedViewInSubtree = this.externalViews.find((view) => isExternalViewSubtreeFocused(element, view));
      if (externalFocusedViewInSubtree) {
        this._focus(externalFocusedViewInSubtree.element);
      } else {
        this._focus(element);
      }
    }, { useCapture: true });
    this.listenTo(element, "blur", () => {
      this._blur();
    }, { useCapture: true });
    this._elements.add(element);
  }
  /**
   * Removes a DOM element from the focus tracker.
   */
  _removeElement(element) {
    if (this._elements.has(element)) {
      this.stopListening(element);
      this._elements.delete(element);
    }
    if (element === this.focusedElement) {
      this._blur();
    }
  }
  /**
   * Adds an external {@link module:ui/view~View view instance} to this focus tracker and makes it contribute to this focus tracker's
   * state either by its `View#element` or by its `View#focusTracker` instance.
   */
  _addView(view) {
    if (view.element) {
      this._addElement(view.element);
    }
    this.listenTo(view.focusTracker, "change:focusedElement", () => {
      if (view.focusTracker.focusedElement) {
        if (view.element) {
          this._focus(view.element);
        }
      } else {
        this._blur();
      }
    });
    this._externalViews.add(view);
  }
  /**
   * Removes an external {@link module:ui/view~View view instance} from this focus tracker.
   */
  _removeView(view) {
    if (view.element) {
      this._removeElement(view.element);
    }
    this.stopListening(view.focusTracker);
    this._externalViews.delete(view);
  }
  /**
   * Destroys the focus tracker by:
   * - Disabling all event listeners attached to tracked elements or external views.
   * - Removing all tracked elements and views that were previously added.
   */
  destroy() {
    this.stopListening();
    this._elements.clear();
    this._externalViews.clear();
    this.isFocused = false;
    this.focusedElement = null;
  }
  /**
   * Stores currently focused element as {@link #focusedElement} and sets {@link #isFocused} `true`.
   */
  _focus(element) {
    this._clearBlurTimeout();
    this.focusedElement = element;
    this.isFocused = true;
  }
  /**
   * Clears currently {@link #focusedElement} and sets {@link #isFocused} `false`.
   *
   * This method uses `setTimeout()` to change order of `blur` and `focus` events calls, ensuring that moving focus between
   * two elements within a single focus tracker's scope, will not cause `[ blurA, focusB ]` sequence but just `[ focusB ]`.
   * The former would cause a momentary change of `#isFocused` to `false` which is not desired because any logic listening to
   * a focus tracker state would experience UI flashes and glitches as the user focus travels across the UI.
   */
  _blur() {
    const isAnyElementFocused = this.elements.find((element) => element.contains(document.activeElement));
    if (isAnyElementFocused) {
      return;
    }
    const isAnyExternalViewFocused = this.externalViews.find((view) => {
      return view.focusTracker.isFocused && !view.focusTracker._blurTimeout;
    });
    if (isAnyExternalViewFocused) {
      return;
    }
    this._clearBlurTimeout();
    this._blurTimeout = setTimeout(() => {
      this.focusedElement = null;
      this.isFocused = false;
    }, 0);
  }
  /**
   * Clears the asynchronous blur event timeout on demand. See {@link #_blur} to learn more.
   */
  _clearBlurTimeout() {
    clearTimeout(this._blurTimeout);
    this._blurTimeout = null;
  }
};
function isViewWithFocusTracker(view) {
  return "focusTracker" in view && view.focusTracker instanceof FocusTracker;
}
function isElement(value) {
  return isElement_default(value);
}
function isExternalViewSubtreeFocused(subTreeRoot, view) {
  if (isFocusedView(subTreeRoot, view)) {
    return true;
  }
  return !!view.focusTracker.externalViews.find((view2) => isFocusedView(subTreeRoot, view2));
}
function isFocusedView(subTreeRoot, view) {
  return !!view.element && view.element.contains(document.activeElement) && subTreeRoot.contains(view.element);
}

// node_modules/@ckeditor/ckeditor5-utils/src/keystrokehandler.js
var KeystrokeHandler = class {
  /**
   * Creates an instance of the keystroke handler.
   */
  constructor() {
    this._listener = new (DomEmitterMixin())();
  }
  /**
   * Starts listening for `keydown` events from a given emitter.
   */
  listenTo(emitter) {
    this._listener.listenTo(emitter, "keydown", (evt, keyEvtData) => {
      this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
    });
  }
  /**
   * Registers a handler for the specified keystroke.
   *
   * @param keystroke Keystroke defined in a format accepted by
   * the {@link module:utils/keyboard~parseKeystroke} function.
   * @param callback A function called with the
   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
   * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.
   * @param options Additional options.
   */
  set(keystroke, callback, options = {}) {
    const keyCode = parseKeystroke(keystroke);
    const priority = options.priority;
    this._listener.listenTo(this._listener, "_keydown:" + keyCode, (evt, keyEvtData) => {
      if (options.filter && !options.filter(keyEvtData)) {
        return;
      }
      callback(keyEvtData, () => {
        keyEvtData.preventDefault();
        keyEvtData.stopPropagation();
        evt.stop();
      });
      evt.return = true;
    }, { priority });
  }
  /**
   * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
   *
   * @param keyEvtData Key event data.
   * @returns Whether the keystroke was handled.
   */
  press(keyEvtData) {
    return !!this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
  }
  /**
   * Stops listening to `keydown` events from the given emitter.
   */
  stopListening(emitter) {
    this._listener.stopListening(emitter);
  }
  /**
   * Destroys the keystroke handler.
   */
  destroy() {
    this.stopListening();
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/objecttomap.js
function objectToMap(obj) {
  const map = /* @__PURE__ */ new Map();
  for (const key in obj) {
    map.set(key, obj[key]);
  }
  return map;
}

// node_modules/@ckeditor/ckeditor5-utils/src/tomap.js
function toMap(data) {
  if (isIterable(data)) {
    return new Map(data);
  } else {
    return objectToMap(data);
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/splicearray.js
var BIG_CHUNK_SIZE = 1e4;
function spliceArray(target, source, start, count2) {
  if (Math.max(source.length, target.length) > BIG_CHUNK_SIZE) {
    return target.slice(0, start).concat(source).concat(target.slice(start + count2, target.length));
  } else {
    const newTarget = Array.from(target);
    newTarget.splice(start, count2, ...source);
    return newTarget;
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/parsebase64encodedobject.js
function parseBase64EncodedObject(encoded) {
  try {
    if (!encoded.startsWith("ey")) {
      return null;
    }
    const decoded = atob(encoded.replace(/-/g, "+").replace(/_/g, "/"));
    return JSON.parse(decoded);
  } catch (e) {
    return null;
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/crc32.js
function makeCrcTable() {
  const crcTable = [];
  for (let n = 0; n < 256; n++) {
    let c = n;
    for (let k = 0; k < 8; k++) {
      if (c & 1) {
        c = 3988292384 ^ c >>> 1;
      } else {
        c = c >>> 1;
      }
    }
    crcTable[n] = c;
  }
  return crcTable;
}
function crc32(inputData) {
  const dataArray = Array.isArray(inputData) ? inputData : [inputData];
  const crcTable = makeCrcTable();
  let crc = 0 ^ -1;
  const dataString = dataArray.map((item) => {
    if (Array.isArray(item)) {
      return item.join("");
    }
    return String(item);
  }).join("");
  for (let i = 0; i < dataString.length; i++) {
    const byte = dataString.charCodeAt(i);
    crc = crc >>> 8 ^ crcTable[(crc ^ byte) & 255];
  }
  crc = (crc ^ -1) >>> 0;
  return crc.toString(16).padStart(8, "0");
}

// node_modules/@ckeditor/ckeditor5-utils/src/unicode.js
function isCombiningMark(character) {
  return !!character && character.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(character);
}
function isHighSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\ud800-\udbff]/.test(character);
}
function isLowSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\udc00-\udfff]/.test(character);
}
function isInsideSurrogatePair(string, offset) {
  return isHighSurrogateHalf(string.charAt(offset - 1)) && isLowSurrogateHalf(string.charAt(offset));
}
function isInsideCombinedSymbol(string, offset) {
  return isCombiningMark(string.charAt(offset));
}
var EMOJI_PATTERN = buildEmojiRegexp();
function isInsideEmojiSequence(string, offset) {
  const matches = String(string).matchAll(EMOJI_PATTERN);
  return Array.from(matches).some((match) => match.index < offset && offset < match.index + match[0].length);
}
function buildEmojiRegexp() {
  const parts = [
    // Emoji Tag Sequence (ETS)
    new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"),
    // Emoji Keycap Sequence
    new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"),
    // Emoji Presentation Sequence
    new RegExp("\\p{Emoji}\\u{FE0F}", "u"),
    // Single-Character Emoji / Emoji Modifier Sequence
    new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")
  ];
  const flagSequence = new RegExp("\\p{Regional_Indicator}{2}", "u").source;
  const emoji = "(?:" + parts.map((part) => part.source).join("|") + ")";
  const sequence = `${flagSequence}|${emoji}(?:‍${emoji})*`;
  return new RegExp(sequence, "ug");
}

export {
  global_default,
  env_default,
  fastDiff,
  diff,
  EventInfo,
  uid,
  priorities_default,
  CKEditorError,
  logWarning,
  logError,
  releaseDate,
  EmitterMixin,
  ObservableMixin,
  ElementReplacer,
  count,
  compareArrays,
  isIterable,
  createElement,
  Config,
  isNode,
  DomEmitterMixin,
  getAncestors,
  getDataFromElement,
  getRangeFromMouseEvent,
  isText,
  isRange,
  Rect,
  resizeobserver_default,
  setDataInElement,
  toUnit,
  indexOf,
  insertAt,
  isComment,
  isValidAttributeName,
  isVisible,
  getOptimalPosition,
  remove,
  scrollViewportToShowTarget,
  keyCodes,
  getCode,
  parseKeystroke,
  getEnvKeystrokeText,
  isArrowKeyCode,
  getLocalizedArrowKeyCodeDirection,
  isForwardArrowKeyCode,
  toArray,
  Locale,
  Collection,
  first,
  FocusTracker,
  KeystrokeHandler,
  toMap,
  spliceArray,
  delay,
  parseBase64EncodedObject,
  crc32,
  isInsideSurrogatePair,
  isInsideCombinedSymbol,
  isInsideEmojiSequence
};
/*! Bundled license information:

@ckeditor/ckeditor5-utils/src/dom/global.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-utils/src/env.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/uid.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/ckeditorerror.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/spy.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/eventinfo.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/priorities.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/inserttopriorityarray.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/version.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/version.js:
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-utils/src/emittermixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-utils/src/observablemixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getdatafromelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/keyboard.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/delay.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/fastdiff.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/diff.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/difftochanges.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/mix.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/elementreplacer.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/abortabledebounce.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/count.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/comparearrays.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/isiterable.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/createelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/config.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/isnode.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/iswindow.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/emittermixin.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/findclosestscrollableancestor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getancestors.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getborderwidths.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getrangefrommouseevent.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/istext.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/isrange.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/getpositionedancestor.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/rect.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/resizeobserver.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/setdatainelement.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/tounit.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/indexof.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/insertat.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/iscomment.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/isvalidattributename.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/isvisible.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/position.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/remove.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/dom/scroll.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/language.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/toarray.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/translation-service.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
  (* istanbul ignore else -- @preserve *)

@ckeditor/ckeditor5-utils/src/locale.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/collection.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/first.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/focustracker.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/keystrokehandler.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/objecttomap.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/tomap.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/wait.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/retry.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/splicearray.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/parsebase64encodedobject.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/crc32.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/unicode.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)

@ckeditor/ckeditor5-utils/src/index.js:
  (**
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
   *)
*/
//# sourceMappingURL=chunk-3X5M7Q3U.js.map
